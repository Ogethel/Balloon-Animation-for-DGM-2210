#define LB_COMPUTE

// If changing LB_COMPUTE, also change in LBGroupVariables.cs

// Landscape Builder. Copyright (c) 2016-2019 SCSM Pty Ltd. All rights reserved.
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System.Linq;  // Includes Float.Sum() and List.Count(..)

namespace LandscapeBuilder
{
    public class LBLandscapeTerrain
    {
        #region Enumerations

        public enum SmoothingAlgorithm
        {
            UnweightedSlidingAverage = 0,
            LayerFilterMap = 1,
            LayerBlendMap = 2,
            None = 99
        }

        #endregion

        #region Variables

        // Temporary variables
        private static int heightmapResolution;
        private static int originalHeightMapResolution;

        private static float xPos;
        private static float yPos;
        private static Vector2 coords;

        private static float heightSum;
        private static float heightSum1;
        private static float heightSum2;

        private static LBLayer layer;
        private static int layerTypeInt;
        private static float downscaling;

        private static int neighbouringCells;
        private static float altitude0;
        private static float altitude1;
        private static float altitude2;
        private static float altitude3;
        private static float altitude4;
        private static float averageAltitude;
        private static float deltaA;
        private static float deltaTotal;
        private static float transportedWater;
        private static float sedimentEroded;
        private static float maxSediment;
        private static float sedimentDeposited;

        private static float[] blendWeights;
        private static float normFactor;
        private static float detailFactor;
        private static float height;
        private static float angle;
        private static bool createTree;
        private static List<LBTerrainTreeInstance> lbTerrainTreeInstanceList;

        private static bool createMesh;
        private static Vector3 meshPosition;
        private static Quaternion meshRotation;
        private static Vector3 meshScale;
        // Stores placed normalised mesh position, minProximity and minProximity Squared pre-calc'd values
        private static List<LBTerrainMeshInstance> lbTerrainMeshInstanceList;
        private static List<CombineInstance> combineMeshes;
        private static float meshGrassProximity;
        private static int detailXPos;
        private static int detailYPos;
        private static int detailPatchSize;
        private static float circDist;
        private static Vector2 circCentre;
        private static float circRadius;
        #endregion

        #region Texture temporary structs
        // Used in TextureTerrain() and LBTerrainTexture.GetPlacementRules()
        public struct LBTexRule
        {
            public float minHeightN;
            public float maxHeightN;
            public float minInclination;
            public float maxInclination;
            public int isCurvatureConcave;
            public float curvatureMinHeightDiffN;
            public float curvatureDistanceXN;
            public float curvatureDistanceZN;
        }

        #endregion

        #region Compute Shader declares
#if LB_COMPUTE

        #region Declares common to TOPO, TEX, GRASS and FPASS compute shaders
        // Compute shader heightmap variables names
        private static readonly string CSheightmapResolution = "hmapRes";

        // Compute shader landscape variable names
        private static readonly string CSlandscapePos = "landscapePos";
        private static readonly string CSlandscapeSize = "landscapeSize";

        // Compute shader terrain variable names
        private static readonly string CSterrainWidth = "terrainWidth";
        private static readonly string CSterrainLength = "terrainLength";
        private static readonly string CSterrainWorldPos = "terrainWorldPos";

        // Compute shader Stencil Layer filter variable names
        private static readonly string CSstencilLayer128Tex2DArray = "stencilLayer128Tex2DArray";
        private static readonly string CSstencilLayer256Tex2DArray = "stencilLayer256Tex2DArray";
        private static readonly string CSstencilLayer512Tex2DArray = "stencilLayer512Tex2DArray";
        private static readonly string CSstencilLayer1024Tex2DArray = "stencilLayer1024Tex2DArray";
        private static readonly string CSstencilLayer2048Tex2DArray = "stencilLayer2048Tex2DArray";
        private static readonly string CSstencilLayer4096Tex2DArray = "stencilLayer4096Tex2DArray";
        private static readonly string CSstencilLayer8192Tex2DArray = "stencilLayer8192Tex2DArray";
        #endregion

        #region Common declares to TOPO, TEX, GRASS compute shaders

        /// <summary>
        /// Used in compute shader (combined LBLayerFilter, LBFilter)
        /// csfilterType Height: 0, Inclination: 1, Map: 2, Stencil: 3, Area 4, Texture 5, Proximity 6
        /// filterMode AND: 0, OR: 1, NOT: 2
        /// lbTexIdx is the LBTerrainTexture owner in the list (-1 if not used)
        /// stencilLayerResolution: 1024, 2048, 4096, 8192 (128, 256 and 512 not supported in LB CS)
        /// stencilLayerIdx: index within the stencilLayer[n]KTex2DArray (n determined by stencilLayerResolution)
        /// texArrayIdx: the slot within the Texture2DArray for the given stencil resolution.
        /// areaRect.x: xMin, areaRect.y: yMin, areaRect.z: xMax, areaRect.w: yMax
        /// </summary>
        struct LBCSFilter
        {
            public uint csfilterType;
            public int filterMode;
            public uint lbTexIdx;
            public int stencilLayerResolution;
            public int stencilLayerTex2DArrIdx;
            public Vector4 areaRect;
            public float minHeight;
            public float maxHeight;
            public float minInclination;
            public float maxInclination;
        }

        private static readonly string CSheightsIn = "heightsIn";
        private static readonly string CSterrainNormals = "terrainNormals";
        // Compute shader filter variable names
        private static readonly string CSlbFilters = "lbFilters";
        private static readonly string CSnumlbFilters = "numlbFilters";
        #endregion

        #region Compute Shader declares TOPO GRASS
        // Compute shader noise variable names
        private static readonly string CSnoiseTileSize = "noiseTileSize";
        private static readonly string CSnoiseOctaves = "noiseOctaves";
        private static readonly string CSmapTex = "mapTex";
        private static readonly string CSmapTexWidth = "mapTexWidth";
        private static readonly string CSmapTexHeight = "mapTexHeight";
        private static readonly string CSmapInverse = "mapInverse";
        #endregion

        #region Compute Shader declares TEX GRASS
        private static readonly string CSheightsLandscape = "heightsLandscape";
        private static readonly string CShmapLandscapeRes = "hmapLandscapeRes";
        #endregion

        #region Compute Shader declares TOPO FPASS MAPPATH
        // Compute shader heightmap variable names
        private static readonly string CSheightsOut = "heightsOut";
        #endregion

        #region Compute Shader declares TOPO
        // Declare compute shader property names to avoid GC and improve performance
        // Compute shader names
        private static readonly string LBCSTopo = "LBCSTopo";
        // Compute shader method names
        private static readonly string CSKTopoPerlin = "TopoPerlin";
        private static readonly string CSKTopoImage = "TopoImage";
        private static readonly string CSKTopoImageModifier = "TopoImageModifier";
        private static readonly string CSKTopoUnityTerrains = "TopoUnityTerrains";
        // Compute shader layer variable names
        private static readonly string CSlayerTypeInt = "layerTypeInt";
        private static readonly string CSheightScale = "heightScale";
        private static readonly string CSrestrictArea = "restrictArea";
        private static readonly string CSareaRect = "areaRect";
        private static readonly string CSareaRectBlendWidth = "areaRectBlendWidth";
        private static readonly string CSareaRectRotation = "areaRectRotation";
        private static readonly string CSremoveBaseNoise = "removeBaseNoise";
        private static readonly string CSaddHeightN = "addHeightN";
        private static readonly string CSaddsubAmount = "addsubAmount";
        private static readonly string CSaddsubCurve = "addsubCurve";
        private static readonly string CSaddsubCurveNumKeys = "addsubCurveNumKeys";
        private static readonly string CSmodifierCurves = "modifierCurves";
        private static readonly string CSmodifierCurvesNumFrames = "modifierCurvesNumFrames";
        private static readonly string CSnumPerOctaveCurves = "numPerOctaveCurves";
        private static readonly string CSnumOutputCurves = "numOutputCurves";
        private static readonly string CSoutputCurveFrameOffset = "outputCurveFrameOffset";
        // Compute shader noise variable names
        private static readonly string CSnoiseOffsetX = "noiseOffsetX";
        private static readonly string CSnoiseOffsetZ = "noiseOffsetZ";
        private static readonly string CSnoiseOffsetXadj = "noiseOffsetXadj";
        private static readonly string CSnoiseOffsetZadj = "noiseOffsetZadj";
        private static readonly string CSnoiseLacunarity = "noiseLacunarity";
        private static readonly string CSnoiseGain = "noiseGain";
        private static readonly string CSnoiseWarpAmount = "noiseWarpAmount";
        private static readonly string CSnoiseWarpOctaves = "noiseWarpOctaves";
        private static readonly string CSnoiseDownscaling = "noiseDownscaling";
        // Compute shader image layer variable names
        private static readonly string CSheightmapImage = "heightmapImage";
        private static readonly string CSimageMinMaxRange = "imageMinMaxRange";
        private static readonly string CSnormaliseImage = "normaliseImage";
        // Compute shader image modifier layer variable names
        private static readonly string CSrawHeightData = "rawHeightData";
        private static readonly string CSuseBlending = "useBlending";
        private static readonly string CSmodifierMode = "modifierMode";
        private static readonly string CSmodifierInvert = "modifierInvert";
        #endregion

        #region Compute Shader declares FPASS
        // Compute shaders
        private static readonly string LBCSFPass = "LBCSFPass";
        // Compute kernal methods
        private static readonly string CSKFPassSmoothingPR1 = "SmoothingPR1";
        private static readonly string CSKFPassSmoothingPR2 = "SmoothingPR2";
        private static readonly string CSKFPassSmoothingPR3 = "SmoothingPR3";
        private static readonly string CSKFPassSmoothingPR4 = "SmoothingPR4";
        private static readonly string CSKFPassSmoothingPR5 = "SmoothingPR5";
        private static readonly string CSKFPassThermalErosion = "ThermalErosion";
        private static readonly string CSKFPassCopyTerrainToHeights = "CopyTerrainToHeights";
        //private static readonly string CSKFPassCopyHeightsToTerrain = "CopyHeightsToTerrain";
        // Compute shader variables
        private static readonly string CSnumStencilLayers = "numStencilLayers";
        private static readonly string CSstencilLayerResolution = "stencilLayerResolution";
        private static readonly string CSsmoothingFilterMode = "smoothingFilterMode";
        private static readonly string CSteFilterMode = "teFilterMode";
        private static readonly string CStetalusHeightDiff = "tetalusHeightDiff";
        private static readonly string CSteErosionStrength = "teErosionStrength";
        private static readonly string CShmapRow = "hmapRow";
        private static readonly string CSterrainhmapRes = "terrainhmapRes";
        private static readonly string CSheights = "heights";
        #endregion

        #region Compute Shader declares LBCSPath, LBCSPathTex, LBCSPathTree
        // Compute shaders
        private static readonly string LBCSPath = "LBCSPath";
        private static readonly string LBCSPathTex = "LBCSPathTex";
        private static readonly string LBCSPathTree = "LBCSPathTree";
        // Compute kernal methods
        private static readonly string CSKPathTopo = "PathTopo";
        private static readonly string CSKObjPathTopo = "ObjPathTopo";
        private static readonly string CSKObjPathSmooth = "ObjPathSmooth";
        private static readonly string CSKObjPathCopyHeightsOutToIn = "CopyHeightsOutToIn";
        private static readonly string CSKObjPathTex = "ObjPathTex";
        private static readonly string CSKObjPathTex4K = "ObjPathTex4K";
        private static readonly string CSKObjPathRemoveTrees = "ObjPathRemoveTrees";

        // Compute shader LBPath variables names
        private static readonly string CSnumSplineCentrePoints = "numSplineCentrePoints";
        private static readonly string CSsplinePointsCentre = "splinePointsCentre";
        private static readonly string CSsplinePointsLeft = "splinePointsLeft";
        private static readonly string CSsplinePointsRight = "splinePointsRight";
        private static readonly string CScheckEdges = "checkEdges";
        private static readonly string CSblendEnds = "blendEnds";
        private static readonly string CSblendStart = "blendStart";
        private static readonly string CSblendEnd = "blendEnd";
        private static readonly string CSquadLookAhead = "quadLookAhead";
        private static readonly string CSclosedCircuit = "closedCircuit";
        private static readonly string CSedgeBlendWidth = "edgeBlendWidth";
        private static readonly string CSsqrblendEdgeWidth = "sqrblendEdgeWidth";
        private static readonly string CSpathBounds = "pathBounds";
        private static readonly string CSsurroundSmoothing = "surroundSmoothing";
        private static readonly string CSblendTerrainHeight = "blendTerrainHeight";
        // Compute shader layer variable names
        private static readonly string CSminHeight = "minHeight";
        private static readonly string CSpathBlendCurve = "blendCurve";
        private static readonly string CSpathHeightCurve = "heightCurve";
        private static readonly string CSpathBlendCurveNumKeys = "blendCurveNumKeys";
        private static readonly string CSpathHeightCurveNumKeys = "heightCurveNumKeys";
        private static readonly string CSpathTypeMode = "typeMode";
        private static readonly string CSpathInvertMultipler = "invertMultipler";
        // Unused variables from LBCSPath shader
        private static readonly string CSmaxWidth = "maxWidth";
        private static readonly string CSsqrborderLeftWidth = "sqrborderLeftWidth";
        private static readonly string CSsqrborderRightWidth = "sqrborderRightWidth";
        private static readonly string CSremoveCentre = "removeCentre";
        private static readonly string CSPathmapTexWidth = "mapTexWidth";
        private static readonly string CSPathmapTexHeight = "mapTexHeight";

        // LBCSPathTex variables
        private static readonly string CSObjPathCoreTexIdx = "coreTexIdx";
        private static readonly string CSObjPathSurroundTexIdx = "surroundTexIdx";
        // float4: strength, noise ind (0=on, 1=off), tilesize noiseoffset
        private static readonly string CSObjPathCoreTexParms = "coreTexParms";
        private static readonly string CSObjPathSurrTexParms = "surrTexParms";

        // LBCSPathTree variables
        private static readonly string CSnumTreeObjProxities = "numTreeObjProxities";
        private static readonly string CStreeObjProximities = "treeObjProximities";
        private static readonly string CSObjPathRemoveTreeIndexes = "removeTreeIndexes";
        private static readonly string CSObjPathtreeDistFromEdge = "treeDistFromEdge";

        // Used with LBCSPathTree compute shader
        struct LBCSObjectProximity
        {
            public Vector3 position;
            public float proximity;
            public uint terrainIndex;
            public uint objectIndex;
        }

        #endregion

        #region Compute Shader declares TEX

        // Compute shader names
        private static readonly string LBCSTex = "LBCSTex";
        // Compute shader method names
        private static readonly string CSKTexPerlin = "TexPerlin";
        private static readonly string CSKTexPerlin4K = "TexPerlin4K";
        private static readonly string CSKTexModGroup = "TexModGroup";
        private static readonly string CSKTexModGroup4K = "TexModGroup4K";

        private static readonly string CSlbPathCurve = "lbPathCurve";
        private static readonly string CSlbPathCurveNumKeys = "lbPathCurveNumKeys";
        private static readonly string CSterrainHeight = "terrainHeight";
        private static readonly string CSnumSplatTextures = "numSplatTextures";
        private static readonly string CSalphaMapWidth = "alphaMapWidth";
        private static readonly string CSalphaMapLength = "alphaMapLength";
        private static readonly string CSsplatMaps = "splatMaps";
        private static readonly string CSsplatAdditions = "splatAdditions";
        private static readonly string CSterrainIdx = "terrainIdx";
        private static readonly string CSnumTerrainsWide = "numTerrainsWide";
        private static readonly string CSlbTexRules = "lbTexRules";
        private static readonly string CSlbTextures = "lbTextures";
        private static readonly string CSmapsTex2DArray = "mapsTex2DArray";
        private static readonly string CStexImportedTex2DArray = "texImportedTex2DArray";

        // Max struct size in OSX Metal is 2048 bytes
        // Using 2 bool next to each other seems to cause issues
        // instead use an int (0=false, 1=true)
        struct LBCSTexture
        {
            public uint texturingMode;
            public float strength;
            public int useNoise;
            public float noiseTileSize;
            public float noiseOffset;
            public int isMinimalBlendingEnabled;
            public int mapTexArrayIdx;
            public uint mapTexWidth;
            public uint mapTexHeight;
            public int mapInverse;
            public int isAreaFiltersToApply;
            public int isStencilLayerFiltersToApply;
            public int importedTexArrayIdx;
            public uint importedTexWidth;
        }
        #endregion

        #region Compute Shader declares GRASS
        // Compute shader names
        private static readonly string LBCSGrass = "LBCSGrass";
        // Compute shader method names
        private static readonly string CSKGrassPerlin = "GrassPerlin";
        // Compute shader buffer names
        private static readonly string CSdetailDensityMap = "detailDensityMap";
        // Compute shader LBTerrainGrass variable names
        private static readonly string CSgrassPlacingMode = "grassPlacingMode";
        private static readonly string CSgrassDontFade = "grassDontFade";
        private static readonly string CSdetailWidth = "detailWidth";
        private static readonly string CSdetailHeight = "detailHeight";
        private static readonly string CSuseNoise = "useNoise";
        private static readonly string CSgrassPlacementCutoff = "grassPlacementCutoff";
        private static readonly string CSgrassNoiseMultiplier = "grassNoiseMultiplier";
        //private static readonly string CSran1Seed = "ran1CurrentF";
        private static readonly string CSminDensity = "minDensity";
        private static readonly string CSmaxDensity = "maxDensity";
        private static readonly string CSminH = "minH";
        private static readonly string CSmaxH = "maxH";
        private static readonly string CSminI = "minI";
        private static readonly string CSmaxI = "maxI";
        private static readonly string CSisCurvatureConcave = "isCurvatureConcave";
        private static readonly string CScurvatureMinHeightDiffN = "curvatureMinHeightDiffN";
        private static readonly string CScurvatureDistanceXN = "curvatureDistanceXN";
        private static readonly string CScurvatureDistanceZN = "curvatureDistanceZN";
        private static readonly string CSisAreaFilters = "isAreaFilters";
        private static readonly string CSisStencilLayerFilters = "isStencilLayerFilters";
        private static readonly string CSisTextureFilters = "isTextureFilters";
        #endregion

#endif
        #endregion

        #region Static General Terrain Data Methods

        // TODO: Try using separate x and z float coordinates instead of vector2 to possibly improve performance

        /// <summary>
        /// Get the interpolated Normal, Height and Steepness from within a landscape using Unity terrain data.
        /// Terrain rects and sample coordinates must be landscape-space positions i.e. positions relative to the landscape
        /// NOTE: For performance, does not do any error checking (assumes you have already done validation).
        /// </summary>
        /// <param name="terrainData"></param>
        /// <param name="terrainWorldPositions"></param>
        /// <param name="worldCoords"></param>
        /// <param name="interpolatedHeight"></param>
        /// <param name="interpolatedNormal"></param>
        /// <param name="interpolatedSteepness"></param>
        public static void GetLandscapeInterpolatedData(TerrainData[] terrainData, Rect[] terrainRects, Vector2 sampleLandscapeCoords, ref float interpolatedHeight, ref Vector3 interpolatedNormal, ref float interpolatedSteepness)
        {
            // Initialise variables
            TerrainData tData;
            Rect terrainRect;

            // Loop through all the terrains in the landscape until we find the one that contains the point required
            for (int index = 0; index < terrainData.Length; index++)
            {
                // Is the point within this terrain?
                terrainRect = terrainRects[index];
                if (terrainRect.Contains(sampleLandscapeCoords))
                {
                    tData = terrainData[index];
                    // Convert point into a normalised position on the terrain
                    float normXPos = Mathf.InverseLerp(terrainRect.xMin, terrainRect.xMax, sampleLandscapeCoords.x);
                    float normYPos = Mathf.InverseLerp(terrainRect.yMin, terrainRect.yMax, sampleLandscapeCoords.y);

                    interpolatedHeight = tData.GetInterpolatedHeight(normXPos, normYPos);
                    interpolatedNormal = tData.GetInterpolatedNormal(normXPos, normYPos);
                    interpolatedSteepness = tData.GetSteepness(normXPos, normYPos);

                    break;
                }
            }
        }

        /// <summary>
        /// Get the interpolated Height and Steepness from within a landscape using Unity terrain data.
        /// Terrain rects and sample coordinates must be landscape-space positions i.e. positions relative to the landscape
        /// NOTE: For performance, does not do any error checking (assumes you have already done validation).
        /// </summary>
        /// <param name="terrainData"></param>
        /// <param name="terrainWorldPositions"></param>
        /// <param name="worldCoords"></param>
        /// <param name="interpolatedHeight"></param>
        /// <param name="interpolatedSteepness"></param>
        public static void GetLandscapeInterpolatedData(TerrainData[] terrainData, Rect[] terrainRects, Vector2 sampleLandscapeCoords, ref float interpolatedHeight, ref float interpolatedSteepness)
        {
            // Initialise variables
            TerrainData tData;
            Rect terrainRect;

            // Loop through all the terrains in the landscape until we find the one that contains the point required
            for (int index = 0; index < terrainData.Length; index++)
            {
                // Is the point within this terrain?
                terrainRect = terrainRects[index];
                if (terrainRect.Contains(sampleLandscapeCoords))
                {
                    tData = terrainData[index];
                    // Convert point into a normalised position on the terrain
                    float normXPos = Mathf.InverseLerp(terrainRect.xMin, terrainRect.xMax, sampleLandscapeCoords.x);
                    float normYPos = Mathf.InverseLerp(terrainRect.yMin, terrainRect.yMax, sampleLandscapeCoords.y);

                    interpolatedHeight = tData.GetInterpolatedHeight(normXPos, normYPos);
                    interpolatedSteepness = tData.GetSteepness(normXPos, normYPos);

                    break;
                }
            }
        }

        /// <summary>
        /// Get the interpolated Height from within a landscape using Unity terrain data.
        /// Terrain rects and sample coordinates must be landscape-space positions i.e. positions relative to the landscape
        /// NOTE: For performance, does not do any error checking (assumes you have already done validation).
        /// </summary>
        /// <param name="terrainData"></param>
        /// <param name="terrainWorldPositions"></param>
        /// <param name="worldCoords"></param>
        /// <param name="interpolatedHeight"></param>
        public static void GetLandscapeInterpolatedData(TerrainData[] terrainData, Rect[] terrainRects, Vector2 sampleLandscapeCoords, ref float interpolatedHeight)
        {
            // Initialise variables
            TerrainData tData;
            Rect terrainRect;

            // Loop through all the terrains in the landscape until we find the one that contains the point required
            for (int index = 0; index < terrainData.Length; index++)
            {
                // Is the point within this terrain?
                terrainRect = terrainRects[index];
                if (terrainRect.Contains(sampleLandscapeCoords))
                {
                    tData = terrainData[index];
                    // Convert point into a normalised position on the terrain
                    float normXPos = Mathf.InverseLerp(terrainRect.xMin, terrainRect.xMax, sampleLandscapeCoords.x);
                    float normYPos = Mathf.InverseLerp(terrainRect.yMin, terrainRect.yMax, sampleLandscapeCoords.y);

                    interpolatedHeight = tData.GetInterpolatedHeight(normXPos, normYPos);

                    break;
                }
            }
        }

        /// <summary>
        /// Get the interpolated Normal from within a landscape using Unity terrain data.
        /// Terrain rects and sample coordinates must be landscape-space positions i.e. positions relative to the landscape
        /// NOTE: For performance, does not do any error checking (assumes you have already done validation).
        /// </summary>
        /// <param name="terrainData"></param>
        /// <param name="terrainWorldPositions"></param>
        /// <param name="worldCoords"></param>
        /// <param name="interpolatedNormal"></param>
        public static void GetLandscapeInterpolatedData(TerrainData[] terrainData, Rect[] terrainRects, Vector2 sampleLandscapeCoords, ref Vector3 interpolatedNormal)
        {
            // Initialise variables
            TerrainData tData;
            Rect terrainRect;

            // Loop through all the terrains in the landscape until we find the one that contains the point required
            for (int index = 0; index < terrainData.Length; index++)
            {
                // Is the point within this terrain?
                terrainRect = terrainRects[index];
                if (terrainRect.Contains(sampleLandscapeCoords))
                {
                    tData = terrainData[index];
                    // Convert point into a normalised position on the terrain
                    float normXPos = Mathf.InverseLerp(terrainRect.xMin, terrainRect.xMax, sampleLandscapeCoords.x);
                    float normYPos = Mathf.InverseLerp(terrainRect.yMin, terrainRect.yMax, sampleLandscapeCoords.y);

                    interpolatedNormal = tData.GetInterpolatedNormal(normXPos, normYPos);

                    break;
                }
            }
        }

        /// <summary>
        /// Get the interpolated Slope or Steepness from within a landscape using Unity terrain data.
        /// Terrain rects and sample coordinates must be landscape-space positions i.e. positions relative to the landscape
        /// NOTE: For performance, does not do any error checking (assumes you have already done validation).
        /// </summary>
        /// <param name="terrainData"></param>
        /// <param name="terrainRects"></param>
        /// <param name="sampleLandscapeCoords"></param>
        /// <param name="interpolatedSteepness"></param>
        public static void GetLandscapeInterpolatedSlopeData(TerrainData[] terrainData, Rect[] terrainRects, Vector2 sampleLandscapeCoords, ref float interpolatedSteepness)
        {
            // Initialise variables
            TerrainData tData;
            Rect terrainRect;

            // Loop through all the terrains in the landscape until we find the one that contains the point required
            for (int index = 0; index < terrainData.Length; index++)
            {
                // Is the point within this terrain?
                terrainRect = terrainRects[index];

                // If this point is not outside the terrain position
                if (!(sampleLandscapeCoords.x < terrainRect.xMin || sampleLandscapeCoords.x > terrainRect.xMax || sampleLandscapeCoords.y < terrainRect.yMin || sampleLandscapeCoords.y > terrainRect.yMax))
                {
                    tData = terrainData[index];
                    // Convert point into a normalised position on the terrain
                    float normXPos = Mathf.InverseLerp(terrainRect.xMin, terrainRect.xMax, sampleLandscapeCoords.x);
                    float normYPos = Mathf.InverseLerp(terrainRect.yMin, terrainRect.yMax, sampleLandscapeCoords.y);

                    interpolatedSteepness = tData.GetSteepness(normXPos, normYPos);

                    break;
                }
            }
        }

        // Currently doesn't return a normalised value
        public static void GetHeightMapInterpolatedData(float[,] heightmap, int heightmapWidth, int heightmapLength, Vector3 terrainSize, float normXCoord, float normZCoord, ref Vector3 interpolatedNormal, ref float interpolatedHeight)
        {
            // Get coordinates of bottom left point in quad
            float xCoord = (float)heightmapWidth * normXCoord;
            float zCoord = (float)heightmapLength * normZCoord;
            int xCoordInt = (int)(xCoord);
            int zCoordInt = (int)(zCoord);
            // Clamp coordinates so it can't be on the top right border of the heightmap
            if (xCoordInt > heightmapWidth - 2) { xCoordInt = heightmapWidth - 2; }
            if (zCoordInt > heightmapLength - 2) { zCoordInt = heightmapLength - 2; }
            float xAmount = xCoord - xCoordInt;
            float zAmount = zCoord - zCoordInt;
            // Get heights of each point
            float heightBL = heightmap[xCoordInt, zCoordInt];
            float heightBR = heightmap[xCoordInt + 1, zCoordInt];
            float heightTL = heightmap[xCoordInt, zCoordInt + 1];
            float heightTR = heightmap[xCoordInt + 1, zCoordInt + 1];
            //interpolatedNormal = -Vector3.Cross(new Vector3(terrainSize.x / (float)heightmapWidth, (heightTR - heightBL) * terrainSize.y, terrainSize.z / (float)heightmapLength),
            //                                    new Vector3(terrainSize.x / (float)heightmapWidth, (heightBR - heightTL) * terrainSize.y, -terrainSize.z / (float)heightmapLength));
            //// Bottom left triangle
            //if (xAmount + zAmount < 1f)
            //{
            //    interpolatedNormal = -Vector3.Cross(new Vector3(terrainSize.x / (float)heightmapWidth, (heightBR - heightBL) * terrainSize.y, 0f),
            //                                        new Vector3(0f, (heightTL - heightBL) * terrainSize.y, terrainSize.z / (float)heightmapLength));
            //}
            //// Top right triangle
            //else
            //{
            //    interpolatedNormal = -Vector3.Cross(new Vector3(-terrainSize.x / (float)heightmapWidth, (heightTL - heightTR) * terrainSize.y, 0f),
            //                                        new Vector3(0f, (heightBR - heightTR) * terrainSize.y, -terrainSize.z / (float)heightmapLength));
            //}
            // Bottom left triangle
            if (xAmount + zAmount < 1f)
            {
                //Vector3 v1 = new Vector3(terrainSize.x / (float)heightmapWidth, (heightBR - heightBL) * terrainSize.y, 0f);
                //Vector3 v2 = new Vector3(0f, (heightTL - heightBL) * terrainSize.y, terrainSize.z / (float)heightmapLength);
                interpolatedNormal = -Vector3.Cross(new Vector3(terrainSize.x / (float)heightmapWidth, (heightBR - heightBL) * terrainSize.y, 0f),
                                                    new Vector3(0f, (heightTL - heightBL) * terrainSize.y, terrainSize.z / (float)heightmapLength));
            }
            // Top right triangle
            else
            {
                interpolatedNormal = -Vector3.Cross(new Vector3(-terrainSize.x / (float)heightmapWidth, (heightTL - heightTR) * terrainSize.y, 0f),
                                                    new Vector3(0f, (heightBR - heightTR) * terrainSize.y, -terrainSize.z / (float)heightmapLength));
            }
            // Calculate interpolated height
            interpolatedHeight = ((1f - zAmount) * (heightBL + ((heightBR - heightBL) * xAmount))) + (zAmount * (heightTL + ((heightTR - heightTL) * xAmount)));
            //float bottomHeights = ((1f - xAmount) * heightBL) + (xAmount * heightBR);
            //float topHeights = ((1f - xAmount) * heightTL) + (xAmount * heightTR);
            //bottomHeights = (heightBL + ((heightBR - heightBL) * xAmount));
            //topHeights = (heightTL + ((heightTR - heightTL) * xAmount));
            //interpolatedHeight = ((1f - zAmount) * bottomHeights) + (zAmount * topHeights);
        }


        /// <summary>
        /// Returns the TerrainData after adjusting its heightmap resolution
        /// </summary>
        /// <returns>The heightmap resolution.</returns>
        /// <param name="tData">T data.</param>
        /// <param name="newHeightmapResolution">New heightmap resolution.</param>
        public static TerrainData AdjustHeightmapResolution(TerrainData tData, int newHeightmapResolution)
        {
            if (tData != null)
            {
                float[,] heightMap = new float[newHeightmapResolution, newHeightmapResolution];
                float terrainWidth = tData.size.x;
                float terrainLength = tData.size.z;
                float terrainHeight = tData.size.y;

                // Loop through heightmap points
                for (int x = 0; x < newHeightmapResolution; x++)
                {
                    for (int y = 0; y < newHeightmapResolution; y++)
                    {
                        //Get height of the terrain at the given position
                        xPos = ((float)x / (float)(newHeightmapResolution - 1));
                        yPos = ((float)y / (float)(newHeightmapResolution - 1));
                        heightMap[x, y] = tData.GetInterpolatedHeight(yPos, xPos);
                        heightMap[x, y] /= terrainHeight;
                    }
                }

                // Set heightmap resolution
                tData.heightmapResolution = newHeightmapResolution;
                // Set heightmap
                tData.SetHeightsDelayLOD(0, 0, heightMap);

                // Reset terrain size - for some reason, when you change the heightmap resolution, it automatically rescales the terrain as well
                tData.size = new Vector3(terrainWidth, terrainHeight, terrainLength);
            }

            return tData;
        }

        /// <summary>
        /// Return the TerrainData for a terrain that contains a point in worldspace with matching x,y heightmap coordinates
        /// NOTE: Multiple terrains in the same landscape can have the same worldspace coordinates, but only one can
        /// have the same worldspace AND heightmap coordinates.
        /// </summary>
        /// <param name="landscape"></param>
        /// <param name="point"></param>
        /// <param name="heightmapX"></param>
        /// <param name="heightmapY"></param>
        /// <returns></returns>
        public static TerrainData GetTerrainData(LBLandscape landscape, Vector3 point, int heightmapX, int heightmapY, bool showErrors = false)
        {
            TerrainData tData = null;
            TerrainData tDataTemp = null;

            Terrain[] landscapeTerrains;
            Vector3 worldPosition;
            float terrainWidth = 0f;

            Rect terrainRect;

            if (landscape != null)
            {
                GameObject landscapeGameObject = landscape.gameObject;

                if (landscapeGameObject != null)
                {
                    // Get the terrains attached to the landscape
                    landscapeTerrains = landscapeGameObject.GetComponentsInChildren<Terrain>();

                    if (landscapeTerrains != null)
                    {
                        // Loop through all the terrains in the landscape until we find the one that contains the point required
                        for (int index = 0; index < landscapeTerrains.Length; index++)
                        {
                            tDataTemp = landscapeTerrains[index].terrainData;
                            worldPosition = landscapeTerrains[index].transform.position;

                            // Terrain width (x) and length (z) are always the same in LB
                            terrainWidth = tDataTemp.size.x;

                            // Get the rectange boundary of the terrain
                            terrainRect = Rect.MinMaxRect(worldPosition.x, worldPosition.z, worldPosition.x + terrainWidth, worldPosition.z + terrainWidth);

                            // Is the point within this terrain? (Don't use Rect.Contains() because it doesn't include top and right edges)
                            if (point.x >= terrainRect.xMin && point.x <= terrainRect.xMax &&
                                point.z >= terrainRect.yMin && point.z <= terrainRect.yMax)
                            {
                                // Convert point into a normalised position on the terrain
                                float normXPos = Mathf.InverseLerp(worldPosition.x, worldPosition.x + terrainWidth, point.x);
                                float normYPos = Mathf.InverseLerp(worldPosition.z, worldPosition.z + terrainWidth, point.z);

                                int x = Mathf.RoundToInt(normXPos * (heightmapResolution - 1));
                                int y = Mathf.RoundToInt(normYPos * (heightmapResolution - 1));

                                if (x == heightmapX && y == heightmapY)
                                {
                                    tData = tDataTemp;
                                    break;
                                }
                            }
                        }
                    }
                    else { if (showErrors) { Debug.LogError("LBLandscapeTerrain.GetTerrainData - no terrains attached to selected landscape"); } }
                }
                else { if (showErrors) { Debug.LogError("LBLandscapeTerrain.GetTerrainData - landscape parent gameobject is null"); } }
            }
            else { if (showErrors) { Debug.LogError("LBLandscapeTerrain.GetTerrainData - landscape script object is null"); } }

            return tData;
        }

        /// <summary>
        /// Get all terrain heightmaps, and populate a single 1-dimensional array supplied by the calling method. The array must be created
        /// before calling this method. This method is much more efficient than returning a float array e.g. float[] flt = MyMethod(..) as it
        /// doesn't require a lot of garbage collection (GC). The float[] parmeter in this method is passed as a reference which
        /// does not require GC.
        /// USAGE:
        ///   int landscapeHeightsSize = landscape.GetTotalHeightmapSize(false);
        ///   System.GC.Collect();
        ///   float[] landscapeScopedHeightmap = new float[landscapeHeightsSize];
        ///   if (GetLandscapeScopedHeightmap(landscape, landscapeScopedHeightmap, false, showErrors)) { .... }
        /// </summary>
        /// <param name="landscape"></param>
        /// <param name="landscapeScopedHeightmap"></param>
        /// <param name="isIncludeInnerEdges"></param>
        /// <param name="showErrors"></param>
        /// <returns></returns>
        public static bool GetLandscapeScopedHeightmap(LBLandscape landscape, float[] landscapeScopedHeightmap, bool isIncludeInnerEdges, bool showErrors)
        {
            bool isSuccessful = false;
            string methodName = "LBLandscapeTerrain.GetLandscapeScopedHeightmap";

            // Perform some basic validation
            if (landscape == null) { if (showErrors) { Debug.LogWarning("ERROR " + methodName + " - landscape cannot be null"); } }
            else if (landscape.landscapeTerrains == null) { if (showErrors) { Debug.LogWarning("ERROR " + methodName + " - no terrains defined in the landscape. Please Report."); } }
            else if (landscapeScopedHeightmap == null) { if (showErrors) { Debug.LogWarning("ERROR " + methodName + " - the landscape-scoped height map array is null. Please Report."); } }
            else if (landscape.landscapeTerrains.Length < 1) { if (showErrors) { Debug.LogWarning("ERROR " + methodName + " - no terrains are in the landscape. Please Report."); } }
            else if (landscape.landscapeTerrains[0] == null) { if (showErrors) { Debug.LogWarning("ERROR " + methodName + " - the first terrain is null. Please Report."); } }
            else if (landscape.landscapeTerrains[0].terrainData == null) { if (showErrors) { Debug.LogWarning("ERROR " + methodName + " - the first terrain's data is null. Please Report."); } }
            else
            {
                int numTerrains = landscape.landscapeTerrains.Length;
                int terrainHeightmapResolution = landscape.GetLandscapeTerrainHeightmapResolution();
                int landscapeHeightsSize = landscape.GetTotalHeightmapSize(isIncludeInnerEdges);

                // By default LB creates terrains left to right, bottom to top (0,0 is bottom left corner)
                int terrainRow = 0;
                int terrainCol = 0;
                int numTerrainsWide = (int)Mathf.Sqrt(numTerrains);
                int rowPixelWidth = isIncludeInnerEdges ? (numTerrainsWide * terrainHeightmapResolution) : (numTerrainsWide * (terrainHeightmapResolution - 1)) + 1;

                // WARNING: If not including inner edges:
                //     colPixelWidth is terrainHeightmapResolution - 1 on all but right-edge terrains (i.e. terrainCol = numTerrainsWide-1)
                //     colPixelLength is terrainHeightmapResolution - 1 on all but top-edge terrains (i.e. terrainRow = numTerrainsWide-1)
                int colPixelWidth = 0;  // The variable number of pixels to be used for the current column (terrain) width
                int colPixelLength = 0; // The variable number of pixels to be used for the current column (terrain) length

                // TopEdge and LeftEdge terrains also includes a terrain in a landscape with only one terrain.
                int colPixelWidthRightEdge = terrainHeightmapResolution;
                int colPixelLengthTopEdge = terrainHeightmapResolution;

                // Inner terrains exclude a terrain in a landscape with only one terrain.
                int colPixelWidthInner = isIncludeInnerEdges ? terrainHeightmapResolution : terrainHeightmapResolution - 1;
                int colPixelLengthInner = isIncludeInnerEdges ? terrainHeightmapResolution : terrainHeightmapResolution - 1;

                // Validate the size of the landscapeScopedHeightmap
                if (landscapeScopedHeightmap.Length != landscapeHeightsSize) { if (showErrors) { Debug.LogWarning("ERROR " + methodName + " - the landscape-scoped height map array is the incorrect size. Array size: " + landscapeScopedHeightmap.Length + " - should be: " + landscapeHeightsSize + ".  Please Report."); } }
                else
                {
                    // The start of the line in the landscapeScopedHeightmap
                    int zOffset = 0;

                    // Set default values when including inner edges
                    if (isIncludeInnerEdges || numTerrains == 1)
                    {
                        colPixelWidth = colPixelWidthRightEdge;
                        colPixelLength = colPixelLengthTopEdge;
                    }

                    // Copy the data from each terrain into the array
                    for (int terrainIdx = 0; terrainIdx < numTerrains; terrainIdx++)
                    {
                        // Copy data from this terrain into the correct position in array
                        Terrain terrain = landscape.landscapeTerrains[terrainIdx];
                        TerrainData tData = terrain.terrainData;

                        terrainRow = terrainIdx % numTerrainsWide;
                        terrainCol = terrainIdx / numTerrainsWide;

                        if (!isIncludeInnerEdges && numTerrains > 1)
                        {
                            if (terrainCol == numTerrainsWide - 1) { colPixelWidth = colPixelWidthRightEdge; }
                            else { colPixelWidth = colPixelWidthInner; }

                            if (terrainRow == numTerrainsWide - 1) { colPixelLength = colPixelLengthTopEdge; }
                            else { colPixelLength = colPixelLengthInner; }
                        }

                        int previousRowsOffset = 0;

                        // Determine the offset for each previous row (if there are any)
                        for (int row = 0; row < terrainRow; row++)
                        {
                            if (row == numTerrainsWide - 1) { previousRowsOffset += (colPixelLengthTopEdge * rowPixelWidth); }
                            else { previousRowsOffset += (colPixelLengthInner * rowPixelWidth); }
                        }

                        float[,] heightMap = tData.GetHeights(0, 0, colPixelWidth, colPixelLength);

                        //Debug.Log("INFO: " + methodName + " " + terrain.name + " tRow:" + terrainRow + " tCol:" + terrainCol + " tIndex:" + terrainIdx + " rowPixelWidth:" + rowPixelWidth + " colPixelWidth:" + colPixelWidth + " colPixelLength:" + colPixelLength + " previousRowsOffset:" + previousRowsOffset + " heightMap size:" + heightMap.GetLength(0) + "," + heightMap.GetLength(1));

                        // Copy one line at a time to correct location in landscapeScopedHeightmap
                        // use "z" variable to avoid confusion with y-axis
                        for (int z = 0; z < colPixelLength; z++)
                        {
                            // previous full terrain rows (if any)
                            // + previous full rows of pixels in the current row of terrains (if z > 0)
                            // + pixels in current row of pixels in terrains (columns) to the left of the current terrain (these will always be INNER terrains)  
                            zOffset = previousRowsOffset + (z * rowPixelWidth) + (terrainCol * colPixelWidthInner);

                            //Debug.Log(" INFO z:" + z + " previousRowsOffset:" + previousRowsOffset + " + (terrainCol * colPixelWidth) + " + (terrainCol * colPixelWidth) + " + (z * rowPixelWidth) + " + (z * rowPixelWidth) + " = " + zOffset + " landscapeScopedHeightmap[" +(zOffset) + ".." + (zOffset+colPixelWidth - 1) + "] = heightMap[" + z + ", 0.." + (colPixelWidth-1) + "]");

                            // NOTE: Cannot use System.Buffer.BlockCopy in this case because the heightmap[y,x] is stored in a different order than
                            // our landscapeScopedHeightmap data.
                            for (int px = 0; px < colPixelWidth; px++) { landscapeScopedHeightmap[zOffset + px] = heightMap[z, px]; }
                        }
                    }

                    isSuccessful = true;
                }
            }

            return isSuccessful;
        }

        /// <summary>
        /// Get all terrain heightmaps, and populate a single 1-dimensional array supplied by the calling method. The array must be created
        /// before calling this method. The float[] parmeter in this method is passed as a reference which does not require GC.
        /// terrainHeightmapResolution is the resolution that the terrains will be sampled at. This may not match the actual terrain heightmap resolution.
        /// Typically used to pass lowres heightmaps to compute shaders.
        /// Heights are returned as normalised values (0.0 - 1.0)
        /// WARNING: Currently does not support non-square landscapes with different number of terrains on x and z axis
        /// </summary>
        /// <param name="landscape"></param>
        /// <param name="landscapeScopedHeightmap"></param>
        /// <param name="terrainHeightmapResolution"></param>
        /// <param name="showErrors"></param>
        /// <returns></returns>
        public static bool GetLandscapeScopedHeightmap(LBLandscape landscape, ref float[] landscapeScopedHeightmap, int terrainHeightmapResolution, bool showErrors)
        {
            bool isSuccessful = false;
            string methodName = "LBLandscapeTerrain.GetLandscapeScopedHeightmap";

            // Perform some basic validation
            if (landscape == null) { if (showErrors) { Debug.LogWarning("ERROR " + methodName + " - landscape cannot be null"); } }
            else if (landscape.landscapeTerrains == null) { if (showErrors) { Debug.LogWarning("ERROR " + methodName + " - no terrains defined in the landscape. Please Report."); } }
            else if (landscapeScopedHeightmap == null) { if (showErrors) { Debug.LogWarning("ERROR " + methodName + " - the landscape-scoped height map array is null. Please Report."); } }
            else if (landscape.landscapeTerrains.Length < 1) { if (showErrors) { Debug.LogWarning("ERROR " + methodName + " - no terrains are in the landscape. Please Report."); } }
            else
            {
                int numTerrains = 0, numTerrainsWide = 0, numTerrainsDeep = 0;
                landscape.GetNumTerrainsXZ(ref numTerrains, ref numTerrainsWide, ref numTerrainsDeep);

                Vector3 terrainSize = numTerrains < 1 ? Vector3.zero : landscape.landscapeTerrains[0].terrainData.size;
                int landscapeHeightsSize = numTerrains < 1 ? 0 : landscape.GetTotalHeightmapSize(false, 65, terrainSize);

                // By default LB creates terrains left to right, bottom to top (0,0 is bottom left corner)
                int terrainRow = 0;
                int terrainCol = 0;

                int rowPixelWidth = (numTerrainsWide * (terrainHeightmapResolution - 1)) + 1;

                // colPixelWidth is terrainHeightmapResolution - 1 on all but right-edge terrains (i.e. terrainCol = numTerrainsWide-1)
                // colPixelLength is terrainHeightmapResolution - 1 on all but top-edge terrains (i.e. terrainRow = numTerrainsWide-1)

                int colPixelWidth = 0;  // The variable number of pixels to be used for the current column (terrain) width
                int colPixelLength = 0; // The variable number of pixels to be used for the current column (terrain) length

                // TopEdge and LeftEdge terrains also includes a terrain in a landscape with only one terrain.
                int colPixelWidthRightEdge = terrainHeightmapResolution;
                int colPixelLengthTopEdge = terrainHeightmapResolution;

                // Inner terrains exclude a terrain in a landscape with only one terrain.
                int colPixelWidthInner = terrainHeightmapResolution - 1;
                int colPixelLengthInner = terrainHeightmapResolution - 1;

                // Validate the size of the landscapeScopedHeightmap
                if (landscapeScopedHeightmap.Length != landscapeHeightsSize) { if (showErrors) { Debug.LogWarning("ERROR " + methodName + " - the landscape-scoped height map array is the incorrect size. Array size: " + landscapeScopedHeightmap.Length + " - should be: " + landscapeHeightsSize + ".  Please Report."); } }
                else
                {
                    // The start of the line in the landscapeScopedHeightmap
                    int zOffset = 0;

                    // Set default values when including inner edges
                    if (numTerrains == 1)
                    {
                        colPixelWidth = colPixelWidthRightEdge;
                        colPixelLength = colPixelLengthTopEdge;
                    }

                    // Copy the data from each terrain into the array
                    for (int terrainIdx = 0; terrainIdx < numTerrains; terrainIdx++)
                    {
                        // Copy data from this terrain into the correct position in array
                        Terrain terrain = landscape.landscapeTerrains[terrainIdx];
                        TerrainData tData = terrain.terrainData;

                        float terrainHeight = tData.size.y;

                        // WARNING: THIS DOES NOT WORK WITH NON-SQUARE LANDSCAPES
                        terrainRow = terrainIdx % numTerrainsWide;
                        terrainCol = terrainIdx / numTerrainsWide;

                        if (numTerrains > 1)
                        {
                            if (terrainCol == numTerrainsWide - 1) { colPixelWidth = colPixelWidthRightEdge; }
                            else { colPixelWidth = colPixelWidthInner; }

                            if (terrainRow == numTerrainsWide - 1) { colPixelLength = colPixelLengthTopEdge; }
                            else { colPixelLength = colPixelLengthInner; }
                        }

                        int previousRowsOffset = 0;

                        // Determine the offset for each previous row (if there are any)
                        for (int row = 0; row < terrainRow; row++)
                        {
                            if (row == numTerrainsWide - 1) { previousRowsOffset += (colPixelLengthTopEdge * rowPixelWidth); }
                            else { previousRowsOffset += (colPixelLengthInner * rowPixelWidth); }
                        }

                        float colPixelLengthTopEdgeLess1F = (float)(colPixelLengthTopEdge - 1);
                        float colPixelWidthRightEdgeLess1F = (float)(colPixelWidthRightEdge - 1);

                        // Copy one line at a time to correct location in landscapeScopedHeightmap
                        // use "z" variable to avoid confusion with y-axis
                        for (int z = 0; z < colPixelLength; z++)
                        {
                            // previous full terrain rows (if any)
                            // + previous full rows of pixels in the current row of terrains (if z > 0)
                            // + pixels in current row of pixels in terrains (columns) to the left of the current terrain (these will always be INNER terrains)  
                            zOffset = previousRowsOffset + (z * rowPixelWidth) + (terrainCol * colPixelWidthInner);
                            float zN = (float)z / colPixelLengthTopEdgeLess1F;

                            for (int px = 0; px < colPixelWidth; px++)
                            {
                                // TerrainData.GetInterpolatedHeight() requires normalised x and z values within the terrain
                                // and returns a height in metres. Convert to normalised height (0.0 - 1.0)

                                float xN = (float)px / colPixelWidthRightEdgeLess1F;
                                landscapeScopedHeightmap[zOffset + px] = tData.GetInterpolatedHeight(xN, zN) / terrainHeight;
                            }
                        }
                    }
                }
            }

            return isSuccessful;
        }

        /// <summary>
        /// Get all terrain heightmaps, and populate a single 2-dimensional array supplied by the calling method.
        /// WARNING: Not fully regression tested
        /// </summary>
        /// <param name="landscape"></param>
        /// <param name="landscapeScopedHeightmap"></param>
        /// <param name="showErrors"></param>
        /// <returns></returns>
        public static bool GetLandscapeScopedHeightmap(LBLandscape landscape, float[,] landscapeScopedHeightmap, bool showErrors)
        {
            bool isSuccessful = false;
            string methodName = "LBLandscapeTerrain.GetLandscapeScopedHeightmap";

            // Perform some basic validation
            if (landscape == null) { if (showErrors) { Debug.LogWarning("ERROR " + methodName + " - landscape cannot be null"); } }
            else if (landscape.landscapeTerrains == null) { if (showErrors) { Debug.LogWarning("ERROR " + methodName + " - no terrains defined in the landscape. Please Report."); } }
            else if (landscapeScopedHeightmap == null) { if (showErrors) { Debug.LogWarning("ERROR " + methodName + " - the landscape-scoped height map array is null. Please Report."); } }
            else if (landscape.landscapeTerrains.Length < 1) { if (showErrors) { Debug.LogWarning("ERROR " + methodName + " - no terrains are in the landscape. Please Report."); } }
            else if (landscape.landscapeTerrains[0] == null) { if (showErrors) { Debug.LogWarning("ERROR " + methodName + " - the first terrain is null. Please Report."); } }
            else if (landscape.landscapeTerrains[0].terrainData == null) { if (showErrors) { Debug.LogWarning("ERROR " + methodName + " - the first terrain's data is null. Please Report."); } }
            else
            {
                int numTerrains = landscape.landscapeTerrains.Length;
                int terrainHeightmapResolution = landscape.landscapeTerrains[0].terrainData.heightmapResolution;
                int pixelPerHeightmap = terrainHeightmapResolution * terrainHeightmapResolution;
                int landscapeHeightsSize = pixelPerHeightmap * numTerrains;

                // Validate the size of the landscapeScopedHeightmap
                if (landscapeScopedHeightmap.Length != landscapeHeightsSize) { if (showErrors) { Debug.LogWarning("ERROR " + methodName + " - the landscape-scoped height map array is the incorrect size. Array size: " + landscapeScopedHeightmap.Length + " - should be: " + landscapeHeightsSize + ".  Please Report."); } }
                else
                {
                    // The start of the line in thelandscapeScopedHeightmap
                    int zOffset = 0, xOffset = 0;
                    int terrainsWide = (int)Mathf.Sqrt(numTerrains);

                    // By default LB creates terrains left to right, bottom to top (0,0 is bottom left corner)
                    int terrainRow = 0;
                    int terrainCol = 0;

                    // Copy the data from each terrain into the array
                    for (int terrainIdx = 0; terrainIdx < numTerrains; terrainIdx++)
                    {
                        // Copy data from this terrain into the correct position in array
                        Terrain terrain = landscape.landscapeTerrains[terrainIdx];
                        TerrainData tData = terrain.terrainData;

                        float[,] heightMap = tData.GetHeights(0, 0, tData.heightmapResolution, tData.heightmapResolution);

                        // Copy one line at a time to correct location in landscapeScopedHeightmap
                        // use "z" variable to avoid confusion with y-axis
                        for (int z = 0; z < terrainHeightmapResolution; z++)
                        {
                            zOffset = (terrainRow * terrainHeightmapResolution) + z;

                            for (int x = 0; x < terrainHeightmapResolution; x++)
                            {
                                xOffset = (terrainCol * terrainHeightmapResolution) + x;
                                landscapeScopedHeightmap[zOffset, xOffset] = heightMap[z, x];
                            }
                        }

                        terrainCol++;

                        if (terrainCol >= terrainsWide) { terrainCol = 0; terrainRow++; }
                    }
                    isSuccessful = true;
                }
            }

            return isSuccessful;
        }

        /// <summary>
        /// Update all the terrain heightmaps in a landscape, with data from a single 1-dimensional array supplied by the calling
        /// method.
        /// </summary>
        /// <param name="landscape"></param>
        /// <param name="landscapeScopedHeightmap"></param>
        /// <param name="showErrors"></param>
        /// <returns></returns>
        public static bool CommitLandscapeScopedHeightmap(LBLandscape landscape, float[] landscapeScopedHeightmap, bool isIncludeInnerEdges, bool showErrors)
        {
            bool isSuccessful = false;
            string methodName = "LBLandscapeTerrain.CommitLandscapeScopedHeightmap";

            // Perform some basic validation
            if (landscape == null) { if (showErrors) { Debug.LogWarning("ERROR " + methodName + " - landscape cannot be null"); } }
            else if (landscape.landscapeTerrains == null) { if (showErrors) { Debug.LogWarning("ERROR " + methodName + " - no terrains defined in the landscape. Please Report."); } }
            else if (landscapeScopedHeightmap == null) { if (showErrors) { Debug.LogWarning("ERROR " + methodName + " - the landscape-scoped height map array is null. Please Report."); } }
            else if (landscape.landscapeTerrains.Length < 1) { if (showErrors) { Debug.LogWarning("ERROR " + methodName + " - no terrains are in the landscape. Please Report."); } }
            else if (landscape.landscapeTerrains[0] == null) { if (showErrors) { Debug.LogWarning("ERROR " + methodName + " - the first terrain is null. Please Report."); } }
            else if (landscape.landscapeTerrains[0].terrainData == null) { if (showErrors) { Debug.LogWarning("ERROR " + methodName + " - the first terrain's data is null. Please Report."); } }
            else
            {
                int numTerrains = landscape.landscapeTerrains.Length;
                int terrainHeightmapResolution = landscape.GetLandscapeTerrainHeightmapResolution();
                int landscapeHeightsSize = landscape.GetTotalHeightmapSize(isIncludeInnerEdges);

                // By default LB creates terrains left to right, bottom to top (0,0 is bottom left corner)
                int terrainRow = 0;
                int terrainCol = 0;
                int numTerrainsWide = (int)Mathf.Sqrt(numTerrains);
                int rowPixelWidth = isIncludeInnerEdges ? (numTerrainsWide * terrainHeightmapResolution) : (numTerrainsWide * (terrainHeightmapResolution - 1)) + 1;

                // WARNING: If not including inner edges:
                //     colPixelWidth is terrainHeightmapResolution - 1 on all but right-edge terrains (i.e. terrainCol = numTerrainsWide-1)
                //     colPixelLength is terrainHeightmapResolution - 1 on all but top-edge terrains (i.e. terrainRow = numTerrainsWide-1)
                //int colPixelWidth = 0;  // The variable number of pixels to be used for the current column (terrain) width
                //int colPixelLength = 0; // The variable number of pixels to be used for the current column (terrain) length

                // TopEdge and LeftEdge terrains also includes a terrain in a landscape with only one terrain.
                int colPixelWidthRightEdge = terrainHeightmapResolution;
                int colPixelLengthTopEdge = terrainHeightmapResolution;

                // Inner terrains exclude a terrain in a landscape with only one terrain.
                int colPixelWidthInner = isIncludeInnerEdges ? terrainHeightmapResolution : terrainHeightmapResolution - 1;
                int colPixelLengthInner = isIncludeInnerEdges ? terrainHeightmapResolution : terrainHeightmapResolution - 1;

                // Validate the size of the landscapeScopedHeightmap
                if (landscapeScopedHeightmap.Length != landscapeHeightsSize) { if (showErrors) { Debug.LogWarning("ERROR " + methodName + " - the landscape-scoped height map array is the incorrect size. Array size: " + landscapeScopedHeightmap.Length + " - should be: " + landscapeHeightsSize + ".  Please Report."); } }
                else
                {
                    // The start of the line in the landscapeScopedHeightmap
                    int zOffset = 0;

                    // Set default values when including inner edges
                    //if (isIncludeInnerEdges || numTerrains == 1)
                    //{
                    //    colPixelWidth = colPixelWidthRightEdge;
                    //    colPixelLength = colPixelLengthTopEdge;
                    //}

                    for (int terrainIdx = 0; terrainIdx < numTerrains; terrainIdx++)
                    {
                        Terrain terrain = landscape.landscapeTerrains[terrainIdx];
                        TerrainData tData = terrain.terrainData;

                        terrainRow = terrainIdx % numTerrainsWide;
                        terrainCol = terrainIdx / numTerrainsWide;

                        //if (!isIncludeInnerEdges && numTerrains > 1)
                        //{
                        //    if (terrainCol == numTerrainsWide - 1) { colPixelWidth = colPixelWidthRightEdge; }
                        //    else { colPixelWidth = colPixelWidthInner; }

                        //    if (terrainRow == numTerrainsWide - 1) { colPixelLength = colPixelLengthTopEdge; }
                        //    else { colPixelLength = colPixelLengthInner; }
                        //}

                        int previousRowsOffset = 0;

                        // Determine the offset for each previous row (if there are any)
                        for (int row = 0; row < terrainRow; row++)
                        {
                            if (row == numTerrainsWide - 1) { previousRowsOffset += (colPixelLengthTopEdge * rowPixelWidth); }
                            else { previousRowsOffset += (colPixelLengthInner * rowPixelWidth); }
                        }

                        // Write back to the full terrain (not the one with potentially no inner edges)
                        float[,] heightMapTerrain = new float[colPixelLengthTopEdge, colPixelWidthRightEdge];

                        //Debug.Log("INFO: commit hm " + terrain.name + " colPixelLengthTopEdge:" + colPixelLengthTopEdge + " colPixelWidthRightEdge:" + colPixelWidthRightEdge + " colPixelLengthInner:" + colPixelLengthInner + " previousRowsOffset:" + previousRowsOffset);

                        // Loop through each horizontal z-axis line of the terrain
                        for (int z = 0; z < colPixelLengthTopEdge; z++)
                        {
                            // previous full terrain rows (if any)
                            // + previous full rows of pixels in the current row of terrains (if z > 0)
                            // + pixels in current row of pixels in terrains (columns) to the left of the current terrain (these will always be INNER terrains)  
                            zOffset = previousRowsOffset + (z * rowPixelWidth) + (terrainCol * colPixelWidthInner);

                            // If not on the left terrain, start from the last pixel in the same column of the previous terrain.
                            // This is done because if we're excluding inner edges of terrains, there is only one point along the edge
                            // of two terrains in the source array. However, two adjoining terrains have two pixels at the same location
                            // along their borders (one in each terrain).
                            //if (!isIncludeInnerEdges && terrainCol > 0) { zOffset--; }

                            // Copy each line for this terrain in the landscape-scoped float[] array, to the terrain heightmap
                            for (int px = 0; px < colPixelWidthRightEdge; px++) { heightMapTerrain[z, px] = landscapeScopedHeightmap[zOffset + px]; }
                        }

                        tData.SetHeightsDelayLOD(0, 0, heightMapTerrain);
                        isSuccessful = true;
                    }
                }
            }

            return isSuccessful;
        }

        /// <summary>
        /// Size and populate a smaller 1D array (smallerLandscapeScopedHeightmap), with data bounded by a rectangle
        /// within a landscape-scoped array landscapeScopedHeightmap.
        /// WARNING: Very limited error checking for performance reasons. Ensure the data is valid before
        /// calling this method.
        /// </summary>
        /// <param name="landscape"></param>
        /// <param name="landscapeScopedHeightmap"></param>
        /// <param name="landscapeScopedHeightmapResolution"></param>
        /// <param name="smallerLandscapeScopedHeightmap"></param>
        /// <param name="smallerLandscapeScopedHeightmapResolution"></param>
        /// <param name="xMinRect"></param>
        /// <param name="xMaxRect"></param>
        /// <param name="yMinRect"></param>
        /// <param name="yMaxRect"></param>
        /// <param name="showErrors"></param>
        /// <returns></returns>
        public static bool GetSmallerLandscapeScopedHeightmap(LBLandscape landscape, float[] landscapeScopedHeightmap, int landscapeScopedHeightmapResolution, ref float[] smallerLandscapeScopedHeightmap, ref int smallerLandscapeScopedHeightmapResolution, Rect rect, bool showErrors)
        {
            bool isSuccessful = false;

            string methodName = "LBLandscapeTerrain.GetSmallerLandscapeScopedHeightmap";

            // Perform some basic validation
            if (landscape == null) { if (showErrors) { Debug.LogWarning("ERROR " + methodName + " - landscape cannot be null"); } }
            else
            {
                // Get normalised landscape coordinates of this rect
                float normXMin = (rect.xMin - landscape.transform.position.x) / landscape.size.x;
                float normXMax = (rect.xMax - landscape.transform.position.x) / landscape.size.x;
                float normYMin = (rect.yMin - landscape.transform.position.z) / landscape.size.y;
                float normYMax = (rect.yMax - landscape.transform.position.z) / landscape.size.y;

                // Confine rect to the bounds of the landscape
                if (normXMin < 0f) { normXMax -= normXMin; normXMin = 0f; }
                else if (normXMax > 1f) { normXMin -= (normXMax - 1f); normXMax = 1f; }
                if (normYMin < 0f) { normYMax -= normYMin; normYMin = 0f; }
                else if (normYMax > 1f) { normYMin -= (normYMax - 1f); normYMax = 1f; }

                // Calculate the resolution of the new heightmap
                // INFO: Was originally using round values, but ceil seems to give better results
                smallerLandscapeScopedHeightmapResolution = Mathf.CeilToInt((rect.width / landscape.size.x) * landscapeScopedHeightmapResolution);
                // Get min and max coordinates of the new heightmap in terms of the landscape heightmap
                // INFO: Was originally using floor values, but round seems to give better results
                int xMinIndex = Mathf.RoundToInt(normXMin * (landscapeScopedHeightmapResolution - 1));
                int yMinIndex = Mathf.RoundToInt(normYMin * (landscapeScopedHeightmapResolution - 1));
                //int xMaxIndex = xMinIndex + smallerLandscapeScopedHeightmapResolution - 1;
                int yMaxIndex = yMinIndex + smallerLandscapeScopedHeightmapResolution - 1;

                // Create the new heightmap
                smallerLandscapeScopedHeightmap = new float[smallerLandscapeScopedHeightmapResolution * smallerLandscapeScopedHeightmapResolution];

                int yIndex, bigHeightmapIndex, smallHeightmapIndex;

                // Retrieve the new heightmap from the landscape heightmap
                for (yIndex = yMinIndex; yIndex <= yMaxIndex; yIndex++)
                {
                    // Index is multiplied by four as it is a BYTE index, not a FLOAT index
                    bigHeightmapIndex = (yIndex * landscapeScopedHeightmapResolution * 4) + (xMinIndex * 4);
                    smallHeightmapIndex = ((yIndex - yMinIndex) * smallerLandscapeScopedHeightmapResolution * 4);
                    System.Buffer.BlockCopy(landscapeScopedHeightmap, bigHeightmapIndex, smallerLandscapeScopedHeightmap, smallHeightmapIndex, sizeof(float) * smallerLandscapeScopedHeightmapResolution);
                }

                isSuccessful = true;
            }

            return isSuccessful;
        }

        /// <summary>
        /// Update data bounded by a rectangle in a landscape-scoped 1D array landscapeScopedHeightmap
        /// within data from a smaller 1D array.
        /// WARNING: Very limited error checking for performance reasons. Ensure the data is valid before
        /// calling this method.
        /// </summary>
        /// <param name="landscape"></param>
        /// <param name="landscapeScopedHeightmap"></param>
        /// <param name="landscapeScopedHeightmapResolution"></param>
        /// <param name="smallerLandscapeScopedHeightmap"></param>
        /// <param name="smallerLandscapeScopedHeightmapResolution"></param>
        /// <param name="xMinRect"></param>
        /// <param name="xMaxRect"></param>
        /// <param name="yMinRect"></param>
        /// <param name="yMaxRect"></param>
        /// <param name="showErrors"></param>
        /// <returns></returns>
        public static bool CommitSmallerLandscapeScopedHeightmap(LBLandscape landscape, float[] landscapeScopedHeightmap, int landscapeScopedHeightmapResolution, float[] smallerLandscapeScopedHeightmap, int smallerLandscapeScopedHeightmapResolution, Rect rect, bool showErrors)
        {
            bool isSuccessful = false;

            string methodName = "LBLandscapeTerrain.CommitSmallerLandscapeScopedHeightmap";

            // Perform some basic validation
            if (landscape == null) { if (showErrors) { Debug.LogWarning("ERROR " + methodName + " - landscape cannot be null"); } }
            else
            {
                // Get normalised landscape coordinates of this rect
                float normXMin = (rect.xMin - landscape.transform.position.x) / landscape.size.x;
                float normXMax = (rect.xMax - landscape.transform.position.x) / landscape.size.x;
                float normYMin = (rect.yMin - landscape.transform.position.z) / landscape.size.y;
                float normYMax = (rect.yMax - landscape.transform.position.z) / landscape.size.y;

                // Confine rect to the bounds of the landscape
                if (normXMin < 0f) { normXMax -= normXMin; normXMin = 0f; }
                else if (normXMax > 1f) { normXMin -= (normXMax - 1f); normXMax = 1f; }
                if (normYMin < 0f) { normYMax -= normYMin; normYMin = 0f; }
                else if (normYMax > 1f) { normYMin -= (normYMax - 1f); normYMax = 1f; }

                // Get min and max coordinates of the new heightmap in terms of the landscape heightmap
                // INFO: Was originally using floor values, but round seems to give better results
                int xMinIndex = Mathf.RoundToInt(normXMin * (landscapeScopedHeightmapResolution - 1));
                int yMinIndex = Mathf.RoundToInt(normYMin * (landscapeScopedHeightmapResolution - 1));
                //int xMaxIndex = xMinIndex + smallerLandscapeScopedHeightmapResolution - 1;
                int yMaxIndex = yMinIndex + smallerLandscapeScopedHeightmapResolution - 1;

                int yIndex, bigHeightmapIndex, smallHeightmapIndex;

                // Copy each line from the small 1D array, back into the larger 1D heightmap array.
                for (yIndex = yMinIndex; yIndex <= yMaxIndex; yIndex++)
                {
                    // Index is multiplied by four as it is a BYTE index, not a FLOAT index
                    bigHeightmapIndex = (yIndex * landscapeScopedHeightmapResolution * 4) + (xMinIndex * 4);
                    smallHeightmapIndex = ((yIndex - yMinIndex) * smallerLandscapeScopedHeightmapResolution * 4);
                    System.Buffer.BlockCopy(smallerLandscapeScopedHeightmap, smallHeightmapIndex, landscapeScopedHeightmap, bigHeightmapIndex, sizeof(float) * smallerLandscapeScopedHeightmapResolution);
                }

                isSuccessful = true;
            }

            return isSuccessful;
        }

        #endregion

        #region Static LOD Methods

        /// <summary>
        /// If TerrainData.SetHeightsDelayLOD() has been used on one or more terrains,
        /// this is required to update the terrain's LOD and vegetation information.
        /// </summary>
        /// <param name="landscapeTerrains"></param>
        public static void ApplyDelayedHeightmapLOD(Terrain[] landscapeTerrains)
        {
            if (landscapeTerrains != null)
            {
                foreach (Terrain terrain in landscapeTerrains)
                {
                    #if UNITY_2019_1_OR_NEWER
                    if (terrain.terrainData != null) { terrain.terrainData.SyncHeightmap(); }
                    #else
                    if (terrain.terrainData != null) { terrain.ApplyDelayedHeightmapModification(); }
                    #endif
                }
            }
        }
        #endregion

        #region Static Heightmap Methods (Layer-based)

        /// <summary>
        /// Apply Perlin Noise or Image heightmap data to a terrain heightmap based on a list of LBLayers.
        /// NOTE 1: ApplyDelayedHeightmapLOD() needs to be called after all terrains have been processed.
        /// Smoothing is now a post-topography effect that is to be applied after all the terrains have been
        /// processed by calling SmoothHeightmapFromLayers() for each terrain
        /// NOTE 2: Ensure any Image textures or Map textures are readable before calling this method.
        /// NOTE 3: Call LBStencil.FreeStencilResources(landscape, true) after calling this method if
        /// a LBFilterType.StencilLayer was used.
        /// </summary>
        /// <param name="landscape"></param> the current LBLandscape instance
        /// <param name="tData"></param> terrains[t].terrainData
        /// <param name="worldPosition"></param> the worldspace position of the terrain - terrains[t].transform.position
        /// <param name="landscapeSize"></param> the width and length of the landscape as a vector2
        /// <param name="landscapePosition"></param> the worldspace position of the landscape - landscape.gameObject.transform.position
        /// <param name="layersList"></param> the list of LBLayers that make up this topography
        /// <returns></returns>
        public static TerrainData HeightmapFromLayers(LBLandscape landscape, TerrainData tData, Vector3 worldPosition, Vector2 landscapeSize, Vector3 landscapePosition, List<LBLayer> layersList)
        {
            float tStart = Time.realtimeSinceStartup;
            string methodName = "LBLandscapeTerrain.HeightmapFromLayers";
            if (landscape == null)
            {
                #if UNITY_EDITOR
                Debug.LogWarning("ERROR " + methodName + " - landscape cannot be null");
                #endif
            }
            if (tData == null)
            {
                #if UNITY_EDITOR
                Debug.LogWarning("ERROR " + methodName + " - terrain data cannot be null");
                #endif
            }
            else
            {
                heightmapResolution = tData.heightmapResolution;

                #region HeightmapFromLayers Variables

                // NOTE: SetHeights() and SetHeightsDelayLOD() expects array to be [y,x].
                // For legacy reasons, LB routines tend to update [x,y] so we need to switch stuff around...
                float[,] heightMap = new float[heightmapResolution, heightmapResolution];

                float xPos2 = 0f, zPos2 = 0f;
                float xAreaPosNormalised = 0f, zAreaPosNormalised = 0f;
                float areaRectBlendWidthMin = 0.05f;    // Blend 5% of each edge with surroundings
                float areaRectBlendWidthMax = 0.50f;    // Blend 50% of each edge with surroundings
                float areaRectBlendWidth = 0.2f;        // Normalised edge width to blend with heightmap (get's calculated for each Layer)
                float areaRectBlendWidthUpper = 0.8f;   // Calculated for each layer
                float areaRectBlendFactor = 0f;
                AnimationCurve areaRectBlendCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);
                Vector2 texCoords = Vector2.zero;
                Vector2 imageMinMaxRange = Vector2.zero;
                float terrainWidth = tData.size.x;
                float terrainHeight = tData.size.y;

#if LB_COMPUTE
                float terrainLength = tData.size.z;
#endif

                // Map LBLayerFilter variables
                LBMapPoint mapPoint;
                float pixelVariationNormalised = 0f;

                LBLayerFilter lbLayerFilter = null;

                // Stencil LBLayerFilter variables
                LBMapPoint arrayPoint = new LBMapPoint(0, 0);
                int stencilLayerResolution = 0;
                //AnimationCurve stencilLayerCurve = LBCurve.SetCurveFromPreset(LBCurve.CurvePreset.PowerOfFour);

                // Get the normalised (0-1) bounds of this terrain within the landscape (used for Map LBLayerFilter)
                float startX = ((worldPosition.x - landscapePosition.x) / landscapeSize.x);
                float endX = startX + (tData.size.x / landscapeSize.x);
                float startZ = ((worldPosition.z - landscapePosition.z) / landscapeSize.y);
                float endZ = startZ + (tData.size.z / landscapeSize.y);
                float xPosNormalised = 0f, zPosNormalised = 0f;

                // MapPath Layer variables
                Vector3 hmapWorldPos = Vector3.zero;
                Vector3 lastLeftPoint = Vector3.zero;
                Vector3 lastRightPoint = Vector3.zero;
                Vector3 firstLeftPoint = Vector3.zero;
                Vector3 firstRightPoint = Vector3.zero;
                int closestPoint = 0, secondclosestPoint = 0;
                int numSplinePoints = 0;
                Vector3 quadP1 = Vector3.zero, quadP2 = Vector3.zero, quadP3 = Vector3.zero, quadP4 = Vector3.zero;
                bool isMatch = false;
                float sqrDistLeft = 0f, sqrDistRight = 0f, sqrPixelDistFromEdge = 0f;
                float sqrDistToEnd = 0f, sqrDistToStart = 0f;
                float sqrblendEdgeWidth = 0f;
                float distFromEdge = 0f;
                float blendAmount = 0f, endBlendAmount = 0f;
                int prevIdx = 0, nextIdx = 0;
                int quadLookAheadInt = 1;
                int widthPoint = 0;
                int firstMatchPtIdx = 0, secondMatchPtIdx = 0;
                float pathWidthAtPoint = 0f;
                // MapPath LayerTypeMode Flatten variables
                float heightAtCentreSpline = 0f;
                float minHeight = 0f, maxHeight = 0;
                Vector3 forwards;
                Vector3 centrePointInterpolated = Vector3.zero;
                Vector3 perpdclr = Vector3.zero;
                Vector3 firstMatchCentrePt = Vector3.zero, secondMatchCentrePt = Vector3.zero;
                Vector3 firstMatchPerp = Vector3.zero, secondMatchPerp = Vector3.zero;
                float pixelDistFromCentre = 0f;
                float normXPos = 0f, normZPos = 0f;
                float flattenLerpValX = 0f, flattenLerpValZ = 0f;

                // Normalised addHeight value for additive/subtractive perlin layers
                float addHeightN = 0f;
                float minHeightmapHeightN = 0f;
                float tempHeight = 0f;

                // Noise offset adjustment. This reduces the chance of noise mirroring due to -ve noise values
                float noiseOffsetXadj = landscape.useLegacyNoiseOffset ? 0 : 25000f;
                float noiseOffsetZadj = landscape.useLegacyNoiseOffset ? 0 : 25000f;

                #endregion

#if !(UNITY_STANDALONE_OSX || UNITY_STANDALONE_WIN || UNITY_XBOXONE || UNITY_WSA_10_0)
                bool isTopographyComputeEnabled = false;
                bool isPathComputeEnabled = false;
#else
                bool isTopographyComputeEnabled = (landscape == null ? false : landscape.useGPUTopography);
                bool isPathComputeEnabled = (landscape == null ? false : landscape.useGPUPath);
#endif

                #region Reset Garbage Collection
                System.GC.Collect();
                #endregion

                #region Init Compute

#if LB_COMPUTE

                // Compute variables
                ComputeBuffer cbufHeightsIn = null;
                ComputeBuffer cbufHeightsOut = null;
                ComputeBuffer cbufAddSubCurve = null;
                ComputeBuffer cbufModifierCurves = null;
                ComputeBuffer cbufModCurvesNumFrames = null; // Combined list of Number of Frames in each PerOctave and Output Curves
                ComputeBuffer cbufLBFilters = null;
                ComputeBuffer cbufRAW = null; // holds LBRaw height data as uints
                Vector4[] pkKeyFrames = null;
                Vector4[] dummypkKeyFrames = { Vector4.zero };
                int[] dummynumKeyFrames = { 0 };
                Vector4 cvec4AreaRect = Vector4.zero;
                Vector4 cvec4MinMaxRange = Vector4.zero;
                Texture2D terrainNormalsTex = null;
                Texture2D dummyTex = null;
                Texture2DArray dummyTex2DArray = null;

                // There are 128x128, 256x256, 512x512, 1Kx1K, 2Kx2K, 4Kx4K and 8Kx8K Text2DArrays for stencil layers
                List<Texture2DArray> stencilLayerTex2DArrayList = new List<Texture2DArray>(7);
                LBCSFilter[] lbcsFilter = null;
                List<string> stencilLayerGUIDList = null;
                // Each unique stencil layer resolution has a list of stencil layer GUIDs
                List<List<string>> stencilLayerArrayGUIDList = new List<List<string>>();
                LBStencilLayer lbStencilLayer = null;

                int cskTopoPerlinNumThreads = 16; // Must match LB_TOPO_NUM_THREADS in LBCSTopo.compute
                int cskTopoImageNumThreads = 16; // Must match LB_TOPO_IMAGE_NUM_THREADS in LBCSTopo.compute
                ComputeShader shaderTopo = null;

                if (isTopographyComputeEnabled)
                {
                    shaderTopo = (ComputeShader)Resources.Load(LBCSTopo, typeof(ComputeShader));
                    if (shaderTopo == null) { Debug.LogWarning("ERROR: " + methodName + " " + LBCSTopo + ".shader not found. Please Report"); }
                    else
                    {
                        dummyTex = new Texture2D(1, 1, TextureFormat.ARGB32, false, true);
                        dummyTex2DArray = new Texture2DArray(1, 1, 1, TextureFormat.ARGB32, false, true);
                    }
                }

#endif

#if LB_COMPUTE

                int cskPathNumThreads = 16; // Must match LB_PATH_NUM_THREADS in LBCSPath.compute
                ComputeShader shaderPath = null;
                ComputeBuffer cbufSplinePointsCentre = null;
                ComputeBuffer cbufSplinePointsLeft = null;
                ComputeBuffer cbufSplinePointsRight = null;
                ComputeBuffer cbufMapPathBlendCurve = null;
                ComputeBuffer cbufMapPathHeightCurve = null;

                if (isPathComputeEnabled)
                {
                    shaderPath = (ComputeShader)Resources.Load(LBCSPath, typeof(ComputeShader));
                    if (shaderPath == null) { Debug.LogWarning("ERROR: " + methodName + " " + LBCSPath + ".shader not found. Please Report"); }
                }
#else
                ComputeShader shaderPath = null;
#endif

                #endregion

                // Loop through layers
                for (int l = 0; l < layersList.Count; l++)
                {
                    // Retrieve the layer data from the list
                    layer = layersList[l];

                    // Make sure that the layer exists
                    if (layer != null)
                    {
                        // If layer is disabled, skip this one
                        if (layer.isDisabled) { continue; }

                        // Store the layer type as an int for fast retrieval later
                        layerTypeInt = layer.LayerTypeInt;

                        if (layerTypeInt < 0) { Debug.LogWarning("ERROR: LBLandscapeTerrain.HeightmapFromLayers - layer type is invalid"); continue; }

                        #region Initialise Perlin LayerFilters

                        // Perlin detail, additive and subtractive layers
                        if ((layerTypeInt >= 1 || layerTypeInt <= 3) && layer.filters != null)
                        {
                            // If it is a Perlin Additive or Subtractive layer, loop through all of the filters to preconfigure things
                            for (int f = 0; f < layer.filters.Count; f++)
                            {
                                lbLayerFilter = layer.filters[f];

                                // Is this a valid Stencil LayerFilter?
                                if (lbLayerFilter.type == LBLayerFilter.LayerFilterType.StencilLayer && !string.IsNullOrEmpty(lbLayerFilter.lbStencilGUID) && !string.IsNullOrEmpty(lbLayerFilter.lbStencilLayerGUID))
                                {
                                    // If the temporary class instance isn't defined, look it up and validate it is in the current landscape
                                    if (lbLayerFilter.lbStencil == null)
                                    {
                                        lbLayerFilter.lbStencil = LBStencil.GetStencilInLandscape(landscape, lbLayerFilter.lbStencilGUID, true);
                                    }

                                    if (lbLayerFilter.lbStencil != null)
                                    {
                                        // Find the Stencil Layer for this Layer Filter and populate the temporary class instance
                                        lbLayerFilter.lbStencilLayer = lbLayerFilter.lbStencil.GetStencilLayerByGUID(lbLayerFilter.lbStencilLayerGUID);

                                        if (lbLayerFilter.lbStencilLayer != null)
                                        {
                                            // Load the USHORT data (Compute uses the uncompressed textures)
                                            if (lbLayerFilter.lbStencilLayer.layerArray == null && !isTopographyComputeEnabled)
                                            {
                                                lbLayerFilter.lbStencilLayer.AllocLayerArray();
                                                lbLayerFilter.lbStencilLayer.UnCompressToUShort();
                                            }

                                            // Cache the layer resolution
                                            if (isTopographyComputeEnabled)
                                            {
                                                lbLayerFilter.stencilLayerResolution = (int)lbLayerFilter.lbStencilLayer.layerResolution;
                                            }
                                        }
                                    }
                                }
                            }

                            lbLayerFilter = null;
                        }

                        #endregion

                        #region Initialise Map LayerFilters
                        // PerlinDetail or ImageDetail layer
                        // Map filter images should have already been checked before calling this method
                        if ((layerTypeInt == 3 || layerTypeInt == 7) && layer.filters != null)
                        {
                            // If it is a detail layer, loop through all of the filters to check if there's anything
                            // out of the ordinary we need to do
                            for (int f = 0; f < layer.filters.Count; f++)
                            {
                                if (layer.filters[f].type == LBLayerFilter.LayerFilterType.Inclination)
                                {
                                    // Filter by inclination - need to actually build the current terrain to check inclination
                                    tData.SetHeightsDelayLOD(0, 0, heightMap);
                                }
                            }
                        }
                        #endregion

                        // Perlin Detail layer
                        if (layerTypeInt == 3) { downscaling = (float)layer.downscaling; }
                        else { downscaling = 1f; }

                        #region Initialise RestrictArea Blending
                        if (layer.restrictArea)
                        {
                            // The BlendRate is provided by a slider between 0 and 1. This is then converted into a value
                            // between our recommended Min and Max width values. The values indicate the distance from each
                            // edge as a decimal. E.g. 0.2 is 20% from the left, and 0.8 is 20% from the right.
                            areaRectBlendWidth = Mathf.Lerp(areaRectBlendWidthMin, areaRectBlendWidthMax, layer.areaBlendRate);
                            areaRectBlendWidthUpper = 1f - areaRectBlendWidth;
                        }
                        #endregion

                        #region Perlin Layer
                        // Is this a Perlin Layer?
                        if (layerTypeInt < 4)
                        {
                            // Perlin noise layer                       

                            #region For additive or subtractive perlin layers with removeBaseNoise
                            if ((layerTypeInt == 1 || layerTypeInt == 2) && layer.removeBaseNoise)
                            {
                                addHeightN = layer.addHeight;

                                if (layer.addMinHeight)
                                {
                                    // NOTE: Currently addMinHeight is not available in the editor for subtractive layers
                                    minHeightmapHeightN = 1f;
                                    // Get the minimum height so far
                                    for (int x2 = 0; x2 < heightmapResolution; x2++)
                                    {
                                        for (int y2 = 0; y2 < heightmapResolution; y2++)
                                        {
                                            tempHeight = heightMap[x2, y2];
                                            if (tempHeight < minHeightmapHeightN) { minHeightmapHeightN = tempHeight; }
                                        }
                                        // Exit early if min. height already reached
                                        if (minHeightmapHeightN == 0f) { break; }
                                    }

                                    // +SMS v2.0.6 Beta 2
                                    addHeightN = minHeightmapHeightN;

                                    //Debug.Log("Layer min height: " + minHeightmapHeightN + " [" + (minHeightmapHeightN * terrainHeight) + "m]");
                                }

                                // Subtractive perlin layers add -ve height
                                if (layerTypeInt == 2) { addHeightN *= -1f; }
                            }
                            // +SMS v2.0.6 Beta 2 - currently only applies to add/subtractive perlin layers (not perlin base or detail layer) with removeBaseNoise
                            else { addHeightN = 0f; }
                            #endregion

                            #region Perlin Compute

#if LB_COMPUTE

                            if (isTopographyComputeEnabled && shaderTopo != null)
                            {
                                //float csStart = Time.realtimeSinceStartup;

                                try
                                {
                                    #region Allocate input and output height arrays
                                    int sqrHeightmapResolution = heightmapResolution * heightmapResolution;

                                    // Create heightmap as a 1-dimensional array
                                    float[] heightMap1D = new float[sqrHeightmapResolution];

                                    float[] heightMap1D_updated = new float[sqrHeightmapResolution];

                                    int heightMap1DSize = (heightMap1D == null ? 0 : heightMap1D.Length);
                                    #endregion

                                    if (heightMap1DSize == sqrHeightmapResolution)
                                    {
                                        // Copy data from 2D heightmap to 1D array - Size is in bytes
                                        //for (int x = 0; x < heightmapResolution; x++) { for (int z = 0; z < heightmapResolution; z++) { heightMap1D[z * heightmapResolution + x] = heightMap[z, x]; } }
                                        System.Buffer.BlockCopy(heightMap, 0, heightMap1D, 0, sizeof(float) * sqrHeightmapResolution);

                                        // Get the index to the Method in the compute shader
                                        int kTopoPerlinIdx = shaderTopo.FindKernel(CSKTopoPerlin);

                                        // Create the buffers to hold the heightmap in/out data
                                        cbufHeightsIn = new ComputeBuffer(sqrHeightmapResolution, sizeof(float), ComputeBufferType.Default);
                                        cbufHeightsOut = new ComputeBuffer(sqrHeightmapResolution, sizeof(float), ComputeBufferType.Default);

                                        #region Get Slope data (PerlinDetail only)

                                        if (layerTypeInt == 3)
                                        {
                                            // Copy terrain normals into a texture - size 2^n so use heightmapResolution-1.
                                            terrainNormalsTex = GetSlopeTexture2D(landscape, landscapePosition, tData, worldPosition, heightmapResolution - 1, heightmapResolution - 1, "LB_RT_CSTex");
                                            if (terrainNormalsTex == null) { Debug.LogWarning("ERROR: " + methodName + " - could not get terrain normals. Please Report"); }
                                            else
                                            {
                                                //Debug.Log("[DEBUG] get terrain normals " + terrainNormalsTex.width);
                                                shaderTopo.SetTexture(kTopoPerlinIdx, CSterrainNormals, terrainNormalsTex);
                                            }
                                        }

                                        // If terrain Normals (slope) is not required or is not created for some reason, create a dummy texture to keep compute shader happy
                                        if (terrainNormalsTex == null)
                                        {
                                            terrainNormalsTex = new Texture2D(1, 1, TextureFormat.ARGB32, false, true);
                                            if (terrainNormalsTex != null)
                                            {
                                                shaderTopo.SetTexture(kTopoPerlinIdx, CSterrainNormals, terrainNormalsTex);
                                            }
                                        }

                                        #endregion

                                        #region Create Filters buffer
                                        // Create the buffer to hold the LBCSFilter struct used in the shader
                                        int sizeLBCSFilter = System.Runtime.InteropServices.Marshal.SizeOf(new LBCSFilter());

                                        // Get number of LBLayerFilters for this LBLayer (currently ignores Map filters for Compute shader)
                                        int numFilters = (layer.filters == null ? 0 : layer.filters.Count);

                                        if (numFilters > 0)
                                        {
                                            cbufLBFilters = new ComputeBuffer(numFilters, sizeLBCSFilter, ComputeBufferType.Default);
                                            // Create the struct used to hold the LBTextureFilter data
                                            lbcsFilter = new LBCSFilter[numFilters];
                                        }
                                        else
                                        {
                                            // Create dummy filter buffer and list of filters
                                            cbufLBFilters = new ComputeBuffer(1, sizeLBCSFilter, ComputeBufferType.Default);
                                            lbcsFilter = new LBCSFilter[1];
                                        }
                                        //Debug.Log("[DEBUG] Layer " + (l + 1) + " Num of filters: " + numFilters);

                                        // Create a list to store the unique stencil layer GUIDs
                                        if (stencilLayerGUIDList == null) { stencilLayerGUIDList = new List<string>(); }
                                        else { stencilLayerGUIDList.Clear(); }

                                        // Create or clear the list before each layer is processed
                                        if (stencilLayerArrayGUIDList == null) { stencilLayerArrayGUIDList = new List<List<string>>(); }
                                        else { stencilLayerArrayGUIDList.Clear(); }

                                        // Add an empty list of string for each possible stencil layer resolution
                                        for (int g = 0; g < 7; g++) { stencilLayerArrayGUIDList.Add(new List<string>(7)); }

                                        #endregion

                                        if (cbufHeightsIn != null && cbufHeightsOut != null && cbufLBFilters != null && stencilLayerGUIDList != null)
                                        {
                                            #region Assign height buffers to TopoPerlin method and copy in height data
                                            shaderTopo.SetBuffer(kTopoPerlinIdx, CSheightsIn, cbufHeightsIn);
                                            shaderTopo.SetBuffer(kTopoPerlinIdx, CSheightsOut, cbufHeightsOut);

                                            // Copy height data into shader
                                            cbufHeightsIn.SetData(heightMap1D);
                                            #endregion

                                            #region Get Layer Filters

                                            // Discover number textures required for each stencil layer resolution
                                            // This isn't very scalable and probably should be done some more generic way
                                            int numStencilLayerTex128 = LBLayer.GetNumStencilLayersByResolution(layer.filters, 128);
                                            int numStencilLayerTex256 = LBLayer.GetNumStencilLayersByResolution(layer.filters, 256);
                                            int numStencilLayerTex512 = LBLayer.GetNumStencilLayersByResolution(layer.filters, 512);
                                            int numStencilLayerTex1024 = LBLayer.GetNumStencilLayersByResolution(layer.filters, 1024);
                                            int numStencilLayerTex2048 = LBLayer.GetNumStencilLayersByResolution(layer.filters, 2048);
                                            int numStencilLayerTex4096 = LBLayer.GetNumStencilLayersByResolution(layer.filters, 4096);
                                            int numStencilLayerTex8192 = LBLayer.GetNumStencilLayersByResolution(layer.filters, 8192);

                                            int lcFilterIdx = 0;

                                            // Create the texture arrays to hold the unique compressed stencil layer textures
                                            // Create a minimum of 1 in each array (cannot have an array size of zero)
                                            // If there is no stencil for a certain resolution, create a dummy Texture2DArray with a 1x1 Texture to conserve GPU memory
                                            if (numStencilLayerTex128 < 1) { stencilLayerTex2DArrayList.Add(new Texture2DArray(1, 1, 1, TextureFormat.ARGB32, false, true)); }
                                            else { stencilLayerTex2DArrayList.Add(new Texture2DArray(128, 128, numStencilLayerTex128, TextureFormat.ARGB32, false, true)); }
                                            if (numStencilLayerTex256 < 1) { stencilLayerTex2DArrayList.Add(new Texture2DArray(1, 1, 1, TextureFormat.ARGB32, false, true)); }
                                            else { stencilLayerTex2DArrayList.Add(new Texture2DArray(256, 256, numStencilLayerTex256, TextureFormat.ARGB32, false, true)); }
                                            if (numStencilLayerTex512 < 1) { stencilLayerTex2DArrayList.Add(new Texture2DArray(1, 1, 1, TextureFormat.ARGB32, false, true)); }
                                            else { stencilLayerTex2DArrayList.Add(new Texture2DArray(512, 512, numStencilLayerTex512, TextureFormat.ARGB32, false, true)); }
                                            if (numStencilLayerTex1024 < 1) { stencilLayerTex2DArrayList.Add(new Texture2DArray(1, 1, 1, TextureFormat.ARGB32, false, true)); }
                                            else { stencilLayerTex2DArrayList.Add(new Texture2DArray(1024, 1024, numStencilLayerTex1024, TextureFormat.ARGB32, false, true)); }
                                            if (numStencilLayerTex2048 < 1) { stencilLayerTex2DArrayList.Add(new Texture2DArray(1, 1, 1, TextureFormat.ARGB32, false, true)); }
                                            else { stencilLayerTex2DArrayList.Add(new Texture2DArray(2048, 2048, numStencilLayerTex2048, TextureFormat.ARGB32, false, true)); }
                                            if (numStencilLayerTex4096 < 1) { stencilLayerTex2DArrayList.Add(new Texture2DArray(1, 1, 1, TextureFormat.ARGB32, false, true)); }
                                            else { stencilLayerTex2DArrayList.Add(new Texture2DArray(4096, 4096, numStencilLayerTex4096, TextureFormat.ARGB32, false, true)); }
                                            if (numStencilLayerTex8192 < 1) { stencilLayerTex2DArrayList.Add(new Texture2DArray(1, 1, 1, TextureFormat.ARGB32, false, true)); }
                                            else { stencilLayerTex2DArrayList.Add(new Texture2DArray(8192, 8192, numStencilLayerTex8192, TextureFormat.ARGB32, false, true)); }

                                            int numSLayerTex2DArrays = stencilLayerTex2DArrayList.Count;

                                            for (int i = 0; i < numSLayerTex2DArrays; i++) { stencilLayerTex2DArrayList[i].hideFlags = HideFlags.DontSave; }

                                            // Track the current index with the Texture2DArrays so we can know which slot to copy the compressed texture into.
                                            // The currArrayIdx is aligned to the stencilLayerTex2DArrayList. So curArrayIdx[0] stores the position in the
                                            // 128x128 Texture2Array for stencilLayerTex2DArrayList[0]. currArrrayIdx[1] is for the Texture2DArrays containing 256x256 textures etc.
                                            int[] currArrayIdx = new int[7];
                                            // Initialise array
                                            if (currArrayIdx != null) { for (int i = 0; i < currArrayIdx.Length; i++) { currArrayIdx[i] = -1; } }

                                            // Only 1 Map filter is supported for Topography Layer Filters with GPU Accel enabled.
                                            // If more are required, stencil layers should be used instead.
                                            bool isFirstMapFilter = true;

                                            #region Populate Filter structures
                                            // For each filter, increment the overall filter index counter
                                            for (int fIdx = 0; fIdx < numFilters && lcFilterIdx < numFilters; fIdx++, lcFilterIdx++)
                                            {
                                                lbLayerFilter = layer.filters[fIdx];

                                                // Common properties
                                                lbcsFilter[lcFilterIdx].filterMode = (int)0; // Topography Layer Filters are always AND
                                                // Area filter are not applicable, so set to dimensions of landscape
                                                lbcsFilter[lcFilterIdx].areaRect.x = 0;
                                                lbcsFilter[lcFilterIdx].areaRect.y = 0;
                                                lbcsFilter[lcFilterIdx].areaRect.z = landscapeSize.x;
                                                lbcsFilter[lcFilterIdx].areaRect.w = landscapeSize.y;
                                                lbcsFilter[lcFilterIdx].lbTexIdx = 0;
                                                lbcsFilter[lcFilterIdx].csfilterType = 999; // Some default number which will be ignored in the shader
                                                // Defaults
                                                lbcsFilter[lcFilterIdx].minHeight = 0f;
                                                lbcsFilter[lcFilterIdx].maxHeight = 1f;
                                                lbcsFilter[lcFilterIdx].minInclination = 0f;
                                                lbcsFilter[lcFilterIdx].maxInclination = 1f;

                                                #region Stencil Filter
                                                // There may be an issue if the GUID is not a valid Stencil Layer GUID
                                                // Filter.lbStencil and Filter.lbStencilLayer properties are pre-loaded above.
                                                // These non-serializable properties are used for compute and non-compute.
                                                if (lbLayerFilter.type == LBLayerFilter.LayerFilterType.StencilLayer)
                                                {
                                                    lbStencilLayer = lbLayerFilter.lbStencilLayer;
                                                    if (lbStencilLayer != null)
                                                    {
                                                        lbcsFilter[lcFilterIdx].csfilterType = 3;

                                                        // Get the layer resolution and convert it to an index for faster lookup
                                                        stencilLayerResolution = (int)lbStencilLayer.layerResolution;
                                                        int stencilLayerResolutionIdx = -1;

                                                        // There might be a better way of doing this via the position in the enum.
                                                        switch (stencilLayerResolution)
                                                        {
                                                            case 128: stencilLayerResolutionIdx = 0; break;
                                                            case 256: stencilLayerResolutionIdx = 1; break;
                                                            case 512: stencilLayerResolutionIdx = 2; break;
                                                            case 1024: stencilLayerResolutionIdx = 3; break;
                                                            case 2048: stencilLayerResolutionIdx = 4; break;
                                                            case 4096: stencilLayerResolutionIdx = 5; break;
                                                            case 8092: stencilLayerResolutionIdx = 6; break;
                                                        }

                                                        // If it doesn't already exist, add it to the list of unique Stencil Layer GUIDs
                                                        if (!stencilLayerGUIDList.Exists(guid => guid == lbLayerFilter.lbStencilLayerGUID))
                                                        {
                                                            // Add the stencil layer data to the Texture2DArray
                                                            if (lbStencilLayer.compressedTexture != null && stencilLayerResolutionIdx >= 0)
                                                            {
                                                                Texture2DArray texture2DArray = null;

                                                                // Add stencil layer GUID to the list of unique Stencil Layer GUIDs
                                                                stencilLayerGUIDList.Add(lbLayerFilter.lbStencilLayerGUID.ToString());

                                                                // Add stencil layer GUID to list of unique GUIDs for this resolution so we can easily look it up for other filters
                                                                stencilLayerArrayGUIDList[stencilLayerResolutionIdx].Add(lbLayerFilter.lbStencilLayerGUID.ToString());

                                                                //Debug.Log("[DEBUG] Add new GUID " + lbLayerFilter.lbStencilLayerGUID + " for " + stencilLayerResolutionIdx + " " + lbStencilLayer.LayerName);

                                                                texture2DArray = stencilLayerTex2DArrayList[stencilLayerResolutionIdx];
                                                                if (texture2DArray != null)
                                                                {
                                                                    currArrayIdx[stencilLayerResolutionIdx]++;
                                                                    LBTextureOperations.CopyTextureTo2DArray(ref texture2DArray, lbStencilLayer.compressedTexture, currArrayIdx[stencilLayerResolutionIdx], true);
                                                                }
                                                            }
                                                        }

                                                        // Get the position within the list
                                                        if (stencilLayerResolution < 0) { lbcsFilter[lcFilterIdx].stencilLayerTex2DArrIdx = -1; }
                                                        else
                                                        {
                                                            lbcsFilter[lcFilterIdx].stencilLayerTex2DArrIdx = stencilLayerArrayGUIDList[stencilLayerResolutionIdx].FindIndex(guid => guid == lbLayerFilter.lbStencilLayerGUID);
                                                            //Debug.Log("[DEBUG] Layer " + (l + 1) + " sten lyr: " + lbStencilLayer.LayerName + " res: " + stencilLayerResolution + " guididx: " + lbcsFilter[lcFilterIdx].stencilLayerTex2DArrIdx);
                                                        }

                                                        // Set stencil layer resolution to 128 if the layer wasn't found.
                                                        lbcsFilter[lcFilterIdx].stencilLayerResolution = (lbLayerFilter.lbStencilLayer == null ? 128 : (int)lbLayerFilter.lbStencilLayer.layerResolution);

                                                        //Debug.Log("[DEBUG] Layer " + (l + 1) + " sten lyr: " + lbStencilLayer.LayerName + " res: " + lbcsFilter[lcFilterIdx].stencilLayerResolution + " guididx: " + lbcsFilter[lcFilterIdx].stencilLayerTex2DArrIdx);

                                                    }
                                                }
                                                #endregion

                                                #region Height Filter
                                                else if (lbLayerFilter.type == LBLayerFilter.LayerFilterType.Height)
                                                {
                                                    lbcsFilter[lcFilterIdx].csfilterType = 0; // Height
                                                    // min/max Heights are already normalised.
                                                    lbcsFilter[lcFilterIdx].minHeight = lbLayerFilter.minHeight;
                                                    lbcsFilter[lcFilterIdx].maxHeight = lbLayerFilter.maxHeight;
                                                }
                                                #endregion

                                                #region Inclination Filter
                                                else if (lbLayerFilter.type == LBLayerFilter.LayerFilterType.Inclination)
                                                {
                                                    lbcsFilter[lcFilterIdx].csfilterType = 1; // Inclination.
                                                    // Normalise min/max values to improve shader performance
                                                    lbcsFilter[lcFilterIdx].minInclination = lbLayerFilter.minInclination / 90f;
                                                    lbcsFilter[lcFilterIdx].maxInclination = lbLayerFilter.maxInclination / 90f;
                                                }
                                                #endregion

                                                #region Map Filter
                                                // Only 1 is supported (if more is required, user should use Stencil Layers)
                                                else if (lbLayerFilter.type == LBLayerFilter.LayerFilterType.Map && isFirstMapFilter && lbLayerFilter.map != null)
                                                {
                                                    lbcsFilter[lcFilterIdx].csfilterType = 2; // Map

                                                    shaderTopo.SetTexture(kTopoPerlinIdx, CSmapTex, lbLayerFilter.map);
                                                    shaderTopo.SetInt(CSmapTexWidth, lbLayerFilter.map.width);
                                                    shaderTopo.SetInt(CSmapTexHeight, lbLayerFilter.map.height);
                                                    shaderTopo.SetBool(CSmapInverse, lbLayerFilter.mapInverse);
                                                    isFirstMapFilter = false;
                                                }
                                                #endregion
                                            }

                                            #region No Map Filters
                                            // If no Map filters are in use, create a dummy one to keep compute shader happy
                                            if (isFirstMapFilter)
                                            {
                                                // Only create dummyTex once for all layers
                                                //dummyTex = new Texture2D(1, 1, TextureFormat.ARGB32, false, true);
                                                shaderTopo.SetTexture(kTopoPerlinIdx, CSmapTex, dummyTex);
                                                shaderTopo.SetInt(CSmapTexWidth, 1);
                                                shaderTopo.SetInt(CSmapTexHeight, 1);
                                                shaderTopo.SetBool(CSmapInverse, false);
                                            }
                                            #endregion

                                            #endregion

                                            #region Set Filters in Shader
                                            // Set and Populate topography filter buffer
                                            shaderTopo.SetBuffer(kTopoPerlinIdx, CSlbFilters, cbufLBFilters);
                                            cbufLBFilters.SetData(lbcsFilter);
                                            // Set the sum of the number of filters for all the Perlin layer
                                            shaderTopo.SetInt(CSnumlbFilters, numFilters);
                                            //Debug.Log("FilterVariables: [" + CSnumlbFilters + "] " + numFilters);

                                            // Assign the Texture2DArrays to the compute shader
                                            if (numSLayerTex2DArrays > 0) { shaderTopo.SetTexture(kTopoPerlinIdx, CSstencilLayer128Tex2DArray, stencilLayerTex2DArrayList[0]); }
                                            if (numSLayerTex2DArrays > 1) { shaderTopo.SetTexture(kTopoPerlinIdx, CSstencilLayer256Tex2DArray, stencilLayerTex2DArrayList[1]); }
                                            if (numSLayerTex2DArrays > 2) { shaderTopo.SetTexture(kTopoPerlinIdx, CSstencilLayer512Tex2DArray, stencilLayerTex2DArrayList[2]); }
                                            if (numSLayerTex2DArrays > 3) { shaderTopo.SetTexture(kTopoPerlinIdx, CSstencilLayer1024Tex2DArray, stencilLayerTex2DArrayList[3]); }
                                            if (numSLayerTex2DArrays > 4) { shaderTopo.SetTexture(kTopoPerlinIdx, CSstencilLayer2048Tex2DArray, stencilLayerTex2DArrayList[4]); }
                                            if (numSLayerTex2DArrays > 5) { shaderTopo.SetTexture(kTopoPerlinIdx, CSstencilLayer4096Tex2DArray, stencilLayerTex2DArrayList[5]); }
                                            if (numSLayerTex2DArrays > 6) { shaderTopo.SetTexture(kTopoPerlinIdx, CSstencilLayer8192Tex2DArray, stencilLayerTex2DArrayList[6]); }
                                            #endregion

                                            #endregion

                                            int numKeyFrames = 0;

                                            #region AddSubCurve

                                            // Perlin Additive and Subtractive Amount curves
                                            // NOTE: Perlin Base and Detail don't use this curve
                                            if (layerTypeInt == 1)
                                            {
                                                //Debug.Log("set curve to linear for testing");
                                                pkKeyFrames = LBCurve.GetComputeKeyFrames(layer.additiveCurve);
                                                numKeyFrames = (pkKeyFrames == null ? 0 : pkKeyFrames.Length);
                                                if (numKeyFrames > 0)
                                                {
                                                    cbufAddSubCurve = new ComputeBuffer(numKeyFrames, sizeof(float) * 4, ComputeBufferType.Default);
                                                    if (cbufAddSubCurve != null) { shaderTopo.SetBuffer(kTopoPerlinIdx, CSaddsubCurve, cbufAddSubCurve); cbufAddSubCurve.SetData(pkKeyFrames); }
                                                }
                                                else { Debug.LogWarning("ERROR " + methodName + " - could not send additive curve data to compute shader for layer " + (l + 1)); }
                                            }
                                            // Perlin Subtractive
                                            else if (layerTypeInt == 2)
                                            {
                                                pkKeyFrames = LBCurve.GetComputeKeyFrames(layer.subtractiveCurve);
                                                numKeyFrames = (pkKeyFrames == null ? 0 : pkKeyFrames.Length);
                                                if (numKeyFrames > 0)
                                                {
                                                    cbufAddSubCurve = new ComputeBuffer(numKeyFrames, sizeof(float) * 4, ComputeBufferType.Default);
                                                    if (cbufAddSubCurve != null) { shaderTopo.SetBuffer(kTopoPerlinIdx, CSaddsubCurve, cbufAddSubCurve); cbufAddSubCurve.SetData(pkKeyFrames); }
                                                }
                                                else { Debug.LogWarning("ERROR " + methodName + " - could not send subtractive curve data to compute shader for layer " + (l + 1)); }
                                            }
                                            else
                                            {
                                                // Just add any type of curve to satisfy compute shader
                                                pkKeyFrames = LBCurve.GetComputeKeyFrames(AnimationCurve.Linear(0f, 0f, 1f, 1f));
                                                numKeyFrames = (pkKeyFrames == null ? 0 : pkKeyFrames.Length);
                                                if (numKeyFrames > 0)
                                                {
                                                    cbufAddSubCurve = new ComputeBuffer(numKeyFrames, sizeof(float) * 4, ComputeBufferType.Default);
                                                    if (cbufAddSubCurve != null) { shaderTopo.SetBuffer(kTopoPerlinIdx, CSaddsubCurve, cbufAddSubCurve); cbufAddSubCurve.SetData(pkKeyFrames); }
                                                }

                                            }
                                            shaderTopo.SetInt(CSaddsubCurveNumKeys, numKeyFrames);

                                            #endregion

                                            #region Combined Per Octave and Output Curves

                                            // Pack all curve keyframes for all the per-octave and output curves into the same buffer.
                                            // Each keyframe is also packed using LBCurve.GetComputeKeyFrames(curve).
                                            // The number of keyframes in each curve is stored in a separate list

                                            int numPerOctaveCurves = (layer.perOctaveCurveModifiers == null ? 0 : layer.perOctaveCurveModifiers.Count);
                                            int numOutputCurves = (layer.outputCurveModifiers == null ? 0 : layer.outputCurveModifiers.Count);

                                            int numPerOctaveCurvesAdded = 0;
                                            int numOutputCurvesAdded = 0;
                                            int totalNumKeyFramesPerOctaveCurves = 0;
                                            int totalNumKeyFramesOuputCurves = 0;

                                            // A list of the packed keyframes in all the per-octave curves
                                            List<Vector4> pkKeyFrameList = new List<Vector4>();

                                            // A list of the number of keyframes in each curve (PerOctave and Output Curves). Create space for at least 1 item.
                                            List<int> numKeyFramesList = new List<int>(numPerOctaveCurves + numOutputCurves == 0 ? 1 : numPerOctaveCurves + numOutputCurves);

                                            #region Per Octave Curves

                                            for (int pcm = 0; pcm < numPerOctaveCurves; pcm++)
                                            {
                                                pkKeyFrames = LBCurve.GetComputeKeyFrames(layer.perOctaveCurveModifiers[pcm]);
                                                numKeyFrames = (pkKeyFrames == null ? 0 : pkKeyFrames.Length);
                                                if (numKeyFrames > 0)
                                                {
                                                    numPerOctaveCurvesAdded++;
                                                    numKeyFramesList.Add(numKeyFrames);
                                                    totalNumKeyFramesPerOctaveCurves += numKeyFrames;

                                                    // Add the keyframes for this curve to the list of keyframes for all modifier curves
                                                    pkKeyFrameList.AddRange(pkKeyFrames);
                                                }
                                            }

                                            #endregion

                                            #region Output Curves

                                            for (int ocm = 0; ocm < numOutputCurves; ocm++)
                                            {
                                                pkKeyFrames = LBCurve.GetComputeKeyFrames(layer.outputCurveModifiers[ocm]);
                                                numKeyFrames = (pkKeyFrames == null ? 0 : pkKeyFrames.Length);
                                                if (numKeyFrames > 0)
                                                {
                                                    numOutputCurvesAdded++;
                                                    numKeyFramesList.Add(numKeyFrames);
                                                    totalNumKeyFramesOuputCurves += numKeyFrames;

                                                    // Add the keyframes for this curve to the list of keyframes for all modifier curves
                                                    pkKeyFrameList.AddRange(pkKeyFrames);
                                                }
                                            }

                                            #endregion

                                            shaderTopo.SetInt(CSnumPerOctaveCurves, numPerOctaveCurvesAdded);
                                            shaderTopo.SetInt(CSnumOutputCurves, numOutputCurvesAdded);

                                            if (pkKeyFrameList.Count > 0)
                                            {
                                                cbufModifierCurves = new ComputeBuffer(totalNumKeyFramesPerOctaveCurves + totalNumKeyFramesOuputCurves, sizeof(float) * 4, ComputeBufferType.Default);
                                                cbufModCurvesNumFrames = new ComputeBuffer(numPerOctaveCurvesAdded + numOutputCurvesAdded, sizeof(uint), ComputeBufferType.Default);
                                                if (cbufModifierCurves != null && cbufModCurvesNumFrames != null)
                                                {
                                                    shaderTopo.SetBuffer(kTopoPerlinIdx, CSmodifierCurves, cbufModifierCurves);
                                                    cbufModifierCurves.SetData(pkKeyFrameList.ToArray());
                                                    shaderTopo.SetBuffer(kTopoPerlinIdx, CSmodifierCurvesNumFrames, cbufModCurvesNumFrames);
                                                    cbufModCurvesNumFrames.SetData(numKeyFramesList.ToArray());
                                                    shaderTopo.SetInt(CSoutputCurveFrameOffset, totalNumKeyFramesPerOctaveCurves);
                                                }
                                            }
                                            else
                                            {
                                                // Create dummy buffers
                                                cbufModifierCurves = new ComputeBuffer(1, sizeof(float) * 4, ComputeBufferType.Default);
                                                cbufModCurvesNumFrames = new ComputeBuffer(1, sizeof(uint), ComputeBufferType.Default);
                                                if (cbufModifierCurves != null && cbufModCurvesNumFrames != null)
                                                {
                                                    shaderTopo.SetBuffer(kTopoPerlinIdx, CSmodifierCurves, cbufModifierCurves);
                                                    cbufModifierCurves.SetData(dummypkKeyFrames);
                                                    shaderTopo.SetBuffer(kTopoPerlinIdx, CSmodifierCurvesNumFrames, cbufModCurvesNumFrames);
                                                    cbufModCurvesNumFrames.SetData(dummynumKeyFrames);
                                                }
                                                shaderTopo.SetInt(CSoutputCurveFrameOffset, 0);
                                            }

                                            #endregion

                                            #region Set variables in compute shader
                                            shaderTopo.SetInt(CSheightmapResolution, heightmapResolution);
                                            // Set layer variables
                                            shaderTopo.SetInt(CSlayerTypeInt, layerTypeInt);
                                            shaderTopo.SetFloat(CSheightScale, layer.heightScale);
                                            shaderTopo.SetBool(CSrestrictArea, layer.restrictArea);
                                            if (layer.restrictArea)
                                            {
                                                // Add the area as boundary points. This becomes a float4 in the compute shader
                                                cvec4AreaRect.x = layer.areaRect.xMin;
                                                cvec4AreaRect.y = layer.areaRect.yMin;
                                                cvec4AreaRect.z = layer.areaRect.xMax;
                                                cvec4AreaRect.w = layer.areaRect.yMax;
                                                shaderTopo.SetVector(CSareaRect, cvec4AreaRect);
                                            }
                                            shaderTopo.SetFloat(CSareaRectBlendWidth, areaRectBlendWidth);
                                            shaderTopo.SetBool(CSremoveBaseNoise, layer.removeBaseNoise);
                                            // imageMinMaxRange is unused in Perlin layers
                                            cvec4MinMaxRange.x = 0f;
                                            cvec4MinMaxRange.y = 0f;
                                            cvec4MinMaxRange.z = 0f;
                                            cvec4MinMaxRange.w = 0f;
                                            shaderTopo.SetVector(CSimageMinMaxRange, cvec4MinMaxRange);
                                            shaderTopo.SetFloat(CSareaRectRotation, 0f);
                                            shaderTopo.SetFloat(CSaddHeightN, addHeightN);
                                            // Set additive/subtractive amount based on layer type. If Perlin Base or Detail set to 1.0
                                            shaderTopo.SetFloat(CSaddsubAmount, (layerTypeInt == 1 ? layer.additiveAmount : layerTypeInt == 2 ? layer.subtractiveAmount : 1f));
                                            // Set terrain variables
                                            shaderTopo.SetFloat(CSterrainWidth, terrainWidth);
                                            shaderTopo.SetFloat(CSterrainLength, terrainLength);
                                            shaderTopo.SetVector(CSterrainWorldPos, worldPosition);
                                            // Set noise variables
                                            shaderTopo.SetFloat(CSnoiseTileSize, layer.noiseTileSize);
                                            shaderTopo.SetFloat(CSnoiseOffsetX, layer.noiseOffsetX);
                                            shaderTopo.SetFloat(CSnoiseOffsetZ, layer.noiseOffsetZ);
                                            shaderTopo.SetFloat(CSnoiseOffsetXadj, noiseOffsetXadj);
                                            shaderTopo.SetFloat(CSnoiseOffsetZadj, noiseOffsetZadj);
                                            shaderTopo.SetInt(CSnoiseOctaves, layer.octaves);
                                            shaderTopo.SetFloat(CSnoiseLacunarity, layer.lacunarity);
                                            shaderTopo.SetFloat(CSnoiseGain, layer.gain);
                                            if (Mathf.Approximately(layer.warpAmount, 0f))
                                            {
                                                shaderTopo.SetFloat(CSnoiseWarpAmount, 0f);
                                            }
                                            else
                                            {
                                                shaderTopo.SetFloat(CSnoiseWarpAmount, layer.warpAmount);
                                                shaderTopo.SetInt(CSnoiseWarpOctaves, layer.warpOctaves);
                                            }
                                            shaderTopo.SetFloat(CSnoiseDownscaling, downscaling);
                                            // Set landscape variables
                                            shaderTopo.SetVector(CSlandscapePos, landscapePosition);
                                            shaderTopo.SetVector(CSlandscapeSize, landscapeSize);
                                            #endregion

                                            #region Execute Shader
                                            // As the heightmap res is 2^n + 1 we need to add an additional threadGroup in both x and z directions.
                                            // In our shader Z is up so x,z in Unity become x,y in shader.
                                            // The additional thread groups will only process 1 pixel. Although this means we "waste" parallel processing
                                            // on the GPU, it means we can process the rest of the heightmap in parallel.
                                            int threadGroupX = (heightmapResolution - 1) / cskTopoPerlinNumThreads;
                                            int threadGroupY = (heightmapResolution - 1) / cskTopoPerlinNumThreads;

                                            // Execute shader
                                            // The Z thread group is 1 because we are processing a 2D heightmap
                                            shaderTopo.Dispatch(kTopoPerlinIdx, threadGroupX + 1, threadGroupY + 1, 1);

                                            // Get data back from shader
                                            cbufHeightsOut.GetData(heightMap1D_updated);
                                            #endregion
                                        }

                                        // Copy data back from 1D heightmap to 2D heightmap
                                        System.Buffer.BlockCopy(heightMap1D_updated, 0, heightMap, 0, sizeof(float) * sqrHeightmapResolution);
                                        //for (int x = 0; x < heightmapResolution; x++) { for (int z = 0; z < heightmapResolution; z++) { heightMap[z, x] = heightMap1D_updated[(z * heightmapResolution) + x];  } }
                                    }
                                }
                                catch (System.Exception ex)
                                {
                                    Debug.LogWarning("ERROR " + methodName + " - could not process perlin layer " + (l + 1) + " " + ex.Message);
                                }

                                #region Free Resources
                                finally
                                {
                                    // Dispose ComputeBuffers
                                    if (cbufLBFilters != null) { cbufLBFilters.Release(); cbufLBFilters = null; }
                                    if (cbufModifierCurves != null) { cbufModifierCurves.Release(); cbufModifierCurves = null; }
                                    if (cbufModCurvesNumFrames != null) { cbufModCurvesNumFrames.Release(); cbufModCurvesNumFrames = null; }
                                    if (cbufAddSubCurve != null) { cbufAddSubCurve.Release(); cbufAddSubCurve = null; }
                                    if (cbufHeightsIn != null) { cbufHeightsIn.Release(); cbufHeightsIn = null; }
                                    if (cbufHeightsOut != null) { cbufHeightsOut.Release(); cbufHeightsOut = null; }

                                    // Dispose any Texture2Ds
                                    if (terrainNormalsTex != null) { LBTextureOperations.DestroyTexture2D(ref terrainNormalsTex); }

                                    // dispose once after all layers have been processed
                                    //if (dummyTex != null) { LBTextureOperations.DestroyTexture2D(ref dummyTex); }

                                    int numStencilLayerArrays = (stencilLayerTex2DArrayList == null ? 0 : stencilLayerTex2DArrayList.Count);

                                    for (int slArrayIdx = numStencilLayerArrays - 1; slArrayIdx >= 0; slArrayIdx--)
                                    {
                                        Texture2DArray texture2DArray = stencilLayerTex2DArrayList[slArrayIdx];
                                        if (texture2DArray != null) { LBTextureOperations.DestroyTexture2DArray(ref texture2DArray); }
                                        // Check if was correctly disposed
                                        if (stencilLayerTex2DArrayList[slArrayIdx] != null) { Debug.LogWarning("ERROR: " + methodName + " - stencillayer tex2Darray" + slArrayIdx + "  not released correctly"); }
                                    }
                                    if (stencilLayerTex2DArrayList != null) { stencilLayerTex2DArrayList.Clear(); }
                                }
                                #endregion

                                //Debug.Log("Topography compute phase finished " + System.DateTime.Now.ToLongTimeString() + " duration: " + (Time.realtimeSinceStartup - csStart).ToString("0.0000") + "s");

                            }
#endif

                            #endregion

                            #region Perlin No Compute

                            for (int x = 0; x < heightmapResolution && !isTopographyComputeEnabled; x++)
                            {
                                for (int y = 0; y < heightmapResolution; y++)
                                {
                                    // Get noise world position of heightmap point (calculate base x,y only once)
                                    // NOTE: SetHeights() and SetHeightsDelayLOD() expects height array to be [y,x].
                                    // Most of our code calls heightMap[x, y], so we need to switch stuff around...
                                    xPos = (tData.heightmapScale.x * y) + worldPosition.x;
                                    yPos = (tData.heightmapScale.z * x) + worldPosition.z;

                                    // These values are used for Restrict Area which are landscape positions in metres from bottom-left corner of landscape
                                    xPos2 = xPos - landscapePosition.x;
                                    zPos2 = yPos - landscapePosition.z;

                                    // Now calculate the noise position
                                    xPos = xPos - layer.noiseOffsetX + noiseOffsetXadj;
                                    yPos = yPos - layer.noiseOffsetZ + noiseOffsetZadj;

                                    // If the layer has a area restriction, check that this point is within the area
                                    if (layer.restrictArea)
                                    {
                                        // If this point is outside the area, proceed to the next position in the terrain
                                        if (!layer.areaRect.Contains(new Vector2(xPos2, zPos2))) { continue; }
                                    }

                                    if (!Mathf.Approximately(layer.warpAmount, 0f))
                                    {
                                        // Warping of noise - adds perlin fractal noise onto the world coordinates
                                        Vector2 warpVector = new Vector2(LBNoise.PerlinFractalNoise(xPos / layer.noiseTileSize, yPos / layer.noiseTileSize, layer.warpOctaves),
                                                                        LBNoise.PerlinFractalNoise(xPos / layer.noiseTileSize + 5.2f, yPos / layer.noiseTileSize + 1.3f, layer.warpOctaves));
                                        xPos += warpVector.x * layer.warpAmount * layer.noiseTileSize;
                                        yPos += warpVector.y * layer.warpAmount * layer.noiseTileSize;
                                    }
                                    // Input the position into the fractal noise function to get a value between 0 and 1
                                    heightSum = LBNoise.PerlinFractalNoise(xPos / layer.noiseTileSize * downscaling, yPos / layer.noiseTileSize * downscaling, layer.octaves, layer.lacunarity, layer.gain, layer.perOctaveCurveModifiers);
                                    // Process using output curve modifiers
                                    if (layer.outputCurveModifiers != null)
                                    {
                                        // Loop through all the animation curves
                                        for (int cm = 0; cm < layer.outputCurveModifiers.Count; cm++)
                                        {
                                            // Modify the terrain based on animation curve
                                            heightSum = layer.outputCurveModifiers[cm].Evaluate(heightSum);
                                        }
                                    }

                                    // #SMS v2.0.6 Beta 2. addHeightN calculated outside loop and addHeightN is -ve for subtractive layer
                                    // If this is an additive or subtractive layer we may want to add a constant value
                                    if (layer.removeBaseNoise && (layerTypeInt == 1 || layerTypeInt == 2)) { heightSum += addHeightN; }

                                    // If this is an additive layer, process the output using the additive curve modifier
                                    if (layerTypeInt == 1)
                                    {
                                        // Modify the height based on the curve and then scale it to normalise it
                                        heightSum = layer.additiveCurve.Evaluate(heightSum) * layer.additiveAmount;
                                    }
                                    // If this is an subtractive layer, process the output using the subtractive curve modifier
                                    else if (layerTypeInt == 2)
                                    {
                                        // Modify the height based on the curve and then scale it to normalise it
                                        heightSum = layer.subtractiveCurve.Evaluate(heightSum) * layer.subtractiveAmount;
                                    }

                                    // #DHS v1.4.3 Beta 2c
                                    // If this is an additive or subtractive layer we may want to add a constant value
                                    // When heightSum is multiplied by heightScale it will make the previosuly added constant
                                    // value incorrect. This section adjusts for that
                                    // #SMS v2.0.6 Beta 2
                                    // Simplify by using single addHeightN calculated outside loop (addHeightN is -ve for subtractive layers)
                                    if (addHeightN < 0.001f || addHeightN >= 0.001f)  // Could use Approximately but this should be faster
                                    {
                                        heightSum += addHeightN * ((1f / layer.heightScale) - 1f);
                                    }

                                    // Scale the noise (Downscaling is only used for Detail layers)
                                    if (layerTypeInt == 3) { heightSum *= layer.heightScale / downscaling; }
                                    else { heightSum *= layer.heightScale; }

                                    #region Perlin Layer Filters
                                    //  Layer filters are only used for detail, additive and subtractive layers
                                    if (layerTypeInt >= 1 && layerTypeInt <= 3)
                                    {
                                        // Process using layer filters
                                        if (layer.filters != null)
                                        {
                                            // Loop through all the filters
                                            for (int f = 0; f < layer.filters.Count; f++)
                                            {
                                                lbLayerFilter = layer.filters[f];

                                                if (lbLayerFilter.type == LBLayerFilter.LayerFilterType.Height)
                                                {
                                                    // Filter by height
                                                    heightSum *= lbLayerFilter.heightCurve.Evaluate(Mathf.InverseLerp(lbLayerFilter.minHeight, lbLayerFilter.maxHeight, heightMap[x, y]));
                                                }
                                                else if (lbLayerFilter.type == LBLayerFilter.LayerFilterType.Inclination)
                                                {
                                                    // Filter by inclination
                                                    angle = tData.GetSteepness((float)y / (heightmapResolution - 1), (float)x / (heightmapResolution - 1));
                                                    heightSum *= lbLayerFilter.inclinationCurve.Evaluate(Mathf.InverseLerp(lbLayerFilter.minInclination, lbLayerFilter.maxInclination, angle));
                                                }
                                                else if (lbLayerFilter.type == LBLayerFilter.LayerFilterType.StencilLayer)
                                                {
                                                    if (lbLayerFilter.lbStencilLayer != null)
                                                    {
                                                        if (lbLayerFilter.lbStencilLayer.layerArray != null)
                                                        {
                                                            // Get the value of the Stencil layer at this point in the terrain
                                                            stencilLayerResolution = (int)lbLayerFilter.lbStencilLayer.layerResolution;
                                                            // Get the point within the stencil layer USHORT array
                                                            // (xPos2 / landscapeSize.x) is the normalised x position in the landscape (value is between 0 and 1)
                                                            // Ensure it it's outside the range of the USHORT array (Clamping in the same line give 2% performance boost)
                                                            arrayPoint.x = Mathf.Clamp(Mathf.RoundToInt((xPos2 / landscapeSize.x) * (stencilLayerResolution - 1f)), 0, stencilLayerResolution - 1);
                                                            arrayPoint.y = Mathf.Clamp(Mathf.RoundToInt((1f - (zPos2 / landscapeSize.y)) * (stencilLayerResolution - 1f)), 0, stencilLayerResolution - 1);

                                                            /// TODO - might be able to improve stencil layer blend using a curve
                                                            heightSum *= lbLayerFilter.lbStencilLayer.layerArray[arrayPoint.x, arrayPoint.y] / 65535f;
                                                            //heightSum *= stencilLayerCurve.Evaluate(layer.filters[f].lbStencilLayer.layerArray[arrayPoint.x, arrayPoint.y] / 65535f);
                                                        }
                                                        else { heightSum = 0f; }
                                                    }
                                                    else { heightSum = 0f; }
                                                }
                                                else if (lbLayerFilter.type == LBLayerFilter.LayerFilterType.Map)
                                                {
                                                    // Filter by LBMap
                                                    if (lbLayerFilter.map != null)
                                                    {
                                                        // Create a LBMap object, so that we can determine if this layer should be applied to the landscape
                                                        LBMap lbMap = new LBMap(lbLayerFilter.map, lbLayerFilter.mapColour, lbLayerFilter.mapTolerance);

                                                        if (lbMap != null)
                                                        {
                                                            lbMap.inverse = lbLayerFilter.mapInverse;

                                                            // Get the normalised "terrain position" of this point - values between 0 and 1
                                                            xPosNormalised = (float)x / (float)(heightmapResolution - 1);
                                                            zPosNormalised = (float)y / (float)(heightmapResolution - 1);

                                                            // Convert the normalised terrain coordinates into a point on the Map texture so that 
                                                            // it can be compared to the point on the Map texture (PNG image) 
                                                            mapPoint = lbMap.GetMapPositionFromTerrainPosition(xPosNormalised, zPosNormalised, startX, endX, startZ, endZ);

                                                            pixelVariationNormalised = lbMap.GetPixelColourVariationNormalised(mapPoint.x, mapPoint.y, Color.clear);

                                                            if (pixelVariationNormalised > 0.001f)
                                                            {
                                                                if (lbMap.inverse)
                                                                {
                                                                    // Not sure why this doesn't reverse blend
                                                                    heightSum *= lbLayerFilter.mapToleranceBlendCurve.Evaluate(pixelVariationNormalised);
                                                                }
                                                                else
                                                                {
                                                                    heightSum *= lbLayerFilter.mapToleranceBlendCurve.Evaluate(1f - pixelVariationNormalised);
                                                                }
                                                            }
                                                        }
                                                        else { heightSum = 0f; }
                                                    }
                                                    // If there is no map texture supplied, then not height will be applied from this layer
                                                    else { heightSum = 0f; }
                                                }
                                            }
                                        }
                                    }
                                    #endregion

                                    // If this is an additive or subtractive layer we may want to remove the base noise
                                    if ((layerTypeInt == 1 || layerTypeInt == 2) && layer.removeBaseNoise)
                                    {
                                        heightSum -= heightMap[x, y] * Mathf.InverseLerp(0f, heightMap[x, y], heightSum);
                                    }

                                    #region Perlin RestrictArea edge blending
                                    if (layer.restrictArea)
                                    {
                                        // Blend along edges
                                        // Get the normalised position within the areaRect
                                        xAreaPosNormalised = (xPos2 - layer.areaRect.xMin) / layer.areaRect.width;
                                        zAreaPosNormalised = (zPos2 - layer.areaRect.yMin) / layer.areaRect.height;

                                        areaRectBlendFactor = 0f;
                                        // Calculate the normalised distance away from the edge, then blend towards the original heightmap
                                        // as you approach the edge.
                                        if (xAreaPosNormalised < areaRectBlendWidth)
                                        {
                                            areaRectBlendFactor = xAreaPosNormalised / areaRectBlendWidth;
                                            heightSum = heightSum * areaRectBlendCurve.Evaluate(areaRectBlendFactor);
                                        }
                                        else if (xAreaPosNormalised > areaRectBlendWidthUpper)
                                        {
                                            areaRectBlendFactor = (xAreaPosNormalised - areaRectBlendWidthUpper) / areaRectBlendWidth;
                                            heightSum = heightSum * areaRectBlendCurve.Evaluate(1f - areaRectBlendFactor);
                                        }

                                        // TODO RestictArea blending - Corners could be an issue...
                                        if (zAreaPosNormalised < areaRectBlendWidth)
                                        {
                                            areaRectBlendFactor = zAreaPosNormalised / areaRectBlendWidth;
                                            heightSum = heightSum * areaRectBlendCurve.Evaluate(areaRectBlendFactor);
                                        }
                                        else if (zAreaPosNormalised > areaRectBlendWidthUpper)
                                        {
                                            areaRectBlendFactor = (zAreaPosNormalised - areaRectBlendWidthUpper) / areaRectBlendWidth;
                                            heightSum = heightSum * areaRectBlendCurve.Evaluate(1f - areaRectBlendFactor);
                                        }
                                    }
                                    #endregion

                                    // Is this a subtractive layer?
                                    if (layerTypeInt == 2)
                                    {
                                        // Subtract the value of this layer from the cumulative height sum
                                        heightMap[x, y] -= heightSum;
                                    }
                                    else
                                    {
                                        // Add the value of this layer onto the cumulative height sum
                                        heightMap[x, y] += heightSum;
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion

                        #region Image Layer
                        else if (layerTypeInt < 8)
                        {
                            // Image layer                      
                            Texture2D image; // = layer.heightmapImage;

                            // If RepairHoles is enabled, use the pre-processed texture
                            if (layer.imageRepairHoles && layer.processingImage != null)
                            {
                                image = layer.processingImage;
                            }
                            else { image = layer.heightmapImage; }

                            if (image != null)
                            {
                                imageMinMaxRange = LBModifierOperations.GetTextureGrayscaleMinMax(image, true);

                                #region Image Compute
#if LB_COMPUTE

                                if (isTopographyComputeEnabled && shaderTopo != null)
                                {
                                    float csStart = Time.realtimeSinceStartup;

                                    // TopoImage() in compute shader expects a linear colour texture.
                                    // Users may have enabled gamma (by enabling sRGB in the Unity Import Settings)
                                    Texture2D linearTex = null;

                                    try
                                    {
                                        //float csTimeA = Time.realtimeSinceStartup;
                                        #region Allocate input and output height arrays
                                        int sqrHeightmapResolution = heightmapResolution * heightmapResolution;

                                        // Create heightmap as a 1-dimensional array
                                        float[] heightMap1D = new float[sqrHeightmapResolution];

                                        float[] heightMap1D_updated = new float[sqrHeightmapResolution];

                                        int heightMap1DSize = (heightMap1D == null ? 0 : heightMap1D.Length);
                                        #endregion

                                        #region Create Linear Texture from the image

                                        // Many compressed formats cause issues. Also Repeat/Wrap can cause issues on the edge of landscapes.
                                        // If user enables gamma (sRGB) in the editor this will still create incorrect (lower) heights
                                        TextureFormat texFmt = image.format;

                                        bool isLinearTexRequired = ((texFmt != TextureFormat.ARGB32 && texFmt != TextureFormat.RGBA32 && texFmt != TextureFormat.RGB24) || image.wrapMode != TextureWrapMode.Clamp);

                                        if (isLinearTexRequired)
                                        {
                                            // Don't include mipmaps
                                            linearTex = new Texture2D(image.width, image.height, TextureFormat.ARGB32, false, true);
                                            if (linearTex != null)
                                            {
                                                // Does the GPU support texture to texture copies? (Basic)
                                                // Metal may not support Graphics.CopyTexture.
                                                if (SystemInfo.copyTextureSupport == UnityEngine.Rendering.CopyTextureSupport.None || (texFmt != TextureFormat.RGBA32 && texFmt != TextureFormat.ARGB32))
                                                {
                                                    // Copy texture on CPU into linear texture (much slow)
                                                    linearTex.SetPixels(image.GetPixels(0));
                                                    linearTex.Apply();
                                                }
                                                // Copy texture on GPU into linear texture (fast)
                                                else { Graphics.CopyTexture(image, 0, 0, linearTex, 0, 0); }
                                            }
                                        }

                                        //Debug.Log("[DEBUG] use linearText: " + (linearTex != null));

                                        #endregion

                                        if (heightMap1DSize == (sqrHeightmapResolution))
                                        {
                                            // Get the index to the Method in the compute shader
                                            int kTopoImageIdx = shaderTopo.FindKernel(CSKTopoImage);

                                            #region Copy Heightmap to 1D and create height in/out buffers

                                            // Copy data from 2D heightmap to 1D array - Size is in bytes
                                            System.Buffer.BlockCopy(heightMap, 0, heightMap1D, 0, sizeof(float) * sqrHeightmapResolution);

                                            // Create the buffers to hold the heightmap in/out data
                                            cbufHeightsIn = new ComputeBuffer(sqrHeightmapResolution, sizeof(float), ComputeBufferType.Default);
                                            cbufHeightsOut = new ComputeBuffer(sqrHeightmapResolution, sizeof(float), ComputeBufferType.Default);
                                            #endregion

                                            #region Get Slope data (ImageDetail layers only)
                                            // Layer filters are only used for detail layers for Image layers
                                            if (layerTypeInt == 7 && layer.filters != null)
                                            {
                                                // Copy terrain normals into a texture - size 2^n so use heightmapResolution-1.
                                                terrainNormalsTex = GetSlopeTexture2D(landscape, landscapePosition, tData, worldPosition, heightmapResolution - 1, heightmapResolution - 1, "LB_RT_CSTex");
                                                if (terrainNormalsTex == null) { Debug.LogWarning("ERROR: " + methodName + " - could not get terrain normals. Please Report"); }
                                                else
                                                {
                                                    //Debug.Log("[DEBUG] get terrain normals " + terrainNormalsTex.width);
                                                    shaderTopo.SetTexture(kTopoImageIdx, CSterrainNormals, terrainNormalsTex);
                                                }
                                            }

                                            // If terrain Normals (slope) is not required or is not created for some reason, create a dummy texture to keep compute shader happy
                                            if (terrainNormalsTex == null)
                                            {
                                                terrainNormalsTex = new Texture2D(1, 1, TextureFormat.ARGB32, false, true);
                                                if (terrainNormalsTex != null)
                                                {
                                                    shaderTopo.SetTexture(kTopoImageIdx, CSterrainNormals, terrainNormalsTex);
                                                }
                                            }

                                            #endregion

                                            #region Create Filters buffer
                                            // Create the buffer to hold the LBCSFilter struct used in the shader
                                            int sizeLBCSFilter = System.Runtime.InteropServices.Marshal.SizeOf(new LBCSFilter());

                                            // Get number of LBLayerFilters for this LBLayer (currently ignores Map filters for Compute shader)
                                            int numFilters = (layer.filters == null ? 0 : layer.filters.Count);

                                            if (numFilters > 0)
                                            {
                                                cbufLBFilters = new ComputeBuffer(numFilters, sizeLBCSFilter, ComputeBufferType.Default);
                                                // Create the struct used to hold the LBTextureFilter data
                                                lbcsFilter = new LBCSFilter[numFilters];
                                            }
                                            else
                                            {
                                                // Create dummy filter buffer and list of filters
                                                cbufLBFilters = new ComputeBuffer(1, sizeLBCSFilter, ComputeBufferType.Default);
                                                lbcsFilter = new LBCSFilter[1];
                                            }
                                            #endregion

                                            if (cbufHeightsIn != null && cbufHeightsOut != null && cbufLBFilters != null)
                                            {
                                                #region Assign height buffers to TopoImage method and copy in height data
                                                shaderTopo.SetBuffer(kTopoImageIdx, CSheightsIn, cbufHeightsIn);
                                                shaderTopo.SetBuffer(kTopoImageIdx, CSheightsOut, cbufHeightsOut);

                                                // Copy height data into shader
                                                cbufHeightsIn.SetData(heightMap1D);
                                                #endregion

                                                #region Get Layer Filters
                                                int lcFilterIdx = 0;

                                                // For each filter, increment the overall filter index counter
                                                for (int fIdx = 0; fIdx < numFilters && lcFilterIdx < numFilters; fIdx++, lcFilterIdx++)
                                                {
                                                    lbLayerFilter = layer.filters[fIdx];

                                                    // Common properties
                                                    lbcsFilter[lcFilterIdx].filterMode = (int)0; // Topography Layer Filters are always AND
                                                    // Area filter are not applicable, so set to dimensions of landscape
                                                    lbcsFilter[lcFilterIdx].areaRect.x = 0;
                                                    lbcsFilter[lcFilterIdx].areaRect.y = 0;
                                                    lbcsFilter[lcFilterIdx].areaRect.z = landscapeSize.x;
                                                    lbcsFilter[lcFilterIdx].areaRect.w = landscapeSize.y;
                                                    lbcsFilter[lcFilterIdx].lbTexIdx = 0;
                                                    lbcsFilter[lcFilterIdx].csfilterType = 999; // Some default number which will be ignored in the shader
                                                    // Defaults
                                                    lbcsFilter[lcFilterIdx].minHeight = 0f;
                                                    lbcsFilter[lcFilterIdx].maxHeight = 1f;
                                                    lbcsFilter[lcFilterIdx].minInclination = 0f;
                                                    lbcsFilter[lcFilterIdx].maxInclination = 1f;

                                                    #region Stencil Layer Filters (not supported)
                                                    if (lbLayerFilter.type == LBLayerFilter.LayerFilterType.StencilLayer)
                                                    {
                                                        // Currently not supported for image layers (compute or non-compute)
                                                        lbcsFilter[lcFilterIdx].csfilterType = 3;
                                                    }
                                                    #endregion

                                                    #region Height Filter
                                                    else if (lbLayerFilter.type == LBLayerFilter.LayerFilterType.Height)
                                                    {
                                                        lbcsFilter[lcFilterIdx].csfilterType = 0; // Height
                                                        // min/max Heights are already normalised.
                                                        lbcsFilter[lcFilterIdx].minHeight = lbLayerFilter.minHeight;
                                                        lbcsFilter[lcFilterIdx].maxHeight = lbLayerFilter.maxHeight;
                                                    }
                                                    #endregion

                                                    #region Inclination Filter
                                                    else if (lbLayerFilter.type == LBLayerFilter.LayerFilterType.Inclination)
                                                    {
                                                        lbcsFilter[lcFilterIdx].csfilterType = 1; // Inclination.
                                                        // Normalise min/max values to improve shader performance
                                                        lbcsFilter[lcFilterIdx].minInclination = lbLayerFilter.minInclination / 90f;
                                                        lbcsFilter[lcFilterIdx].maxInclination = lbLayerFilter.maxInclination / 90f;
                                                    }
                                                    #endregion

                                                    #region Map Filter (not supported)
                                                    else if (lbLayerFilter.type == LBLayerFilter.LayerFilterType.Map)
                                                    {
                                                        // Currently not supported in the compute shader
                                                        lbcsFilter[lcFilterIdx].csfilterType = 2; // Map
                                                    }
                                                    #endregion
                                                }

                                                // Set and Populate topography filter buffer
                                                shaderTopo.SetBuffer(kTopoImageIdx, CSlbFilters, cbufLBFilters);
                                                cbufLBFilters.SetData(lbcsFilter);
                                                // Set the sum of the number of filters for all the Perlin layer
                                                shaderTopo.SetInt(CSnumlbFilters, numFilters);

                                                #endregion

                                                int numKeyFrames = 0;

                                                #region AddSubCurve

                                                // Image Additive and Subtractive Amount curves
                                                // NOTE: Image Base and Detail don't use these curve
                                                if (layerTypeInt == 5) { pkKeyFrames = LBCurve.GetComputeKeyFrames(layer.additiveCurve); }
                                                else if (layerTypeInt == 6) { pkKeyFrames = LBCurve.GetComputeKeyFrames(layer.subtractiveCurve); }
                                                // Just add any type of curve to satisfy compute shader
                                                else { pkKeyFrames = LBCurve.GetComputeKeyFrames(AnimationCurve.Linear(0f, 0f, 1f, 1f)); }

                                                numKeyFrames = (pkKeyFrames == null ? 0 : pkKeyFrames.Length);
                                                if (numKeyFrames > 0)
                                                {
                                                    cbufAddSubCurve = new ComputeBuffer(numKeyFrames, sizeof(float) * 4, ComputeBufferType.Default);
                                                    if (cbufAddSubCurve != null) { shaderTopo.SetBuffer(kTopoImageIdx, CSaddsubCurve, cbufAddSubCurve); cbufAddSubCurve.SetData(pkKeyFrames); }
                                                }
                                                else { Debug.LogWarning("ERROR " + methodName + " - could not send additive or subtractive curve data to compute shader for (Image) layer " + (l + 1)); }

                                                shaderTopo.SetInt(CSaddsubCurveNumKeys, numKeyFrames);
                                                #endregion

                                                #region Image (Output) Curves

                                                // Pack all curve keyframes for all the image (output) curves into the same buffer.
                                                // Each keyframe is also packed using LBCurve.GetComputeKeyFrames(curve).
                                                // The number of keyframes in each curve is stored in a separate list
                                                int numOutputCurves = (layer.imageCurveModifiers == null ? 0 : layer.imageCurveModifiers.Count);
                                                int numOutputCurvesAdded = 0;
                                                int totalNumKeyFramesOuputCurves = 0;

                                                // A list of the packed keyframes in all the per-octave curves
                                                List<Vector4> pkKeyFrameList = new List<Vector4>();

                                                // A list of the number of keyframes in each image (output) curve. Create space for at least 1 item.
                                                List<int> numKeyFramesList = new List<int>(numOutputCurves == 0 ? 1 : numOutputCurves);

                                                for (int ocm = 0; ocm < numOutputCurves; ocm++)
                                                {
                                                    pkKeyFrames = LBCurve.GetComputeKeyFrames(layer.imageCurveModifiers[ocm]);
                                                    numKeyFrames = (pkKeyFrames == null ? 0 : pkKeyFrames.Length);
                                                    if (numKeyFrames > 0)
                                                    {
                                                        numOutputCurvesAdded++;
                                                        numKeyFramesList.Add(numKeyFrames);
                                                        totalNumKeyFramesOuputCurves += numKeyFrames;

                                                        // Add the keyframes for this curve to the list of keyframes for all modifier curves
                                                        pkKeyFrameList.AddRange(pkKeyFrames);
                                                    }
                                                }

                                                shaderTopo.SetInt(CSnumPerOctaveCurves, 0);
                                                shaderTopo.SetInt(CSnumOutputCurves, numOutputCurvesAdded);

                                                if (pkKeyFrameList.Count > 0)
                                                {
                                                    cbufModifierCurves = new ComputeBuffer(totalNumKeyFramesOuputCurves, sizeof(float) * 4, ComputeBufferType.Default);
                                                    cbufModCurvesNumFrames = new ComputeBuffer(numOutputCurvesAdded, sizeof(uint), ComputeBufferType.Default);
                                                    if (cbufModifierCurves != null && cbufModCurvesNumFrames != null)
                                                    {
                                                        shaderTopo.SetBuffer(kTopoImageIdx, CSmodifierCurves, cbufModifierCurves);
                                                        cbufModifierCurves.SetData(pkKeyFrameList.ToArray());
                                                        shaderTopo.SetBuffer(kTopoImageIdx, CSmodifierCurvesNumFrames, cbufModCurvesNumFrames);
                                                        cbufModCurvesNumFrames.SetData(numKeyFramesList.ToArray());
                                                        shaderTopo.SetInt(CSoutputCurveFrameOffset, 0);
                                                    }
                                                }
                                                else
                                                {
                                                    // Create dummy buffers
                                                    cbufModifierCurves = new ComputeBuffer(1, sizeof(float) * 4, ComputeBufferType.Default);
                                                    cbufModCurvesNumFrames = new ComputeBuffer(1, sizeof(uint), ComputeBufferType.Default);
                                                    if (cbufModifierCurves != null && cbufModCurvesNumFrames != null)
                                                    {
                                                        shaderTopo.SetBuffer(kTopoImageIdx, CSmodifierCurves, cbufModifierCurves);
                                                        cbufModifierCurves.SetData(dummypkKeyFrames);
                                                        shaderTopo.SetBuffer(kTopoImageIdx, CSmodifierCurvesNumFrames, cbufModCurvesNumFrames);
                                                        cbufModCurvesNumFrames.SetData(dummynumKeyFrames);
                                                    }
                                                    shaderTopo.SetInt(CSoutputCurveFrameOffset, 0);
                                                }

                                                #endregion

                                                #region Copy Heightmap Image to compute shader
                                                shaderTopo.SetTexture(kTopoImageIdx, CSheightmapImage, (linearTex != null ? linearTex : image));
                                                #endregion

                                                #region Assign dummy Stencil Layer Texture2DArrays to the compute shader

                                                // Stencil Layer filters are not supported with Image Layers, however on U2018.x they
                                                // need to be assigned in the shader to avoid the following error:
                                                // Compute shader (LBCSTopo): Property (stencilLayer128Tex2DArray) at kernel index (1) is not set
                                                shaderTopo.SetTexture(kTopoImageIdx, CSstencilLayer128Tex2DArray, dummyTex2DArray);
                                                shaderTopo.SetTexture(kTopoImageIdx, CSstencilLayer256Tex2DArray, dummyTex2DArray);
                                                shaderTopo.SetTexture(kTopoImageIdx, CSstencilLayer512Tex2DArray, dummyTex2DArray);
                                                shaderTopo.SetTexture(kTopoImageIdx, CSstencilLayer1024Tex2DArray, dummyTex2DArray);
                                                shaderTopo.SetTexture(kTopoImageIdx, CSstencilLayer2048Tex2DArray, dummyTex2DArray);
                                                shaderTopo.SetTexture(kTopoImageIdx, CSstencilLayer4096Tex2DArray, dummyTex2DArray);
                                                shaderTopo.SetTexture(kTopoImageIdx, CSstencilLayer8192Tex2DArray, dummyTex2DArray);

                                                #endregion

                                                #region Set variables in compute shader
                                                shaderTopo.SetInt(CSheightmapResolution, heightmapResolution);
                                                // Set layer variables
                                                shaderTopo.SetInt(CSlayerTypeInt, layerTypeInt);
                                                shaderTopo.SetFloat(CSheightScale, layer.imageHeightScale);
                                                shaderTopo.SetBool(CSrestrictArea, layer.restrictArea);
                                                if (layer.restrictArea)
                                                {
                                                    // Add the area as boundary points. This becomes a float4 in the compute shader
                                                    cvec4AreaRect.x = layer.areaRect.xMin;
                                                    cvec4AreaRect.y = layer.areaRect.yMin;
                                                    cvec4AreaRect.z = layer.areaRect.xMax;
                                                    cvec4AreaRect.w = layer.areaRect.yMax;
                                                    shaderTopo.SetVector(CSareaRect, cvec4AreaRect);
                                                }
                                                shaderTopo.SetFloat(CSareaRectBlendWidth, areaRectBlendWidth);
                                                shaderTopo.SetBool(CSremoveBaseNoise, layer.removeBaseNoise);
                                                shaderTopo.SetBool(CSnormaliseImage, layer.normaliseImage);
                                                cvec4MinMaxRange.x = imageMinMaxRange.x;
                                                cvec4MinMaxRange.y = imageMinMaxRange.y;
                                                cvec4MinMaxRange.z = 0f;
                                                cvec4MinMaxRange.w = 0f;
                                                shaderTopo.SetVector(CSimageMinMaxRange, cvec4MinMaxRange);
                                                shaderTopo.SetFloat(CSareaRectRotation, 0f);
                                                //Debug.Log("[DEBUG] imageMinMaxRange: " + cvec4MinMaxRange);
                                                addHeightN = 0f;
                                                // TODO - addHeightN
                                                shaderTopo.SetFloat(CSaddHeightN, addHeightN);
                                                // Set additive/subtractive amount based on layer type. If Image Base or Detail set to 1.0
                                                shaderTopo.SetFloat(CSaddsubAmount, (layerTypeInt == 5 ? layer.additiveAmount : layerTypeInt == 6 ? layer.subtractiveAmount : 1f));
                                                // Set terrain variables
                                                shaderTopo.SetFloat(CSterrainWidth, terrainWidth);
                                                shaderTopo.SetFloat(CSterrainLength, terrainLength);
                                                shaderTopo.SetVector(CSterrainWorldPos, worldPosition);
                                                // Set landscape variables
                                                shaderTopo.SetVector(CSlandscapePos, landscapePosition);
                                                shaderTopo.SetVector(CSlandscapeSize, landscapeSize);

                                                #endregion

                                                #region Execute Shader
                                                // As the heightmap res is 2^n + 1 we need to add an additional threadGroup in both x and z directions.
                                                // In our shader Z is up so x,z in Unity become x,y in shader.
                                                // The additional thread groups will only process 1 pixel. Although this means we "waste" parallel processing
                                                // on the GPU, it means we can process the rest of the heightmap in parallel.
                                                int threadGroupX = (heightmapResolution - 1) / cskTopoImageNumThreads;
                                                int threadGroupY = (heightmapResolution - 1) / cskTopoImageNumThreads;

                                                // Execute shader
                                                // The Z thread group is 1 because we are processing a 2D heightmap
                                                shaderTopo.Dispatch(kTopoImageIdx, threadGroupX + 1, threadGroupY + 1, 1);

                                                // Get data back from shader
                                                cbufHeightsOut.GetData(heightMap1D_updated);
                                                #endregion
                                            }

                                            // Copy data back from 1D heightmap to 2D heightmap
                                            System.Buffer.BlockCopy(heightMap1D_updated, 0, heightMap, 0, sizeof(float) * sqrHeightmapResolution);

                                            //float csTimeB = Time.realtimeSinceStartup;
                                            //Debug.Log("Topography compute subtask for layer " + (l + 1) + " " + System.DateTime.Now.ToLongTimeString() + " duration: " + (csTimeB - csTimeA).ToString("0.0000") + "s");

                                        }

                                    }
                                    catch (System.Exception ex)
                                    {
                                        Debug.LogWarning("ERROR " + methodName + " - could not process image layer " + (l + 1) + " " + ex.Message);
                                    }

                                    #region Free Resources for Image Compute
                                    finally
                                    {
                                        // Dispose ComputeBuffers
                                        if (cbufLBFilters != null) { cbufLBFilters.Release(); cbufLBFilters = null; }
                                        if (cbufAddSubCurve != null) { cbufAddSubCurve.Release(); cbufAddSubCurve = null; }
                                        if (cbufModifierCurves != null) { cbufModifierCurves.Release(); cbufModifierCurves = null; }
                                        if (cbufModCurvesNumFrames != null) { cbufModCurvesNumFrames.Release(); cbufModCurvesNumFrames = null; }
                                        if (cbufHeightsIn != null) { cbufHeightsIn.Release(); cbufHeightsIn = null; }
                                        if (cbufHeightsOut != null) { cbufHeightsOut.Release(); cbufHeightsOut = null; }

                                        // Dispose any Texture2Ds
                                        if (terrainNormalsTex != null) { LBTextureOperations.DestroyTexture2D(ref terrainNormalsTex); }
                                        if (linearTex != null) { LBTextureOperations.DestroyTexture2D(ref linearTex); }
                                    }
                                    #endregion

                                    //Debug.Log("[DEBUG] Topography compute phase finished layer " + (l + 1) + " " + System.DateTime.Now.ToLongTimeString() + " duration: " + (Time.realtimeSinceStartup - csStart).ToString("0.0000") + "s");
                                }

#endif
                                #endregion

                                #region Image Non-Compute
                                for (int x = 0; x < heightmapResolution && !isTopographyComputeEnabled; x++)
                                {
                                    for (int y = 0; y < heightmapResolution; y++)
                                    {
                                        // Get world position of heightmap point
                                        xPos = (tData.heightmapScale.x * y) + worldPosition.x - landscapePosition.x;
                                        yPos = (tData.heightmapScale.z * x) + worldPosition.z - landscapePosition.z;

                                        // If the layer has an area restriction, check that this point is within the area
                                        if (layer.restrictArea)
                                        {
                                            // If this point is outside the area, proceed to the next position in the terrain
                                            if (!layer.areaRect.Contains(new Vector2(xPos, yPos))) { continue; }
                                            else
                                            {
                                                // Get the normalised position within the areaRect
                                                xAreaPosNormalised = (xPos - layer.areaRect.xMin) / layer.areaRect.width;
                                                zAreaPosNormalised = (yPos - layer.areaRect.yMin) / layer.areaRect.height;

                                                // Convert the area position into texture coordinates
                                                texCoords = new Vector2(xAreaPosNormalised * (image.width - 1), zAreaPosNormalised * (image.height - 1));
                                            }
                                        }
                                        else
                                        {
                                            // Convert the position into texture coordinates
                                            // (xPos / landscapeSize.x) is the normalised x position in the landscape (value is between 0 and 1)
                                            texCoords = new Vector2((xPos / landscapeSize.x) * (image.width - 1), (yPos / landscapeSize.y) * (image.height - 1));
                                        }

                                        int xCoord = Mathf.Clamp(Mathf.RoundToInt(texCoords.x), 0, image.width - 1);
                                        int yCoord = Mathf.Clamp(Mathf.RoundToInt(texCoords.y), 0, image.height - 1);

                                        // Get the height from the grayscale value in the image at the given coordinates
                                        heightSum = image.GetPixel(xCoord, yCoord).grayscale;

                                        if (layer.normaliseImage)
                                        {
                                            // Normalise the image Pixel - converting it to a range of 0 to 1
                                            heightSum = Normalise(heightSum, imageMinMaxRange.x, imageMinMaxRange.y);
                                        }

                                        // Process using image output curve modifiers
                                        if (layer.imageCurveModifiers != null)
                                        {
                                            // Loop through all the animation curves
                                            for (int cm = 0; cm < layer.imageCurveModifiers.Count; cm++)
                                            {
                                                // Modify the terrain based on animation curves
                                                heightSum = layer.imageCurveModifiers[cm].Evaluate(heightSum);
                                            }
                                        }

                                        // Scale the heightmap
                                        heightSum *= layer.imageHeightScale;

                                        // If this is an additive layer, process the output using the additive curve modifier
                                        if (layerTypeInt == 5)
                                        {
                                            // Modify the height based on the curve and then scale it to normalise it
                                            heightSum = layer.additiveCurve.Evaluate(heightSum) * layer.additiveAmount;
                                            //heightSum *= layer.additiveAmount;
                                        }
                                        // If this is an subtractive layer, process the output using the subtractive curve modifier
                                        else if (layerTypeInt == 6)
                                        {
                                            // Modify the height based on the curve and then scale it to normalise it
                                            heightSum = layer.subtractiveCurve.Evaluate(heightSum) * layer.subtractiveAmount;
                                        }

                                        // Layer filters are only used for detail layers for Image layers
                                        if (layerTypeInt == 7 && layer.filters != null)
                                        {
                                            // Loop through all the filters
                                            for (int f = 0; f < layer.filters.Count; f++)
                                            {
                                                if (layer.filters[f].type == LBLayerFilter.LayerFilterType.Height)
                                                {
                                                    // Filter by height
                                                    heightSum *= layer.filters[f].heightCurve.Evaluate(Mathf.InverseLerp(layer.filters[f].minHeight, layer.filters[f].maxHeight, heightMap[x, y]));
                                                }
                                                else if (layer.filters[f].type == LBLayerFilter.LayerFilterType.Inclination)
                                                {
                                                    // Filter by inclination
                                                    angle = tData.GetSteepness((float)y / (heightmapResolution - 1), (float)x / (heightmapResolution - 1));
                                                    heightSum *= layer.filters[f].inclinationCurve.Evaluate(Mathf.InverseLerp(layer.filters[f].minInclination, layer.filters[f].maxInclination, angle));
                                                }
                                                else if (layer.filters[f].type == LBLayerFilter.LayerFilterType.Map)
                                                {
                                                    // Filter by LBMap
                                                    if (layer.filters[f].map != null)
                                                    {
                                                        // Create a LBMap object, so that we can determine if this layer should be applied to the landscape
                                                        LBMap lbMap = new LBMap(layer.filters[f].map, layer.filters[f].mapColour, layer.filters[f].mapTolerance);

                                                        if (lbMap != null)
                                                        {
                                                            lbMap.inverse = layer.filters[f].mapInverse;

                                                            // Get the normalised "terrain position" of this point - values between 0 and 1
                                                            xPosNormalised = (float)x / (float)(heightmapResolution - 1);
                                                            zPosNormalised = (float)y / (float)(heightmapResolution - 1);

                                                            // Convert the normalised terrain coordinates into a point on the Map texture so that 
                                                            // it can be compared to the point on the Map texture (PNG image) 
                                                            mapPoint = lbMap.GetMapPositionFromTerrainPosition(xPosNormalised, zPosNormalised, startX, endX, startZ, endZ);

                                                            // Check if the pixel in the map is the same as the mapColour within the Tolerance factor
                                                            // If inverse is enabled, the opposite will be returned
                                                            if (!lbMap.IsMapPixelMatchToMapColour(mapPoint.x, mapPoint.y, false, true)) { heightSum = 0f; }
                                                            else
                                                            {
                                                                // TODO - Topography (Image) LBLayerFilter - Map: apply a blend based on the colour tolerance


                                                            }
                                                        }
                                                        else { heightSum = 0f; }
                                                    }
                                                    // If there is no map texture supplied, then not height will be applied from this layer
                                                    else { heightSum = 0f; }
                                                }
                                                else if (layer.filters[f].type == LBLayerFilter.LayerFilterType.StencilLayer)
                                                {
                                                    // WARNING: Stencil layers currently have no effect for Image Detail Layers
                                                    heightSum = 0f;
                                                }
                                            }
                                        }

                                        // If this is an additive or subtractive layer we may want to remove the base noise
                                        if ((layerTypeInt == 5 || layerTypeInt == 6) && layer.removeBaseNoise)
                                        {
                                            heightSum -= heightMap[x, y] * Mathf.InverseLerp(0f, heightMap[x, y], heightSum);
                                        }

                                        #region Blend RestrictArea
                                        if (layer.restrictArea)
                                        {
                                            // Blend along edges
                                            // Get the normalised position within the areaRect
                                            xAreaPosNormalised = (xPos - layer.areaRect.xMin) / layer.areaRect.width;
                                            zAreaPosNormalised = (yPos - layer.areaRect.yMin) / layer.areaRect.height;

                                            areaRectBlendFactor = 0f;
                                            // Calculate the normalised distance away from the edge, then blend towards the original heightmap
                                            // as you approach the edge.
                                            if (xAreaPosNormalised < areaRectBlendWidth)
                                            {
                                                areaRectBlendFactor = xAreaPosNormalised / areaRectBlendWidth;
                                                heightSum = Mathf.Lerp(0f, heightSum, areaRectBlendFactor);
                                            }
                                            else if (xAreaPosNormalised > areaRectBlendWidthUpper)
                                            {
                                                areaRectBlendFactor = (xAreaPosNormalised - areaRectBlendWidthUpper) / areaRectBlendWidth;
                                                heightSum = Mathf.Lerp(heightSum, 0f, areaRectBlendFactor);
                                            }

                                            // TODO RestictArea blending - Corners could be an issue...
                                            if (zAreaPosNormalised < areaRectBlendWidth)
                                            {
                                                areaRectBlendFactor = zAreaPosNormalised / areaRectBlendWidth;
                                                heightSum = Mathf.Lerp(0f, heightSum, areaRectBlendFactor);
                                            }
                                            else if (zAreaPosNormalised > areaRectBlendWidthUpper)
                                            {
                                                areaRectBlendFactor = (zAreaPosNormalised - areaRectBlendWidthUpper) / areaRectBlendWidth;
                                                heightSum = Mathf.Lerp(heightSum, 0f, areaRectBlendFactor);
                                            }
                                        }
                                        #endregion

                                        // Is this a subtractive layer?
                                        if (layerTypeInt == 6)
                                        {
                                            // Subtract the value of this layer from the cumulative height sum
                                            heightMap[x, y] -= heightSum;
                                        }
                                        else
                                        {
                                            // Add the value of this layer onto the cumulative height sum
                                            heightMap[x, y] += heightSum;
                                        }
                                    }
                                }
                                #endregion
                            }
                            else
                            {
                                Debug.LogWarning("Layer " + (l + 1).ToString() + " output for could not be generated because the given image is null");
                            }

                            #region Image Interpolation smoothing
                            // Perform interpolation smoothing if needed
                            if (layer.interpolationSmoothing != 0 && tData.heightmapResolution > 65 && image != null)
                            {
                                // Temporarily set heights in order to use adjust heightmap resolution function
                                tData.SetHeightsDelayLOD(0, 0, heightMap);

                                // Store the original heightmap resolution
                                originalHeightMapResolution = tData.heightmapResolution;
                                // Calculate the new heightmap resolution
                                heightmapResolution = Mathf.RoundToInt(((image.width + image.height) / 2f) * (((tData.size.x + tData.size.z) / 2f) / ((landscapeSize.x + landscapeSize.y) / 2f)) / (float)layer.interpolationSmoothing) + 1;

                                // InterpolationSmoothing of 2 with resolution of 2 will result in an error
                                // This changes it to be equivalent of 4.
                                if (originalHeightMapResolution == 129 && layer.interpolationSmoothing == 2)
                                {
                                    heightmapResolution = 129;
                                }

                                // Heightmaps for unity terrains should be 2^x + 1
                                heightmapResolution = Mathf.ClosestPowerOfTwo(heightmapResolution) + 1;

                                // Adjust the heightmap resolution
                                tData = LBLandscapeTerrain.AdjustHeightmapResolution(tData, heightmapResolution);

                                // Reset it; now all heightmap values will have been interpolated somewhat
                                tData = LBLandscapeTerrain.AdjustHeightmapResolution(tData, originalHeightMapResolution);

                                // Retrieve new heightmap data
                                // Old CODE
                                //heightMap = tData.GetHeights(0, 0, heightmapResolution, heightmapResolution);
                                // v1.3.2 Beta 10i
                                heightMap = tData.GetHeights(0, 0, originalHeightMapResolution, originalHeightMapResolution);

                                // Set the heightmapResolution variable back to its original value
                                heightmapResolution = originalHeightMapResolution;
                            }
                            #endregion
                        }
                        #endregion

                        #region MapPath Layer
                        // MapPath layer
                        else if (layerTypeInt == 20 && layer.lbMapPath != null)
                        {
                            #region MapPath settings common to Compute and Non-Compute
                            // Update the path data from the MapPath object as it may have been changed by the user in the editor.
                            layer.lbPath = layer.lbMapPath.lbPath;

                            bool blendEdges = layer.lbPath.edgeBlendWidth > 0f;
                            bool blendEnds = layer.lbPath.blendStart || layer.lbPath.blendEnd;

                            // Override blend ends settings if it is a complete closed circuit.
                            if (layer.lbPath.closedCircuit) { blendEnds = false; }

                            // LayerTypeMode.Flatten uses tData.GetInterpolatedHeight, which requires updated heightmap data.
                            if (layer.layerTypeMode == LBLayer.LayerTypeMode.Flatten)
                            {
                                // TODO - attempt to use in-memory data rather than having to set then read using GetInterpolatedHeight()
                                // Costs around 0.1 secs per 2Kx2K terrain
                                tData.SetHeightsDelayLOD(0, 0, heightMap);
                            }

                            #endregion

                            #region MapPath Compute
                            if (isPathComputeEnabled && isTopographyComputeEnabled && shaderPath != null)
                            {
#if LB_COMPUTE

                                #region Get Splines
                                // Force refresh of spline cache
                                layer.lbPath.isSplinesCached2 = false;
                                layer.lbPath.CacheSplinePoints2();

                                List<Vector3> splinePointsCentre = layer.lbPath.cachedCentreSplinePointList;
                                Vector3[] splinePointsLeft = layer.lbPath.GetSplinePathEdgePoints2(LBPath.PositionType.Left, true, true);
                                Vector3[] splinePointsRight = layer.lbPath.GetSplinePathEdgePoints2(LBPath.PositionType.Right, true, true);
                                #endregion

                                #region Reset Garbage Collection
                                System.GC.Collect();
                                #endregion

                                try
                                {
                                    int numSplineCentrePoints = (splinePointsCentre == null ? 0 : splinePointsCentre.Count);

                                    // Perform some validation
                                    if (numSplineCentrePoints < 2) { Debug.LogWarning("ERROR: " + methodName + " - Layer " + (l + 1).ToString() + " - must have at least 2 centre spline points"); }
                                    else if (splinePointsLeft == null) { Debug.LogWarning("ERROR: " + methodName + " - Layer " + (l + 1).ToString() + " - no left splines defined"); }
                                    else if (splinePointsRight == null) { Debug.LogWarning("ERROR: " + methodName + " - Layer " + (l + 1).ToString() + " - no right splines defined"); }
                                    else if (splinePointsLeft.Length != splinePointsRight.Length) { Debug.LogWarning("ERROR: " + methodName + " - Layer " + (l + 1).ToString() + " - in this release the number of left and right spline points must be the same"); }
                                    else if (numSplineCentrePoints != splinePointsRight.Length) { Debug.LogWarning("ERROR: " + methodName + " - Layer " + (l + 1).ToString() + " - in this release the number of centre, left and right spline points must be the same"); }
                                    else
                                    {
                                        // Get the index to the Method in the compute shader
                                        int kPathTopoIdx = shaderPath.FindKernel(CSKPathTopo);

                                        #region Allocate input and output height arrays
                                        int sqrHeightmapResolution = heightmapResolution * heightmapResolution;

                                        // Create heightmap as a 1-dimensional array
                                        float[] heightMap1D = new float[sqrHeightmapResolution];

                                        float[] heightMap1D_updated = new float[sqrHeightmapResolution];

                                        int heightMap1DSize = (heightMap1D == null ? 0 : heightMap1D.Length);
                                        #endregion

                                        #region Create Buffers
                                        shaderPath.SetInt(CSnumSplineCentrePoints, numSplineCentrePoints);

                                        // Assume all spline have the same number of items (which is validated above)
                                        cbufSplinePointsCentre = new ComputeBuffer(numSplineCentrePoints, sizeof(float) * 3, ComputeBufferType.Default);
                                        cbufSplinePointsLeft = new ComputeBuffer(numSplineCentrePoints, sizeof(float) * 3, ComputeBufferType.Default);
                                        cbufSplinePointsRight = new ComputeBuffer(numSplineCentrePoints, sizeof(float) * 3, ComputeBufferType.Default);

                                        // Create the buffers to hold the heightmap in/out data
                                        cbufHeightsIn = new ComputeBuffer(sqrHeightmapResolution, sizeof(float), ComputeBufferType.Default);
                                        cbufHeightsOut = new ComputeBuffer(sqrHeightmapResolution, sizeof(float), ComputeBufferType.Default);
                                        #endregion

                                        // Ensure buffers were created
                                        if (cbufSplinePointsCentre != null && cbufSplinePointsLeft != null && cbufSplinePointsRight != null && cbufHeightsIn != null && cbufHeightsOut != null && heightMap1DSize == sqrHeightmapResolution)
                                        {
                                            #region Copy spline data to shader
                                            // Allocate buffers to the compute shader method
                                            shaderPath.SetBuffer(kPathTopoIdx, CSsplinePointsCentre, cbufSplinePointsCentre);
                                            shaderPath.SetBuffer(kPathTopoIdx, CSsplinePointsLeft, cbufSplinePointsLeft);
                                            shaderPath.SetBuffer(kPathTopoIdx, CSsplinePointsRight, cbufSplinePointsRight);
                                            // Copy the data to the shader
                                            cbufSplinePointsCentre.SetData(splinePointsCentre.ToArray());
                                            cbufSplinePointsLeft.SetData(splinePointsLeft);
                                            cbufSplinePointsRight.SetData(splinePointsRight);
                                            #endregion

                                            int numKeyFrames = 0;

                                            #region BlendCurve
                                            pkKeyFrames = LBCurve.GetComputeKeyFrames(layer.mapPathBlendCurve);

                                            numKeyFrames = (pkKeyFrames == null ? 0 : pkKeyFrames.Length);
                                            if (numKeyFrames > 0)
                                            {
                                                cbufMapPathBlendCurve = new ComputeBuffer(numKeyFrames, sizeof(float) * 4, ComputeBufferType.Default);
                                                if (cbufMapPathBlendCurve != null) { shaderPath.SetBuffer(kPathTopoIdx, CSpathBlendCurve, cbufMapPathBlendCurve); cbufMapPathBlendCurve.SetData(pkKeyFrames); }
                                            }
                                            else { Debug.LogWarning("ERROR " + methodName + " - could not send MapPath blend curve data to compute shader for (MapPath) layer " + (l + 1)); }

                                            shaderPath.SetInt(CSpathBlendCurveNumKeys, numKeyFrames);
                                            #endregion

                                            #region HeightCurve
                                            pkKeyFrames = LBCurve.GetComputeKeyFrames(layer.mapPathHeightCurve);

                                            numKeyFrames = (pkKeyFrames == null ? 0 : pkKeyFrames.Length);
                                            if (numKeyFrames > 0)
                                            {
                                                cbufMapPathHeightCurve = new ComputeBuffer(numKeyFrames, sizeof(float) * 4, ComputeBufferType.Default);
                                                if (cbufMapPathHeightCurve != null) { shaderPath.SetBuffer(kPathTopoIdx, CSpathHeightCurve, cbufMapPathHeightCurve); cbufMapPathHeightCurve.SetData(pkKeyFrames); }
                                            }
                                            else { Debug.LogWarning("ERROR " + methodName + " - could not send MapPath height curve data to compute shader for (MapPath) layer " + (l + 1)); }

                                            shaderPath.SetInt(CSpathHeightCurveNumKeys, numKeyFrames);
                                            #endregion

                                            #region Assign height buffers to PathTopo method and copy in height data
                                            shaderPath.SetBuffer(kPathTopoIdx, CSheightsIn, cbufHeightsIn);
                                            shaderPath.SetBuffer(kPathTopoIdx, CSheightsOut, cbufHeightsOut);

                                            // Copy data from 2D heightmap to 1D array - Size is in bytes
                                            System.Buffer.BlockCopy(heightMap, 0, heightMap1D, 0, sizeof(float) * sqrHeightmapResolution);

                                            // Copy height data into shader
                                            cbufHeightsIn.SetData(heightMap1D);
                                            #endregion

                                            #region Set landscape and topography variables in shader
                                            shaderPath.SetInt(CSheightmapResolution, heightmapResolution);
                                            // Landscape variables
                                            shaderPath.SetVector(CSlandscapePos, landscape.transform.position);
                                            shaderPath.SetVector(CSlandscapeSize, landscape.size);
                                            // Set terrain variables
                                            shaderPath.SetFloat(CSterrainWidth, terrainWidth);
                                            shaderPath.SetFloat(CSterrainLength, terrainLength);
                                            shaderPath.SetVector(CSterrainWorldPos, worldPosition);
                                            #endregion

                                            #region Set path variables in shader                                            
                                            shaderPath.SetBool(CScheckEdges, blendEdges);
                                            shaderPath.SetBool(CSblendEnds, blendEnds);
                                            shaderPath.SetBool(CSblendStart, layer.lbPath.blendStart);
                                            shaderPath.SetBool(CSblendEnd, layer.lbPath.blendEnd);
                                            shaderPath.SetBool(CSclosedCircuit, layer.lbPath.closedCircuit);
                                            shaderPath.SetInt(CSquadLookAhead, quadLookAheadInt);
                                            shaderPath.SetFloat(CSedgeBlendWidth, layer.lbPath.edgeBlendWidth);
                                            shaderPath.SetFloat(CSsqrblendEdgeWidth, layer.lbPath.edgeBlendWidth * layer.lbPath.edgeBlendWidth);

                                            // Unused in PathTopo, but set to avoid issues
                                            shaderPath.SetVector(CSpathBounds, Vector4.zero);
                                            shaderPath.SetInt(CSPathmapTexWidth, 0);
                                            shaderPath.SetInt(CSPathmapTexHeight, 0);
                                            shaderPath.SetBool(CSremoveCentre, false);
                                            shaderPath.SetFloat(CSsqrborderLeftWidth, 0f);
                                            shaderPath.SetFloat(CSsqrborderRightWidth, 0f);
                                            shaderPath.SetFloat(CSmaxWidth, 0f);
                                            shaderPath.SetFloat(CSterrainHeight, terrainHeight);
                                            shaderPath.SetFloat(CSsurroundSmoothing, 0f);
                                            shaderPath.SetFloat(CSblendTerrainHeight, 0f);
                                            #endregion

                                            #region Layer variables
                                            shaderPath.SetFloat(CSheightScale, layer.heightScale);
                                            shaderPath.SetFloat(CSminHeight, layer.minHeight);
                                            shaderPath.SetInt(CSpathTypeMode, (int)layer.layerTypeMode);
                                            // To avoid a if branch in the shader, use a multiplier instead
                                            shaderPath.SetFloat(CSpathInvertMultipler, layer.mapPathAddInvert ? -1f : 1f);
                                            #endregion

                                            #region Execute Shader
                                            // As the heightmap res is 2^n + 1 we need to add an additional threadGroup in both x and z directions.
                                            // In our shader Z is up so x,z in Unity become x,y in shader.
                                            // The additional thread groups will only process 1 pixel. Although this means we "waste" parallel processing
                                            // on the GPU, it means we can process the rest of the heightmap in parallel.
                                            int threadGroupX = (heightmapResolution - 1) / cskPathNumThreads;
                                            int threadGroupY = (heightmapResolution - 1) / cskPathNumThreads;

                                            // Execute shader
                                            // The Z thread group is 1 because we are processing a 2D heightmap
                                            shaderPath.Dispatch(kPathTopoIdx, threadGroupX + 1, threadGroupY + 1, 1);

                                            // Get data back from shader
                                            cbufHeightsOut.GetData(heightMap1D_updated);
                                            #endregion

                                            // Copy data back from 1D heightmap to 2D heightmap
                                            System.Buffer.BlockCopy(heightMap1D_updated, 0, heightMap, 0, sizeof(float) * sqrHeightmapResolution);
                                        }
                                    }
                                }
                                catch (System.Exception ex)
                                {
                                    Debug.LogWarning("ERROR " + methodName + " - could not process MapPath layer " + (l + 1) + " on GPU. " + ex.Message);
                                }

                                #region Free shader resources
                                finally
                                {
                                    if (cbufHeightsIn != null) { cbufHeightsIn.Release(); cbufHeightsIn = null; }
                                    if (cbufHeightsOut != null) { cbufHeightsOut.Release(); cbufHeightsOut = null; }
                                    if (cbufSplinePointsCentre != null) { cbufSplinePointsCentre.Release(); cbufSplinePointsCentre = null; }
                                    if (cbufSplinePointsLeft != null) { cbufSplinePointsLeft.Release(); cbufSplinePointsLeft = null; }
                                    if (cbufSplinePointsRight != null) { cbufSplinePointsRight.Release(); cbufSplinePointsRight = null; }
                                    if (cbufMapPathBlendCurve != null) { cbufMapPathBlendCurve.Release(); cbufMapPathBlendCurve = null; }
                                    if (cbufMapPathHeightCurve != null) { cbufMapPathHeightCurve.Release(); cbufMapPathHeightCurve = null; }
                                }
                                #endregion

#endif
                            }
                            #endregion

                            #region MapPath Non-Compute
                            else
                            {
                                hmapWorldPos.y = 0f;

                                // Load the splines for this layer MapPath
                                layer.lbPath.CachePathPointDistances();
                                layer.lbPath.CacheSplinePointDistances();
                                Vector3[] splinePointsCentre = layer.lbPath.cachedCentreSplinePoints;
                                Vector3[] splinePointsLeft = layer.lbPath.GetSplinePathEdgePoints(LBPath.PositionType.Left, true);
                                Vector3[] splinePointsRight = layer.lbPath.GetSplinePathEdgePoints(LBPath.PositionType.Right, true);

                                // Perform some validation
                                if (splinePointsCentre == null || splinePointsLeft == null || splinePointsRight == null) { Debug.LogWarning("ERROR: " + methodName + " - Layer " + (l + 1).ToString() + " has no centre/left/right splines defined"); }
                                else if (splinePointsCentre.Length < 2 || splinePointsLeft.Length < 2 || splinePointsRight.Length < 2) { Debug.LogWarning("ERROR: " + methodName + " - Layer " + (l + 1).ToString() + " - must have at least 2 centre/left/right spline points"); }
                                else if (splinePointsLeft.Length != splinePointsRight.Length) { Debug.LogWarning("ERROR: " + methodName + " - Layer " + (l + 1).ToString() + " - in this release the number of left and right spline points must be the same"); }
                                else if (splinePointsCentre.Length != splinePointsRight.Length) { Debug.LogWarning("ERROR: " + methodName + " - Layer " + (l + 1).ToString() + " - in this release the number of centre, left and right spline points must be the same"); }
                                else
                                {
                                    numSplinePoints = splinePointsCentre.Length;

                                    // Cache the last left/right points so we don't need to get them from the list for each point
                                    lastLeftPoint = splinePointsLeft[numSplinePoints - 1];
                                    lastRightPoint = splinePointsRight[numSplinePoints - 1];
                                    firstLeftPoint = splinePointsLeft[0];
                                    firstRightPoint = splinePointsRight[0];
                                    sqrblendEdgeWidth = layer.lbPath.edgeBlendWidth * layer.lbPath.edgeBlendWidth;

                                    for (int x = 0; x < heightmapResolution; x++)
                                    {
                                        for (int y = 0; y < heightmapResolution; y++)
                                        {
                                            // Reset the heightSum
                                            heightSum = 0f;

                                            // Get world position of heightmap point (calculate base x,y only once)
                                            // This will be used for Map Path which are actual world positions
                                            hmapWorldPos.x = (tData.heightmapScale.x * y) + worldPosition.x;
                                            hmapWorldPos.z = (tData.heightmapScale.z * x) + worldPosition.z;

                                            // Is this World Position in the path?

                                            // Find the closest central spline point
                                            closestPoint = LBMap.FindClosestPoint(splinePointsCentre, hmapWorldPos);

                                            // Find the closest of its consecutive points
                                            secondclosestPoint = LBMap.FindClosestConsecutivePoint(splinePointsCentre, hmapWorldPos, closestPoint);

                                            int firstPtIdx = (closestPoint < secondclosestPoint ? closestPoint : secondclosestPoint);
                                            int secondPtIdx = (closestPoint < secondclosestPoint ? secondclosestPoint : closestPoint);

                                            quadP1.x = splinePointsLeft[firstPtIdx].x;
                                            quadP1.z = splinePointsLeft[firstPtIdx].z;
                                            quadP2.x = splinePointsLeft[secondPtIdx].x;
                                            quadP2.z = splinePointsLeft[secondPtIdx].z;
                                            quadP3.x = splinePointsRight[firstPtIdx].x;
                                            quadP3.z = splinePointsRight[firstPtIdx].z;
                                            quadP4.x = splinePointsRight[secondPtIdx].x;
                                            quadP4.z = splinePointsRight[secondPtIdx].z;

                                            widthPoint = firstPtIdx;
                                            firstMatchPtIdx = firstPtIdx;
                                            secondMatchPtIdx = secondPtIdx;

                                            // Set all the Y positions to 0
                                            quadP1.y = 0f; quadP2.y = 0f; quadP3.y = 0f; quadP4.y = 0f;

                                            isMatch = LBMap.IsInQuad(quadP1, quadP2, quadP3, quadP4, hmapWorldPos);

                                            // Check the previous quads to get all edge fragments from the outside of corners and the inside of the last curve
                                            for (prevIdx = 0; !isMatch && firstPtIdx > prevIdx && prevIdx < quadLookAheadInt; prevIdx++)
                                            {
                                                quadP1.x = splinePointsLeft[firstPtIdx - prevIdx - 1].x;
                                                quadP1.z = splinePointsLeft[firstPtIdx - prevIdx - 1].z;
                                                quadP2.x = splinePointsLeft[firstPtIdx - prevIdx].x;
                                                quadP2.z = splinePointsLeft[firstPtIdx - prevIdx].z;
                                                quadP3.x = splinePointsRight[firstPtIdx - prevIdx - 1].x;
                                                quadP3.z = splinePointsRight[firstPtIdx - prevIdx - 1].z;
                                                quadP4.x = splinePointsRight[firstPtIdx - prevIdx].x;
                                                quadP4.z = splinePointsRight[firstPtIdx - prevIdx].z;

                                                widthPoint = firstPtIdx - prevIdx;
                                                firstMatchPtIdx = firstPtIdx - prevIdx - 1;
                                                secondMatchPtIdx = firstPtIdx - prevIdx;

                                                isMatch = LBMap.IsInQuad(quadP1, quadP2, quadP3, quadP4, hmapWorldPos);
                                            }

                                            // Check the next quads to get all edge fragments from the inside of corners and the outside of the last curve
                                            for (nextIdx = 0; !isMatch && secondPtIdx + nextIdx + 1 < numSplinePoints && nextIdx < quadLookAheadInt; nextIdx++)
                                            {
                                                quadP1.x = splinePointsLeft[secondPtIdx + nextIdx].x;
                                                quadP1.z = splinePointsLeft[secondPtIdx + nextIdx].z;
                                                quadP2.x = splinePointsLeft[secondPtIdx + nextIdx + 1].x;
                                                quadP2.z = splinePointsLeft[secondPtIdx + nextIdx + 1].z;
                                                quadP3.x = splinePointsRight[secondPtIdx + nextIdx].x;
                                                quadP3.z = splinePointsRight[secondPtIdx + nextIdx].z;
                                                quadP4.x = splinePointsRight[secondPtIdx + nextIdx + 1].x;
                                                quadP4.z = splinePointsRight[secondPtIdx + nextIdx + 1].z;

                                                widthPoint = secondPtIdx + nextIdx;
                                                firstMatchPtIdx = secondPtIdx + nextIdx;
                                                secondMatchPtIdx = secondPtIdx + nextIdx + 1;

                                                isMatch = LBMap.IsInQuad(quadP1, quadP2, quadP3, quadP4, hmapWorldPos);
                                            }

                                            // v1.3.3 Beta 1a
                                            // Fill in the gap halfway between the second last spline point and the
                                            // last spline point (which should be the same as the first spline point).
                                            if (!isMatch && layer.lbPath.closedCircuit)
                                            {
                                                quadP1.x = splinePointsLeft[numSplinePoints - 2].x;
                                                quadP1.z = splinePointsLeft[numSplinePoints - 2].z;
                                                quadP2.x = splinePointsLeft[0].x;
                                                quadP2.z = splinePointsLeft[0].z;
                                                quadP3.x = splinePointsRight[numSplinePoints - 2].x;
                                                quadP3.z = splinePointsRight[numSplinePoints - 2].z;
                                                quadP4.x = splinePointsRight[0].x;
                                                quadP4.z = splinePointsRight[0].z;

                                                widthPoint = 0;
                                                firstMatchPtIdx = numSplinePoints - 2;
                                                secondMatchPtIdx = numSplinePoints - 1;

                                                isMatch = LBMap.IsInQuad(quadP1, quadP2, quadP3, quadP4, hmapWorldPos);
                                            }

                                            if (isMatch)
                                            {
                                                // How far away from the edge is this point?
                                                sqrDistLeft = LBMap.PlanarSquareDistance(hmapWorldPos, quadP1);
                                                sqrDistRight = LBMap.PlanarSquareDistance(hmapWorldPos, quadP3);

                                                // Left side
                                                if (sqrDistLeft < sqrDistRight)
                                                {
                                                    // What is the distance from this point to the left edge?
                                                    sqrPixelDistFromEdge = Mathf.Abs(LBMap.SquareDistanceToSide(quadP1, quadP2, hmapWorldPos));
                                                }
                                                // Right side
                                                else
                                                {
                                                    // What is the distance from this point to the right edge?
                                                    sqrPixelDistFromEdge = Mathf.Abs(LBMap.SquareDistanceToSide(quadP3, quadP4, hmapWorldPos));
                                                }

                                                // Get width of the path at the nearest point
                                                pathWidthAtPoint = layer.lbPath.GetWidthOnSpline(widthPoint);

                                                if (blendEdges && layer.lbPath.edgeBlendWidth > 0f)
                                                {
                                                    // Only blend if we are within the BlendEdgeWidth distance
                                                    if (sqrPixelDistFromEdge <= sqrblendEdgeWidth)
                                                    {
                                                        blendAmount = layer.mapPathBlendCurve.Evaluate(sqrPixelDistFromEdge / sqrblendEdgeWidth);
                                                    }
                                                    else { blendAmount = 1f; }

                                                    // Only process the ends if blending is required there
                                                    // Blend ends settings are overridden if it is a complete closed circuit.
                                                    if (blendEnds)
                                                    {
                                                        sqrDistToEnd = LBMap.SquareDistanceToSide(lastLeftPoint, lastRightPoint, hmapWorldPos);
                                                        sqrDistToStart = LBMap.SquareDistanceToSide(firstLeftPoint, firstRightPoint, hmapWorldPos);

                                                        // NOTE: If the path length < 2 x blend Edge Width, the results may be a little unpredicable
                                                        if (layer.lbPath.blendStart && sqrDistToStart <= sqrblendEdgeWidth)
                                                        {
                                                            endBlendAmount = Mathf.Lerp(0f, blendAmount, sqrDistToStart / sqrblendEdgeWidth);
                                                            //endBlendAmount = layer.mapPathBlendCurve.Evaluate(sqrDistToStart / sqrblendEdgeWidth);
                                                            if (endBlendAmount < blendAmount) { blendAmount = endBlendAmount; }
                                                        }

                                                        if (layer.lbPath.blendEnd && sqrDistToEnd <= sqrblendEdgeWidth)
                                                        {
                                                            endBlendAmount = Mathf.Lerp(0f, blendAmount, sqrDistToEnd / sqrblendEdgeWidth);
                                                            //endBlendAmount = layer.mapPathBlendCurve.Evaluate(sqrDistToEnd / sqrblendEdgeWidth);
                                                            if (endBlendAmount < blendAmount) { blendAmount = endBlendAmount; }
                                                        }
                                                    }
                                                }
                                                else { blendAmount = 1f; }

                                                distFromEdge = Mathf.Sqrt(sqrPixelDistFromEdge) / (pathWidthAtPoint * 0.5f);

                                                // Set the min and max height of the path in the topography based.
                                                if (layer.layerTypeMode == LBLayer.LayerTypeMode.Set)
                                                {
                                                    // Left side
                                                    if (sqrDistLeft < sqrDistRight)
                                                    {
                                                        heightSum = Mathf.Lerp(layer.minHeight, layer.heightScale, layer.mapPathHeightCurve.Evaluate(distFromEdge * 0.5f));
                                                    }
                                                    // Right side
                                                    else
                                                    {
                                                        heightSum = Mathf.Lerp(layer.minHeight, layer.heightScale, layer.mapPathHeightCurve.Evaluate(1f - (distFromEdge * 0.5f)));
                                                    }
                                                    // Blend between the original topography height and the set height
                                                    heightMap[x, y] = Mathf.Lerp(heightMap[x, y], heightSum, blendAmount);
                                                }
                                                // Add (or subtract) a number of metres from the topography along the path
                                                else if (layer.layerTypeMode == LBLayer.LayerTypeMode.Add)
                                                {
                                                    // Left side
                                                    if (sqrDistLeft < sqrDistRight)
                                                    {
                                                        heightSum = Mathf.Lerp(0f, blendAmount * layer.heightScale, layer.mapPathHeightCurve.Evaluate(distFromEdge * 0.5f));
                                                    }
                                                    // Right side
                                                    else
                                                    {
                                                        heightSum = Mathf.Lerp(0f, blendAmount * layer.heightScale, layer.mapPathHeightCurve.Evaluate(1f - (distFromEdge * 0.5f)));
                                                    }

                                                    // Subtract or add the blended height
                                                    if (layer.mapPathAddInvert) { heightMap[x, y] -= heightSum; }
                                                    else { heightMap[x, y] += heightSum; }
                                                }
                                                // Flatten the topography along the path
                                                else if (layer.layerTypeMode == LBLayer.LayerTypeMode.Flatten)
                                                {
                                                    // Objective: Get the height at the centrespline perpendicular to the current heightmap point

                                                    // Get points from the array so only have to lookup once
                                                    firstMatchCentrePt = splinePointsCentre[firstMatchPtIdx];
                                                    secondMatchCentrePt = splinePointsCentre[secondMatchPtIdx];

                                                    forwards = secondMatchCentrePt - firstMatchCentrePt;

                                                    // SquareDistanceToSide ignores the Y value (get absolute value because sometimes SquareDistanceToSide can return small -ve)
                                                    pixelDistFromCentre = Mathf.Sqrt(Mathf.Abs(LBMap.SquareDistanceToSide(firstMatchCentrePt, secondMatchCentrePt, hmapWorldPos)));

                                                    // Get the perpendicular vector from the pixel to the centre spline
                                                    perpdclr = Quaternion.Euler(0f, (sqrDistLeft > sqrDistRight ? -1f : 1f) * 90f, 0f) * forwards;
                                                    perpdclr = perpdclr.normalized * pixelDistFromCentre;

                                                    firstMatchPerp = firstMatchCentrePt - perpdclr;
                                                    secondMatchPerp = secondMatchCentrePt - perpdclr;

                                                    flattenLerpValX = Mathf.InverseLerp(firstMatchPerp.x, secondMatchPerp.x, hmapWorldPos.x);
                                                    flattenLerpValZ = Mathf.InverseLerp(firstMatchPerp.z, secondMatchPerp.z, hmapWorldPos.z);

                                                    // Get the point on the centre spline
                                                    centrePointInterpolated.x = Mathf.Lerp(firstMatchCentrePt.x, secondMatchCentrePt.x, flattenLerpValX);
                                                    centrePointInterpolated.z = Mathf.Lerp(firstMatchCentrePt.z, secondMatchCentrePt.z, flattenLerpValZ);
                                                    centrePointInterpolated.y = 0;

                                                    // Get the normalised (0-1) position on the terrain on the path centre spline adjacent to the current heightmap point
                                                    normXPos = Mathf.InverseLerp(worldPosition.x, worldPosition.x + terrainWidth, centrePointInterpolated.x);
                                                    normZPos = Mathf.InverseLerp(worldPosition.z, worldPosition.z + terrainWidth, centrePointInterpolated.z);

                                                    // Get the height at the centre spline point on the terrain (0-1)
                                                    heightAtCentreSpline = tData.GetInterpolatedHeight(normXPos, normZPos) / terrainHeight;

                                                    // Calculate min/max heights
                                                    minHeight = heightAtCentreSpline - (layer.heightScale * 0.5f);
                                                    maxHeight = heightAtCentreSpline + (layer.heightScale * 0.5f);

                                                    // evaluate the height curve
                                                    // Left side
                                                    if (sqrDistLeft < sqrDistRight)
                                                    {
                                                        heightSum = layer.mapPathHeightCurve.Evaluate(distFromEdge * 0.5f);
                                                    }
                                                    // Right side
                                                    else
                                                    {
                                                        heightSum = layer.mapPathHeightCurve.Evaluate(1f - (distFromEdge * 0.5f));
                                                    }

                                                    // Calculate actual height by lerping between min and max heights
                                                    heightMap[x, y] = Mathf.Lerp(heightMap[x, y], Mathf.Lerp(minHeight, maxHeight, heightSum), blendAmount);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion
                        }
                        #endregion

                        #region Landform Modifier Layer
                        //else if (layerTypeInt == 30)
                        //{

                        //}
                        #endregion

                        #region Image Modifier Layer
                        else if (layerTypeInt == 35)
                        {
                            // One RAW file for all landscape
                            LBRaw lbRaw = layer.modifierRAWFile;

                            if (lbRaw == null) { { Debug.LogWarning("ERROR " + methodName + " - could not find LBRaw"); } }
                            else if (!lbRaw.ValidateRAWHeightData(false)) { Debug.LogWarning("ERROR " + methodName + " - layer " + (l + 1) + " does not contain any valid RAW data"); }
                            else
                            {
                                // When the areaRect Width/Height equals the width/length of the landscape, image modifiers can create small holes
                                // along the edges. Adding a small amount to the edges overcomes this problem.
                                float areaRectW = (layer.areaRect.width == landscapeSize.x ? landscapeSize.x + 0.002f : layer.areaRect.width);
                                float areaRectH = (layer.areaRect.height == landscapeSize.y ? landscapeSize.y + 0.002f : layer.areaRect.height);

                                #region Image Modifier Compute
#if LB_COMPUTE
                                if (isTopographyComputeEnabled && shaderTopo != null)
                                {
                                    //float csStart = Time.realtimeSinceStartup;

                                    // Load the single RAW file
                                    // NOTE: this means we're loading the same file for each terrain (which may be inefficient)
                                    try
                                    {
                                        // Get the index to the Method in the compute shader
                                        int kTopoImageModifierIdx = shaderTopo.FindKernel(CSKTopoImageModifier);

                                        #region Allocate input and output height arrays
                                        int sqrHeightmapResolution = heightmapResolution * heightmapResolution;

                                        // Create heightmap as a 1-dimensional array
                                        float[] heightMap1D = new float[sqrHeightmapResolution];

                                        float[] heightMap1D_updated = new float[sqrHeightmapResolution];
                                        int heightMap1DSize = (heightMap1D == null ? 0 : heightMap1D.Length);

                                        uint[] rawHeightData1D = new uint[lbRaw.rawSourceWidth * lbRaw.rawSourceLength];
                                        int rawHeightData1DSize = (rawHeightData1D == null ? 0 : rawHeightData1D.Length);

                                        #endregion

                                        if (heightMap1DSize == sqrHeightmapResolution && rawHeightData1DSize == lbRaw.rawSourceWidth * lbRaw.rawSourceLength)
                                        {
                                            #region Load Image Modifier RAW data and create buffer
                                            lbRaw.ConvertRawHeightDataToInt(ref rawHeightData1D);
                                            cbufRAW = new ComputeBuffer(rawHeightData1DSize, sizeof(uint), ComputeBufferType.Default);
                                            #endregion

                                            #region Copy Heightmap to 1D and create height in/out buffers
                                            // Copy data from 2D heightmap to 1D array - Size is in bytes
                                            System.Buffer.BlockCopy(heightMap, 0, heightMap1D, 0, sizeof(float) * sqrHeightmapResolution);

                                            // Create the buffers to hold the heightmap in/out data
                                            cbufHeightsIn = new ComputeBuffer(sqrHeightmapResolution, sizeof(float), ComputeBufferType.Default);
                                            cbufHeightsOut = new ComputeBuffer(sqrHeightmapResolution, sizeof(float), ComputeBufferType.Default);
                                            #endregion

                                            if (cbufRAW != null && cbufHeightsIn != null && cbufHeightsOut != null)
                                            {
                                                #region Assign height buffers to TopoImageModifier method
                                                shaderTopo.SetBuffer(kTopoImageModifierIdx, CSheightsIn, cbufHeightsIn);
                                                shaderTopo.SetBuffer(kTopoImageModifierIdx, CSheightsOut, cbufHeightsOut);
                                                shaderTopo.SetBuffer(kTopoImageModifierIdx, CSrawHeightData, cbufRAW);
                                                #endregion

                                                #region Copy height and raw data into shader
                                                cbufHeightsIn.SetData(heightMap1D);
                                                cbufRAW.SetData(rawHeightData1D);
                                                #endregion

                                                #region Set variables in compute shader
                                                shaderTopo.SetInt(CSheightmapResolution, heightmapResolution);
                                                // Set layer variables
                                                shaderTopo.SetInt(CSlayerTypeInt, layerTypeInt);
                                                shaderTopo.SetFloat(CSheightScale, layer.imageHeightScale);
                                                shaderTopo.SetBool(CSrestrictArea, layer.restrictArea);
                                                // Add the area as boundary points. This becomes a float4 in the compute shader
                                                cvec4AreaRect.x = layer.areaRect.x - (areaRectW * 0.5f);
                                                cvec4AreaRect.y = layer.areaRect.y - (areaRectH * 0.5f);
                                                cvec4AreaRect.z = cvec4AreaRect.x + areaRectW;
                                                cvec4AreaRect.w = cvec4AreaRect.y + areaRectH;
                                                shaderTopo.SetVector(CSareaRect, cvec4AreaRect);
                                                shaderTopo.SetFloat(CSareaRectBlendWidth, areaRectBlendWidth);
                                                shaderTopo.SetFloat(CSareaRectRotation, layer.areaRectRotation * Mathf.Deg2Rad);
                                                shaderTopo.SetBool(CSremoveBaseNoise, layer.removeBaseNoise);
                                                shaderTopo.SetBool(CSnormaliseImage, layer.normaliseImage);
                                                cvec4MinMaxRange.x = (float)lbRaw.rawMinHeight;
                                                cvec4MinMaxRange.y = (float)lbRaw.rawMaxHeight;
                                                cvec4MinMaxRange.z = (float)lbRaw.rawSourceWidth;
                                                cvec4MinMaxRange.w = (float)lbRaw.rawSourceLength;
                                                shaderTopo.SetVector(CSimageMinMaxRange, cvec4MinMaxRange);
                                                // Store the floorOffsetY in addHeightN
                                                shaderTopo.SetFloat(CSaddHeightN, layer.floorOffsetY);
                                                // Set additive/subtractive amount
                                                shaderTopo.SetFloat(CSaddsubAmount, layer.additiveAmount);
                                                // Modifier mode can be Add (0) or Set (5).
                                                shaderTopo.SetBool(CSuseBlending, layer.modifierUseBlending);
                                                shaderTopo.SetInt(CSmodifierMode, (int)layer.modifierMode);
                                                shaderTopo.SetBool(CSmodifierInvert, layer.modifierAddInvert);
                                                // Set terrain variables
                                                shaderTopo.SetFloat(CSterrainWidth, terrainWidth);
                                                shaderTopo.SetFloat(CSterrainLength, terrainLength);
                                                shaderTopo.SetVector(CSterrainWorldPos, worldPosition);
                                                // Set landscape variables
                                                shaderTopo.SetVector(CSlandscapePos, landscapePosition);
                                                shaderTopo.SetVector(CSlandscapeSize, landscapeSize);
                                                #endregion

                                                #region Execute Shader
                                                // As the heightmap res is 2^n + 1 we need to add an additional threadGroup in both x and z directions.
                                                // In our shader Z is up so x,z in Unity become x,y in shader.
                                                // The additional thread groups will only process 1 pixel. Although this means we "waste" parallel processing
                                                // on the GPU, it means we can process the rest of the heightmap in parallel.
                                                int threadGroupX = (heightmapResolution - 1) / cskTopoImageNumThreads;
                                                int threadGroupY = (heightmapResolution - 1) / cskTopoImageNumThreads;

                                                // Execute shader
                                                // The Z thread group is 1 because we are processing a 2D heightmap
                                                shaderTopo.Dispatch(kTopoImageModifierIdx, threadGroupX + 1, threadGroupY + 1, 1);

                                                // Get data back from shader
                                                cbufHeightsOut.GetData(heightMap1D_updated);
                                                #endregion

                                                // Copy data back from 1D heightmap to 2D heightmap
                                                System.Buffer.BlockCopy(heightMap1D_updated, 0, heightMap, 0, sizeof(float) * sqrHeightmapResolution);
                                            }
                                        }
                                    }
                                    catch (System.Exception ex)
                                    {
                                        Debug.LogWarning("ERROR " + methodName + " - could not process image modifier layer " + (l + 1) + " " + ex.Message);
                                    }

                                    #region Free Resources
                                    finally
                                    {
                                        if (cbufHeightsIn != null) { cbufHeightsIn.Release(); cbufHeightsIn = null; }
                                        if (cbufHeightsOut != null) { cbufHeightsOut.Release(); cbufHeightsOut = null; }
                                        if (cbufRAW != null) { cbufRAW.Release(); cbufRAW = null; }
                                    }
                                    #endregion

                                    //Debug.Log("Topography compute phase finished (Image Modifier) " + System.DateTime.Now.ToLongTimeString() + " duration: " + (Time.realtimeSinceStartup - csStart).ToString("0.0000") + "s");

                                }
#endif
                                #endregion

                                #region Image Modifier Non-Compute
                                if (!isTopographyComputeEnabled)
                                {
                                    ushort heightUShort = 0;
                                    int x = 0, y = 0;
                                    //int byteIndex = 0;
                                    //int xCoord = 0, yCoord = 0;
                                    float vectorLength, angleAlpha, vectorAngle;

                                    float previousHeight = 0f;
                                    float blendFactor = 0f;
                                    float xDistToCentre, yDistToCentre, distToCentre;

                                    for (x = 0; x < heightmapResolution; x++)
                                    {
                                        for (y = 0; y < heightmapResolution; y++)
                                        {
                                            // Get world position of heightmap point
                                            // Should test whether -landscape position is needed
                                            xPos = (tData.heightmapScale.x * y) + worldPosition.x - landscapePosition.x;
                                            yPos = (tData.heightmapScale.z * x) + worldPosition.z - landscapePosition.z;

                                            // Get position relative to centre of modifier area rect
                                            xPos -= layer.areaRect.x;
                                            yPos -= layer.areaRect.y;

                                            // Convert position into landspace space by rotating anticlockwise given rotation
                                            // Get length of original vector
                                            vectorLength = Mathf.Sqrt((xPos * xPos) + (yPos * yPos));
                                            if (!Mathf.Approximately(vectorLength, 0f))
                                            {
                                                // Have to fix result of arctan for 2nd and 3rd quadrants
                                                angleAlpha = Mathf.Atan(yPos / xPos);
                                                if (xPos < 0f) { angleAlpha += Mathf.PI; }
                                                // Get new result of angle
                                                vectorAngle = (angleAlpha + (layer.areaRectRotation * Mathf.Deg2Rad)) % (Mathf.PI * 2f);
                                                xPos = vectorLength * Mathf.Cos(vectorAngle);
                                                yPos = vectorLength * Mathf.Sin(vectorAngle);
                                            }

                                            // Convert into image space
                                            xPos = (xPos / areaRectW) + 0.5f;
                                            yPos = (yPos / areaRectH) + 0.5f;

                                            // Only continue if coords are in 0-1 range (this indicates it is inside area rect)
                                            if (xPos < 0f || xPos > 1f || yPos < 0f || yPos > 1f) { continue; }

                                            // Sample the height by using a weighted average of the four surrounding data points
                                            heightUShort = lbRaw.SampleHeightAtCoordinates(xPos, yPos);

                                            // Heights are stored as [height,width] and are 0.0 - 1.0f.

                                            // Normalise the RAW Pixel - converting it to a range of 0 to 1
                                            heightSum = Normalise(heightUShort, lbRaw.rawMinHeight, lbRaw.rawMaxHeight);

                                            //// Get the height from the grayscale value in the image at the given coordinates
                                            //heightSum = image.GetPixel(xCoord, yCoord).grayscale;

                                            // Get current terrain height
                                            previousHeight = heightMap[x, y];

                                            if (layer.modifierUseBlending)
                                            {
                                                // Calculate blending factor
                                                // Get the square distance to the centre of the modifier
                                                // 0.5 is subtracted so that central region isn't blended
                                                xDistToCentre = (xPos - 0.5f) * 2f;
                                                yDistToCentre = (yPos - 0.5f) * 2f;
                                                distToCentre = ((xDistToCentre * xDistToCentre) + (yDistToCentre * yDistToCentre) - 0.5f) * 2f;
                                                // Add domain warping to the distance to hide the circular shape
                                                distToCentre += LBNoise.PerlinFractalNoise(xPos * 5f, yPos * 5f, 3) * 1f;
                                                // If (adjusted) distance to centre is positive, use blending
                                                blendFactor = Mathf.Clamp01(distToCentre);
                                            }
                                            // Otherwise disable blending
                                            else { blendFactor = 0f; }

                                            if (layer.modifierMode == LBLayer.LayerModifierMode.Add)
                                            {
                                                // Scale the heightmap and add/remove additive amount
                                                heightSum = Mathf.Clamp01((heightSum - 1f + layer.additiveAmount) * layer.imageHeightScale);

                                                // If subtract is enabled, remove the heightsum from the heightmap
                                                if (layer.modifierAddInvert) { heightMap[x, y] -= heightSum * (1f - blendFactor); }
                                                // Else add it to the heightmap
                                                else { heightMap[x, y] += heightSum * (1f - blendFactor); }
                                            }
                                            else
                                            {
                                                // Scale the heightmap
                                                heightSum = Mathf.Clamp01(heightSum * layer.imageHeightScale);
                                                // Add the y offset
                                                heightSum = Mathf.Clamp01(heightSum + layer.floorOffsetY);

                                                // If subtract is enabled, set the heightmap to the height sum if
                                                // the height sum is LOWER than the heightmap
                                                if (layer.modifierAddInvert)
                                                {
                                                    // If we are removing from the heightmap, invert heights first
                                                    heightSum = 1f - heightSum;
                                                    if (heightSum < previousHeight) { heightMap[x, y] = Mathf.Lerp(heightSum, previousHeight, blendFactor); }
                                                }
                                                // Else set the heightmap to the height sum if
                                                // the height sum is HIGHER than the heightmap
                                                else
                                                {
                                                    //if (heightSum > heightMap[x, y]) { heightMap[x, y] = heightSum; }
                                                    if (heightSum > previousHeight) { heightMap[x, y] = Mathf.Lerp(heightSum, previousHeight, blendFactor); }
                                                }
                                            }
                                        }
                                    }
                                }
                                #endregion
                            }
                        }
                        #endregion

                        #region Unity Terrains Layer

                        else if (layerTypeInt == 50 && layer.lbTerrainDataList != null)
                        {
                            // 1 LBTerrainData instance per terrain

                            // We're only doing this once for each terrain as there can only be one Unity Terrains layer per landscape
                            LBTerrainData lbTerrainData = layer.lbTerrainDataList.Find(td => td.sourceTerrainDataName == tData.name);

                            if (lbTerrainData == null) { { Debug.LogWarning("ERROR " + methodName + " - could not find LBTerrainData for " + tData.name); } }
                            else if (lbTerrainData.ValidateRAWHeightData(landscape, true))
                            {
                                #region Initialise Unity Terrain Layer
                                ushort heightUShort = 0;
                                int x = 0, y = 0, byteIndex = 0;

                                // Only permit normalise on TIF imported-data
                                bool isGeoTIFF = LBTerrainData.GetDataSourceDisplayName(layer.lbTerrainDataList).ToLower().Contains("tif");
                                bool isNormalise = isGeoTIFF && layer.normaliseImage;

                                ushort minHeightUShort = 0;
                                ushort maxHeightUShort = 0;
                                float floorOffsetN = layer.floorOffsetY / terrainHeight;

                                if (isNormalise)
                                {
                                    // Need to fetch all the min/max values for all the LBTerrainData in this layer
                                    if (!LBTerrainData.GetRAWMinMaxHeights(layer.lbTerrainDataList, ref minHeightUShort, ref maxHeightUShort))
                                    {
                                        Debug.LogWarning("ERROR " + methodName + " - could not get LBTerrainData min/max heights for " + tData.name);
                                    }
                                }
                                #endregion

                                #region Unity Terrain Layer Compute

#if LB_COMPUTE
                                if (isTopographyComputeEnabled && shaderTopo != null)
                                {
                                    //float csStart = Time.realtimeSinceStartup;

                                    try
                                    {
                                        // Get the index to the Method in the compute shader
                                        int kTopoUnityTerrainsIdx = shaderTopo.FindKernel(CSKTopoUnityTerrains);

                                        // NOTE: Strategy is to re-use the heightOut buffer to upload RAW data to shader.
                                        // We can do that in this layer type as the LBTerrainData raw heightmap is the same
                                        // resolution as the actual terrain heightmap. Using only 1 buffer saves memory
                                        // and improves performance by approx 10%

                                        #region Allocate input and output height arrays
                                        int sqrHeightmapResolution = heightmapResolution * heightmapResolution;

                                        // Create heightmap as a 1-dimensional array
                                        // No need for a heightMap1D (input) layer as Unity Terrains layers are always the first
                                        float[] heightMap1D_updated = new float[sqrHeightmapResolution];
                                        int heightMap1DSize = (heightMap1D_updated == null ? 0 : heightMap1D_updated.Length);

                                        //uint[] rawHeightData1D = new uint[sqrHeightmapResolution];
                                        //int rawHeightData1DSize = (rawHeightData1D == null ? 0 : rawHeightData1D.Length);

                                        #endregion

                                        if (heightMap1DSize == sqrHeightmapResolution) // && rawHeightData1DSize == sqrHeightmapResolution)
                                        {
                                            #region Create HeightsOut buffer and re-use for uploading RAW TerrainData
                                            cbufHeightsOut = new ComputeBuffer(sqrHeightmapResolution, sizeof(float), ComputeBufferType.Default);
                                            lbTerrainData.ConvertRawHeightDataToFloat(ref heightMap1D_updated);
                                            #endregion

                                            #region Load RAW data and create buffer (currently not used)
                                            //lbTerrainData.ConvertRawHeightDataToInt(ref rawHeightData1D);
                                            //cbufRAW = new ComputeBuffer(rawHeightData1DSize, sizeof(uint), ComputeBufferType.Default);
                                            #endregion

                                            if (cbufHeightsOut != null)
                                            //if (cbufRAW != null && cbufHeightsOut != null)
                                            {
                                                #region Assign height buffer to TopoUnityTerrains method
                                                shaderTopo.SetBuffer(kTopoUnityTerrainsIdx, CSheightsOut, cbufHeightsOut);
                                                cbufHeightsOut.SetData(heightMap1D_updated);
                                                //shaderTopo.SetBuffer(kTopoUnityTerrainsIdx, CSrawHeightData, cbufRAW);
                                                #endregion

                                                #region Copy raw data into shader (currently not used)
                                                //cbufRAW.SetData(rawHeightData1D);
                                                #endregion

                                                #region Set variables in compute shader
                                                shaderTopo.SetInt(CSheightmapResolution, heightmapResolution);
                                                // Set layer variables
                                                shaderTopo.SetInt(CSlayerTypeInt, layerTypeInt);
                                                shaderTopo.SetFloat(CSheightScale, layer.heightScale);
                                                shaderTopo.SetBool(CSrestrictArea, layer.restrictArea);
                                                // Add the area as boundary points. This becomes a float4 in the compute shader
                                                cvec4AreaRect.x = layer.areaRect.xMin;
                                                cvec4AreaRect.y = layer.areaRect.yMin;
                                                cvec4AreaRect.z = layer.areaRect.xMax;
                                                cvec4AreaRect.w = layer.areaRect.yMax;
                                                shaderTopo.SetVector(CSareaRect, cvec4AreaRect);
                                                shaderTopo.SetFloat(CSareaRectBlendWidth, 0f);
                                                shaderTopo.SetFloat(CSareaRectRotation, 0f);
                                                shaderTopo.SetBool(CSremoveBaseNoise, layer.removeBaseNoise);
                                                shaderTopo.SetBool(CSnormaliseImage, layer.normaliseImage);
                                                cvec4MinMaxRange.x = (float)minHeightUShort;
                                                cvec4MinMaxRange.y = (float)maxHeightUShort;
                                                cvec4MinMaxRange.z = (float)heightmapResolution;
                                                cvec4MinMaxRange.w = (float)heightmapResolution;
                                                shaderTopo.SetVector(CSimageMinMaxRange, cvec4MinMaxRange);
                                                // Store the floorOffsetY in addHeightN
                                                shaderTopo.SetFloat(CSaddHeightN, floorOffsetN);
                                                // Set additive/subtractive amount
                                                shaderTopo.SetFloat(CSaddsubAmount, layer.additiveAmount);
                                                // Modifier mode can be Add (0) or Set (5).
                                                shaderTopo.SetBool(CSuseBlending, layer.modifierUseBlending);
                                                shaderTopo.SetInt(CSmodifierMode, (int)layer.modifierMode);
                                                shaderTopo.SetBool(CSmodifierInvert, layer.modifierAddInvert);
                                                // Set terrain variables
                                                shaderTopo.SetFloat(CSterrainWidth, terrainWidth);
                                                shaderTopo.SetFloat(CSterrainLength, terrainLength);
                                                shaderTopo.SetVector(CSterrainWorldPos, worldPosition);
                                                // Set landscape variables
                                                shaderTopo.SetVector(CSlandscapePos, landscapePosition);
                                                shaderTopo.SetVector(CSlandscapeSize, landscapeSize);
                                                #endregion

                                                #region Execute Shader
                                                // As the heightmap res is 2^n + 1 we need to add an additional threadGroup in both x and z directions.
                                                // In our shader Z is up so x,z in Unity become x,y in shader.
                                                // The additional thread groups will only process 1 pixel. Although this means we "waste" parallel processing
                                                // on the GPU, it means we can process the rest of the heightmap in parallel.
                                                int threadGroupX = (heightmapResolution - 1) / cskTopoImageNumThreads;
                                                int threadGroupY = (heightmapResolution - 1) / cskTopoImageNumThreads;

                                                // Execute shader
                                                // The Z thread group is 1 because we are processing a 2D heightmap
                                                shaderTopo.Dispatch(kTopoUnityTerrainsIdx, threadGroupX + 1, threadGroupY + 1, 1);

                                                // Get data back from shader
                                                cbufHeightsOut.GetData(heightMap1D_updated);
                                                #endregion

                                                // Copy data back from 1D heightmap to 2D heightmap
                                                System.Buffer.BlockCopy(heightMap1D_updated, 0, heightMap, 0, sizeof(float) * sqrHeightmapResolution);
                                            }
                                        }
                                    }
                                    catch (System.Exception ex)
                                    {
                                        Debug.LogWarning("ERROR " + methodName + " - could not process unity terrains layer " + (l + 1) + " " + ex.Message);
                                    }

                                    #region Free Resources
                                    finally
                                    {
                                        if (cbufHeightsOut != null) { cbufHeightsOut.Release(); cbufHeightsOut = null; }
                                        if (cbufRAW != null) { cbufRAW.Release(); cbufRAW = null; }
                                    }
                                    #endregion

                                    //Debug.Log("Topography compute phase finished (Unity Terrains Layer) " + System.DateTime.Now.ToLongTimeString() + " duration: " + (Time.realtimeSinceStartup - csStart).ToString("0.0000") + "s");
                                }
#endif
                                #endregion

                                #region Unity Terrian Layer Non-Compute

                                if (!isTopographyComputeEnabled)
                                {
                                    for (x = 0; x < heightmapResolution; x++)
                                    {
                                        for (y = 0; y < heightmapResolution; y++)
                                        {
                                            // Most of our Topography code uses heightMap[x, y], whereas SetHeights() and SetHeightsDelayLOD expects heightMap[y, x]
                                            // Switch x and y to use our heightMap[x,y] format.
                                            byteIndex = x * (heightmapResolution * 2) + (y * 2);

                                            // LB stores RAW data in little endian (Windows) format, which is more suited to Intel processors.
                                            heightUShort = (ushort)((lbTerrainData.rawHeightData[byteIndex + 1] << 8) | lbTerrainData.rawHeightData[byteIndex]);

                                            // Heights are stored as [height,width] and are 0.0 - 1.0f.

                                            // Step 1. Optionally normalise or get the actual 0-1 value from the ushort
                                            if (isNormalise)
                                            {
                                                // Normalise the RAW Pixel - converting it to a range of 0 to 1
                                                heightSum = Normalise(heightUShort, minHeightUShort, maxHeightUShort);
                                            }
                                            else { heightSum = heightUShort / 65535f; }

                                            // Step 2. Multiple by heightScale
                                            heightSum *= layer.heightScale;

                                            // Step 3. Compress lower limit upwards
                                            // for some 0-1 compression scalar "x": newHeight = x + (oldHeight * (1 - x))
                                            if (floorOffsetN > 0f) { heightSum = floorOffsetN + (heightSum * (1f - floorOffsetN)); }

                                            heightMap[x, y] += Mathf.Clamp01(heightSum);
                                        }
                                    }
                                }

                                #endregion
                            }
                        }

                        #endregion
                    }
                }

                #region Release Compute Resources
#if LB_COMPUTE
                if (isTopographyComputeEnabled)
                {
                    // dispose once after all layers have been processed
                    if (dummyTex != null) { LBTextureOperations.DestroyTexture2D(ref dummyTex); }
                    if (dummyTex2DArray != null) { LBTextureOperations.DestroyTexture2DArray(ref dummyTex2DArray); }
                }
#endif
                #endregion

                // Set heightmap
                tData.SetHeightsDelayLOD(0, 0, heightMap);
            }

            if (landscape != null)
            {
                if (landscape.showTiming) { Debug.Log("Time taken for terrain heightmap: " + (Time.realtimeSinceStartup - tStart).ToString("0.000") + "s"); }
            }

            return tData;
        }
        #endregion

        #region Static Heightmap Methods (Not Layer-based)

        /// <summary>
        /// Returns the TerrainData after the heightmap is generated from a perlin fractal noise function
        /// </summary>
        /// <returns>The noise heightmap.</returns>
        /// <param name="tData">T data.</param>
        /// <param name="worldPosition">World position.</param>
        /// <param name="octaves">Octaves.</param>
        /// <param name="noiseTileSize">Noise tile size.</param>
        /// <param name="noiseOffset">Noise offset.</param>
        /// <param name="power">Power.</param>
        /// <param name="lacunarity">Lacunarity.</param>
        /// <param name="gain">Gain.</param>
        /// <param name="ridgedNoise">If set to <c>true</c> ridged noise.</param>
        /// <param name="inverseNoise">If set to <c>true</c> inverse noise.</param>
        /// <param name="fakeErosionType">Fake erosion type.</param>
        /// <param name="warpFactor">Warp factor.</param>
        /// <param name="warpOctaves">Warp octaves.</param>
        /// <param name="curveModifier">Curve modifier.</param>
        /// <param name="heightScale">Height scale.</param>
        public static TerrainData PerlinNoiseHeightmap(TerrainData tData, Vector3 worldPosition, int octaves, float noiseTileSize, Vector2 noiseOffset, float power, float lacunarity, float gain, bool ridgedNoise, bool inverseNoise, int fakeErosionType, float warpFactor, int warpOctaves, AnimationCurve curveModifier, float heightScale)
        {
            if (tData != null)
            {
                heightmapResolution = tData.heightmapResolution;

                AnimationCurve fakeErosionCurve = LBCurve.SetCurveFromPreset(LBCurve.CurvePreset.FiveTieredTerraced);

                float[,] heightMap = tData.GetHeights(0, 0, heightmapResolution, heightmapResolution);
                // Loop through heightmap points
                for (int x = 0; x < heightmapResolution; x++)
                {
                    for (int y = 0; y < heightmapResolution; y++)
                    {
                        // Get world position of heightmap point
                        xPos = (tData.heightmapScale.x * y) + worldPosition.x - noiseOffset.x;
                        yPos = (tData.heightmapScale.z * x) + worldPosition.z - noiseOffset.y;
                        if (!Mathf.Approximately(warpFactor, 0f))
                        {
                            // Warping of noise - adds perlin fractal noise onto the world coordinates
                            Vector2 warpVector = new Vector2(LBNoise.PerlinFractalNoise(xPos / noiseTileSize, yPos / noiseTileSize, warpOctaves),
                                                             LBNoise.PerlinFractalNoise(xPos / noiseTileSize + 5.2f, yPos / noiseTileSize + 1.3f, warpOctaves));
                            xPos += warpVector.x * warpFactor * noiseTileSize;
                            yPos += warpVector.y * warpFactor * noiseTileSize;
                        }
                        // Input the position into the fractal noise function to get a value between 0 and 1
                        if (fakeErosionType != 0)
                        {
                            heightSum = LBNoise.PerlinFractalNoise(xPos / noiseTileSize, yPos / noiseTileSize, octaves, lacunarity, gain, ridgedNoise, fakeErosionCurve, fakeErosionType);
                        }
                        else
                        {
                            heightSum = LBNoise.PerlinFractalNoise(xPos / noiseTileSize, yPos / noiseTileSize, octaves, lacunarity, gain, ridgedNoise);
                        }
                        // Inverse noise inverts the noise
                        if (inverseNoise) { heightSum = 1f - heightSum; }
                        // Raise the noise to some power
                        if (!Mathf.Approximately(power, 1f)) { heightSum = Mathf.Pow(heightSum, power); }
                        // Modify the terrain based on an animation curve
                        heightSum = curveModifier.Evaluate(heightSum);
                        // Scale the noise
                        heightSum *= heightScale;
                        // Set the terrain height
                        heightMap[x, y] = heightSum;
                    }
                }
                // Set heightmap
                tData.SetHeights(0, 0, heightMap);
            }

            return tData;
        }

        /// <summary>
        /// Returns the TerrainData after the heightmap is generated from a perlin fractal noise function affected by specified curve modifiers
        /// </summary>
        /// <returns>The noise heightmap.</returns>
        /// <param name="tData">T data.</param>
        /// <param name="worldPosition">World position.</param>
        /// <param name="octaves">Octaves.</param>
        /// <param name="noiseTileSize">Noise tile size.</param>
        /// <param name="noiseOffset">Noise offset.</param>
        /// <param name="lacunarity">Lacunarity.</param>
        /// <param name="gain">Gain.</param>
        /// <param name="warpFactor">Warp factor.</param>
        /// <param name="warpOctaves">Warp octaves.</param>
        /// <param name="curveModifiers">Curve modifiers.</param>
        /// <param name="perOctaveCurveModifiers">Per octave curve modifiers.</param>
        /// <param name="heightScale">Height scale.</param>
        public static TerrainData PerlinNoiseHeightmap(TerrainData tData, Vector3 worldPosition, int octaves, float noiseTileSize, Vector2 noiseOffset, float lacunarity, float gain, float warpFactor, int warpOctaves, List<AnimationCurve> curveModifiers, List<AnimationCurve> perOctaveCurveModifiers, float heightScale)
        {
            if (tData != null)
            {
                heightmapResolution = tData.heightmapResolution;

                float[,] heightMap = tData.GetHeights(0, 0, heightmapResolution, heightmapResolution);
                // Loop through heightmap points
                for (int x = 0; x < heightmapResolution; x++)
                {
                    for (int y = 0; y < heightmapResolution; y++)
                    {
                        // Get world position of heightmap point
                        xPos = (tData.heightmapScale.x * y) + worldPosition.x - noiseOffset.x;
                        yPos = (tData.heightmapScale.z * x) + worldPosition.z - noiseOffset.y;
                        if (!Mathf.Approximately(warpFactor, 0f))
                        {
                            // Warping of noise - adds perlin fractal noise onto the world coordinates
                            Vector2 warpVector = new Vector2(LBNoise.PerlinFractalNoise(xPos / noiseTileSize, yPos / noiseTileSize, warpOctaves),
                                                             LBNoise.PerlinFractalNoise(xPos / noiseTileSize + 5.2f, yPos / noiseTileSize + 1.3f, warpOctaves));
                            xPos += warpVector.x * warpFactor * noiseTileSize;
                            yPos += warpVector.y * warpFactor * noiseTileSize;
                        }
                        // Input the position into the fractal noise function to get a value between 0 and 1
                        heightSum = LBNoise.PerlinFractalNoise(xPos / noiseTileSize, yPos / noiseTileSize, octaves, lacunarity, gain, perOctaveCurveModifiers);
                        if (curveModifiers != null)
                        {
                            // Loop through all the animation curves
                            for (int cm = 0; cm < curveModifiers.Count; cm++)
                            {
                                // Modify the terrain based on animation curves
                                heightSum = curveModifiers[cm].Evaluate(heightSum);
                            }
                        }
                        // Scale the noise
                        heightSum *= heightScale;
                        // Set the terrain height
                        heightMap[x, y] = heightSum;
                    }
                }
                // Set heightmap
                tData.SetHeights(0, 0, heightMap);
            }

            return tData;
        }

        /// <summary>
        /// Returns the TerrainData after its heightmap is generated from an image
        /// </summary>
        /// <returns>The based heightmap.</returns>
        /// <param name="tData">T data.</param>
        /// <param name="worldPosition">World position.</param>
        /// <param name="landscapeSize">Landscape size.</param>
        /// <param name="landscapePosition">Landscape position.</param>
        /// <param name="image">Image.</param>
        /// <param name="heightScale">Height scale.</param>
        /// <param name="curveModifier">Curve modifier.</param>
        /// <param name="smoothingIterations">Smoothing iterations.</param>
        public static TerrainData ImageBasedHeightmap(TerrainData tData, Vector3 worldPosition, Vector2 landscapeSize, Vector3 landscapePosition, Texture2D image, float heightScale, AnimationCurve curveModifier, int interpolationSmoothing)
        {
            if (tData != null)
            {
                if (interpolationSmoothing != 0)
                {
                    originalHeightMapResolution = tData.heightmapResolution;
                    heightmapResolution = Mathf.RoundToInt(((image.width + image.height) / 2f) * (((tData.size.x + tData.size.z) / 2f) / ((landscapeSize.x + landscapeSize.y) / 2f)) / (float)interpolationSmoothing) + 1;
                    // Heightmaps for unity terrains should be 2^x + 1
                    heightmapResolution = Mathf.ClosestPowerOfTwo(heightmapResolution) + 1;

                    tData = LBLandscapeTerrain.AdjustHeightmapResolution(tData, heightmapResolution);
                }
                else
                {
                    heightmapResolution = tData.heightmapResolution;
                }

                float[,] heightMap = tData.GetHeights(0, 0, heightmapResolution, heightmapResolution);

                if (image != null)
                {
                    // Loop through heightmap points
                    for (int x = 0; x < heightmapResolution; x++)
                    {
                        for (int y = 0; y < heightmapResolution; y++)
                        {
                            // Get local (relative to landscape) position of heightmap point
                            xPos = (tData.heightmapScale.x * y) + worldPosition.x - landscapePosition.x;
                            yPos = (tData.heightmapScale.z * x) + worldPosition.z - landscapePosition.z;
                            // Convert the position into texture coordinates
                            Vector2 texCoords = new Vector2((xPos / landscapeSize.x) * (image.width - 1), (yPos / landscapeSize.y) * (image.height - 1));
                            int xCoord = Mathf.Clamp(Mathf.RoundToInt(texCoords.x), 0, image.width - 1);
                            int yCoord = Mathf.Clamp(Mathf.RoundToInt(texCoords.y), 0, image.height - 1);
                            // Get the height from the grayscale value in the image at the given coordinates
                            heightSum = image.GetPixel(xCoord, yCoord).grayscale;
                            // Scale the heightmap
                            heightSum *= heightScale;
                            // Modify the terrain based on an animation curve
                            heightSum = curveModifier.Evaluate(heightSum);
                            // Set the terrain height
                            heightMap[x, y] = heightSum;
                        }
                    }
                    // Set heightmap
                    tData.SetHeights(0, 0, heightMap);
                }
                else
                {
                    Debug.LogError("Heightmap could not be generated because the given image is null");
                }

                if (interpolationSmoothing != 0)
                {
                    tData = LBLandscapeTerrain.AdjustHeightmapResolution(tData, originalHeightMapResolution);
                }
            }

            return tData;
        }

        public static TerrainData MaskedHeightmap(TerrainData tData, Vector3 worldPosition, Vector2 landscapeSize, Vector3 landscapePosition, int maskModeInt, AnimationCurve distToCentreMask, float maskWarpAmount, float maskNoiseTileSize, Vector2 maskNoiseOffset, AnimationCurve maskNoiseCurveModifier)
        {
            if (tData != null && maskModeInt != 0)
            {
                UnityEngine.Random.InitState(0);

                heightmapResolution = tData.heightmapResolution;

                Vector2 landscapeCentre = new Vector2(landscapePosition.x, landscapePosition.z) + (landscapeSize * 0.5f);
                float maxDistToCentre = Mathf.Sqrt((landscapeSize.x * landscapeSize.x) + (landscapeSize.y * landscapeSize.y)) * 0.5f;

                float[,] heightMap = tData.GetHeights(0, 0, heightmapResolution, heightmapResolution);
                // Loop through heightmap points
                for (int x = 0; x < heightmapResolution; x++)
                {
                    for (int y = 0; y < heightmapResolution; y++)
                    {
                        // Get world position of heightmap point
                        coords.x = (tData.heightmapScale.x * y) + worldPosition.x;
                        coords.y = (tData.heightmapScale.z * x) + worldPosition.z;
                        if (!Mathf.Approximately(maskWarpAmount, 0f))
                        {
                            // Warping of noise - adds perlin fractal noise onto the world coordinates
                            Vector2 warpVector = new Vector2(LBNoise.PerlinFractalNoise(coords.x / maskNoiseTileSize, coords.y / maskNoiseTileSize, 1),
                                                             LBNoise.PerlinFractalNoise(coords.x / maskNoiseTileSize + 5.2f, coords.y / maskNoiseTileSize + 1.3f, 1));
                            coords.x += warpVector.x * maskWarpAmount * maskNoiseTileSize;
                            coords.y += warpVector.y * maskWarpAmount * maskNoiseTileSize;
                        }

                        if (maskModeInt == 1)
                        {
                            // Distance to centre mask
                            float distToCenter = Vector2.Distance(landscapeCentre, coords) / maxDistToCentre;
                            heightSum = distToCentreMask.Evaluate(distToCenter);
                        }
                        else
                        {
                            // Noise mask
                            // Offset the noise
                            coords -= maskNoiseOffset;
                            // Get the height scaling value from perlin noise function
                            heightSum = Mathf.PerlinNoise(coords.x / maskNoiseTileSize, coords.y / maskNoiseTileSize);
                            //heightSum = LBNoise.PerlinFractalNoise(coords.x / maskNoiseTileSize, coords.y / maskNoiseTileSize, 1) * 2f;
                            // Modify the output with a curve modifier
                            heightSum = maskNoiseCurveModifier.Evaluate(heightSum);
                        }

                        // Scale the terrain height
                        heightMap[x, y] *= heightSum;
                    }
                }
                // Set heightmap
                tData.SetHeights(0, 0, heightMap);
            }

            return tData;
        }

        /// <summary>
        /// Write heighmap data from a terrain into the correct location in an image
        /// worldPosition = the world space position of the terrain
        /// </summary>
        /// <param name="tData"></param>
        /// <param name="worldPosition"></param>
        /// <param name="landscapeSize"></param>
        /// <param name="landscapePosition"></param>
        /// <param name="image"></param>
        public static void ExportImageBasedHeightmap(TerrainData tData, Vector3 worldPosition, Vector2 landscapeSize, Vector3 landscapePosition, Texture2D image, Vector2 normaliseMinMaxHeights)
        {
            string methodName = "LBLandscapeTerrain.ExportImageBasedHeightmap";

            if (tData == null) { Debug.LogWarning("ERROR: " + methodName + " Heightmap could not be generated because the terrain data is null"); }
            else if (tData.size.y < 0.01f) { Debug.LogWarning("ERROR: " + methodName + " - Heightmap could not be generated because the terrain height is invalid"); }
            else if (image == null) { Debug.LogWarning("ERROR: " + methodName + " - Heightmap could not be generated because the given image is null"); }
            else
            {
                Color pixelColour = Color.white;
                float terrainHeight = tData.size.y;
                int imageWidth = image.width;
                int imageHeight = image.height;

                // Get the normalised (0-1) bounds of this terrain within the image bounds
                float startX = ((worldPosition.x - landscapePosition.x) / landscapeSize.x);
                float endX = startX + (tData.size.x / landscapeSize.x);
                float startY = ((worldPosition.z - landscapePosition.z) / landscapeSize.y);
                float endY = startY + (tData.size.z / landscapeSize.y);

                // Convert the min/max heights from metres to 0-1 values
                float minHeightN = normaliseMinMaxHeights.x / terrainHeight;
                float maxHeightN = normaliseMinMaxHeights.y / terrainHeight;

                //Debug.Log("INFO tH: " + terrainHeight + " img w: " + imageWidth + " h: " + imageHeight + " X:" + startX +"-" + endX + " Z:" + startY + "-" + endY);

                for (int x = 0; x < imageWidth; x++)
                {
                    // Get the 0-1 x value of this pixel
                    float xDecimal = (float)x / (float)(imageWidth - 1);
                    // If this pixel is within the x bounds of this terrain...
                    if (xDecimal >= startX && xDecimal <= endX)
                    {
                        for (int y = 0; y < imageHeight; y++)
                        {
                            // Get the 0-1 y value of this pixel
                            float yDecimal = (float)y / (float)(imageHeight - 1);
                            // If this pixel is within the y bounds of this terrain...
                            if (yDecimal >= startY && yDecimal <= endY)
                            {
                                // Get the normalised (0-1) position of the pixel in relation to the terrain
                                float xDecimal2 = (xDecimal - startX) / (endX - startX);
                                float yDecimal2 = (yDecimal - startY) / (endY - startY);
                                // Get the height at that point on the terrain (0-1)
                                heightSum = tData.GetInterpolatedHeight(xDecimal2, yDecimal2) / terrainHeight;

                                // Set the pixel colour - normalise if required
                                if (maxHeightN > 0f && maxHeightN > minHeightN)
                                {
                                    pixelColour = Color.white * ((heightSum - minHeightN) * (1f / (maxHeightN - minHeightN)));
                                }
                                else
                                {
                                    pixelColour = Color.white * heightSum;
                                }
                                pixelColour.a = 1f;
                                image.SetPixel(x, y, pixelColour);
                            }
                        }
                    }
                }

                // This is pretty slow, and therefore needs to be done only when necessary
                // i.e. not within a tight loop
                image.Apply();
            }
        }

        /// <summary>
        /// Export a single heightmap image for the terrain. This is different from ExportImageBasedHeightmap which is used for
        /// a landscape-wide heightmap image.
        /// The formula used here is based on one supplied by the RTP author for use with creating the Tessellation heightmaps
        /// required for Relief Terrain Pack. See LBIntegration.RTPEnable() for more information.
        /// </summary>
        /// <param name="tData"></param>
        /// <param name="showErrors"></param>
        /// <returns></returns>
        public static Texture2D ExportImageBasedHeightmapSingleTerrain(TerrainData tData, bool showErrors)
        {
            Texture2D texture = null;

            if (tData == null)
            {
                if (showErrors) { Debug.Log("LBLandscapeTerrain.ExportImageBasedHeightmapSingleTerrain - terraindata cannot be null"); }
            }
            else
            {
                texture = new Texture2D(tData.heightmapResolution - 1, tData.heightmapResolution - 1, TextureFormat.RGBA32, false, true);
                if (texture == null) { Debug.Log("LBLandscapeTerrain.ExportImageBasedHeightmapSingleTerrain - could not create new texture"); }
                else
                {
                    float height = 0f;
                    int hiPixel, lowPixel;
                    int normalX, normalZ;
                    Vector3 norm = Vector3.zero;

                    Color32[] pixels = new Color32[texture.width * texture.height];
                    for (int x = 0; x < texture.width; x++)
                    {
                        for (int y = 0; y < texture.height; y++)
                        {
                            xPos = 1.0f * x / (texture.width - 1);
                            yPos = 1.0f * y / (texture.height - 1);

                            height = tData.GetInterpolatedHeight(xPos, yPos) / tData.size.y;
                            hiPixel = Mathf.FloorToInt(height * 255.0f);
                            lowPixel = Mathf.FloorToInt((height * 255.0f - hiPixel) * 255.0f);

                            norm = tData.GetInterpolatedNormal(xPos, yPos);
                            normalX = Mathf.RoundToInt(Mathf.Clamp01(norm.x * 0.5f + 0.5f) * 255.0f);
                            normalZ = Mathf.RoundToInt(Mathf.Clamp01(norm.z * 0.5f + 0.5f) * 255.0f);
                            pixels[y * texture.width + x] = new Color32((byte)hiPixel, (byte)lowPixel, (byte)normalX, (byte)normalZ);
                        }
                    }
                    texture.SetPixels32(pixels);
                    texture.Apply(false, false);
                }
            }

            return texture;
        }

        /// <summary>
        /// Returns the TerrainData after its heightmap is modified by a crater modifier
        /// </summary>
        /// <returns>The modifier.</returns>
        /// <param name="tData">T data.</param>
        /// <param name="heightDelta">Height delta.</param>
        /// <param name="inverse">If set to <c>true</c> inverse.</param>
        /// <param name="worldPosition">World position.</param>
        /// <param name="selectionRect">Selection rect.</param>
        /// <param name="blendEdges">If set to <c>true</c> blend edges.</param>
        public static TerrainData CraterModifier(TerrainData tData, float heightDelta, bool inverse, Vector3 worldPosition, Rect selectionRect, bool blendEdges)
        {
            if (tData != null)
            {
                float terrainWidth = tData.size.x;

                Rect terrainRect = Rect.MinMaxRect(worldPosition.x, worldPosition.z, worldPosition.x + terrainWidth, worldPosition.z + terrainWidth);

                // Only do anything if this terrain is part of the highlighted area
                if (selectionRect.Overlaps(terrainRect))
                {
                    heightmapResolution = tData.heightmapResolution;

                    float[,] heightMap = tData.GetHeights(0, 0, heightmapResolution, heightmapResolution);

                    // Loop through heightmap points
                    for (int x = 0; x < heightmapResolution; x++)
                    {
                        for (int y = 0; y < heightmapResolution; y++)
                        {
                            // Find the world-space coordinates of this terrain position
                            xPos = (tData.heightmapScale.x * y) + worldPosition.x;
                            yPos = (tData.heightmapScale.z * x) + worldPosition.z;
                            coords = new Vector2(xPos, yPos);
                            // Do something if the coordinates are within the highlighted area
                            if (selectionRect.Contains(coords))
                            {
                                float blendFactor = 0f;
                                if (blendEdges)
                                {
                                    // Blend out anything more than halfway between the centre and the outside of the higlighted area
                                    float distToCenter = Vector2.Distance(coords, selectionRect.center);
                                    blendFactor = (Mathf.Clamp(distToCenter / (selectionRect.width * 0.5f), 0.5f, 1f) - 0.5f) * 2f;
                                    blendFactor = 1f - blendFactor;
                                }
                                // Calculate the heightmap based on a sine curve
                                if (inverse) { heightMap[x, y] += Mathf.Sin(blendFactor * 2f / Mathf.PI) * heightDelta; }
                                else { heightMap[x, y] -= Mathf.Sin(blendFactor * 2f / Mathf.PI) * heightDelta; }
                            }
                        }
                    }

                    // Set heightmap
                    tData.SetHeights(0, 0, heightMap);
                }
            }

            return tData;
        }

        /// <summary>
        /// Returns the TerrainData after its heightmap is modified by a noise modifier
        /// </summary>
        /// <returns>The modifier.</returns>
        /// <param name="tData">T data.</param>
        /// <param name="octaves">Octaves.</param>
        /// <param name="noiseTileSize">Noise tile size.</param>
        /// <param name="ridgedNoise">If set to <c>true</c> ridged noise.</param>
        /// <param name="heightScale">Height scale.</param>
        /// <param name="worldPosition">World position.</param>
        /// <param name="selectionRect">Selection rect.</param>
        /// <param name="blendEdges">If set to <c>true</c> blend edges.</param>
        public static TerrainData NoiseModifier(TerrainData tData, int octaves, float noiseTileSize, bool ridgedNoise, float heightScale, Vector3 worldPosition, Rect selectionRect, bool blendEdges)
        {
            if (tData != null)
            {
                float terrainWidth = tData.size.x;

                Rect terrainRect = Rect.MinMaxRect(worldPosition.x, worldPosition.z, worldPosition.x + terrainWidth, worldPosition.z + terrainWidth);

                // Only do anything if this terrain is part of the highlighted area
                if (selectionRect.Overlaps(terrainRect))
                {
                    heightmapResolution = tData.heightmapResolution;

                    float[,] heightMap = tData.GetHeights(0, 0, heightmapResolution, heightmapResolution);

                    // Loop through heightmap points
                    for (int x = 0; x < heightmapResolution; x++)
                    {
                        for (int y = 0; y < heightmapResolution; y++)
                        {
                            // Find the world-space coordinates of this terrain position
                            xPos = (tData.heightmapScale.x * y) + worldPosition.x;
                            yPos = (tData.heightmapScale.z * x) + worldPosition.z;
                            coords = new Vector2(xPos, yPos);
                            // Do something if the coordinates are within the highlighted area
                            if (selectionRect.Contains(coords))
                            {
                                float blendFactor = 0f;
                                if (blendEdges)
                                {
                                    // Blend out anything more than halfway between the centre and the outside of the higlighted area
                                    float distToCenter = Vector2.Distance(coords, selectionRect.center);
                                    blendFactor = (Mathf.Clamp(distToCenter / (selectionRect.width * 0.5f), 0.5f, 1f) - 0.5f) * 2f;
                                }
                                // Input the position into the fractal noise function to get a value between 0 and 1
                                heightSum = LBNoise.PerlinFractalNoise(xPos / noiseTileSize, yPos / noiseTileSize, octaves, 2f, 0.5f, ridgedNoise);
                                // Scale the noise vertically
                                heightSum *= heightScale;
                                // Adjust the noise range
                                heightSum -= heightScale * 0.5f;
                                // Add the generated noise to the heightmap
                                heightMap[x, y] += heightSum * (1f - blendFactor);
                            }
                        }
                    }

                    // Set heightmap
                    tData.SetHeights(0, 0, heightMap);
                }
            }

            return tData;
        }

        /// <summary>
        /// Returns the TerrainData after its heightmap is modified by an erosion modifier
        /// </summary>
        /// <returns>The modifier.</returns>
        /// <param name="tData">T data.</param>
        /// <param name="terrainDurability">Terrain Durability.</param>
        /// <param name="rainfall">Rainfall.</param>
        /// <param name="worldPosition">World position.</param>
        /// <param name="selectionRect">Selection rect.</param>
        /// <param name="blendEdges">If set to <c>true</c> blend edges.</param>
        public static TerrainData ErosionModifier(TerrainData tData, float rainfall, float erosion, float deposition, float flattening, Vector3 worldPosition, Rect selectionRect, bool blendEdges)
        {
            if (tData != null)
            {
                float terrainWidth = tData.size.x;
                float terrainHeight = tData.size.y;

                //float blendRate = 1.0f;

                // Declare variables outside the loop to improve performance
                float erosionMultiplier = 0f, blendFactor = 0f, distToCenter = 0f;

                Rect terrainRect = Rect.MinMaxRect(worldPosition.x, worldPosition.z, worldPosition.x + terrainWidth, worldPosition.z + terrainWidth);

                // Only do anything if this terrain is part of the highlighted area
                if (selectionRect.Overlaps(terrainRect))
                {
                    heightmapResolution = tData.heightmapResolution;

                    float[,] heightMap = tData.GetHeights(0, 0, heightmapResolution, heightmapResolution);

                    // Loop through heightmap points
                    for (int x = 0; x < heightmapResolution; x++)
                    {
                        for (int y = 0; y < heightmapResolution; y++)
                        {
                            // Find the world-space coordinates of this terrain position
                            xPos = (tData.heightmapScale.x * y) + worldPosition.x;
                            yPos = (tData.heightmapScale.z * x) + worldPosition.z;
                            coords = new Vector2(xPos, yPos);
                            // Do something if the coordinates are within the highlighted area
                            if (selectionRect.Contains(coords))
                            {
                                blendFactor = 0f;
                                if (blendEdges)
                                {
                                    // Blend out anything more than halfway between the centre and the outside of the higlighted area
                                    distToCenter = Vector2.Distance(coords, selectionRect.center);
                                    blendFactor = (Mathf.Clamp(distToCenter / (selectionRect.width * 0.5f), 0.5f, 1f) - 0.5f) * 2f;

                                    // Adjust blend distance between halfway to centre and outer edge
                                    //blendFactor = Mathf.Clamp01(blendFactor / blendRate);
                                }

                                // Get the normalised (0-1) position of this point in the terrain
                                xPos = (xPos - worldPosition.x) / terrainWidth;
                                yPos = (yPos - worldPosition.z) / terrainWidth;

                                angle = (tData.GetSteepness(xPos, yPos) / 90f);
                                height = tData.GetInterpolatedHeight(xPos, yPos) / terrainHeight;
                                angle = (LBLandscapeTerrain.SignedPow((angle * 2f) - 1f, 3f) * 0.1f) + 0.5f;
                                height = (LBLandscapeTerrain.SignedPow((height * 2f) - 1f, flattening) * 0.5f) + 0.5f;
                                //height = (Mathf.Pow((height * 2f) - 1f, 3f) * 0.5f) + 0.5f;

                                angle = 0.5f;

                                erosionMultiplier = 0f;
                                // if (x != 0 && x != heightmapResolution - 1 && y != 0 && y != heightmapResolution - 1)
                                // {
                                //     erosionMultiplier = (angle * height) - 0.5f;
                                // }
                                // else { erosionMultiplier = (0.5f * height) - 0.5f; }
                                erosionMultiplier = (angle * height) - 0.25f;
                                if (erosionMultiplier > 0f) { erosionMultiplier *= erosion; }
                                else { erosionMultiplier *= deposition; }

                                heightSum = -erosionMultiplier * rainfall;

                                // Add the generated erosion to the heightmap
                                heightMap[x, y] += heightSum * (1f - blendFactor);
                            }
                        }
                    }

                    // Set heightmap
                    tData.SetHeights(0, 0, heightMap);
                }
            }

            return tData;
        }

        private static float SignedPow(float num, float pow)
        {
            float signedPow = Mathf.Pow(num, pow);
            if (Mathf.Sign(signedPow) != Mathf.Sign(num)) { signedPow *= -1f; }
            return signedPow;
        }

        /// <summary>
        /// Returns the TerrainData after its heightmap is modified by a flatten modifier within a selected rectangle
        /// </summary>
        /// <returns>The modifier.</returns>
        /// <param name="tData">T data.</param>
        /// <param name="flattenHeight">Height.</param>
        /// <param name="worldPosition">World position.</param>
        /// <param name="selectionRect">Selection rect.</param>
        /// <param name="blendEdges">If set to <c>true</c> blend edges.</param>
        public static TerrainData FlattenModifier(TerrainData tData, float flattenHeight, Vector3 worldPosition, Rect selectionRect, bool blendEdges, float blendRate)
        {
            if (tData != null)
            {
                float terrainWidth = tData.size.x;

                Rect terrainRect = Rect.MinMaxRect(worldPosition.x, worldPosition.z, worldPosition.x + terrainWidth, worldPosition.z + terrainWidth);

                // Only do anything if this terrain is part of the highlighted area
                if (selectionRect.Overlaps(terrainRect))
                {
                    heightmapResolution = tData.heightmapResolution;

                    float[,] heightMap = tData.GetHeights(0, 0, heightmapResolution, heightmapResolution);

                    // Loop through heightmap points
                    for (int x = 0; x < heightmapResolution; x++)
                    {
                        for (int y = 0; y < heightmapResolution; y++)
                        {
                            // Find the world-space coordinates of this terrain position
                            xPos = (tData.heightmapScale.x * y) + worldPosition.x;
                            yPos = (tData.heightmapScale.z * x) + worldPosition.z;
                            coords = new Vector2(xPos, yPos);
                            // Do something if the coordinates are within the highlighted area
                            if (selectionRect.Contains(coords))
                            {
                                float blendFactor = 0f;
                                if (blendEdges)
                                {
                                    // Blend out anything more than halfway between the centre and the outside of the higlighted area
                                    float distToCenter = Vector2.Distance(coords, selectionRect.center);
                                    blendFactor = (Mathf.Clamp(distToCenter / (selectionRect.width * 0.5f), 0.5f, 1f) - 0.5f) * 2f;
                                    // Adjust blend distance between halfway to centre and outer edge
                                    blendFactor = Mathf.Clamp01(blendFactor / blendRate);
                                }
                                // Calculate the heightmap based on the height variable
                                heightMap[x, y] = (heightMap[x, y] * blendFactor) + (flattenHeight * (1f - blendFactor));
                            }
                        }
                    }

                    // Set heightmap
                    tData.SetHeightsDelayLOD(0, 0, heightMap);
                }
            }
            return tData;
        }

        /// <summary>
        /// Given a list of positions and rectangles within a landscape, flatten the heightmap in these locations. Blend the edges with
        /// the surrounding heighmap. In 2.0.4 changed blendRate to flattenBlendRateList
        /// </summary>
        /// <param name="landscape"></param>
        /// <param name="flattenPosList"></param>
        /// <param name="flattenRectList"></param>
        /// <param name="flattenBlendRateList"></param>
        /// <param name="showProgressDelegate"></param>
        /// <param name="progressMsg"></param>
        /// <param name="showErrors"></param>
        public static void FlattenModifier(LBLandscape landscape, List<Vector3> flattenPosList, List<Rect> flattenRectList, List<float> flattenBlendRateList,
                                           LBLandscape.ShowProgressDelegate showProgressDelegate, string progressMsg, bool showErrors)
        {
            // Initialise variables
            string methodName = "LBLandscapeTerrain.FlattenModifier";
            int numPositions = (flattenPosList == null ? 0 : flattenPosList.Count);
            int numRects = (flattenRectList == null ? 0 : flattenRectList.Count);
            int numBlendRates = (flattenBlendRateList == null ? 0 : flattenBlendRateList.Count);

            // Do some basic validation
            if (landscape == null) { if (showErrors) { Debug.LogWarning("ERROR " + methodName + " - landscape cannot be null. Please Report."); } }
            else if (flattenPosList == null) { if (showErrors) { Debug.LogWarning("ERROR " + methodName + " - flattenPosList cannot be null. Please Report."); } }
            else if (flattenRectList == null) { if (showErrors) { Debug.LogWarning("ERROR " + methodName + " - flattenRectList cannot be null. Please Report."); } }
            else if (flattenBlendRateList == null) { if (showErrors) { Debug.LogWarning("ERROR " + methodName + " - flattenBlendRateList cannot be null. Please Report."); } }
            else if (numPositions != numRects || numRects != numBlendRates) { if (showErrors) { Debug.LogWarning("ERROR " + methodName + " - flattenRectList and flattenPosList and flattenBlendRateList count mismatch. Please Report."); } }
            else
            {
                bool showProgress = (showProgressDelegate != null);
                bool isIncludeInnerEdges = false;
                float progress = 0f;
                float lastProgressUpdateTime = 0f;
                Vector3 flattenPos = Vector3.zero;
                Vector2 worldPos2D = Vector2.zero;
                int posIdx = 0, hmapIdx = 0, x = 0;

                int landscapeHeightsSize = landscape.GetTotalHeightmapSize(isIncludeInnerEdges);
                int heightmapResolution = (int)Mathf.Sqrt(landscapeHeightsSize);

                // It is approx 1% faster to use local variables that to reference
                // the landscape class for every iteration of the heightmap
                float landscapeMinX = landscape.start.x;
                float landscapeMinZ = landscape.start.z;

                // Rect local variables - used for more optimal performance
                float xMinRect = 0f, xMaxRect = 0f, yMinRect = 0f, yMaxRect = 0f;
                float blendFactor = 0f, blendRateAdjusted = 0f;
                Vector2 centreRect = Vector2.zero;
                float distToCenter = 0f;

                // Force garbage collection so we have largest blocks of memory possible
                System.GC.Collect();

                // Create the array from a contiguous block of space in memory
                float[] landscapeHeightmap = new float[landscapeHeightsSize];

                float[] smallerLandscapeHeightmap = new float[0];

                if (!GetLandscapeScopedHeightmap(landscape, landscapeHeightmap, isIncludeInnerEdges, showErrors)) { if (showErrors) { Debug.LogWarning("ERROR " + methodName + " - could not populate landscape-scoped heightmap array"); } }
                else
                {
                    for (posIdx = 0; posIdx < numPositions; posIdx++)
                    {
                        flattenPos = flattenPosList[posIdx];
                        Rect flattenRect = flattenRectList[posIdx];

                        // Block copy each row of the rect within the heightmap array into a temp array
                        int smallerHeightmapResolution = 2;
                        GetSmallerLandscapeScopedHeightmap(landscape, landscapeHeightmap, heightmapResolution, ref smallerLandscapeHeightmap, ref smallerHeightmapResolution, flattenRect, showErrors);
                        float smallerHeightmapResolutionLess1 = smallerHeightmapResolution - 1;
                        int smallerLandscapeHeightsSize = smallerLandscapeHeightmap.Length;

                        xMinRect = flattenRect.xMin;
                        xMaxRect = flattenRect.xMax;
                        yMinRect = flattenRect.yMin;
                        yMaxRect = flattenRect.yMax;
                        centreRect = flattenRect.center;

                        // Get the size and position of this block
                        float blockWidth = xMaxRect - xMinRect;
                        float blockLength = yMaxRect - yMinRect;
                        // Clamp is used to adjust for shifiting the position of the array to within bounds of landscape
                        float blockMinX = Mathf.Clamp(xMinRect, landscapeMinX, landscapeMinX + landscape.size.x - blockWidth);
                        float blockMinZ = Mathf.Clamp(yMinRect, landscapeMinZ, landscapeMinZ + landscape.size.y - blockLength);

                        blendRateAdjusted = flattenRect.width * (1f - flattenBlendRateList[posIdx]) * 0.5f;

                        // Loop through heightmap points
                        for (hmapIdx = 0; hmapIdx < smallerLandscapeHeightsSize; hmapIdx++)
                        {
                            // NOTE: Leave these commented out calcs to make worldPos2D calc more readable.
                            // Get x and y coordinates from heightmap array index
                            x = hmapIdx % smallerHeightmapResolution;
                            //z = (hmapIdx - x) / smallerHeightmapResolution;

                            // Get the normalised position in the landscape
                            //xPosN = (float)x / (float)(smallerHeightmapResolution - 1);
                            //zPosN = (float)z / (float)(smallerHeightmapResolution - 1);

                            // Find the world-space coordinates of this landscape position
                            //worldPos2D.x = (xPosN * blockWidth) + blockMinX;
                            //worldPos2D.y = (zPosN * blockLength) + blockMinZ;

                            // Consolidate above 3 sets of calculations into single set for a 18% performance boost.
                            worldPos2D.x = (((float)x / smallerHeightmapResolutionLess1) * blockWidth) + blockMinX;
                            worldPos2D.y = (((float)((int)((hmapIdx - x) / smallerHeightmapResolution)) / smallerHeightmapResolutionLess1) * blockLength) + blockMinZ;

                            // Do something if the coordinates are within the flatten area

                            // There is 70% overhead in comparing worldPos with flattenRect
                            // flattenRect.Contains() is 50% slower than comparing with Rect.xMin, xMax etc.
                            // Using xMinRect.. local variables is 18% faster than using Rect.xMin... etc.
                            if (worldPos2D.x >= xMinRect && worldPos2D.x <= xMaxRect &&
                                worldPos2D.y >= yMinRect && worldPos2D.y <= yMaxRect)
                            {
                                // Blend out anything more than halfway between the centre and the outside of the higlighted area
                                distToCenter = Vector2.Distance(worldPos2D, centreRect);

                                blendFactor = Mathf.Clamp01((distToCenter - blendRateAdjusted) / ((flattenRect.width / 2f) - blendRateAdjusted));

                                // Calculate the heightmap based on the height variable
                                smallerLandscapeHeightmap[hmapIdx] = (smallerLandscapeHeightmap[hmapIdx] * blendFactor) + (flattenPos.y * (1f - blendFactor));
                            }
                        }

                        // Block copy each row of the temp array back to the heightmap array
                        CommitSmallerLandscapeScopedHeightmap(landscape, landscapeHeightmap, heightmapResolution, smallerLandscapeHeightmap, smallerHeightmapResolution, flattenRect, showErrors);

                        #region Progress
                        // Only update progress bar every fixed amount of time
                        if (showProgress && Time.realtimeSinceStartup > lastProgressUpdateTime + 2.00f)
                        {
                            // Call back to update the progress bar
                            progress = (float)posIdx / (float)numPositions;
                            lastProgressUpdateTime = Time.realtimeSinceStartup;
                            showProgressDelegate("Populating Landscape With Groups - Flatten", progressMsg + ": " + posIdx + " of " + numPositions, progress);
                        }
                        #endregion
                    }

                    #region Copy heightmap data back to terrains
                    // After data is processed, copy back from array to terrain heightmaps and free memory
                    CommitLandscapeScopedHeightmap(landscape, landscapeHeightmap, isIncludeInnerEdges, showErrors);
                    #endregion
                }
            }
        }

        /// <summary>
        /// Returns the TerrainData after its heightmap is modified by a topography modifier
        /// </summary>
        /// <param name="tData"></param>
        /// <param name="modifierMode"></param>
        /// <param name="worldPosition"></param>
        /// <param name="octaves"></param>
        /// <param name="noiseTileSize"></param>
        /// <param name="noiseOffset"></param>
        /// <param name="power"></param>
        /// <param name="lacunarity"></param>
        /// <param name="gain"></param>
        /// <param name="ridgedNoise"></param>
        /// <param name="inverseNoise"></param>
        /// <param name="warpFactor"></param>
        /// <param name="warpOctaves"></param>
        /// <param name="curveModifier"></param>
        /// <param name="heightScale"></param>
        /// <param name="selectionRect"></param>
        /// <param name="blendEdges"></param>
        /// <param name="blendEdgesRate"></param>
        /// <returns></returns>
        public static TerrainData TopographyModifier(TerrainData tData, int modifierMode, Vector3 worldPosition, int octaves, float noiseTileSize, Vector3 noiseOffset,
                                                      float power, float lacunarity, float gain, bool ridgedNoise, bool inverseNoise, float warpFactor, int warpOctaves,
                                                      AnimationCurve curveModifier, float heightScale, Rect selectionRect, bool blendEdges, float blendEdgesRate)
        {
            if (tData != null)
            {
                float terrainWidth = tData.size.x;

                Rect terrainRect = Rect.MinMaxRect(worldPosition.x, worldPosition.z, worldPosition.x + terrainWidth, worldPosition.z + terrainWidth);

                // Only do anything if this terrain is part of the highlighted area
                if (selectionRect.Overlaps(terrainRect))
                {
                    heightmapResolution = tData.heightmapResolution;

                    float[,] heightMap = tData.GetHeights(0, 0, heightmapResolution, heightmapResolution);

                    // Loop through heightmap points
                    for (int x = 0; x < heightmapResolution; x++)
                    {
                        for (int y = 0; y < heightmapResolution; y++)
                        {
                            // Find the world-space coordinates of this terrain position
                            xPos = (tData.heightmapScale.x * y) + worldPosition.x;
                            yPos = (tData.heightmapScale.z * x) + worldPosition.z;
                            coords = new Vector2(xPos, yPos);
                            // Do something if the coordinates are within the highlighted area
                            if (selectionRect.Contains(coords))
                            {
                                float blendFactor = 0f;
                                if (blendEdges)
                                {
                                    // Blend out anything more than halfway between the centre and the outside of the highlighted area
                                    float distToCenter = Vector2.Distance(coords, selectionRect.center);
                                    blendFactor = (Mathf.Clamp(distToCenter / (selectionRect.width * 0.5f), 0.5f, 1f) - 0.5f) * 2f;
                                    // Adjust blend distance between halfway to centre and outer edge
                                    blendFactor = Mathf.Clamp01(blendFactor / blendEdgesRate);
                                }

                                // Get world position of heightmap point
                                xPos = (tData.heightmapScale.x * y) + worldPosition.x - noiseOffset.x;
                                yPos = (tData.heightmapScale.z * x) + worldPosition.z - noiseOffset.z;
                                if (!Mathf.Approximately(warpFactor, 0f))
                                {
                                    // Warping of noise - adds perlin fractal noise onto the world coordinates
                                    Vector2 warpVector = new Vector2(LBNoise.PerlinFractalNoise(xPos / noiseTileSize, yPos / noiseTileSize, warpOctaves),
                                                                     LBNoise.PerlinFractalNoise(xPos / noiseTileSize + 5.2f, yPos / noiseTileSize + 1.3f, warpOctaves));
                                    xPos += warpVector.x * warpFactor * noiseTileSize;
                                    yPos += warpVector.y * warpFactor * noiseTileSize;
                                }
                                // Input the position into the fractal noise function to get a value between 0 and 1
                                heightSum = LBNoise.PerlinFractalNoise(xPos / noiseTileSize, yPos / noiseTileSize, octaves, lacunarity, gain, ridgedNoise);
                                // Raise the noise to some power
                                if (!Mathf.Approximately(power, 1f)) { heightSum = Mathf.Pow(heightSum, power); }
                                // Inverse noise inverts the noise
                                if (inverseNoise) { heightSum = 1f - heightSum; }
                                // Modify the terrain based on an animation curve
                                heightSum = curveModifier.Evaluate(heightSum);
                                // Scale the noise
                                heightSum *= heightScale;

                                if (modifierMode == 0)
                                {
                                    // Topography Modifier Mode: Add
                                    // Get the height from the perlin noise output added on to the old heightmap value
                                    heightSum = heightMap[x, y] + heightSum;
                                }
                                else if (modifierMode == 1)
                                {
                                    // Topography Modifier Mode: Subtract
                                    // Get the height from the perlin noise output subtracted from the old heightmap value
                                    heightSum = heightMap[x, y] - heightSum;
                                }
                                else if (modifierMode == 2)
                                {
                                    // Topography Modifier Mode: Multiply
                                    // Get the height from the perlin noise output multiplied by the old heightmap value
                                    heightSum = heightMap[x, y] * heightSum;
                                }
                                // Else: Topography Modifier Mode: Set
                                // Get the height from the perlin noise ouput - so don't do anything

                                heightSum += noiseOffset.y;

                                heightMap[x, y] = (heightMap[x, y] * blendFactor) + (heightSum * (1f - blendFactor));
                            }
                        }
                    }

                    // Set heightmap
                    tData.SetHeights(0, 0, heightMap);
                }
            }

            return tData;
        }

        /// <summary>
        /// Returns the TerrainData after its heightmap is modified by an image modifier
        /// </summary>
        /// <param name="tData"></param>
        /// <param name="image"></param>
        /// <param name="modifierMode"></param>
        /// <param name="curveModifier"></param>
        /// <param name="heightScale"></param>
        /// <param name="worldPosition"></param>
        /// <param name="selectionRect"></param>
        /// <param name="blendEdges"></param>
        /// <param name="lbModifierImage"></param>
        /// <returns></returns>
        public static TerrainData ImageModifier(TerrainData tData, Texture2D image, int modifierMode, AnimationCurve curveModifier, float heightScale,
                                                 Vector3 worldPosition, Rect selectionRect, bool blendEdges, LBModifierImage lbModifierImage)
        {
            if (tData != null)
            {
                // Create floats outside to loops to improve performance
                float grayscale = 0f, blendFactor = 0f, noiseHeightSum = 0f, heightTarget = 0f, lerpGradiant = 0f, blendMax = 0f;

                // All terrains in LB are square, so terrain Length is always the same as Width
                float terrainWidth = tData.size.x;

                Rect terrainRect = Rect.MinMaxRect(worldPosition.x, worldPosition.z, worldPosition.x + terrainWidth, worldPosition.z + terrainWidth);

                // Only do anything if this terrain is part of the highlighted area
                if (selectionRect.Overlaps(terrainRect))
                {
                    heightmapResolution = tData.heightmapResolution;

                    float[,] heightMap = tData.GetHeights(0, 0, heightmapResolution, heightmapResolution);

                    // Loop through heightmap points
                    for (int x = 0; x < heightmapResolution; x++)
                    {
                        for (int y = 0; y < heightmapResolution; y++)
                        {
                            // Find the world-space coordinates of this terrain position
                            xPos = (tData.heightmapScale.x * y) + worldPosition.x;
                            yPos = (tData.heightmapScale.z * x) + worldPosition.z;
                            coords = new Vector2(xPos, yPos);
                            // Do something if the coordinates are within the highlighted area
                            if (selectionRect.Contains(coords))
                            {
                                blendFactor = 0f;
                                if (blendEdges)
                                {
                                    // Blend out anything more than halfway between the centre and the outside of the higlighted area
                                    float distToCenter = Vector2.Distance(coords, selectionRect.center);
                                    blendFactor = (Mathf.Clamp(distToCenter / (selectionRect.width * 0.5f), 0.5f, 1f) - 0.5f) * 2f;

                                    if (lbModifierImage != null)
                                    {
                                        // Adjust blend distance between halfway to centre and outer edge
                                        blendFactor = Mathf.Clamp01(blendFactor / lbModifierImage.blendRate);
                                    }
                                }
                                // Get local (relative to selection rect) position of heightmap point
                                xPos = (tData.heightmapScale.x * y) + worldPosition.x - selectionRect.xMin;
                                yPos = (tData.heightmapScale.z * x) + worldPosition.z - selectionRect.yMin;
                                // Convert the position into texture coordinates
                                Vector2 texCoords = new Vector2((xPos / selectionRect.width) * image.width, (yPos / selectionRect.height) * image.height);
                                int xCoord = Mathf.Clamp(Mathf.RoundToInt(texCoords.x), 0, image.width - 1);
                                int yCoord = Mathf.Clamp(Mathf.RoundToInt(texCoords.y), 0, image.height - 1);

                                // Get the grayscale value (0-1) of the colour at the given coordinates
                                grayscale = image.GetPixel(xCoord, yCoord).grayscale;

                                // Determine how much, if any, noise should be applied to the heightmap
                                noiseHeightSum = 0f;
                                if (lbModifierImage != null)
                                {
                                    if (lbModifierImage.useNoise)
                                    {
                                        // Input the position into the fractal noise function to get a value between 0 and 1
                                        noiseHeightSum = LBNoise.PerlinFractalNoise(xPos / lbModifierImage.noiseTileSize, yPos / lbModifierImage.noiseTileSize, lbModifierImage.noiseOctaves, 2f, 0.5f, lbModifierImage.noiseRidged);
                                        // Scale the noise vertically
                                        noiseHeightSum *= lbModifierImage.noiseHeightScale;
                                        // Adjust the noise range
                                        noiseHeightSum -= lbModifierImage.noiseHeightScale * 0.5f;
                                    }
                                }

                                if (modifierMode == 0)
                                {
                                    // Image Modifier Mode: Add
                                    // Get the height from the grayscale value in the image at the given coordinates
                                    heightSum = (grayscale * heightScale) + noiseHeightSum;

                                    // Modify the terrain based on the animation curve, taking into consideration heightScale
                                    // and the maximum grayscale value of the image
                                    heightSum = curveModifier.Evaluate(heightSum / (heightScale * lbModifierImage.ImageGrayscaleMinMax.y))
                                     * heightScale * lbModifierImage.ImageGrayscaleMinMax.y;

                                    // Add on to the old heightmap value
                                    heightSum = heightMap[x, y] + heightSum;

                                    //heightSum = heightMap[x,y] + (grayscale * heightScale) + noiseHeightSum;
                                }
                                else if (modifierMode == 1)
                                {
                                    // Image Modifier Mode: Subtract
                                    // Get the height from the grayscale value in the image at the given coordinates 
                                    // subtracted from the old heightmap value
                                    heightSum = heightMap[x, y] - (grayscale * heightScale) + noiseHeightSum;
                                }
                                else if (modifierMode == 2)
                                {
                                    // Image Modifier Mode: Multiply
                                    // Get the height from the grayscale value in the image at the given coordinates 
                                    // multiplied by the old heightmap value
                                    heightSum = (heightMap[x, y] * (grayscale * heightScale)) + noiseHeightSum;
                                }
                                else if (modifierMode == 3)
                                {
                                    // Image Modifier Mode: Set
                                    // Get the height from the grayscale value in the image at the given coordinates
                                    heightSum = (grayscale * heightScale) + noiseHeightSum;
                                }
                                else if (modifierMode == 4)
                                {
                                    if (lbModifierImage == null)
                                    {
                                        Debug.LogError("LBLandscapeTerrain ImageModifier: LBModifierLandform parameter is not defined");
                                    }
                                    else
                                    {
                                        // Image Modifier Mode: Landform Set
                                        // This takes into consideration the existing height of the terrain but ignores the inclination
                                        if (grayscale > 0.001f)  // Ignore black background
                                        {
                                            heightSum = (grayscale * heightScale) + noiseHeightSum;

                                            // Modify the terrain based on the animation curve
                                            //heightSum = curveModifier.Evaluate(heightSum);

                                            heightSum = curveModifier.Evaluate(heightSum / (heightScale * lbModifierImage.ImageGrayscaleMinMax.y))
                                                                                * heightScale * lbModifierImage.ImageGrayscaleMinMax.y;


                                            if (lbModifierImage.modifierLandformCategory == LBModifierOperations.ModifierLandformCategory.Valleys ||
                                                lbModifierImage.modifierLandformCategory == LBModifierOperations.ModifierLandformCategory.Lakes)
                                            {
                                                heightSum *= -1;
                                            }

                                            heightTarget = heightSum + lbModifierImage.heightOffset; // Target

                                            // In images that ignore the inclination of the terrain, there is a significant step-up between
                                            // the edge of the non-black portions of the image and the terrain. To overcome this, a minimum
                                            // amount of blend must be applied (even when Blend Edges is off). A good blendRate is 0.2
                                            blendMax = lbModifierImage.ImageGrayscaleMinMax.x + (lbModifierImage.imageGrayscaleRange * lbModifierImage.blendRate);

                                            if (grayscale <= blendMax)
                                            {
                                                // Normalise grayscale based on the lower edges of the heightmap image modifer
                                                lerpGradiant = (grayscale - lbModifierImage.ImageGrayscaleMinMax.x) / (blendMax - lbModifierImage.ImageGrayscaleMinMax.x);
                                                heightSum = Mathf.Lerp(heightMap[x, y], heightTarget, lerpGradiant);

                                                heightMap[x, y] = Mathf.Clamp01(heightSum);
                                            }
                                            else
                                            {
                                                // Set the height from the modifier (no need for blending)
                                                // This also assumes that there are no non-black areas close to the modifier image borders
                                                heightMap[x, y] = Mathf.Clamp01(heightTarget);
                                            }
                                        }
                                        else
                                        {
                                            // Black so make same height as terrain enable this code to reveal the black or base portion of the image
                                            //heightMap[x, y] -= 0.002f;
                                        }
                                    }
                                }
                                else
                                {
                                    // never should get here
                                    heightSum = 0f;
                                }

                                if (modifierMode != 4)
                                {
                                    // Modify the terrain based on the animation curve
                                    //heightSum = curveModifier.Evaluate(heightSum);

                                    // Calculate the heightmap based on the grayscale value of the given image
                                    heightMap[x, y] = (heightMap[x, y] * blendFactor) + (heightSum * (1f - blendFactor));
                                }
                            }
                        }
                    }

                    // Set heightmap
                    tData.SetHeights(0, 0, heightMap);
                }
            }

            return tData;
        }

        #endregion

        #region Static Final Pass Terrain Method

        /// <summary>
        /// INCOMPLETE
        /// Erosion, smoothing and masking
        /// Assumes all terrains in the landscape have same heightmap resolution
        /// Load heightmap from all terains into a single array.
        /// Some of these variables are unused...
        /// </summary>
        /// <param name="landscape"></param>
        /// <param name="landscapePosition"></param>
        /// <param name="useHydraulicErosion"></param>
        /// <param name="heIterations"></param>
        /// <param name="heRainfall"></param>
        /// <param name="heEvaporation"></param>
        /// <param name="heCarryingCapacity"></param>
        /// <param name="heStrength"></param>
        /// <param name="heDebugWaterLevel"></param>
        /// <param name="showProgressDelegate"></param>
        /// <param name="showErrors"></param>
        /// <returns></returns>
        public static bool FinalPassHeightmap(LBLandscape landscape, Vector3 landscapePosition, bool useHydraulicErosion,
            int heIterations, float heRainfall, float heEvaporation, float heCarryingCapacity, float heStrength, bool heDebugWaterLevel,
            LBLandscape.ShowProgressDelegate showProgressDelegate, bool showErrors)
        {
            bool isSuccessful = false;
            string methodName = "LBLandscapeTerrain.FinalPassHeightmap";
            float tStart = Time.realtimeSinceStartup;

            // Perform some basic validation
            if (landscape == null) { if (showErrors) { Debug.LogWarning("ERROR " + methodName + " - landscape cannot be null"); } }
            else if (landscape.landscapeTerrains == null) { if (showErrors) { Debug.LogWarning("ERROR " + methodName + " - no terrains defined in the landscape. Please Report."); } }
            else if (landscape.landscapeTerrains.Length < 1) { if (showErrors) { Debug.LogWarning("ERROR " + methodName + " - no terrains are in the landscape. Please Report."); } }
            else if (landscape.landscapeTerrains[0] == null) { if (showErrors) { Debug.LogWarning("ERROR " + methodName + " - the first terrain is null. Please Report."); } }
            else if (landscape.landscapeTerrains[0].terrainData == null) { if (showErrors) { Debug.LogWarning("ERROR " + methodName + " - the first terrain's data is null. Please Report."); } }
            else
            {
                // Load heightmap from all terains into a single array

                // Get data for first terrain and assume all are the same
                Terrain firstTerrain = landscape.landscapeTerrains[0];
                TerrainData tData = firstTerrain.terrainData;

                #region Get settings from landscape
                bool useThermalErosion = landscape.useThermalErosion;
                int teIterations = landscape.thermalErosionIterations;
                float teTalusAngle = landscape.thermalErosionTalusAngle;
                float teErosionStrength = landscape.thermalErosionStrength;
                string teStencilGUID = landscape.fPassThErosionStencilGUID;
                string teStencilLayerGUID = landscape.fPassThErosionStencilLayerGUID;
                int teFilterMode = (int)landscape.fPassThErosionFilterMode;

                bool useSmoothing = landscape.useFinalPassSmoothing;
                int smoothingIterations = landscape.finalPassSmoothingIterations;
                int smoothingPixelRange = landscape.finalPassPixelRange;
                string smoothingStencilGUID = landscape.fPassSmoothStencilGUID;
                string smoothingStencilLayerGUID = landscape.fPassSmoothStencilLayerGUID;
                int smoothingFilterMode = (int)landscape.fPassSmoothFilterMode;
                //Vector2 landscapeSize = landscape.size;
                #endregion

                bool isIncludeInnerEdges = false;

                // Check for available memory
                //int numTerrains = landscape.landscapeTerrains.Length;
                //int terrainHeightmapResolution = firstTerrain.terrainData.heightmapResolution;
                int landscapeHeightsSize = landscape.GetTotalHeightmapSize(isIncludeInnerEdges);

                // Force garbage collection so we have largest blocks of memory possible
                System.GC.Collect();

                // Create the array from a contiguous block of space in memory
                float[] landscapeHeightmap = new float[landscapeHeightsSize];

                int heightmapResolution = (int)Mathf.Sqrt(landscapeHeightsSize);

                // Uncomment this line if testing Hydraulic Erosion
                //float[,] heightMap = new float[heightmapResolution, heightmapResolution];

                if (!GetLandscapeScopedHeightmap(landscape, landscapeHeightmap, isIncludeInnerEdges, showErrors)) { if (showErrors) { Debug.LogWarning("ERROR " + methodName + " - could not populate landscape-scoped heightmap array"); } }
                else
                {
                    float maxTerrainHeight = tData.size.y;

                    #region Is Compute Shader being used?
                    // Only enabled when GPU Acceleration is enabled for Topography
                    // and LB_COMPUTE is declared at top of this script.
#if !(UNITY_STANDALONE_OSX || UNITY_STANDALONE_WIN || UNITY_XBOXONE || UNITY_WSA_10_0)
                    bool isFPassComputeEnabled = false;
#elif !(LB_COMPUTE)
                    bool isFPassComputeEnabled = false;
#else
                    bool isFPassComputeEnabled = (landscape == null ? false : landscape.useGPUTopography) && (useThermalErosion || useSmoothing);
#endif
                    #endregion

                    // NOTE: We don't need this for compute shader
                    float[] tempLandscapeHeightMap = landscapeHeightmap.Clone() as float[];

                    // Uncomment this line if testing Hydraulic Erosion
                    //float[,] tempHeightMap = heightMap.Clone() as float[,];

                    //Vector3 terrainWorldPosition = terrain.transform.position;

                    #region Local variables

                    // TODO: Remove unused variables (after making all other changes)
                    // Also maybe comment some of these variables, explaining what they are used for

                    // Local variable declarations (for performance)
                    float totalHeight = 0f;
                    float totalHeightDifference = 0f;
                    float averageHeight = 0f;
                    float thisHeight = 0f;
                    float thisSurroundingHeight = 0f;
                    float minHeightDifference = 0f;
                    float maxHeightDifference = 0f;
                    float heightDifferenceScalar = 0f;
                    int numberOfSampledCells = 0;

                    float thisWaterLevel = 0f;
                    float erodedAmount = 0f;
                    float maxErodedAmount = 0f;
                    float sedimentToDeposit = 0f;
                    float totalWaterToRemove = 0f;
                    float totalSedimentToRemove = 0f;
                    float waterDistributionProportion = 0f;

                    float heightDiff1 = 0f;
                    float heightDiff2 = 0f;
                    float heightDiff3 = 0f;
                    float heightDiff4 = 0f;
                    float heightDiff5 = 0f;
                    float heightDiff6 = 0f;
                    float heightDiff7 = 0f;
                    float heightDiff8 = 0f;
                    float tempHeightDiff = 0f;
                    float[] heightDiffCache = new float[9];
                    int heightDiffCacheIndex = 0;

                    // Test Thermal erosion array
                    //float[] teheightDiff = new float[9];

                    // For loop variables
                    int x = 0, y = 0, mapIndex = 0, blockXMin = 0, blockXMax = 0, blockYMin = 0, blockYMax = 0, blockX = 0, blockY = 0;
                    int tempMapIndex = 0;

                    #endregion

                    #region Local Stencil Filter varibles
                    bool isFPSmoothStencilEnabled = false;
                    bool isFPTeStencilEnabled = false;
                    float stencilLayerBlend = 1f;
                    float hmapResMinus1F = (float)(heightmapResolution - 1);
                    LBMapPoint stencilLayerPoint = new LBMapPoint(0, 0);
                    #endregion

                    #region Pre-load Stencils

                    if (useSmoothing && !string.IsNullOrEmpty(smoothingStencilGUID) && !string.IsNullOrEmpty(smoothingStencilLayerGUID))
                    {
                        // If the temporary class instance isn't defined, look it up and validate it is in the current landscape
                        if (landscape.fPassSmoothlbStencil == null)
                        {
                            landscape.fPassSmoothlbStencil = LBStencil.GetStencilInLandscape(landscape, smoothingStencilGUID, true);
                        }

                        if (landscape.fPassSmoothlbStencil != null)
                        {
                            // Find the Stencil Layer for this Layer Filter and populate the temporary class instance
                            landscape.fPassSmoothlbStencilLayer = landscape.fPassSmoothlbStencil.GetStencilLayerByGUID(smoothingStencilLayerGUID);

                            if (landscape.fPassSmoothlbStencilLayer != null)
                            {
                                // Load the USHORT data (Compute uses the uncompressed textures)
                                if (landscape.fPassSmoothlbStencilLayer.layerArray == null && !isFPassComputeEnabled)
                                {
                                    landscape.fPassSmoothlbStencilLayer.AllocLayerArray();
                                    landscape.fPassSmoothlbStencilLayer.UnCompressToUShort();
                                }

                                // Cache the layer resolution
                                landscape.fPassSmoothStencilLayerRes = (int)landscape.fPassSmoothlbStencilLayer.layerResolution;
                                isFPSmoothStencilEnabled = isFPassComputeEnabled || landscape.fPassSmoothlbStencilLayer.layerArray != null;
                            }
                        }
                    }

                    if (useThermalErosion && !string.IsNullOrEmpty(teStencilGUID) && !string.IsNullOrEmpty(teStencilLayerGUID))
                    {
                        // If the temporary class instance isn't defined, look it up and validate it is in the current landscape
                        if (landscape.fPassThErosionlbStencil == null)
                        {
                            // If this stencil is also being used as a Smoothing filter, no need to find it again.
                            if (isFPSmoothStencilEnabled && teStencilGUID == smoothingStencilGUID)
                            {
                                landscape.fPassThErosionlbStencil = landscape.fPassSmoothlbStencil;
                            }
                            else
                            {
                                landscape.fPassThErosionlbStencil = LBStencil.GetStencilInLandscape(landscape, teStencilGUID, true);
                            }
                        }

                        if (landscape.fPassThErosionlbStencil != null)
                        {
                            // Find the Stencil Layer for this Layer Filter and populate the temporary class instance
                            landscape.fPassThErosionlbStencilLayer = landscape.fPassThErosionlbStencil.GetStencilLayerByGUID(teStencilLayerGUID);

                            if (landscape.fPassThErosionlbStencilLayer != null)
                            {
                                // Load the USHORT data (Compute uses the uncompressed textures)
                                // No need to uncompress if it has already been uncompressed
                                if (landscape.fPassThErosionlbStencilLayer.layerArray == null && !isFPassComputeEnabled)
                                {
                                    landscape.fPassThErosionlbStencilLayer.AllocLayerArray();
                                    landscape.fPassThErosionlbStencilLayer.UnCompressToUShort();
                                }

                                // Cache the layer resolution
                                landscape.fPassThErosionStencilLayerRes = (int)landscape.fPassThErosionlbStencilLayer.layerResolution;
                                isFPTeStencilEnabled = isFPassComputeEnabled || landscape.fPassThErosionlbStencilLayer.layerArray != null;
                            }
                        }
                    }

                    #endregion

                    #region Reset Garbage Collection
                    System.GC.Collect();
                    #endregion

                    #region Initial Compute Shader                   

#if LB_COMPUTE
                    // Compute shader variables
                    ComputeShader shaderFPass = null;
                    ComputeBuffer cbufHeights = null;   // Landscape-scoped data
                    ComputeBuffer cbufHeightsOut = null; // Terrain-scoped Data
                    int kFPassThermalErosionIdx = -1;
                    int kFPassSmoothingIdx = -1;
                    int kFPassCopyTerrainToHeightsIdx = -1;
                    //int kFPassCopyHeightsToTerrainIdx = -1;
                    int cskSmoothingNumThreads = 16; // Must match LB_SM_NUM_THREADS in LBCSFPass.compute
                    int cskThermalErosionNumThreads = 1; // Must match LB_TE_NUM_THREADS in LBCSFPass.compute
                    int cskCopyNumThreads = 256; // Must match LB_CPY_NUM_THREADS in LBCSFPass.compute
                    bool isHeightsUpdated = false;  // Have heights been updated in the compute shader?

                    // Terrain data - assume all terrains in landscape the same
                    int terrainHeightmapResolution = tData.heightmapResolution;
                    int terrainHeightmapSize1D = terrainHeightmapResolution * terrainHeightmapResolution;
                    float[] terrainHeightmap1D = new float[terrainHeightmapSize1D];
                    float terrainWidth = tData.size.x;
                    float terrainLength = tData.size.z;

                    Texture2DArray dummyTex2DArray = null;
                    // There are 128x128, 256x256, 512x512, 1Kx1K, 2Kx2K, 4Kx4K and 8Kx8K Text2DArrays for stencil layers
                    List<Texture2DArray> stencilLayerTex2DArrayList = null;
                    int numTerrains = landscape.landscapeTerrains.Length;

                    if (isFPassComputeEnabled)
                    {
                        try
                        {
                            // Find shader
                            shaderFPass = (ComputeShader)Resources.Load(LBCSFPass, typeof(ComputeShader));
                            if (shaderFPass == null) { Debug.LogWarning("ERROR: " + methodName + " " + LBCSFPass + ".shader not found. Please Report"); }
                            else
                            {
                                dummyTex2DArray = new Texture2DArray(1, 1, 1, TextureFormat.ARGB32, false, true);
                                stencilLayerTex2DArrayList = new List<Texture2DArray>(7);

                                // Create buffers
                                // Contains the heights for the entire landscape
                                cbufHeights = new ComputeBuffer(landscapeHeightsSize, sizeof(float), ComputeBufferType.Default);
                                // Is space to write data for a single terrain
                                cbufHeightsOut = new ComputeBuffer(terrainHeightmapSize1D, sizeof(float), ComputeBufferType.Default);
                                // Copy data to buffers
                                if (cbufHeights != null && cbufHeightsOut != null)
                                {
                                    cbufHeights.SetData(landscapeHeightmap);
                                    cbufHeightsOut.SetData(terrainHeightmap1D);
                                }

                                // Set common shader variables
                                // Terrain variables (assume all terrains are the same size in landscape)
                                shaderFPass.SetInt(CSterrainhmapRes, terrainHeightmapResolution);
                                shaderFPass.SetFloat(CSterrainWidth, terrainWidth);
                                shaderFPass.SetFloat(CSterrainLength, terrainLength);
                                // Landscape variables
                                shaderFPass.SetInt(CSheightmapResolution, heightmapResolution);
                                shaderFPass.SetVector(CSlandscapePos, landscapePosition);
                                shaderFPass.SetVector(CSlandscapeSize, landscape.size);
                            }
                        }
                        catch (System.Exception ex)
                        {
                            Debug.LogWarning("ERROR " + methodName + " - could not intialise final pass compute shader. PLEASE REPORT " + ex.Message);
                        }
                    }
#endif
                    #endregion

                    // TODO: Check all TODOs in this function and do cleanup

                    #region Thermal Erosion 1D Array

                    if (useThermalErosion)
                    {
                        // This won't work for non-square terrains...
                        // Deg2Rad = PI / 180. Rad2Deg = 180 / PI.
                        float talusHeightDifference = (Mathf.Tan(teTalusAngle * Mathf.Deg2Rad) * (landscape.size.x / (float)heightmapResolution)) / maxTerrainHeight;

                        #region Init Compute Shader Thermal Erosion
                        if (isFPassComputeEnabled)
                        {
#if LB_COMPUTE
                            try
                            {
                                isHeightsUpdated = false;
                                if (shaderFPass != null && cbufHeights != null && cbufHeightsOut != null)
                                {
                                    // Get the index to the Method in the compute shader
                                    kFPassThermalErosionIdx = shaderFPass.FindKernel(CSKFPassThermalErosion);
                                    kFPassCopyTerrainToHeightsIdx = shaderFPass.FindKernel(CSKFPassCopyTerrainToHeights);
                                    //kFPassCopyHeightsToTerrainIdx = shaderFPass.FindKernel(CSKFPassCopyHeightsToTerrain);

                                    // Set thermal erosion shader varibales
                                    shaderFPass.SetInt(CSteFilterMode, teFilterMode);
                                    shaderFPass.SetFloat(CStetalusHeightDiff, talusHeightDifference);
                                    shaderFPass.SetFloat(CSteErosionStrength, teErosionStrength);

                                    // Set unsed smoothing shader variables to avoid compute shader errors
                                    shaderFPass.SetInt(CSsmoothingFilterMode, smoothingFilterMode);
                                    shaderFPass.SetVector(CSterrainWorldPos, Vector3.zero);

                                    // Stencil layer filter (0 or 1)
                                    int stencilLayerResolution = isFPTeStencilEnabled ? landscape.fPassThErosionStencilLayerRes : 1;
                                    shaderFPass.SetInt(CSnumStencilLayers, isFPTeStencilEnabled ? 1 : 0);
                                    shaderFPass.SetInt(CSstencilLayerResolution, stencilLayerResolution);

                                    #region Copy Stencil Layer to compute shader
                                    if (isFPTeStencilEnabled)
                                    {
                                        // Create the texture arrays to hold the unique compressed stencil layer textures
                                        // Create 1 in each array (cannot have an array size of zero)
                                        // Currently in Final Pass we only support 1 stencil layer for smoothing. However, will use TexArrays for consistency
                                        // If there is no stencil for a certain resolution, create a dummy Texture2DArray with a 1x1 Texture to conserve GPU memory
                                        if (stencilLayerResolution != 128) { stencilLayerTex2DArrayList.Add(new Texture2DArray(1, 1, 1, TextureFormat.ARGB32, false, true)); }
                                        else { stencilLayerTex2DArrayList.Add(new Texture2DArray(128, 128, 1, TextureFormat.ARGB32, false, true)); }
                                        if (stencilLayerResolution != 256) { stencilLayerTex2DArrayList.Add(new Texture2DArray(1, 1, 1, TextureFormat.ARGB32, false, true)); }
                                        else { stencilLayerTex2DArrayList.Add(new Texture2DArray(256, 256, 1, TextureFormat.ARGB32, false, true)); }
                                        if (stencilLayerResolution != 512) { stencilLayerTex2DArrayList.Add(new Texture2DArray(1, 1, 1, TextureFormat.ARGB32, false, true)); }
                                        else { stencilLayerTex2DArrayList.Add(new Texture2DArray(512, 512, 1, TextureFormat.ARGB32, false, true)); }
                                        if (stencilLayerResolution != 1024) { stencilLayerTex2DArrayList.Add(new Texture2DArray(1, 1, 1, TextureFormat.ARGB32, false, true)); }
                                        else { stencilLayerTex2DArrayList.Add(new Texture2DArray(1024, 1024, 1, TextureFormat.ARGB32, false, true)); }
                                        if (stencilLayerResolution != 2048) { stencilLayerTex2DArrayList.Add(new Texture2DArray(1, 1, 1, TextureFormat.ARGB32, false, true)); }
                                        else { stencilLayerTex2DArrayList.Add(new Texture2DArray(2048, 2048, 1, TextureFormat.ARGB32, false, true)); }
                                        if (stencilLayerResolution != 4096) { stencilLayerTex2DArrayList.Add(new Texture2DArray(1, 1, 1, TextureFormat.ARGB32, false, true)); }
                                        else { stencilLayerTex2DArrayList.Add(new Texture2DArray(4096, 4096, 1, TextureFormat.ARGB32, false, true)); }
                                        if (stencilLayerResolution != 8192) { stencilLayerTex2DArrayList.Add(new Texture2DArray(1, 1, 1, TextureFormat.ARGB32, false, true)); }
                                        else { stencilLayerTex2DArrayList.Add(new Texture2DArray(8192, 8192, 1, TextureFormat.ARGB32, false, true)); }

                                        int numSLayerTex2DArrays = stencilLayerTex2DArrayList.Count;

                                        for (int i = 0; i < numSLayerTex2DArrays; i++) { stencilLayerTex2DArrayList[i].hideFlags = HideFlags.DontSave; }

                                        int stencilLayerResolutionIdx = -1;

                                        // There might be a better way of doing this via the position in the enum.
                                        switch (stencilLayerResolution)
                                        {
                                            case 128: stencilLayerResolutionIdx = 0; break;
                                            case 256: stencilLayerResolutionIdx = 1; break;
                                            case 512: stencilLayerResolutionIdx = 2; break;
                                            case 1024: stencilLayerResolutionIdx = 3; break;
                                            case 2048: stencilLayerResolutionIdx = 4; break;
                                            case 4096: stencilLayerResolutionIdx = 5; break;
                                            case 8092: stencilLayerResolutionIdx = 6; break;
                                        }

                                        // Add the stencil layer data to the Texture2DArray
                                        if (landscape.fPassThErosionlbStencilLayer.compressedTexture != null && stencilLayerResolutionIdx >= 0)
                                        {
                                            Texture2DArray texture2DArray = stencilLayerTex2DArrayList[stencilLayerResolutionIdx];

                                            if (texture2DArray != null)
                                            {
                                                LBTextureOperations.CopyTextureTo2DArray(ref texture2DArray, landscape.fPassThErosionlbStencilLayer.compressedTexture, 0, true);
                                            }
                                        }

                                        // Assign the Texture2DArrays to the compute shader
                                        CopyStencilLayerTex2DArrayListToShader(stencilLayerTex2DArrayList, shaderFPass, kFPassThermalErosionIdx);
                                    }
                                    else
                                    {
                                        ConfigDummyStencilLayerTex2DArrayList(stencilLayerTex2DArrayList, shaderFPass, kFPassThermalErosionIdx);
                                    }
                                    #endregion
                                }
                            }
                            catch (System.Exception ex)
                            {
                                Debug.LogWarning("ERROR " + methodName + " - could not erode landscape with compute shader. PLEASE REPORT " + ex.Message);
                            }
#endif
                        }

                        #endregion Init Compute Shader Thermal Erosion

                        // Loop through iterations
                        for (int i = 0; i < teIterations; i++)
                        {
                            #region Compute Shader
                            if (isFPassComputeEnabled)
                            {
#if LB_COMPUTE

                                // Process terrain-scoped heightmap in each iteration (reads from landscape-scoped heightmap)
                                //for (int tIdx = 0; tIdx < numTerrains; tIdx++)

                                // Process one row of the landscape-scoped heightmap at a time
                                for (int hmapRowIdx = 0; hmapRowIdx < heightmapResolution; hmapRowIdx++)
                                {
                                    //// Copy the 1D landscape-scoped heightmap terrain chunk into the smaller 1D terrain heightmap in shader
                                    //// Assign buffers to CopyHeightsToTerrain method
                                    //shaderFPass.SetBuffer(kFPassCopyHeightsToTerrainIdx, CSheights, cbufHeights);
                                    //shaderFPass.SetBuffer(kFPassCopyHeightsToTerrainIdx, CSheightsOut, cbufHeightsOut);

                                    // Set terrain variables
                                    //shaderFPass.SetVector(CSterrainWorldPos, landscape.landscapeTerrains[tIdx].transform.position);
                                    shaderFPass.SetInt(CShmapRow, hmapRowIdx);

                                    //int threadGroupX = terrainHeightmapSize1D / cskCopyNumThreads;
                                    //int threadGroupY = 1;
                                    //// Round up threadGroupX by adding 1.
                                    //shaderFPass.Dispatch(kFPassCopyHeightsToTerrainIdx, threadGroupX + 1, threadGroupY, 1);

                                    // Assign buffers to thermal erosion method
                                    shaderFPass.SetBuffer(kFPassThermalErosionIdx, CSheights, cbufHeights);
                                    //shaderFPass.SetBuffer(kFPassThermalErosionIdx, CSheightsOut, cbufHeightsOut);

                                    // Execute thermal erosion iteration in shader
                                    // As the heightmap res is 2^n + 1 we need to add an additional threadGroup in both x and z directions.
                                    // In our shader Z is up so x,z in Unity become x,y in shader.
                                    // The additional thread groups will only process 1 pixel. Although this means we "waste" parallel processing
                                    // on the GPU, it means we can process the rest of the heightmap in parallel.
                                    //int threadGroupX = (terrainHeightmapResolution - 1) / cskThermalErosionNumThreads;
                                    //int threadGroupY = (terrainHeightmapResolution - 1) / cskThermalErosionNumThreads;

                                    // Currently single threaded (1) in attempt to match non-compute execution and heightmap soil/rock distribution
                                    int threadGroupX = heightmapResolution / cskThermalErosionNumThreads;

                                    // Execute shader
                                    // The Y and Z thread group is 1 because we are processing a 1D heightmap
                                    shaderFPass.Dispatch(kFPassThermalErosionIdx, threadGroupX, 1, 1);

                                    //// Copy terrain-scoped heightmap to landscape-scoped heightmap in shader
                                    //// Assign buffers to CopyTerrainToHeights method
                                    //shaderFPass.SetBuffer(kFPassCopyTerrainToHeightsIdx, CSheights, cbufHeights);
                                    //shaderFPass.SetBuffer(kFPassCopyTerrainToHeightsIdx, CSheightsOut, cbufHeightsOut);

                                    //threadGroupX = terrainHeightmapSize1D / cskCopyNumThreads;
                                    //threadGroupY = 1;
                                    //// Round up threadGroupX by adding 1.
                                    //shaderFPass.Dispatch(kFPassCopyTerrainToHeightsIdx, threadGroupX + 1, threadGroupY, 1);
                                }

                                isHeightsUpdated = true;
#endif


                            }
                            #endregion Compute Shader

                            #region Non-Compute Shader
                            else
                            {
                                // Loop through all parts of the array
                                for (mapIndex = 0; mapIndex < landscapeHeightsSize; mapIndex++)
                                {
                                    // Get x and y coordinates from heightmap array index
                                    x = mapIndex % heightmapResolution;
                                    y = (mapIndex - x) / heightmapResolution;

                                    #region Get Stencil Layer Value if applicable
                                    if (isFPTeStencilEnabled)
                                    {
                                        // Get the value of the Stencil layer at this point in the terrain
                                        // Get the point within the stencil layer USHORT array
                                        // ((float)x / hmapResMinus1F is the normalised x position in the landscape (value is between 0 and 1)
                                        // Ensure it it's outside the range of the USHORT array (Clamping in the same line give 2% performance boost)
                                        stencilLayerPoint.x = Mathf.Clamp(Mathf.RoundToInt(((float)x / hmapResMinus1F) * (landscape.fPassThErosionStencilLayerRes - 1f)), 0, landscape.fPassThErosionStencilLayerRes - 1);
                                        stencilLayerPoint.y = Mathf.Clamp(Mathf.RoundToInt((1f - ((float)y / hmapResMinus1F)) * (landscape.fPassThErosionStencilLayerRes - 1f)), 0, landscape.fPassThErosionStencilLayerRes - 1);

                                        stencilLayerBlend = landscape.fPassThErosionlbStencilLayer.layerArray[stencilLayerPoint.x, stencilLayerPoint.y] / 65535f;
                                    }
                                    else { stencilLayerBlend = 1f; }
                                    #endregion

                                    // Initialise variables
                                    totalHeightDifference = 0f;
                                    maxHeightDifference = 0f;
                                    thisHeight = landscapeHeightmap[mapIndex];

                                    // Check if any smoothing applies to this point in the landscape.
                                    if (isFPTeStencilEnabled && ((stencilLayerBlend == 0.0f && teFilterMode == 0) || (stencilLayerBlend > 0.9999f && teFilterMode == 2)))
                                    {
                                        tempLandscapeHeightMap[mapIndex] = landscapeHeightmap[mapIndex];
                                    }
                                    else
                                    {
                                        #region Calculate Height Totals

                                        // Loop through 8 neighbours
                                        // 1. Find height difference relative to talus height for each neighbour
                                        // 2. Find max height difference
                                        // 3. Find the total height difference
                                        // Height difference only counts neighbours which are more than the talus
                                        // height below the current cell

                                        // Left column
                                        if (x > 0)
                                        {
                                            // Bottom-left neighbour
                                            if (y > 0)
                                            {
                                                // Get height difference relative to talus height
                                                heightDiff1 = thisHeight - landscapeHeightmap[mapIndex - heightmapResolution - 1] - talusHeightDifference;
                                                // Only count positive height differences
                                                if (heightDiff1 > 0f)
                                                {
                                                    // If this is greater than the current maximum height difference,
                                                    // record it as the new maximum height
                                                    if (heightDiff1 > maxHeightDifference) { maxHeightDifference = heightDiff1; }
                                                    // Add this height to the total
                                                    totalHeightDifference += heightDiff1;
                                                }
                                                // Clamp the height difference to positive values only
                                                else { heightDiff1 = 0f; }
                                            }
                                            // Top-left neighbour
                                            if (y < heightmapResolution - 1)
                                            {
                                                // Get height difference relative to talus height
                                                heightDiff2 = thisHeight - landscapeHeightmap[mapIndex + heightmapResolution - 1] - talusHeightDifference;
                                                // Only count positive height differences
                                                if (heightDiff2 > 0f)
                                                {
                                                    // If this is greater than the current maximum height difference,
                                                    // record it as the new maximum height
                                                    if (heightDiff2 > maxHeightDifference) { maxHeightDifference = heightDiff2; }
                                                    // Add this height to the total
                                                    totalHeightDifference += heightDiff2;
                                                }
                                                // Clamp the height difference to positive values only
                                                else { heightDiff2 = 0f; }
                                            }
                                            // Centre-left neighbour
                                            // Get height difference relative to talus height
                                            heightDiff3 = thisHeight - landscapeHeightmap[mapIndex - 1] - talusHeightDifference;
                                            // Only count positive height differences
                                            if (heightDiff3 > 0f)
                                            {
                                                // If this is greater than the current maximum height difference,
                                                // record it as the new maximum height
                                                if (heightDiff3 > maxHeightDifference) { maxHeightDifference = heightDiff3; }
                                                // Add this height to the total
                                                totalHeightDifference += heightDiff3;
                                            }
                                            // Clamp the height difference to positive values only
                                            else { heightDiff3 = 0f; }
                                        }
                                        // Right column
                                        if (x < heightmapResolution - 1)
                                        {
                                            // Bottom-right neighbour
                                            if (y > 0)
                                            {
                                                // Get height difference relative to talus height
                                                heightDiff4 = thisHeight - landscapeHeightmap[mapIndex - heightmapResolution + 1] - talusHeightDifference;
                                                // Only count positive height differences
                                                if (heightDiff4 > 0f)
                                                {
                                                    // If this is greater than the current maximum height difference,
                                                    // record it as the new maximum height
                                                    if (heightDiff4 > maxHeightDifference) { maxHeightDifference = heightDiff4; }
                                                    // Add this height to the total
                                                    totalHeightDifference += heightDiff4;
                                                }
                                                // Clamp the height difference to positive values only
                                                else { heightDiff4 = 0f; }
                                            }
                                            // Top-right neighbour
                                            if (y < heightmapResolution - 1)
                                            {
                                                // Get height difference relative to talus height
                                                heightDiff5 = thisHeight - landscapeHeightmap[mapIndex + heightmapResolution + 1] - talusHeightDifference;
                                                // Only count positive height differences
                                                if (heightDiff5 > 0f)
                                                {
                                                    // If this is greater than the current maximum height difference,
                                                    // record it as the new maximum height
                                                    if (heightDiff5 > maxHeightDifference) { maxHeightDifference = heightDiff5; }
                                                    // Add this height to the total
                                                    totalHeightDifference += heightDiff5;
                                                }
                                                // Clamp the height difference to positive values only
                                                else { heightDiff5 = 0f; }
                                            }
                                            // Centre-right neighbour
                                            // Get height difference relative to talus height
                                            heightDiff6 = thisHeight - landscapeHeightmap[mapIndex + 1] - talusHeightDifference;
                                            // Only count positive height differences
                                            if (heightDiff6 > 0f)
                                            {
                                                // If this is greater than the current maximum height difference,
                                                // record it as the new maximum height
                                                if (heightDiff6 > maxHeightDifference) { maxHeightDifference = heightDiff6; }
                                                // Add this height to the total
                                                totalHeightDifference += heightDiff6;
                                            }
                                            // Clamp the height difference to positive values only
                                            else { heightDiff6 = 0f; }
                                        }
                                        // Middle column
                                        // Bottom-centre neighbour
                                        if (y > 0)
                                        {
                                            // Get height difference relative to talus height
                                            heightDiff7 = thisHeight - landscapeHeightmap[mapIndex - heightmapResolution] - talusHeightDifference;
                                            // Only count positive height differences
                                            if (heightDiff7 > 0f)
                                            {
                                                // If this is greater than the current maximum height difference,
                                                // record it as the new maximum height
                                                if (heightDiff7 > maxHeightDifference) { maxHeightDifference = heightDiff7; }
                                                // Add this height to the total
                                                totalHeightDifference += heightDiff7;
                                            }
                                            // Clamp the height difference to positive values only
                                            else { heightDiff7 = 0f; }
                                        }
                                        // Top-centre neighbour
                                        if (y < heightmapResolution - 1)
                                        {
                                            // Get height difference relative to talus height
                                            heightDiff8 = thisHeight - landscapeHeightmap[mapIndex + heightmapResolution] - talusHeightDifference;
                                            // Only count positive height differences
                                            if (heightDiff8 > 0f)
                                            {
                                                // If this is greater than the current maximum height difference,
                                                // record it as the new maximum height
                                                if (heightDiff8 > maxHeightDifference) { maxHeightDifference = heightDiff8; }
                                                // Add this height to the total
                                                totalHeightDifference += heightDiff8;
                                            }
                                            // Clamp the height difference to positive values only
                                            else { heightDiff8 = 0f; }
                                        }

                                        #endregion Calculate Height Totals

                                        #region Distribute Heights

                                        // If material slippage should occur, distribute the difference in height between
                                        // this cell and the lowest neighbouring cell between its lower neighbours
                                        // The amount of distributed material is proportional to the height difference
                                        if (totalHeightDifference > 0f)
                                        {
                                            // Scale the height difference based on user-chosen erosion strength
                                            // Also halve the value as we want to remove half the difference from this cell
                                            // to equalise it with its neighbours
                                            maxHeightDifference *= teErosionStrength * 0.5f;

                                            // If applicable, apply the stencil blending
                                            if (isFPTeStencilEnabled)
                                            {
                                                // Might also need to adjust to totalHeightDifference and avoid div0
                                                if (teFilterMode == 0) // AND
                                                {
                                                    // Lerp between 0 and maxHeightDifference
                                                    maxHeightDifference *= stencilLayerBlend;
                                                }
                                                else // Assume NOT
                                                {
                                                    // Lerp between maxHeightDifference and 0
                                                    // Mathf.LerpUnclamped(a,b,t) same as: a + (b - a) * t
                                                    maxHeightDifference *= (1f - stencilLayerBlend);
                                                }
                                            }

                                            // Remove the material from this cell
                                            tempLandscapeHeightMap[mapIndex] -= maxHeightDifference;

                                            // Add the material to the neighbouring cells

                                            // This scalar is calculated now for performance
                                            // Full equation is: 
                                            // height += maxHeightDifference * (heightDiffX / totalHeightDifference)
                                            heightDifferenceScalar = maxHeightDifference / totalHeightDifference;

                                            // Loop through 8 neighbours
                                            // Add the height difference that is proportional to its own height difference

                                            // Left column
                                            if (x > 0)
                                            {
                                                // Bottom-left neighbour
                                                if (y > 0)
                                                {
                                                    tempLandscapeHeightMap[mapIndex - heightmapResolution - 1] += heightDiff1 * heightDifferenceScalar;
                                                }
                                                // Top-left neighbour
                                                if (y < heightmapResolution - 1)
                                                {
                                                    tempLandscapeHeightMap[mapIndex + heightmapResolution - 1] += heightDiff2 * heightDifferenceScalar;
                                                }
                                                // Centre-left neighbour
                                                tempLandscapeHeightMap[mapIndex - 1] += heightDiff3 * heightDifferenceScalar;
                                            }
                                            // Right column
                                            if (x < heightmapResolution - 1)
                                            {
                                                // Bottom-right neighbour
                                                if (y > 0)
                                                {
                                                    tempLandscapeHeightMap[mapIndex - heightmapResolution + 1] += heightDiff4 * heightDifferenceScalar;
                                                }
                                                // Top-right neighbour
                                                if (y < heightmapResolution - 1)
                                                {
                                                    tempLandscapeHeightMap[mapIndex + heightmapResolution + 1] += heightDiff5 * heightDifferenceScalar;
                                                }
                                                // Centre-right neighbour
                                                tempLandscapeHeightMap[mapIndex + 1] += heightDiff6 * heightDifferenceScalar;
                                            }
                                            // Middle column
                                            // Bottom-centre neighbour
                                            if (y > 0)
                                            {
                                                tempLandscapeHeightMap[mapIndex - heightmapResolution] += heightDiff7 * heightDifferenceScalar;
                                            }
                                            // Top-centre neighbour
                                            if (y < heightmapResolution - 1)
                                            {
                                                tempLandscapeHeightMap[mapIndex + heightmapResolution] += heightDiff8 * heightDifferenceScalar;
                                            }
                                        }

                                        #endregion Distribute Heights
                                    }
                                }

                                // Copy heightmap data
                                System.Buffer.BlockCopy(tempLandscapeHeightMap, 0, landscapeHeightmap, 0, landscapeHeightsSize * sizeof(float));
                            }

                            #endregion Non-Compute Shader

                            #region Progress
                            if (showProgressDelegate != null)
                            {
                                // Call back to update the progress bar
                                showProgressDelegate("Topography Final Pass Thermal Erosion", i + 1 + " of " + teIterations, (float)i / (float)teIterations);
                            }
                            #endregion
                        }

                        #region Get Updated Heights from Compute Shader
                        if (isFPassComputeEnabled)
                        {
#if LB_COMPUTE
                            if (isHeightsUpdated && cbufHeights != null)
                            {
                                cbufHeights.GetData(landscapeHeightmap);
                            }
#endif
                        }
                        #endregion

                        #region Free Stencil Compute Shader Resources
#if LB_COMPUTE
                        // The stencil list is also used for Smoothing below, so needs to be cleared.
                        int numStencilLayerArrays = (stencilLayerTex2DArrayList == null ? 0 : stencilLayerTex2DArrayList.Count);

                        for (int slArrayIdx = numStencilLayerArrays - 1; slArrayIdx >= 0; slArrayIdx--)
                        {
                            Texture2DArray texture2DArray = stencilLayerTex2DArrayList[slArrayIdx];
                            if (texture2DArray != null) { LBTextureOperations.DestroyTexture2DArray(ref texture2DArray); }
                            // Check if was correctly disposed
                            if (stencilLayerTex2DArrayList[slArrayIdx] != null) { Debug.LogWarning("ERROR: " + methodName + " - stencillayer tex2Darray" + slArrayIdx + "  not released correctly"); }
                        }
                        if (stencilLayerTex2DArrayList != null) { stencilLayerTex2DArrayList.Clear(); }
#endif
                        #endregion
                    }

                    #endregion Thermal Erosion 1D Array

                    #region Hydraulic Erosion 2D Array

#if true == false
                if (useHydraulicErosion && false)
                {
                    float[,] waterMap = new float[heightmapResolution, heightmapResolution];
                    float[,] tempWaterMap = new float[heightmapResolution, heightmapResolution];
                    float[,] sedimentMap = new float[heightmapResolution, heightmapResolution];
                    float[,] tempSedimentMap = new float[heightmapResolution, heightmapResolution];

                    // Loop through iterations
                    for (int i = 0; i < heIterations; i++)
                    {
                    #region Rainfall and Erosion

                        // Loop through points in the height map
                        for (x = 0; x < heightmapResolution; x++)
                        {
                            for (y = 0; y < heightmapResolution; y++)
                            {
                                // Add water due to rainfall
                                thisWaterLevel = waterMap[x, y] + (heRainfall / 1000f);
                                waterMap[x, y] = thisWaterLevel;
                                tempWaterMap[x, y] = thisWaterLevel;

                                // Erode amount of soil proportional to the water level
                                erodedAmount = heStrength * thisWaterLevel;
                                maxErodedAmount = (heCarryingCapacity * thisWaterLevel) - sedimentMap[x, y];
                                // Don't erode more than can be dissolved in the water present
                                if (erodedAmount > maxErodedAmount) { erodedAmount = maxErodedAmount; }
                                // Don't erode more than the current height of the terrain
                                thisHeight = heightMap[x, y];
                                if (erodedAmount > thisHeight) { erodedAmount = thisHeight; }
                                // Theoretically line below shouldn't be needed...
                                // CHECK THIS LATER
                                if (erodedAmount < 0f) { erodedAmount = 0f; }

                                // Update heightmap and sediment map
                                heightMap[x, y] -= erodedAmount;
                                tempHeightMap[x, y] -= erodedAmount;
                                sedimentMap[x, y] += erodedAmount;
                                tempSedimentMap[x, y] += erodedAmount;
                            }
                        }

                    #endregion Rainfall and Erosion

                    #region Transportation

                        // Loop through points in the height map
                        for (x = 0; x < heightmapResolution; x++)
                        {
                            for (y = 0; y < heightmapResolution; y++)
                            {
                                // WARNING: Copied from thermal erosion code

                                thisWaterLevel = waterMap[x, y];

                                if (thisWaterLevel > 0f)
                                {
                                    thisHeight = heightMap[x, y] + thisWaterLevel;
                                    totalHeightDifference = 0f;

                                    // Currently unused
                                    maxHeightDifference = 0f;

                    #region Calculate Height Totals

                                    // Loop through 8 neighbours
                                    // NEED TO REWRITE
                                    // 1. Find height difference relative to talus height for each neighbour
                                    // 2. Find max height difference
                                    // 3. Find the total height difference
                                    // Height difference only counts neighbours which are more than the talus
                                    // height below the current cell

                                    // Currently not using max height

                                    // Left column
                                    if (x > 0)
                                    {
                                        // Bottom-left neighbour
                                        if (y > 0)
                                        {
                                            // Get height difference
                                            heightDiff1 = thisHeight - heightMap[x - 1, y - 1] - waterMap[x - 1, y - 1];
                                            // Only count positive height differences
                                            if (heightDiff1 > 0f)
                                            {
                                                // If this is greater than the current maximum height difference,
                                                // record it as the new maximum height
                                                if (heightDiff1 > maxHeightDifference) { maxHeightDifference = heightDiff1; }
                                                // Add this height to the total
                                                totalHeightDifference += heightDiff1;
                                            }
                                            // Clamp the height difference to positive values only
                                            else { heightDiff1 = 0f; }
                                        }
                                        // Top-left neighbour
                                        if (y < heightmapResolution - 1)
                                        {
                                            // Get height difference
                                            heightDiff2 = thisHeight - heightMap[x - 1, y + 1] - waterMap[x - 1, y + 1];
                                            // Only count positive height differences
                                            if (heightDiff2 > 0f)
                                            {
                                                // If this is greater than the current maximum height difference,
                                                // record it as the new maximum height
                                                if (heightDiff2 > maxHeightDifference) { maxHeightDifference = heightDiff2; }
                                                // Add this height to the total
                                                totalHeightDifference += heightDiff2;
                                            }
                                            // Clamp the height difference to positive values only
                                            else { heightDiff2 = 0f; }
                                        }
                                        // Centre-left neighbour
                                        // Get height difference
                                        heightDiff3 = thisHeight - heightMap[x - 1, y] - waterMap[x - 1, y];
                                        // Only count positive height differences
                                        if (heightDiff3 > 0f)
                                        {
                                            // If this is greater than the current maximum height difference,
                                            // record it as the new maximum height
                                            if (heightDiff3 > maxHeightDifference) { maxHeightDifference = heightDiff3; }
                                            // Add this height to the total
                                            totalHeightDifference += heightDiff3;
                                        }
                                        // Clamp the height difference to positive values only
                                        else { heightDiff3 = 0f; }
                                    }
                                    // Right column
                                    if (x < heightmapResolution - 1)
                                    {
                                        // Bottom-right neighbour
                                        if (y > 0)
                                        {
                                            // Get height difference
                                            heightDiff4 = thisHeight - heightMap[x + 1, y - 1] - waterMap[x + 1, y - 1];
                                            // Only count positive height differences
                                            if (heightDiff4 > 0f)
                                            {
                                                // If this is greater than the current maximum height difference,
                                                // record it as the new maximum height
                                                if (heightDiff4 > maxHeightDifference) { maxHeightDifference = heightDiff4; }
                                                // Add this height to the total
                                                totalHeightDifference += heightDiff4;
                                            }
                                            // Clamp the height difference to positive values only
                                            else { heightDiff4 = 0f; }
                                        }
                                        // Top-right neighbour
                                        if (y < heightmapResolution - 1)
                                        {
                                            // Get height difference
                                            heightDiff5 = thisHeight - heightMap[x + 1, y + 1] - waterMap[x + 1, y + 1];
                                            // Only count positive height differences
                                            if (heightDiff5 > 0f)
                                            {
                                                // If this is greater than the current maximum height difference,
                                                // record it as the new maximum height
                                                if (heightDiff5 > maxHeightDifference) { maxHeightDifference = heightDiff5; }
                                                // Add this height to the total
                                                totalHeightDifference += heightDiff5;
                                            }
                                            // Clamp the height difference to positive values only
                                            else { heightDiff5 = 0f; }
                                        }
                                        // Centre-right neighbour
                                        // Get height difference
                                        heightDiff6 = thisHeight - heightMap[x + 1, y] - waterMap[x + 1, y];
                                        // Only count positive height differences
                                        if (heightDiff6 > 0f)
                                        {
                                            // If this is greater than the current maximum height difference,
                                            // record it as the new maximum height
                                            if (heightDiff6 > maxHeightDifference) { maxHeightDifference = heightDiff6; }
                                            // Add this height to the total
                                            totalHeightDifference += heightDiff6;
                                        }
                                        // Clamp the height difference to positive values only
                                        else { heightDiff6 = 0f; }
                                    }
                                    // Middle column
                                    // Bottom-centre neighbour
                                    if (y > 0)
                                    {
                                        // Get height difference
                                        heightDiff7 = thisHeight - heightMap[x, y - 1] - waterMap[x, y - 1];
                                        // Only count positive height differences
                                        if (heightDiff7 > 0f)
                                        {
                                            // If this is greater than the current maximum height difference,
                                            // record it as the new maximum height
                                            if (heightDiff7 > maxHeightDifference) { maxHeightDifference = heightDiff7; }
                                            // Add this height to the total
                                            totalHeightDifference += heightDiff7;
                                        }
                                        // Clamp the height difference to positive values only
                                        else { heightDiff7 = 0f; }
                                    }
                                    // Top-centre neighbour
                                    if (y < heightmapResolution - 1)
                                    {
                                        // Get height difference
                                        heightDiff8 = thisHeight - heightMap[x, y + 1] - waterMap[x, y + 1];
                                        // Only count positive height differences
                                        if (heightDiff8 > 0f)
                                        {
                                            // If this is greater than the current maximum height difference,
                                            // record it as the new maximum height
                                            if (heightDiff8 > maxHeightDifference) { maxHeightDifference = heightDiff8; }
                                            // Add this height to the total
                                            totalHeightDifference += heightDiff8;
                                        }
                                        // Clamp the height difference to positive values only
                                        else { heightDiff8 = 0f; }
                                    }

                    #endregion Calculate Height Totals

                    #region Distribute Heights

                                    // REQUIRES COMMENTS

                                    // If material slippage should occur, distiribute the difference in height between
                                    // this cell and the lowest neighbouring cell between its lower neighbours
                                    // The amount of distributed material is proportional to the height difference
                                    if (totalHeightDifference > 0f)
                                    {
                                        // TEST: Changed temp maps to actual maps

                                        //totalWaterToRemove = totalHeightDifference * 0.5f;
                                        // WHY DOES THIS NEED TO BE 0.2???
                                        totalWaterToRemove = totalHeightDifference * 0.5f;
                                        // Don't remove more water than the water level
                                        if (totalWaterToRemove > thisWaterLevel) { totalWaterToRemove = thisWaterLevel; }

                                        // Scale the height difference based on user-chosen erosion strength
                                        // Also halve the value as we want to remove half the difference from this cell
                                        // to equalise it with its neighbours
                                        //maxHeightDifference *= teErosionStrength * 0.5f;

                                        totalSedimentToRemove = (totalWaterToRemove / thisWaterLevel) * sedimentMap[x, y];

                                        // Remove the water and sediment from this cell
                                        //tempHeightMap[x, y] -= maxHeightDifference;
                                        waterMap[x, y] -= totalWaterToRemove;
                                        sedimentMap[x, y] -= totalSedimentToRemove;

                                        // Add the material to the neighbouring cells

                                        // This scalar is calculated now for performance
                                        // Full equation is: 
                                        // height += maxHeightDifference * (heightDiffX / totalHeightDifference)
                                        //heightDifferenceScalar = maxHeightDifference / totalHeightDifference;

                                        // Loop through 8 neighbours
                                        // Distribute water and sediment in proportion to their height differences



                                        // Left column
                                        if (x > 0)
                                        {
                                            // Bottom-left neighbour
                                            if (y > 0)
                                            {
                                                // Water only flows downhill, so exclude heights above this cell
                                                if (heightDiff1 > 0f)
                                                {
                                                    // Get the proportion of the water distributed to this cell
                                                    waterDistributionProportion = heightDiff1 / totalHeightDifference;
                                                    // Distribute the water and sediment
                                                    waterMap[x - 1, y - 1] += totalWaterToRemove * waterDistributionProportion;
                                                    sedimentMap[x - 1, y - 1] += totalSedimentToRemove * waterDistributionProportion;
                                                }
                                            }
                                            // Top-left neighbour
                                            if (y < heightmapResolution - 1)
                                            {
                                                // Water only flows downhill, so exclude heights above this cell
                                                if (heightDiff2 > 0f)
                                                {
                                                    // Get the proportion of the water distributed to this cell
                                                    waterDistributionProportion = heightDiff2 / totalHeightDifference;
                                                    // Distribute the water and sediment
                                                    waterMap[x - 1, y + 1] += totalWaterToRemove * waterDistributionProportion;
                                                    sedimentMap[x - 1, y + 1] += totalSedimentToRemove * waterDistributionProportion;
                                                }
                                            }
                                            // Centre-left neighbour
                                            // Water only flows downhill, so exclude heights above this cell
                                            if (heightDiff3 > 0f)
                                            {
                                                // Get the proportion of the water distributed to this cell
                                                waterDistributionProportion = heightDiff3 / totalHeightDifference;
                                                // Distribute the water and sediment
                                                waterMap[x - 1, y] += totalWaterToRemove * waterDistributionProportion;
                                                sedimentMap[x - 1, y] += totalSedimentToRemove * waterDistributionProportion;
                                            }
                                        }
                                        // Right column
                                        if (x < heightmapResolution - 1)
                                        {
                                            // Bottom-right neighbour
                                            if (y > 0)
                                            {
                                                // Water only flows downhill, so exclude heights above this cell
                                                if (heightDiff4 > 0f)
                                                {
                                                    // Get the proportion of the water distributed to this cell
                                                    waterDistributionProportion = heightDiff4 / totalHeightDifference;
                                                    // Distribute the water and sediment
                                                    waterMap[x + 1, y - 1] += totalWaterToRemove * waterDistributionProportion;
                                                    sedimentMap[x + 1, y - 1] += totalSedimentToRemove * waterDistributionProportion;
                                                }
                                            }
                                            // Top-right neighbour
                                            if (y < heightmapResolution - 1)
                                            {
                                                // Water only flows downhill, so exclude heights above this cell
                                                if (heightDiff5 > 0f)
                                                {
                                                    // Get the proportion of the water distributed to this cell
                                                    waterDistributionProportion = heightDiff5 / totalHeightDifference;
                                                    // Distribute the water and sediment
                                                    waterMap[x + 1, y + 1] += totalWaterToRemove * waterDistributionProportion;
                                                    sedimentMap[x + 1, y + 1] += totalSedimentToRemove * waterDistributionProportion;
                                                }
                                            }
                                            // Centre-right neighbour
                                            // Water only flows downhill, so exclude heights above this cell
                                            if (heightDiff6 > 0f)
                                            {
                                                // Get the proportion of the water distributed to this cell
                                                waterDistributionProportion = heightDiff6 / totalHeightDifference;
                                                // Distribute the water and sediment
                                                waterMap[x + 1, y] += totalWaterToRemove * waterDistributionProportion;
                                                sedimentMap[x + 1, y] += totalSedimentToRemove * waterDistributionProportion;
                                            }
                                        }
                                        // Middle column
                                        // Bottom-centre neighbour
                                        if (y > 0)
                                        {
                                            // Water only flows downhill, so exclude heights above this cell
                                            if (heightDiff7 > 0f)
                                            {
                                                // Get the proportion of the water distributed to this cell
                                                waterDistributionProportion = heightDiff7 / totalHeightDifference;
                                                // Distribute the water and sediment
                                                waterMap[x, y - 1] += totalWaterToRemove * waterDistributionProportion;
                                                sedimentMap[x, y - 1] += totalSedimentToRemove * waterDistributionProportion;
                                            }
                                        }
                                        // Top-centre neighbour
                                        if (y < heightmapResolution - 1)
                                        {
                                            // Water only flows downhill, so exclude heights above this cell
                                            if (heightDiff8 > 0f)
                                            {
                                                // Get the proportion of the water distributed to this cell
                                                waterDistributionProportion = heightDiff8 / totalHeightDifference;
                                                // Distribute the water and sediment
                                                waterMap[x, y + 1] += totalWaterToRemove * waterDistributionProportion;
                                                sedimentMap[x, y + 1] += totalSedimentToRemove * waterDistributionProportion;
                                            }
                                        }
                                    }

                    #endregion Distribute Heights
                                }
                            }
                        }

                        //// Copy water map data
                        //for (int x = 0; x < heightmapResolution; x++) { for (int y = 0; y < heightmapResolution; y++) { waterMap[x, y] = tempWaterMap[x, y]; } }

                        //// Copy sediment map data
                        //for (int x = 0; x < heightmapResolution; x++) { for (int y = 0; y < heightmapResolution; y++) { sedimentMap[x, y] = tempSedimentMap[x, y]; } }

                        // Copy water map data
                        for (x = 0; x < heightmapResolution; x++) { for (y = 0; y < heightmapResolution; y++) { tempWaterMap[x, y] = waterMap[x, y]; } }

                        // Copy sediment map data
                        for (x = 0; x < heightmapResolution; x++) { for (y = 0; y < heightmapResolution; y++) { tempSedimentMap[x, y] = sedimentMap[x, y]; } }

                    #endregion Transportation

                    #region Evaporation and Deposition

                        // Loop through points in the height map
                        for (x = 0; x < heightmapResolution; x++)
                        {
                            for (y = 0; y < heightmapResolution; y++)
                            {
                                // Decrease the water level as water evaporates
                                thisWaterLevel = waterMap[x, y] * (1f - heEvaporation);
                                waterMap[x, y] = thisWaterLevel;
                                tempWaterMap[x, y] = thisWaterLevel;

                                // Deposit sediment that cannot be carried by the water present
                                sedimentToDeposit = sedimentMap[x, y] - (heCarryingCapacity * thisWaterLevel);
                                if (sedimentToDeposit > 0f)
                                {
                                    heightMap[x, y] += sedimentToDeposit;
                                    tempHeightMap[x, y] += sedimentToDeposit;
                                    sedimentMap[x, y] -= sedimentToDeposit;
                                    tempSedimentMap[x, y] -= sedimentToDeposit;
                                }
                            }
                        }

                    #endregion Evaporation and Deposition

                    }

                    // May not need this part: Investigate later...
                    // Add residual sediment back into heightmap
                    // Loop through points in the heightmap
                    for (x = 0; x < heightmapResolution; x++)
                    {
                        for (y = 0; y < heightmapResolution; y++)
                        {
                            heightMap[x, y] += sedimentMap[x, y];
                            // Also may not need this line, if temp height map remains unused after H erosion
                            tempHeightMap[x, y] += sedimentMap[x, y];
                        }
                    }
                }
#endif

                    #endregion Hydraulic Erosion 2D Array

                    #region Hydraulic Erosion 1D Array

#if true == false
                    if (useHydraulicErosion && false)
                    {
                        // TODO: Delete all commented code when done

                        //float[,] waterMap = new float[heightmapResolution, heightmapResolution];
                        //float[,] tempWaterMap = new float[heightmapResolution, heightmapResolution];
                        //float[,] sedimentMap = new float[heightmapResolution, heightmapResolution];
                        //float[,] tempSedimentMap = new float[heightmapResolution, heightmapResolution];

                        // TODO: Are temp water and sediment maps still entirely needed?

                        float[] landscapeWaterMap = new float[landscapeHeightsSize];
                        float[] tempLandscapeWaterMap = new float[landscapeHeightsSize];
                        float[] landscapeSedimentMap = new float[landscapeHeightsSize];
                        float[] tempLandscapeSedimentMap = new float[landscapeHeightsSize];

                        // Loop through iterations
                        for (int i = 0; i < heIterations; i++)
                        {
                    #region Rainfall and Erosion

                            // Loop through all points in the height map
                            for (mapIndex = 0; mapIndex < landscapeHeightsSize; mapIndex++)
                            {
                                // TODO: Try rainfall based on noise of position

                                // Add water due to rainfall
                                thisWaterLevel = landscapeWaterMap[mapIndex] + (heRainfall / 1000f);
                                landscapeWaterMap[mapIndex] = thisWaterLevel;
                                tempLandscapeWaterMap[mapIndex] = thisWaterLevel;

                                // Erode amount of soil proportional to the water level
                                erodedAmount = heStrength * thisWaterLevel;
                                maxErodedAmount = (heCarryingCapacity * thisWaterLevel) - landscapeSedimentMap[mapIndex];
                                // Don't erode more than can be dissolved in the water present
                                if (erodedAmount > maxErodedAmount) { erodedAmount = maxErodedAmount; }
                                // Don't erode more than the current height of the terrain
                                thisHeight = landscapeHeightmap[mapIndex];
                                if (erodedAmount > thisHeight) { erodedAmount = thisHeight; }
                                // Theoretically line below shouldn't be needed...
                                // CHECK THIS LATER
                                if (erodedAmount < 0f) { erodedAmount = 0f; }

                                // Update heightmap and sediment map
                                landscapeHeightmap[mapIndex] -= erodedAmount;
                                tempLandscapeHeightMap[mapIndex] -= erodedAmount;
                                landscapeSedimentMap[mapIndex] += erodedAmount;
                                tempLandscapeSedimentMap[mapIndex] += erodedAmount;
                            }

                    #endregion Rainfall and Erosion

                    #region Transportation

                            // Loop through all points in the height map
                            for (mapIndex = 0; mapIndex < landscapeHeightsSize; mapIndex++)
                            {
                                // Get x and y coordinates from heightmap array index
                                x = mapIndex % heightmapResolution;
                                y = (mapIndex - x) / heightmapResolution;

                                // WARNING: Copied from thermal erosion code (and from 2D code)

                                thisWaterLevel = landscapeWaterMap[mapIndex];

                                if (thisWaterLevel > 0f)
                                {
                                    thisHeight = landscapeHeightmap[mapIndex] + thisWaterLevel;
                                    totalHeightDifference = 0f;

                                    // TODO: Currently unused
                                    maxHeightDifference = 0f;

                    #region Calculate Height Totals

                                    // Loop through 8 neighbours
                                    // TODO: NEED TO REWRITE
                                    // 1. Find height difference relative to talus height for each neighbour
                                    // 2. Find max height difference
                                    // 3. Find the total height difference
                                    // Height difference only counts neighbours which are more than the talus
                                    // height below the current cell

                                    // Currently not using max height

                                    // Left column
                                    if (x > 0)
                                    {
                                        // Bottom-left neighbour
                                        if (y > 0)
                                        {
                                            // Get height difference
                                            heightDiff1 = thisHeight - landscapeHeightmap[mapIndex - heightmapResolution - 1] - landscapeWaterMap[mapIndex - heightmapResolution - 1];
                                            // Only count positive height differences
                                            if (heightDiff1 > 0f)
                                            {
                                                // If this is greater than the current maximum height difference,
                                                // record it as the new maximum height
                                                if (heightDiff1 > maxHeightDifference) { maxHeightDifference = heightDiff1; }
                                                // Add this height to the total
                                                totalHeightDifference += heightDiff1;
                                            }
                                            // Clamp the height difference to positive values only
                                            else { heightDiff1 = 0f; }
                                        }
                                        // Top-left neighbour
                                        if (y < heightmapResolution - 1)
                                        {
                                            // Get height difference
                                            heightDiff2 = thisHeight - landscapeHeightmap[mapIndex + heightmapResolution - 1] - landscapeWaterMap[mapIndex + heightmapResolution - 1];
                                            // Only count positive height differences
                                            if (heightDiff2 > 0f)
                                            {
                                                // If this is greater than the current maximum height difference,
                                                // record it as the new maximum height
                                                if (heightDiff2 > maxHeightDifference) { maxHeightDifference = heightDiff2; }
                                                // Add this height to the total
                                                totalHeightDifference += heightDiff2;
                                            }
                                            // Clamp the height difference to positive values only
                                            else { heightDiff2 = 0f; }
                                        }
                                        // Centre-left neighbour
                                        // Get height difference
                                        heightDiff3 = thisHeight - landscapeHeightmap[mapIndex - 1] - landscapeWaterMap[mapIndex - 1];
                                        // Only count positive height differences
                                        if (heightDiff3 > 0f)
                                        {
                                            // If this is greater than the current maximum height difference,
                                            // record it as the new maximum height
                                            if (heightDiff3 > maxHeightDifference) { maxHeightDifference = heightDiff3; }
                                            // Add this height to the total
                                            totalHeightDifference += heightDiff3;
                                        }
                                        // Clamp the height difference to positive values only
                                        else { heightDiff3 = 0f; }
                                    }
                                    // Right column
                                    if (x < heightmapResolution - 1)
                                    {
                                        // Bottom-right neighbour
                                        if (y > 0)
                                        {
                                            // Get height difference
                                            heightDiff4 = thisHeight - landscapeHeightmap[mapIndex - heightmapResolution + 1] - landscapeWaterMap[mapIndex - heightmapResolution + 1];
                                            // Only count positive height differences
                                            if (heightDiff4 > 0f)
                                            {
                                                // If this is greater than the current maximum height difference,
                                                // record it as the new maximum height
                                                if (heightDiff4 > maxHeightDifference) { maxHeightDifference = heightDiff4; }
                                                // Add this height to the total
                                                totalHeightDifference += heightDiff4;
                                            }
                                            // Clamp the height difference to positive values only
                                            else { heightDiff4 = 0f; }
                                        }
                                        // Top-right neighbour
                                        if (y < heightmapResolution - 1)
                                        {
                                            // Get height difference
                                            heightDiff5 = thisHeight - landscapeHeightmap[mapIndex + heightmapResolution + 1] - landscapeWaterMap[mapIndex + heightmapResolution + 1];
                                            // Only count positive height differences
                                            if (heightDiff5 > 0f)
                                            {
                                                // If this is greater than the current maximum height difference,
                                                // record it as the new maximum height
                                                if (heightDiff5 > maxHeightDifference) { maxHeightDifference = heightDiff5; }
                                                // Add this height to the total
                                                totalHeightDifference += heightDiff5;
                                            }
                                            // Clamp the height difference to positive values only
                                            else { heightDiff5 = 0f; }
                                        }
                                        // Centre-right neighbour
                                        // Get height difference
                                        heightDiff6 = thisHeight - landscapeHeightmap[mapIndex + 1] - landscapeWaterMap[mapIndex + 1];
                                        // Only count positive height differences
                                        if (heightDiff6 > 0f)
                                        {
                                            // If this is greater than the current maximum height difference,
                                            // record it as the new maximum height
                                            if (heightDiff6 > maxHeightDifference) { maxHeightDifference = heightDiff6; }
                                            // Add this height to the total
                                            totalHeightDifference += heightDiff6;
                                        }
                                        // Clamp the height difference to positive values only
                                        else { heightDiff6 = 0f; }
                                    }
                                    // Middle column
                                    // Bottom-centre neighbour
                                    if (y > 0)
                                    {
                                        // Get height difference
                                        heightDiff7 = thisHeight - landscapeHeightmap[mapIndex - heightmapResolution] - landscapeWaterMap[mapIndex - heightmapResolution];
                                        // Only count positive height differences
                                        if (heightDiff7 > 0f)
                                        {
                                            // If this is greater than the current maximum height difference,
                                            // record it as the new maximum height
                                            if (heightDiff7 > maxHeightDifference) { maxHeightDifference = heightDiff7; }
                                            // Add this height to the total
                                            totalHeightDifference += heightDiff7;
                                        }
                                        // Clamp the height difference to positive values only
                                        else { heightDiff7 = 0f; }
                                    }
                                    // Top-centre neighbour
                                    if (y < heightmapResolution - 1)
                                    {
                                        // Get height difference
                                        heightDiff8 = thisHeight - landscapeHeightmap[mapIndex + heightmapResolution] - landscapeWaterMap[mapIndex + heightmapResolution];
                                        // Only count positive height differences
                                        if (heightDiff8 > 0f)
                                        {
                                            // If this is greater than the current maximum height difference,
                                            // record it as the new maximum height
                                            if (heightDiff8 > maxHeightDifference) { maxHeightDifference = heightDiff8; }
                                            // Add this height to the total
                                            totalHeightDifference += heightDiff8;
                                        }
                                        // Clamp the height difference to positive values only
                                        else { heightDiff8 = 0f; }
                                    }

                    #endregion Calculate Height Totals

                    #region Distribute Heights

                                    // TODO: REQUIRES COMMENTS

                                    // If material slippage should occur, distribute the difference in height between
                                    // this cell and the lowest neighbouring cell between its lower neighbours
                                    // The amount of distributed material is proportional to the height difference
                                    if (totalHeightDifference > 0f)
                                    {
                                        // TEST: Changed temp maps to actual maps

                                        totalWaterToRemove = totalHeightDifference * 0.5f;
                                        // Don't remove more water than the water level
                                        if (totalWaterToRemove > thisWaterLevel) { totalWaterToRemove = thisWaterLevel; }

                                        // Scale the height difference based on user-chosen erosion strength
                                        // Also halve the value as we want to remove half the difference from this cell
                                        // to equalise it with its neighbours
                                        //maxHeightDifference *= teErosionStrength * 0.5f;

                                        totalSedimentToRemove = (totalWaterToRemove / thisWaterLevel) * landscapeSedimentMap[mapIndex];

                                        // Remove the water and sediment from this cell
                                        //tempHeightMap[x, y] -= maxHeightDifference;
                                        landscapeWaterMap[mapIndex] -= totalWaterToRemove;
                                        landscapeSedimentMap[mapIndex] -= totalSedimentToRemove;

                                        // Add the material to the neighbouring cells

                                        // This scalar is calculated now for performance
                                        // Full equation is: 
                                        // height += maxHeightDifference * (heightDiffX / totalHeightDifference)
                                        //heightDifferenceScalar = maxHeightDifference / totalHeightDifference;

                                        // Loop through 8 neighbours
                                        // Distribute water and sediment in proportion to their height differences

                                        // Left column
                                        if (x > 0)
                                        {
                                            // Bottom-left neighbour
                                            if (y > 0)
                                            {
                                                // Water only flows downhill, so exclude heights above this cell
                                                if (heightDiff1 > 0f)
                                                {
                                                    // Get the proportion of the water distributed to this cell
                                                    waterDistributionProportion = heightDiff1 / totalHeightDifference;
                                                    // Distribute the water and sediment
                                                    landscapeWaterMap[mapIndex - heightmapResolution - 1] += totalWaterToRemove * waterDistributionProportion;
                                                    landscapeSedimentMap[mapIndex - heightmapResolution - 1] += totalSedimentToRemove * waterDistributionProportion;
                                                }
                                            }
                                            // Top-left neighbour
                                            if (y < heightmapResolution - 1)
                                            {
                                                // Water only flows downhill, so exclude heights above this cell
                                                if (heightDiff2 > 0f)
                                                {
                                                    // Get the proportion of the water distributed to this cell
                                                    waterDistributionProportion = heightDiff2 / totalHeightDifference;
                                                    // Distribute the water and sediment
                                                    landscapeWaterMap[mapIndex + heightmapResolution - 1] += totalWaterToRemove * waterDistributionProportion;
                                                    landscapeSedimentMap[mapIndex + heightmapResolution - 1] += totalSedimentToRemove * waterDistributionProportion;
                                                }
                                            }
                                            // Centre-left neighbour
                                            // Water only flows downhill, so exclude heights above this cell
                                            if (heightDiff3 > 0f)
                                            {
                                                // Get the proportion of the water distributed to this cell
                                                waterDistributionProportion = heightDiff3 / totalHeightDifference;
                                                // Distribute the water and sediment
                                                landscapeWaterMap[mapIndex - 1] += totalWaterToRemove * waterDistributionProportion;
                                                landscapeSedimentMap[mapIndex - 1] += totalSedimentToRemove * waterDistributionProportion;
                                            }
                                        }
                                        // Right column
                                        if (x < heightmapResolution - 1)
                                        {
                                            // Bottom-right neighbour
                                            if (y > 0)
                                            {
                                                // Water only flows downhill, so exclude heights above this cell
                                                if (heightDiff4 > 0f)
                                                {
                                                    // Get the proportion of the water distributed to this cell
                                                    waterDistributionProportion = heightDiff4 / totalHeightDifference;
                                                    // Distribute the water and sediment
                                                    landscapeWaterMap[mapIndex - heightmapResolution + 1] += totalWaterToRemove * waterDistributionProportion;
                                                    landscapeSedimentMap[mapIndex - heightmapResolution + 1] += totalSedimentToRemove * waterDistributionProportion;
                                                }
                                            }
                                            // Top-right neighbour
                                            if (y < heightmapResolution - 1)
                                            {
                                                // Water only flows downhill, so exclude heights above this cell
                                                if (heightDiff5 > 0f)
                                                {
                                                    // Get the proportion of the water distributed to this cell
                                                    waterDistributionProportion = heightDiff5 / totalHeightDifference;
                                                    // Distribute the water and sediment
                                                    landscapeWaterMap[mapIndex + heightmapResolution + 1] += totalWaterToRemove * waterDistributionProportion;
                                                    landscapeSedimentMap[mapIndex + heightmapResolution + 1] += totalSedimentToRemove * waterDistributionProportion;
                                                }
                                            }
                                            // Centre-right neighbour
                                            // Water only flows downhill, so exclude heights above this cell
                                            if (heightDiff6 > 0f)
                                            {
                                                // Get the proportion of the water distributed to this cell
                                                waterDistributionProportion = heightDiff6 / totalHeightDifference;
                                                // Distribute the water and sediment
                                                landscapeWaterMap[mapIndex + 1] += totalWaterToRemove * waterDistributionProportion;
                                                landscapeSedimentMap[mapIndex + 1] += totalSedimentToRemove * waterDistributionProportion;
                                            }
                                        }
                                        // Middle column
                                        // Bottom-centre neighbour
                                        if (y > 0)
                                        {
                                            // Water only flows downhill, so exclude heights above this cell
                                            if (heightDiff7 > 0f)
                                            {
                                                // Get the proportion of the water distributed to this cell
                                                waterDistributionProportion = heightDiff7 / totalHeightDifference;
                                                // Distribute the water and sediment
                                                landscapeWaterMap[mapIndex - heightmapResolution] += totalWaterToRemove * waterDistributionProportion;
                                                landscapeSedimentMap[mapIndex - heightmapResolution] += totalSedimentToRemove * waterDistributionProportion;
                                            }
                                        }
                                        // Top-centre neighbour
                                        if (y < heightmapResolution - 1)
                                        {
                                            // Water only flows downhill, so exclude heights above this cell
                                            if (heightDiff8 > 0f)
                                            {
                                                // Get the proportion of the water distributed to this cell
                                                waterDistributionProportion = heightDiff8 / totalHeightDifference;
                                                // Distribute the water and sediment
                                                landscapeWaterMap[mapIndex + heightmapResolution] += totalWaterToRemove * waterDistributionProportion;
                                                landscapeSedimentMap[mapIndex + heightmapResolution] += totalSedimentToRemove * waterDistributionProportion;
                                            }
                                        }
                                    }

                    #endregion Distribute Heights
                                }
                            }

                            // TODO: Is this needed? If the temp data is never read from, theoretically it shouldn't be...
                            // Copy water map data
                            System.Buffer.BlockCopy(landscapeWaterMap, 0, tempLandscapeWaterMap, 0, landscapeHeightsSize * sizeof(float));
                            // Copy sediment map data
                            System.Buffer.BlockCopy(landscapeSedimentMap, 0, tempLandscapeSedimentMap, 0, landscapeHeightsSize * sizeof(float));

                    #endregion Transportation

                    #region Evaporation and Deposition

                            // Loop through all points in the height map
                            for (mapIndex = 0; mapIndex < landscapeHeightsSize; mapIndex++)
                            {
                                // Decrease the water level as water evaporates
                                thisWaterLevel = landscapeWaterMap[mapIndex] * (1f - heEvaporation);
                                landscapeWaterMap[mapIndex] = thisWaterLevel;
                                // TODO: Again, do we need to set temp values if they are never read from?
                                tempLandscapeWaterMap[mapIndex] = thisWaterLevel;

                                // Deposit sediment that cannot be carried by the water present
                                sedimentToDeposit = landscapeSedimentMap[mapIndex] - (heCarryingCapacity * thisWaterLevel);
                                if (sedimentToDeposit > 0f)
                                {
                                    // TODO: More temp maps written to...?
                                    landscapeHeightmap[mapIndex] += sedimentToDeposit;
                                    tempLandscapeHeightMap[mapIndex] += sedimentToDeposit;
                                    landscapeSedimentMap[mapIndex] -= sedimentToDeposit;
                                    tempLandscapeSedimentMap[mapIndex] -= sedimentToDeposit;
                                }
                            }

                    #endregion Evaporation and Deposition
                        }

                        // TODO: May not need this part: Investigate later...
                        // Add residual sediment back into heightmap
                        // Loop through all points in the height map
                        for (mapIndex = 0; mapIndex < landscapeHeightsSize; mapIndex++)
                        {
                            //landscapeHeightmap[mapIndex] += landscapeSedimentMap[mapIndex];
                            // Also may not need this line, if temp height map remains unused after H erosion
                            //tempLandscapeHeightMap[mapIndex] += landscapeSedimentMap[mapIndex];
                        }
                    }
#endif

                    #endregion Hydraulic Erosion 1D Array

                    #region Hydraulic Erosion 1D Array (Experimental)

#if true == false

                    if (useHydraulicErosion && false)
                    {
                        // TODO: Delete all commented code when done

                        //float[,] waterMap = new float[heightmapResolution, heightmapResolution];
                        //float[,] tempWaterMap = new float[heightmapResolution, heightmapResolution];
                        //float[,] sedimentMap = new float[heightmapResolution, heightmapResolution];
                        //float[,] tempSedimentMap = new float[heightmapResolution, heightmapResolution];

                        // TODO: Are temp water and sediment maps still entirely needed?

                        float[] landscapeWaterMap = new float[landscapeHeightsSize];
                        //float[] tempLandscapeWaterMap = new float[landscapeHeightsSize];
                        float[] landscapeSedimentMap = new float[landscapeHeightsSize];
                        //float[] tempLandscapeSedimentMap = new float[landscapeHeightsSize];

                        // Experimental maps
                        float[] landscapeWaterDiffMap = new float[landscapeHeightsSize];
                        float[] landscapeSedimentDiffMap = new float[landscapeHeightsSize];

                        // Loop through iterations
                        for (int i = 0; i < heIterations; i++)
                        {
                    #region Rainfall and Erosion

                            // Loop through all points in the height map
                            for (mapIndex = 0; mapIndex < landscapeHeightsSize; mapIndex++)
                            {
                                // TODO: Try rainfall based on noise of position

                                // Add water due to rainfall
                                thisWaterLevel = landscapeWaterMap[mapIndex] + (heRainfall / 1000f);
                                landscapeWaterMap[mapIndex] = thisWaterLevel;
                                //tempLandscapeWaterMap[mapIndex] = thisWaterLevel;

                                // Erode amount of soil proportional to the water level
                                erodedAmount = heStrength * thisWaterLevel;
                                maxErodedAmount = (heCarryingCapacity * thisWaterLevel) - landscapeSedimentMap[mapIndex];
                                // Don't erode more than can be dissolved in the water present
                                if (erodedAmount > maxErodedAmount) { erodedAmount = maxErodedAmount; }
                                // Don't erode more than the current height of the terrain
                                thisHeight = landscapeHeightmap[mapIndex];
                                if (erodedAmount > thisHeight) { erodedAmount = thisHeight; }
                                // Theoretically line below shouldn't be needed...
                                // CHECK THIS LATER
                                if (erodedAmount < 0f) { erodedAmount = 0f; }

                                // Update heightmap and sediment map
                                landscapeHeightmap[mapIndex] -= erodedAmount;
                                //tempLandscapeHeightMap[mapIndex] -= erodedAmount;
                                landscapeSedimentMap[mapIndex] += erodedAmount;
                                //tempLandscapeSedimentMap[mapIndex] += erodedAmount;

                                // Set water/sediment difference maps to zero in preparation for transportation step
                                landscapeWaterDiffMap[mapIndex] = 0f;
                                landscapeSedimentDiffMap[mapIndex] = 0f;
                            }

                    #endregion Rainfall and Erosion

                    #region Transportation

                            // Loop through all points in the height map
                            for (mapIndex = 0; mapIndex < landscapeHeightsSize; mapIndex++)
                            {
                                // Get x and y coordinates from heightmap array index
                                x = mapIndex % heightmapResolution;
                                y = (mapIndex - x) / heightmapResolution;

                                // WARNING: Copied from thermal erosion code (and from 2D code)

                                thisWaterLevel = landscapeWaterMap[mapIndex];

                                if (thisWaterLevel > 0f)
                                {
                                    thisHeight = landscapeHeightmap[mapIndex] + thisWaterLevel;
                                    totalHeightDifference = 0f;
                                    totalHeight = 0f;
                                    numberOfSampledCells = 0;

                                    minHeightDifference = 100000f;

                                    // TODO: Currently unused
                                    maxHeightDifference = 0f;

                    #region Calculate Height Totals

                                    // Loop through 8 neighbours
                                    // TODO: NEED TO REWRITE
                                    // 1. Find height difference relative to talus height for each neighbour
                                    // 2. Find max height difference
                                    // 3. Find the total height difference
                                    // Height difference only counts neighbours which are more than the talus
                                    // height below the current cell

                                    // TODO: Currently not using max height, eventually remove if statements in next 8 blocks

                                    // Left column
                                    if (x > 0)
                                    {
                                        // Bottom-left neighbour
                                        if (y > 0)
                                        {
                                            // Get height difference of water levels between these two cells
                                            thisSurroundingHeight = landscapeHeightmap[mapIndex - heightmapResolution - 1] + landscapeWaterMap[mapIndex - heightmapResolution - 1];
                                            heightDiff1 = thisHeight - thisSurroundingHeight;
                                            // Only count positive height differences
                                            if (heightDiff1 > 0f)
                                            {
                                                // If this is greater than the current maximum height difference,
                                                // record it as the new maximum height
                                                if (heightDiff1 > maxHeightDifference) { maxHeightDifference = heightDiff1; }
                                                if (heightDiff1 < minHeightDifference) { minHeightDifference = heightDiff1; }
                                                // Add this height difference to the total
                                                totalHeightDifference += heightDiff1;
                                                // Add this height to the total
                                                totalHeight += thisSurroundingHeight;
                                                numberOfSampledCells++;
                                            }
                                            // Clamp the height difference to positive values only
                                            else { heightDiff1 = 0f; }
                                        }
                                        // Top-left neighbour
                                        if (y < heightmapResolution - 1)
                                        {
                                            // Get height difference of water levels between these two cells
                                            thisSurroundingHeight = landscapeHeightmap[mapIndex + heightmapResolution - 1] + landscapeWaterMap[mapIndex + heightmapResolution - 1];
                                            heightDiff2 = thisHeight - thisSurroundingHeight;
                                            // Only count positive height differences
                                            if (heightDiff2 > 0f)
                                            {
                                                // If this is greater than the current maximum height difference,
                                                // record it as the new maximum height
                                                if (heightDiff2 > maxHeightDifference) { maxHeightDifference = heightDiff2; }
                                                if (heightDiff2 < minHeightDifference) { minHeightDifference = heightDiff2; }
                                                // Add this height difference to the total
                                                totalHeightDifference += heightDiff2;
                                                // Add this height to the total
                                                totalHeight += thisSurroundingHeight;
                                                numberOfSampledCells++;
                                            }
                                            // Clamp the height difference to positive values only
                                            else { heightDiff2 = 0f; }
                                        }
                                        // Centre-left neighbour
                                        // Get height difference of water levels between these two cells
                                        thisSurroundingHeight = landscapeHeightmap[mapIndex - 1] + landscapeWaterMap[mapIndex - 1];
                                        heightDiff3 = thisHeight - thisSurroundingHeight;
                                        // Only count positive height differences
                                        if (heightDiff3 > 0f)
                                        {
                                            // If this is greater than the current maximum height difference,
                                            // record it as the new maximum height
                                            if (heightDiff3 > maxHeightDifference) { maxHeightDifference = heightDiff3; }
                                            if (heightDiff3 < minHeightDifference) { minHeightDifference = heightDiff3; }
                                            // Add this height difference to the total
                                            totalHeightDifference += heightDiff3;
                                            // Add this height to the total
                                            totalHeight += thisSurroundingHeight;
                                            numberOfSampledCells++;
                                        }
                                        // Clamp the height difference to positive values only
                                        else { heightDiff3 = 0f; }
                                    }
                                    // Right column
                                    if (x < heightmapResolution - 1)
                                    {
                                        // Bottom-right neighbour
                                        if (y > 0)
                                        {
                                            // Get height difference of water levels between these two cells
                                            thisSurroundingHeight = landscapeHeightmap[mapIndex - heightmapResolution + 1] + landscapeWaterMap[mapIndex - heightmapResolution + 1];
                                            heightDiff4 = thisHeight - thisSurroundingHeight;
                                            // Only count positive height differences
                                            if (heightDiff4 > 0f)
                                            {
                                                // If this is greater than the current maximum height difference,
                                                // record it as the new maximum height
                                                if (heightDiff4 > maxHeightDifference) { maxHeightDifference = heightDiff4; }
                                                if (heightDiff4 < minHeightDifference) { minHeightDifference = heightDiff4; }
                                                // Add this height difference to the total
                                                totalHeightDifference += heightDiff4;
                                                // Add this height to the total
                                                totalHeight += thisSurroundingHeight;
                                                numberOfSampledCells++;
                                            }
                                            // Clamp the height difference to positive values only
                                            else { heightDiff4 = 0f; }
                                        }
                                        // Top-right neighbour
                                        if (y < heightmapResolution - 1)
                                        {
                                            // Get height difference of water levels between these two cells
                                            thisSurroundingHeight = landscapeHeightmap[mapIndex + heightmapResolution + 1] + landscapeWaterMap[mapIndex + heightmapResolution + 1];
                                            heightDiff5 = thisHeight - thisSurroundingHeight;
                                            // Only count positive height differences
                                            if (heightDiff5 > 0f)
                                            {
                                                // If this is greater than the current maximum height difference,
                                                // record it as the new maximum height
                                                if (heightDiff5 > maxHeightDifference) { maxHeightDifference = heightDiff5; }
                                                if (heightDiff5 < minHeightDifference) { minHeightDifference = heightDiff5; }
                                                // Add this height difference to the total
                                                totalHeightDifference += heightDiff5;
                                                // Add this height to the total
                                                totalHeight += thisSurroundingHeight;
                                                numberOfSampledCells++;
                                            }
                                            // Clamp the height difference to positive values only
                                            else { heightDiff5 = 0f; }
                                        }
                                        // Centre-right neighbour
                                        // Get height difference of water levels between these two cells
                                        thisSurroundingHeight = landscapeHeightmap[mapIndex + 1] + landscapeWaterMap[mapIndex + 1];
                                        heightDiff6 = thisHeight - thisSurroundingHeight;
                                        // Only count positive height differences
                                        if (heightDiff6 > 0f)
                                        {
                                            // If this is greater than the current maximum height difference,
                                            // record it as the new maximum height
                                            if (heightDiff6 > maxHeightDifference) { maxHeightDifference = heightDiff6; }
                                            if (heightDiff6 < minHeightDifference) { minHeightDifference = heightDiff6; }
                                            // Add this height difference to the total
                                            totalHeightDifference += heightDiff6;
                                            // Add this height to the total
                                            totalHeight += thisSurroundingHeight;
                                            numberOfSampledCells++;
                                        }
                                        // Clamp the height difference to positive values only
                                        else { heightDiff6 = 0f; }
                                    }
                                    // Middle column
                                    // Bottom-centre neighbour
                                    if (y > 0)
                                    {
                                        // Get height difference of water levels between these two cells
                                        thisSurroundingHeight = landscapeHeightmap[mapIndex - heightmapResolution] + landscapeWaterMap[mapIndex - heightmapResolution];
                                        heightDiff7 = thisHeight - thisSurroundingHeight;
                                        // Only count positive height differences
                                        if (heightDiff7 > 0f)
                                        {
                                            // If this is greater than the current maximum height difference,
                                            // record it as the new maximum height
                                            if (heightDiff7 > maxHeightDifference) { maxHeightDifference = heightDiff7; }
                                            if (heightDiff7 < minHeightDifference) { minHeightDifference = heightDiff7; }
                                            // Add this height difference to the total
                                            totalHeightDifference += heightDiff7;
                                            // Add this height to the total
                                            totalHeight += thisSurroundingHeight;
                                            numberOfSampledCells++;
                                        }
                                        // Clamp the height difference to positive values only
                                        else { heightDiff7 = 0f; }
                                    }
                                    // Top-centre neighbour
                                    if (y < heightmapResolution - 1)
                                    {
                                        // Get height difference of water levels between these two cells
                                        thisSurroundingHeight = landscapeHeightmap[mapIndex + heightmapResolution] + landscapeWaterMap[mapIndex + heightmapResolution];
                                        heightDiff8 = thisHeight - thisSurroundingHeight;
                                        // Only count positive height differences
                                        if (heightDiff8 > 0f)
                                        {
                                            // If this is greater than the current maximum height difference,
                                            // record it as the new maximum height
                                            if (heightDiff8 > maxHeightDifference) { maxHeightDifference = heightDiff8; }
                                            if (heightDiff8 < minHeightDifference) { minHeightDifference = heightDiff8; }
                                            // Add this height difference to the total
                                            totalHeightDifference += heightDiff8;
                                            // Add this height to the total
                                            totalHeight += thisSurroundingHeight;
                                            numberOfSampledCells++;
                                        }
                                        // Clamp the height difference to positive values only
                                        else { heightDiff8 = 0f; }
                                    }

                    #endregion Calculate Height Totals

                    #region Distribute Heights

                                    // TODO: REQUIRES NEW COMMENTS

                                    // If material slippage should occur, distribute the difference in height between
                                    // this cell and the lowest neighbouring cell between its lower neighbours
                                    // The amount of distributed material is proportional to the height difference
                                    if (totalHeightDifference > 0f && numberOfSampledCells > 0)
                                    {
                                        // TEST: Changed temp maps to actual maps

                                        // Original code: creates spikes
                                        //totalWaterToRemove = totalHeightDifference * 0.5f;
                                        //// Don't remove more water than the water level
                                        //if (totalWaterToRemove > thisWaterLevel) { totalWaterToRemove = thisWaterLevel; }

                                        // The amount of water to be removed (i.e. transported) from this cell is the minimum of:
                                        // - The water in this cell
                                        // - The amount of water needed for it to reach the average water level
                                        //totalWaterToRemove = minHeightDifference * 0.5f;
                                        totalWaterToRemove = thisHeight - (totalHeight / (float)numberOfSampledCells);
                                        if (totalWaterToRemove > thisWaterLevel) { totalWaterToRemove = thisWaterLevel; }

                                        // Scale the height difference based on user-chosen erosion strength
                                        // Also halve the value as we want to remove half the difference from this cell
                                        // to equalise it with its neighbours
                                        //maxHeightDifference *= teErosionStrength * 0.5f;

                                        totalSedimentToRemove = (totalWaterToRemove / thisWaterLevel) * landscapeSedimentMap[mapIndex];

                                        // Remove the water and sediment from this cell
                                        //landscapeWaterMap[mapIndex] -= totalWaterToRemove;
                                        //landscapeSedimentMap[mapIndex] -= totalSedimentToRemove;
                                        landscapeWaterDiffMap[mapIndex] -= totalWaterToRemove;
                                        landscapeSedimentDiffMap[mapIndex] -= totalSedimentToRemove;

                                        // Add the material to the neighbouring cells

                                        // This scalar is calculated now for performance
                                        // Full equation is: 
                                        // height += maxHeightDifference * (heightDiffX / totalHeightDifference)
                                        //heightDifferenceScalar = maxHeightDifference / totalHeightDifference;

                                        // Loop through 8 neighbours
                                        // Distribute water and sediment in proportion to their height differences

                                        // Left column
                                        if (x > 0)
                                        {
                                            // Bottom-left neighbour
                                            if (y > 0)
                                            {
                                                // Water only flows downhill, so exclude heights above this cell
                                                if (heightDiff1 > 0f)
                                                {
                                                    // Get the proportion of the water distributed to this cell
                                                    waterDistributionProportion = heightDiff1 / totalHeightDifference;
                                                    // Distribute the water and sediment
                                                    landscapeWaterDiffMap[mapIndex - heightmapResolution - 1] += totalWaterToRemove * waterDistributionProportion;
                                                    landscapeSedimentDiffMap[mapIndex - heightmapResolution - 1] += totalSedimentToRemove * waterDistributionProportion;
                                                }
                                            }
                                            // Top-left neighbour
                                            if (y < heightmapResolution - 1)
                                            {
                                                // Water only flows downhill, so exclude heights above this cell
                                                if (heightDiff2 > 0f)
                                                {
                                                    // Get the proportion of the water distributed to this cell
                                                    waterDistributionProportion = heightDiff2 / totalHeightDifference;
                                                    // Distribute the water and sediment
                                                    landscapeWaterDiffMap[mapIndex + heightmapResolution - 1] += totalWaterToRemove * waterDistributionProportion;
                                                    landscapeSedimentDiffMap[mapIndex + heightmapResolution - 1] += totalSedimentToRemove * waterDistributionProportion;
                                                }
                                            }
                                            // Centre-left neighbour
                                            // Water only flows downhill, so exclude heights above this cell
                                            if (heightDiff3 > 0f)
                                            {
                                                // Get the proportion of the water distributed to this cell
                                                waterDistributionProportion = heightDiff3 / totalHeightDifference;
                                                // Distribute the water and sediment
                                                landscapeWaterDiffMap[mapIndex - 1] += totalWaterToRemove * waterDistributionProportion;
                                                landscapeSedimentDiffMap[mapIndex - 1] += totalSedimentToRemove * waterDistributionProportion;
                                            }
                                        }
                                        // Right column
                                        if (x < heightmapResolution - 1)
                                        {
                                            // Bottom-right neighbour
                                            if (y > 0)
                                            {
                                                // Water only flows downhill, so exclude heights above this cell
                                                if (heightDiff4 > 0f)
                                                {
                                                    // Get the proportion of the water distributed to this cell
                                                    waterDistributionProportion = heightDiff4 / totalHeightDifference;
                                                    // Distribute the water and sediment
                                                    landscapeWaterDiffMap[mapIndex - heightmapResolution + 1] += totalWaterToRemove * waterDistributionProportion;
                                                    landscapeSedimentDiffMap[mapIndex - heightmapResolution + 1] += totalSedimentToRemove * waterDistributionProportion;
                                                }
                                            }
                                            // Top-right neighbour
                                            if (y < heightmapResolution - 1)
                                            {
                                                // Water only flows downhill, so exclude heights above this cell
                                                if (heightDiff5 > 0f)
                                                {
                                                    // Get the proportion of the water distributed to this cell
                                                    waterDistributionProportion = heightDiff5 / totalHeightDifference;
                                                    // Distribute the water and sediment
                                                    landscapeWaterDiffMap[mapIndex + heightmapResolution + 1] += totalWaterToRemove * waterDistributionProportion;
                                                    landscapeSedimentDiffMap[mapIndex + heightmapResolution + 1] += totalSedimentToRemove * waterDistributionProportion;
                                                }
                                            }
                                            // Centre-right neighbour
                                            // Water only flows downhill, so exclude heights above this cell
                                            if (heightDiff6 > 0f)
                                            {
                                                // Get the proportion of the water distributed to this cell
                                                waterDistributionProportion = heightDiff6 / totalHeightDifference;
                                                // Distribute the water and sediment
                                                landscapeWaterDiffMap[mapIndex + 1] += totalWaterToRemove * waterDistributionProportion;
                                                landscapeSedimentDiffMap[mapIndex + 1] += totalSedimentToRemove * waterDistributionProportion;
                                            }
                                        }
                                        // Middle column
                                        // Bottom-centre neighbour
                                        if (y > 0)
                                        {
                                            // Water only flows downhill, so exclude heights above this cell
                                            if (heightDiff7 > 0f)
                                            {
                                                // Get the proportion of the water distributed to this cell
                                                waterDistributionProportion = heightDiff7 / totalHeightDifference;
                                                // Distribute the water and sediment
                                                landscapeWaterDiffMap[mapIndex - heightmapResolution] += totalWaterToRemove * waterDistributionProportion;
                                                landscapeSedimentDiffMap[mapIndex - heightmapResolution] += totalSedimentToRemove * waterDistributionProportion;
                                            }
                                        }
                                        // Top-centre neighbour
                                        if (y < heightmapResolution - 1)
                                        {
                                            // Water only flows downhill, so exclude heights above this cell
                                            if (heightDiff8 > 0f)
                                            {
                                                // Get the proportion of the water distributed to this cell
                                                waterDistributionProportion = heightDiff8 / totalHeightDifference;
                                                // Distribute the water and sediment
                                                landscapeWaterDiffMap[mapIndex + heightmapResolution] += totalWaterToRemove * waterDistributionProportion;
                                                landscapeSedimentDiffMap[mapIndex + heightmapResolution] += totalSedimentToRemove * waterDistributionProportion;
                                            }
                                        }
                                    }

                    #endregion Distribute Heights
                                }
                            }

                            //// TODO: Is this needed? If the temp data is never read from, theoretically it shouldn't be...
                            //// Copy water map data
                            //System.Buffer.BlockCopy(landscapeWaterMap, 0, tempLandscapeWaterMap, 0, landscapeHeightsSize * sizeof(float));
                            //// Copy sediment map data
                            //System.Buffer.BlockCopy(landscapeSedimentMap, 0, tempLandscapeSedimentMap, 0, landscapeHeightsSize * sizeof(float));

                    #endregion Transportation

                    #region Evaporation and Deposition

                            // Loop through all points in the height map
                            for (mapIndex = 0; mapIndex < landscapeHeightsSize; mapIndex++)
                            {
                                // Add water and sediment differences from the previous calculation
                                // TODO: Should probably combine this with another line for speed
                                landscapeWaterMap[mapIndex] += landscapeWaterDiffMap[mapIndex];
                                landscapeSedimentMap[mapIndex] += landscapeSedimentDiffMap[mapIndex];

                                // Decrease the water level as water evaporates
                                thisWaterLevel = landscapeWaterMap[mapIndex] * (1f - heEvaporation);
                                landscapeWaterMap[mapIndex] = thisWaterLevel;
                                // TODO: Again, do we need to set temp values if they are never read from?
                                //tempLandscapeWaterMap[mapIndex] = thisWaterLevel;

                                // Deposit sediment that cannot be carried by the water present
                                sedimentToDeposit = landscapeSedimentMap[mapIndex] - (heCarryingCapacity * thisWaterLevel);
                                if (sedimentToDeposit > 0f)
                                {
                                    // TODO: More temp maps written to...?
                                    landscapeHeightmap[mapIndex] += sedimentToDeposit;
                                    //tempLandscapeHeightMap[mapIndex] += sedimentToDeposit;
                                    landscapeSedimentMap[mapIndex] -= sedimentToDeposit;
                                    //tempLandscapeSedimentMap[mapIndex] -= sedimentToDeposit;
                                }
                            }

                    #endregion Evaporation and Deposition
                        }

                        // TODO: May not need this part: Investigate later...
                        // Add residual sediment back into heightmap
                        // Loop through all points in the height map
                        for (mapIndex = 0; mapIndex < landscapeHeightsSize; mapIndex++)
                        {
                            //landscapeHeightmap[mapIndex] += landscapeSedimentMap[mapIndex];
                            // Also may not need this line, if temp height map remains unused after H erosion
                            //tempLandscapeHeightMap[mapIndex] += landscapeSedimentMap[mapIndex];

                            //landscapeHeightmap[mapIndex] = landscapeWaterMap[mapIndex] * 10f;
                        }
                    }
#endif

                    #endregion Hydraulic Erosion 1D Array (Experimental)

                    #region Hydraulic Erosion 1D Array - Current

                    if (useHydraulicErosion && true)
                    {
                        // TODO: Delete all commented code when done

                        // State maps
                        float[] landscapeWaterMap = new float[landscapeHeightsSize];
                        float[] landscapeSedimentMap = new float[landscapeHeightsSize];

                        // Difference maps
                        float[] landscapeWaterDiffMap = new float[landscapeHeightsSize];
                        float[] landscapeSedimentDiffMap = new float[landscapeHeightsSize];

                        // Loop through iterations
                        for (int i = 0; i < heIterations; i++)
                        {
                            #region Rainfall and Erosion

                            // Loop through all points in the height map
                            for (mapIndex = 0; mapIndex < landscapeHeightsSize; mapIndex++)
                            {
                                // Add water due to rainfall
                                thisWaterLevel = landscapeWaterMap[mapIndex] + (heRainfall / 1000f);
                                landscapeWaterMap[mapIndex] = thisWaterLevel;

                                // Erode amount of soil proportional to the water level
                                erodedAmount = heStrength * thisWaterLevel;
                                maxErodedAmount = (heCarryingCapacity * thisWaterLevel) - landscapeSedimentMap[mapIndex];
                                // Don't erode more than can be dissolved in the water present
                                if (erodedAmount > maxErodedAmount) { erodedAmount = maxErodedAmount; }
                                // Don't erode more than the current height of the terrain
                                thisHeight = landscapeHeightmap[mapIndex];
                                if (erodedAmount > thisHeight) { erodedAmount = thisHeight; }
                                // Theoretically line below shouldn't be needed...
                                // CHECK THIS LATER
                                if (erodedAmount < 0f) { erodedAmount = 0f; }

                                // Update heightmap and sediment map
                                landscapeHeightmap[mapIndex] -= erodedAmount;
                                landscapeSedimentMap[mapIndex] += erodedAmount;

                                // Set water/sediment difference maps to zero in preparation for transportation step
                                landscapeWaterDiffMap[mapIndex] = 0f;
                                landscapeSedimentDiffMap[mapIndex] = 0f;
                            }

                            #endregion Rainfall and Erosion

                            #region Transportation

                            // Loop through all points in the height map
                            for (mapIndex = 0; mapIndex < landscapeHeightsSize; mapIndex++)
                            {
                                // Get the water level of this pixel
                                thisWaterLevel = landscapeWaterMap[mapIndex];

                                // Only do anything if there is water to be distributed
                                if (thisWaterLevel > 0f)
                                {
                                    // Get the height of the terrain + water at this point
                                    thisHeight = landscapeHeightmap[mapIndex] + thisWaterLevel;

                                    // Initialise totals
                                    totalHeightDifference = 0f;
                                    totalHeight = 0f;
                                    numberOfSampledCells = 0;

                                    // Initialise min-max height difference variables
                                    minHeightDifference = 100000f;
                                    maxHeightDifference = 0f;

                                    // Get x and y coordinates from heightmap array index
                                    x = mapIndex % heightmapResolution;
                                    y = (mapIndex - x) / heightmapResolution;

                                    // Get min-max indices for this block
                                    blockXMin = x - 1;
                                    blockXMax = x + 1;
                                    blockYMin = y - 1;
                                    blockYMax = y + 1;

                                    // Clamp min-max indices for this block to within the landscape
                                    if (blockXMin < 0) { blockXMin = 0; }
                                    if (blockXMax > heightmapResolution - 1) { blockXMax = heightmapResolution - 1; }
                                    if (blockYMin < 0) { blockYMin = 0; }
                                    if (blockYMax > heightmapResolution - 1) { blockYMax = heightmapResolution - 1; }

                                    #region Calculate Height Totals

                                    // Loop through the neighbours of this pixel
                                    heightDiffCacheIndex = 0;
                                    for (blockX = blockXMin; blockX <= blockXMax; blockX++)
                                    {
                                        for (blockY = blockYMin; blockY <= blockYMax; blockY++)
                                        {
                                            // Skip centre pixel
                                            if (blockX != x || blockY != y)
                                            {
                                                // Get the index of this adjacent pixel
                                                tempMapIndex = (blockY * heightmapResolution) + blockX;
                                                // Get the height and height difference at this pixel
                                                thisSurroundingHeight = landscapeHeightmap[tempMapIndex] + landscapeWaterMap[tempMapIndex];
                                                //heightDiffCache[heightDiffCacheIndex] = thisHeight - thisSurroundingHeight;
                                                tempHeightDiff = thisHeight - thisSurroundingHeight;
                                                // Only count positive height differences
                                                if (tempHeightDiff > 0f)
                                                {
                                                    // If this is greater/lower than the current maximum/minimum height difference,
                                                    // record it as the new maximum height
                                                    if (tempHeightDiff > maxHeightDifference) { maxHeightDifference = tempHeightDiff; }
                                                    if (tempHeightDiff < minHeightDifference) { minHeightDifference = tempHeightDiff; }
                                                    // Add this height difference to the total
                                                    totalHeightDifference += tempHeightDiff;
                                                    // Add this height to the total
                                                    totalHeight += thisSurroundingHeight;
                                                    // Keep count of the number of cells sampled
                                                    numberOfSampledCells++;
                                                }
                                                // Store height diff in cache
                                                heightDiffCache[heightDiffCacheIndex] = tempHeightDiff;
                                            }
                                            heightDiffCacheIndex++;
                                        }
                                    }

                                    #endregion Calculate Height Totals

                                    #region Distribute Heights

                                    // Only move water if there are neighbours that are lower than this pixel
                                    if (totalHeightDifference > 0f && numberOfSampledCells > 0)
                                    {
                                        // The amount of water to be removed (i.e. transported) from this cell is the minimum of:
                                        // - The water in this cell
                                        // - The amount of water needed for it to reach the average water level
                                        //totalWaterToRemove = minHeightDifference * 0.5f;
                                        //totalWaterToRemove = totalHeightDifference * 0.5f;
                                        averageHeight = (totalHeight + landscapeHeightmap[mapIndex]) / (float)(numberOfSampledCells + 1);
                                        totalWaterToRemove = thisHeight - averageHeight;
                                        if (totalWaterToRemove > thisWaterLevel) { totalWaterToRemove = thisWaterLevel; }

                                        // Calculate the total sediment to remove, assuming sediment is evenly distributed throughout water
                                        totalSedimentToRemove = (totalWaterToRemove / thisWaterLevel) * landscapeSedimentMap[mapIndex];

                                        // Loop through the neighbours of this pixel
                                        heightDiffCacheIndex = 0;
                                        for (blockX = blockXMin; blockX <= blockXMax; blockX++)
                                        {
                                            for (blockY = blockYMin; blockY <= blockYMax; blockY++)
                                            {
                                                // Skip centre pixel
                                                if (blockX != x || blockY != y)
                                                {
                                                    // Get the index for this adjacent pixel
                                                    tempMapIndex = (blockY * heightmapResolution) + blockX;
                                                    // Retrieve height diff from cache
                                                    tempHeightDiff = heightDiffCache[heightDiffCacheIndex];
                                                    // Water only flows downhill, so exclude heights above this cell
                                                    if (tempHeightDiff > 0f)
                                                    {
                                                        // Get the proportion of the water distributed to this cell
                                                        waterDistributionProportion = tempHeightDiff / totalHeightDifference;
                                                        // Distribute the water and sediment
                                                        landscapeWaterMap[tempMapIndex] += totalWaterToRemove * waterDistributionProportion;
                                                        landscapeSedimentMap[tempMapIndex] += totalSedimentToRemove * waterDistributionProportion;
                                                        //landscapeWaterDiffMap[tempMapIndex] += totalWaterToRemove * waterDistributionProportion;
                                                        //landscapeSedimentDiffMap[tempMapIndex] += totalSedimentToRemove * waterDistributionProportion;
                                                        //if (totalWaterToRemove * waterDistributionProportion > landscapeWaterDiffMap[tempMapIndex])
                                                        //{
                                                        //    landscapeWaterDiffMap[tempMapIndex] = totalWaterToRemove * waterDistributionProportion;
                                                        //    totalWaterRemoved += totalWaterToRemove * waterDistributionProportion;
                                                        //}
                                                        //if (totalSedimentToRemove * waterDistributionProportion > landscapeSedimentDiffMap[tempMapIndex])
                                                        //{
                                                        //    landscapeSedimentDiffMap[tempMapIndex] = totalSedimentToRemove * waterDistributionProportion;
                                                        //    totalSedimentRemoved += totalSedimentToRemove * waterDistributionProportion;
                                                        //}
                                                    }
                                                }
                                                heightDiffCacheIndex++;
                                            }
                                        }

                                        // Remove the water and sediment from this cell
                                        landscapeWaterMap[mapIndex] -= totalWaterToRemove;
                                        landscapeSedimentMap[mapIndex] -= totalSedimentToRemove;
                                        //landscapeWaterMap[mapIndex] -= totalWaterRemoved;
                                        //landscapeSedimentMap[mapIndex] -= totalSedimentRemoved;
                                        //landscapeWaterDiffMap[mapIndex] -= totalWaterToRemove;
                                        //landscapeSedimentDiffMap[mapIndex] -= totalSedimentToRemove;
                                        //landscapeWaterDiffMap[mapIndex] = -totalWaterToRemove;
                                        //landscapeSedimentDiffMap[mapIndex] = -totalSedimentToRemove;
                                    }

                                    #endregion Distribute Heights
                                }
                            }

                            //// TODO: Is this needed? If the temp data is never read from, theoretically it shouldn't be...
                            //// Copy water map data
                            //System.Buffer.BlockCopy(landscapeWaterMap, 0, tempLandscapeWaterMap, 0, landscapeHeightsSize * sizeof(float));
                            //// Copy sediment map data
                            //System.Buffer.BlockCopy(landscapeSedimentMap, 0, tempLandscapeSedimentMap, 0, landscapeHeightsSize * sizeof(float));

                            #endregion Transportation

                            #region Evaporation and Deposition

                            // Loop through all points in the height map
                            for (mapIndex = 0; mapIndex < landscapeHeightsSize; mapIndex++)
                            {
                                // Add water and sediment differences from the previous calculation
                                // TODO: Should probably combine this with another line for speed
                                landscapeWaterMap[mapIndex] += landscapeWaterDiffMap[mapIndex];
                                landscapeSedimentMap[mapIndex] += landscapeSedimentDiffMap[mapIndex];

                                // Decrease the water level as water evaporates
                                thisWaterLevel = landscapeWaterMap[mapIndex] * (1f - heEvaporation);
                                landscapeWaterMap[mapIndex] = thisWaterLevel;
                                // TODO: Again, do we need to set temp values if they are never read from?
                                //tempLandscapeWaterMap[mapIndex] = thisWaterLevel;

                                // Deposit sediment that cannot be carried by the water present
                                sedimentToDeposit = landscapeSedimentMap[mapIndex] - (heCarryingCapacity * thisWaterLevel);
                                if (sedimentToDeposit > 0f)
                                {
                                    // Add sediment to height map...
                                    landscapeHeightmap[mapIndex] += sedimentToDeposit;
                                    // ... and remove it from sediment map
                                    landscapeSedimentMap[mapIndex] -= sedimentToDeposit;
                                }
                            }

                            #endregion Evaporation and Deposition

                            #region Progress
                            if (showProgressDelegate != null)
                            {
                                // Call back to update the progress bar
                                showProgressDelegate("Topography Final Pass Hydraulic Erosion", i + 1 + " of " + heIterations, (float)i / (float)heIterations);
                            }
                            #endregion
                        }

                        // TODO: May not need this part: Investigate later...
                        // Add residual sediment back into heightmap
                        // Loop through all points in the height map
                        for (mapIndex = 0; mapIndex < landscapeHeightsSize; mapIndex++)
                        {
                            //landscapeHeightmap[mapIndex] += landscapeSedimentMap[mapIndex];
                            // Also may not need this line, if temp height map remains unused after H erosion
                            //tempLandscapeHeightMap[mapIndex] += landscapeSedimentMap[mapIndex];

                            // Purely for debugging purposes
                            if (heDebugWaterLevel) { landscapeHeightmap[mapIndex] = landscapeWaterMap[mapIndex] * 10f; }
                        }
                    }

                    #endregion Hydraulic Erosion 1D Array (Experimental, Iterative)

                    #region Smoothing 1D Array

                    if (useSmoothing)
                    {
                        #region Init Compute Shader Smoothing
                        if (isFPassComputeEnabled)
                        {
#if LB_COMPUTE
                            try
                            {
                                isHeightsUpdated = false;
                                if (shaderFPass != null && cbufHeights != null) // && cbufHeightsTemp != null)
                                {
                                    // Get the index to the Method in the compute shader
                                    // To reduce the size of generated compute shader code, there is a dedicated method
                                    // for each smoothing pixel range.
                                    switch (smoothingPixelRange)
                                    {
                                        case 1: kFPassSmoothingIdx = shaderFPass.FindKernel(CSKFPassSmoothingPR1); break;
                                        case 2: kFPassSmoothingIdx = shaderFPass.FindKernel(CSKFPassSmoothingPR2); break;
                                        case 3: kFPassSmoothingIdx = shaderFPass.FindKernel(CSKFPassSmoothingPR3); break;
                                        case 4: kFPassSmoothingIdx = shaderFPass.FindKernel(CSKFPassSmoothingPR4); break;
                                        default: kFPassSmoothingIdx = shaderFPass.FindKernel(CSKFPassSmoothingPR5); break;
                                    }

                                    kFPassCopyTerrainToHeightsIdx = shaderFPass.FindKernel(CSKFPassCopyTerrainToHeights);

                                    // Set unused thermal erosion shader variables to avoid compute shader errors
                                    shaderFPass.SetInt(CSteFilterMode, 0);
                                    shaderFPass.SetFloat(CStetalusHeightDiff, 0f);
                                    shaderFPass.SetFloat(CSteErosionStrength, 0f);
                                    shaderFPass.SetInt(CShmapRow, 0);

                                    // Set smoothing shader variables
                                    shaderFPass.SetInt(CSsmoothingFilterMode, smoothingFilterMode);

                                    // Stencil layer filter (0 or 1)
                                    int stencilLayerResolution = isFPSmoothStencilEnabled ? landscape.fPassSmoothStencilLayerRes : 1;
                                    shaderFPass.SetInt(CSnumStencilLayers, isFPSmoothStencilEnabled ? 1 : 0);
                                    shaderFPass.SetInt(CSstencilLayerResolution, stencilLayerResolution);

                                    #region Copy Stencil Layer to compute shader
                                    if (isFPSmoothStencilEnabled)
                                    {
                                        // Create the texture arrays to hold the unique compressed stencil layer textures
                                        // Create 1 in each array (cannot have an array size of zero)
                                        // Currently in Final Pass we only support 1 stencil layer for smoothing. However, will use TexArrays for consistency
                                        // If there is no stencil for a certain resolution, create a dummy Texture2DArray with a 1x1 Texture to conserve GPU memory
                                        if (stencilLayerResolution != 128) { stencilLayerTex2DArrayList.Add(new Texture2DArray(1, 1, 1, TextureFormat.ARGB32, false, true)); }
                                        else { stencilLayerTex2DArrayList.Add(new Texture2DArray(128, 128, 1, TextureFormat.ARGB32, false, true)); }
                                        if (stencilLayerResolution != 256) { stencilLayerTex2DArrayList.Add(new Texture2DArray(1, 1, 1, TextureFormat.ARGB32, false, true)); }
                                        else { stencilLayerTex2DArrayList.Add(new Texture2DArray(256, 256, 1, TextureFormat.ARGB32, false, true)); }
                                        if (stencilLayerResolution != 512) { stencilLayerTex2DArrayList.Add(new Texture2DArray(1, 1, 1, TextureFormat.ARGB32, false, true)); }
                                        else { stencilLayerTex2DArrayList.Add(new Texture2DArray(512, 512, 1, TextureFormat.ARGB32, false, true)); }
                                        if (stencilLayerResolution != 1024) { stencilLayerTex2DArrayList.Add(new Texture2DArray(1, 1, 1, TextureFormat.ARGB32, false, true)); }
                                        else { stencilLayerTex2DArrayList.Add(new Texture2DArray(1024, 1024, 1, TextureFormat.ARGB32, false, true)); }
                                        if (stencilLayerResolution != 2048) { stencilLayerTex2DArrayList.Add(new Texture2DArray(1, 1, 1, TextureFormat.ARGB32, false, true)); }
                                        else { stencilLayerTex2DArrayList.Add(new Texture2DArray(2048, 2048, 1, TextureFormat.ARGB32, false, true)); }
                                        if (stencilLayerResolution != 4096) { stencilLayerTex2DArrayList.Add(new Texture2DArray(1, 1, 1, TextureFormat.ARGB32, false, true)); }
                                        else { stencilLayerTex2DArrayList.Add(new Texture2DArray(4096, 4096, 1, TextureFormat.ARGB32, false, true)); }
                                        if (stencilLayerResolution != 8192) { stencilLayerTex2DArrayList.Add(new Texture2DArray(1, 1, 1, TextureFormat.ARGB32, false, true)); }
                                        else { stencilLayerTex2DArrayList.Add(new Texture2DArray(8192, 8192, 1, TextureFormat.ARGB32, false, true)); }

                                        int numSLayerTex2DArrays = stencilLayerTex2DArrayList.Count;

                                        for (int i = 0; i < numSLayerTex2DArrays; i++) { stencilLayerTex2DArrayList[i].hideFlags = HideFlags.DontSave; }

                                        int stencilLayerResolutionIdx = -1;

                                        // There might be a better way of doing this via the position in the enum.
                                        switch (stencilLayerResolution)
                                        {
                                            case 128: stencilLayerResolutionIdx = 0; break;
                                            case 256: stencilLayerResolutionIdx = 1; break;
                                            case 512: stencilLayerResolutionIdx = 2; break;
                                            case 1024: stencilLayerResolutionIdx = 3; break;
                                            case 2048: stencilLayerResolutionIdx = 4; break;
                                            case 4096: stencilLayerResolutionIdx = 5; break;
                                            case 8092: stencilLayerResolutionIdx = 6; break;
                                        }

                                        // Add the stencil layer data to the Texture2DArray
                                        if (landscape.fPassSmoothlbStencilLayer.compressedTexture != null && stencilLayerResolutionIdx >= 0)
                                        {
                                            Texture2DArray texture2DArray = stencilLayerTex2DArrayList[stencilLayerResolutionIdx];

                                            if (texture2DArray != null)
                                            {
                                                LBTextureOperations.CopyTextureTo2DArray(ref texture2DArray, landscape.fPassSmoothlbStencilLayer.compressedTexture, 0, true);
                                            }
                                        }

                                        // Assign the Texture2DArrays to the compute shader
                                        CopyStencilLayerTex2DArrayListToShader(stencilLayerTex2DArrayList, shaderFPass, kFPassSmoothingIdx);
                                    }
                                    else
                                    {
                                        ConfigDummyStencilLayerTex2DArrayList(stencilLayerTex2DArrayList, shaderFPass, kFPassSmoothingIdx);
                                    }
                                    #endregion
                                }
                            }
                            catch (System.Exception ex)
                            {
                                Debug.LogWarning("ERROR " + methodName + " - could not smooth landscape with compute shader. PLEASE REPORT " + ex.Message);
                            }
#endif
                        }
                        #endregion Compute Shader

                        // Loop through iterations
                        for (int i = 0; i < smoothingIterations; i++)
                        {
                            #region Compute Shader Smoothing Iteration
                            if (isFPassComputeEnabled)
                            {
#if LB_COMPUTE

                                // Process terrain-scoped heightmap in each iteration (reads from landscape-scoped heightmap)
                                for (int tIdx = 0; tIdx < numTerrains; tIdx++)
                                {
                                    // Get terrain heightmap
                                    //int smallerHeightmapResolution = 2;
                                    Terrain terrain = landscape.landscapeTerrains[tIdx];

                                    // Assign buffers to smoothing method
                                    // Landscape heights
                                    shaderFPass.SetBuffer(kFPassSmoothingIdx, CSheights, cbufHeights);
                                    // Place to write terrain heights
                                    shaderFPass.SetBuffer(kFPassSmoothingIdx, CSheightsOut, cbufHeightsOut);

                                    // Set terrain variables
                                    shaderFPass.SetVector(CSterrainWorldPos, terrain.transform.position);

                                    int threadGroupX = (terrainHeightmapResolution - 1) / cskSmoothingNumThreads;
                                    int threadGroupY = (terrainHeightmapResolution - 1) / cskSmoothingNumThreads;

                                    // Execute shader
                                    // The Z thread group is 1 because we are processing a 2D heightmap
                                    shaderFPass.Dispatch(kFPassSmoothingIdx, threadGroupX + 1, threadGroupY + 1, 1);

                                    // Copy terrain-scoped heightmap to landscape-scoped heightmap in shader
                                    // Assign buffers to CopyTerrainToHeights method
                                    shaderFPass.SetBuffer(kFPassCopyTerrainToHeightsIdx, CSheights, cbufHeights);
                                    shaderFPass.SetBuffer(kFPassCopyTerrainToHeightsIdx, CSheightsOut, cbufHeightsOut);

                                    threadGroupX = terrainHeightmapSize1D / cskCopyNumThreads;
                                    // Round up threadGroupX by adding 1.
                                    shaderFPass.Dispatch(kFPassCopyTerrainToHeightsIdx, threadGroupX + 1, 1, 1);

                                    //Vector3 landscapePositionVector = terrain.transform.position - landscapePosition;
                                    //Rect terrainRect = Rect.MinMaxRect(landscapePositionVector.x, landscapePositionVector.z, landscapePositionVector.x + terrainWidth, landscapePositionVector.z + terrainLength);

                                    //cbufHeightsOut.GetData(terrainHeightmap1D);
                                    //CommitSmallerLandscapeScopedHeightmap(landscape, landscapeHeightmap, heightmapResolution, terrainHeightmap1D, terrainHeightmapResolution, terrainRect, showErrors);
                                }

                                isHeightsUpdated = true;
#endif
                            }
                            #endregion Compute Shader

                            #region Non-Compute Shader Smoothing Iteration
                            else
                            {
                                // Loop through all parts of the array
                                for (mapIndex = 0; mapIndex < landscapeHeightsSize; mapIndex++)
                                {
                                    // Get x and y coordinates from heightmap array index
                                    x = mapIndex % heightmapResolution;
                                    y = (mapIndex - x) / heightmapResolution;

                                    // TODO: Maybe try indexing without converting to x-y?

                                    #region Get Stencil Layer Value if applicable
                                    if (isFPSmoothStencilEnabled)
                                    {
                                        // Get the value of the Stencil layer at this point in the terrain
                                        // Get the point within the stencil layer USHORT array
                                        // (xPos2 / landscapeSize.x) is the normalised x position in the landscape (value is between 0 and 1)
                                        // Ensure it it's outside the range of the USHORT array (Clamping in the same line give 2% performance boost)
                                        stencilLayerPoint.x = Mathf.Clamp(Mathf.RoundToInt(((float)x / hmapResMinus1F) * (landscape.fPassSmoothStencilLayerRes - 1f)), 0, landscape.fPassSmoothStencilLayerRes - 1);
                                        stencilLayerPoint.y = Mathf.Clamp(Mathf.RoundToInt((1f - ((float)y / hmapResMinus1F)) * (landscape.fPassSmoothStencilLayerRes - 1f)), 0, landscape.fPassSmoothStencilLayerRes - 1);

                                        stencilLayerBlend = landscape.fPassSmoothlbStencilLayer.layerArray[stencilLayerPoint.x, stencilLayerPoint.y] / 65535f;
                                    }
                                    else { stencilLayerBlend = 1f; }
                                    #endregion

                                    // Check if any smoothing applies to this point in the landscape.
                                    if (isFPSmoothStencilEnabled && ((stencilLayerBlend == 0.0f && smoothingFilterMode == 0) || (stencilLayerBlend > 0.9999f && smoothingFilterMode == 2)))
                                    {
                                        tempLandscapeHeightMap[mapIndex] = landscapeHeightmap[mapIndex];
                                    }
                                    else
                                    {
                                        // Get min-max indices for this smoothing range
                                        blockXMin = x - smoothingPixelRange;
                                        blockXMax = x + smoothingPixelRange;
                                        blockYMin = y - smoothingPixelRange;
                                        blockYMax = y + smoothingPixelRange;

                                        // Clamp min-max indices for this block to within the landscape
                                        if (blockXMin < 0) { blockXMin = 0; }
                                        if (blockXMax > heightmapResolution - 1) { blockXMax = heightmapResolution - 1; }
                                        if (blockYMin < 0) { blockYMin = 0; }
                                        if (blockYMax > heightmapResolution - 1) { blockYMax = heightmapResolution - 1; }

                                        // Reset height total
                                        totalHeight = 0f;

                                        // Looking up the array is relatively slow, so only do it once outside the loop
                                        thisHeight = landscapeHeightmap[mapIndex];

                                        // Loop through this block
                                        for (blockX = blockXMin; blockX <= blockXMax; blockX++)
                                        {
                                            for (blockY = blockYMin; blockY <= blockYMax; blockY++)
                                            {
                                                // Read from the current heightmap into the height total
                                                if (isFPSmoothStencilEnabled)
                                                {
                                                    if (smoothingFilterMode == 0)
                                                    {
                                                        // Lerp between thisHeight and neighbour height
                                                        // Mathf.LerpUnclamped(a,b,t) same as: a + (b - a) * t
                                                        totalHeight += (thisHeight + (landscapeHeightmap[(blockY * heightmapResolution) + blockX] - thisHeight) * stencilLayerBlend);
                                                    }
                                                    else // Assume NOT
                                                    {
                                                        // Lerp between neighbour height and thisHeight
                                                        // Mathf.LerpUnclamped(a,b,t) same as: a + (b - a) * t
                                                        thisSurroundingHeight = landscapeHeightmap[(blockY * heightmapResolution) + blockX];
                                                        totalHeight += (thisSurroundingHeight + (thisHeight - thisSurroundingHeight) * stencilLayerBlend);
                                                    }
                                                }
                                                else
                                                {
                                                    totalHeight += landscapeHeightmap[(blockY * heightmapResolution) + blockX];
                                                }
                                            }
                                        }

                                        // Average height values and then set this average height to the temp heightmap
                                        tempLandscapeHeightMap[mapIndex] = totalHeight / (float)((blockXMax - blockXMin + 1) * (blockYMax - blockYMin + 1));
                                    }
                                }

                                // After each iteration, read values from temp heightmap back into real heightmap
                                System.Buffer.BlockCopy(tempLandscapeHeightMap, 0, landscapeHeightmap, 0, landscapeHeightsSize * sizeof(float));
                            }
                            #endregion Non-Compute Shader

                            #region Progress
                            // Call back to update the progress bar
                            if (showProgressDelegate != null)
                            {
                                showProgressDelegate("Topography Final Pass Smoothing", i + 1 + " of " + smoothingIterations, (float)i / (float)smoothingIterations);
                            }
                            #endregion
                        }

                        #region Get Updated Heights from Compute Shader
                        if (isFPassComputeEnabled)
                        {
#if LB_COMPUTE
                            if (isHeightsUpdated && cbufHeights != null)
                            {
                                cbufHeights.GetData(landscapeHeightmap);
                            }
#endif
                        }
                        #endregion
                    }

                    #endregion

                    #region Free Compute Shader Resource
#if LB_COMPUTE
                    if (isFPassComputeEnabled)
                    {
                        if (dummyTex2DArray != null) { LBTextureOperations.DestroyTexture2DArray(ref dummyTex2DArray); }
                        if (cbufHeights != null) { cbufHeights.Release(); cbufHeights = null; }
                        if (cbufHeightsOut != null) { cbufHeightsOut.Release(); cbufHeightsOut = null; }

                        int numStencilLayerArrays = (stencilLayerTex2DArrayList == null ? 0 : stencilLayerTex2DArrayList.Count);

                        for (int slArrayIdx = numStencilLayerArrays - 1; slArrayIdx >= 0; slArrayIdx--)
                        {
                            Texture2DArray texture2DArray = stencilLayerTex2DArrayList[slArrayIdx];
                            if (texture2DArray != null) { LBTextureOperations.DestroyTexture2DArray(ref texture2DArray); }
                            // Check if was correctly disposed
                            if (stencilLayerTex2DArrayList[slArrayIdx] != null) { Debug.LogWarning("ERROR: " + methodName + " - stencillayer tex2Darray" + slArrayIdx + "  not released correctly"); }
                        }
                        if (stencilLayerTex2DArrayList != null) { stencilLayerTex2DArrayList.Clear(); }

                        if (shaderFPass != null) { shaderFPass = null; }

                    }
#endif
                    #endregion

                    #region Copy heightmap data back to terrains

                    // After data is processed, copy back from array to terrain heightmaps and free memory
                    isSuccessful = CommitLandscapeScopedHeightmap(landscape, landscapeHeightmap, isIncludeInnerEdges, showErrors);

                    #endregion

                }

                landscapeHeightmap = null;
            }

            if (landscape != null)
            {
                if (landscape.showTiming) { Debug.Log("Time taken for Topography Final Pass: " + (Time.realtimeSinceStartup - tStart).ToString("0.000") + "s"); }
            }

            return isSuccessful;
        }

        #endregion Static Final Pass Terrain Method

        #region Static Texturing Methods

        /// <summary>
        /// Returns the TerrainData after texturing it
        /// The landscape parm is required for LBFilter.StencilLayer, and Imported texture data.
        /// To avoid differences in slope and height on terrain boundaries, also supply the landscape parm.
        /// Call LBStencil.FreeStencilResources(landscape, true) after calling this method if
        /// a LBFilterType.StencilLayer was used.
        /// </summary>
        /// <param name="tData"></param>
        /// <param name="terrainTexturesList"></param>
        /// <param name="worldPosition"></param>
        /// <param name="landscapeSize"></param>
        /// <param name="landscapePosition"></param>
        /// <param name="showTiming"></param>
        /// <param name="landscape"></param>
        /// <returns></returns>
        public static TerrainData TextureTerrain(TerrainData tData, List<LBTerrainTexture> terrainTexturesList, Vector3 worldPosition, Vector2 landscapeSize, Vector3 landscapePosition,
                                                 bool showTiming = false, LBLandscape landscape = null)
        {
            float tStart = Time.realtimeSinceStartup;
            if (tData != null)
            {
                #if LB_COMPUTE && UNITY_EDITOR
                string methodName = "LBLandscapeTerrain.TextureTerrain";
                #endif

                #region Declare variables outside the loops to improve performance
                float textureNoiseTileSize = 0f, noiseValue = 0f, pixelColourAvgVariation = 0f;
                Vector2 worldPoint = Vector2.zero;
                Vector2 landscapePoint = Vector2.zero;   // This is the position in metres within the landscape (world space point - start position of landscape)
                #endregion

                #region Remove disabled LBTerrainTexture items from the list. Create new list so we don't affect original in LBLandscape
                // Remove LBTerrainTexture items without a valid texture
                List<LBTerrainTexture> terrainTexturesListNoDisabled = LBTerrainTexture.GetActiveTextureList(terrainTexturesList);
                int enabledTextures = (terrainTexturesListNoDisabled == null ? 0 : terrainTexturesListNoDisabled.Count);
                #endregion

                #region Used for LBTextureFilters
                bool includePoint = true;
                bool includePointCurrentFilter = false;
                int textureFilterIndex = 0;
                LBTextureFilter lbTextureFilter;
                #endregion

                UnityEngine.Random.InitState(0);

                for (int t = 0; t < enabledTextures; t++)
                {
                    // As Random is using the same seed for each terrain, it should return the same noiseOffset
                    terrainTexturesListNoDisabled[t].noiseOffset = UnityEngine.Random.Range(0f, terrainTexturesListNoDisabled[t].noiseTileSize);
                }

                Vector2 terrainSize = new Vector2(tData.size.x, tData.size.z);
                Vector3 terrainSize3D = tData.size;

                float terrainHeight = tData.size.y;

                #region Texture Map variables
                LBMapPoint mapPoint;
                LBMap lbMap = null;
                float pixelVariationNormalised = 0f;

                // Used with lbMap.useAdvancedTolerance
                float pixelTolerance = 0f;
                #endregion

                #region Get the normalised (0-1) bounds of this terrain within the landscape
                float startX = ((worldPosition.x - landscapePosition.x) / landscapeSize.x);
                float endX = startX + (tData.size.x / landscapeSize.x);
                float startY = ((worldPosition.z - landscapePosition.z) / landscapeSize.y);
                float endY = startY + (tData.size.z / landscapeSize.y);
                #endregion

                // Texture terrain
                if (terrainTexturesListNoDisabled != null)
                {
#if !(UNITY_STANDALONE_OSX || UNITY_STANDALONE_WIN || UNITY_XBOXONE || UNITY_WSA_10_0)
                    bool isTexComputeEnabled = false;
#else
                    bool isTexComputeEnabled = (landscape == null ? false : landscape.useGPUTexturing);
#endif

                    #region Get splatPrototypes (2018.2 or earlier) or terrainLayers (for 2018.3+)
                    if (enabledTextures > 0)
                    {
                        // Set textures to use from landscape textures list
                        // If the Texture is tinted, use the tinted texture rather than the main texture
#if UNITY_2018_3_OR_NEWER && UNITY_EDITOR
                        if (landscape != null && landscape.useProjectForTerrainData)
                        {
                            tData.terrainLayers = landscape.activeTerrainLayerList.ToArray();
                        }
                        else
                        {
                            tData.terrainLayers = LBTerrainTexture.ToTerrainLayerList(terrainTexturesListNoDisabled).ToArray();
                        }
#elif UNITY_2018_3_OR_NEWER
                        tData.terrainLayers = LBTerrainTexture.ToTerrainLayerList(terrainTexturesListNoDisabled).ToArray();
#else
                        tData.splatPrototypes = LBTerrainTexture.ToSplatPrototypeList(terrainTexturesListNoDisabled).ToArray();
#endif
                    }
                    else
                    {
                        // All textures have been disabled
                        // This will effectively return the default Unity terrain material (a greyish colour)
#if UNITY_2018_3_OR_NEWER
                        tData.terrainLayers = null;
#else
                        tData.splatPrototypes = null;
#endif
                    }

                    #endregion

                    #region Initialise LBMaps
                    List<LBMap> lbMapList = new List<LBMap>();
                    if (!isTexComputeEnabled)
                    {
                        // Pre-create a list of maps - some maps may not be applicable but will improve performance
                        // There will be no need to create a map for each point for those Textures that use a map
                        foreach (LBTerrainTexture terrainTexture in terrainTexturesListNoDisabled)
                        {
                            if (terrainTexture != null)
                            {
                                lbMap = new LBMap(terrainTexture.map, terrainTexture.mapColour, terrainTexture.mapTolerance);
                                lbMap.inverse = terrainTexture.mapInverse;
                                lbMap.useAdvancedTolerance = terrainTexture.useAdvancedMapTolerance;
                                lbMap.toleranceRed = terrainTexture.mapToleranceRed;
                                lbMap.toleranceGreen = terrainTexture.mapToleranceGreen;
                                lbMap.toleranceBlue = terrainTexture.mapToleranceBlue;
                                lbMap.toleranceAlpha = terrainTexture.mapToleranceAlpha;
                                lbMap.mapWeightRed = terrainTexture.mapWeightRed;
                                lbMap.mapWeightGreen = terrainTexture.mapWeightGreen;
                                lbMap.mapWeightBlue = terrainTexture.mapWeightBlue;
                                lbMap.mapWeightAlpha = terrainTexture.mapWeightAlpha;
                                lbMap.toleranceBlendCurve = terrainTexture.mapToleranceBlendCurve;
                                if (lbMap.useAdvancedTolerance) { lbMap.UpdateColourMatchRange(); }
                                lbMapList.Add(lbMap);
                            }
                        }
                        lbMap = null;
                    }
                    #endregion

                    #region Build alphamap/splatmap
                    int numSplatTextures = tData.alphamapLayers;
                    int alphamapWidth = tData.alphamapWidth;
                    int alphamapHeight = tData.alphamapHeight;
                    float[,,] alphamap = new float[alphamapWidth, alphamapHeight, numSplatTextures];
                    blendWeights = new float[numSplatTextures];
                    #endregion

                    #region Get Rule Arrays
                    // NEW in v2.0.7 Beta 6 to replace ruleArray1-4 arrays
                    // Min/Max Heights are normalised (0.0-1.0)
                    // Min/Max Inclinations are 0.0 - 90.0 degrees
                    LBTexRule[] lbTexRulesArray = LBTerrainTexture.GetPlacementRules(terrainTexturesListNoDisabled, terrainHeight, terrainSize);
                    #endregion

                    // We calc this inside the compute shader, so don't actually require it when compute is enabled.
                    AnimationCurve texturingCurve = LBCurve.SetCurveFromPreset(LBCurve.FilterCurvePreset.WideRange);

                    #region Are there any Area LBTextureFilter's applied?
                    // NOTE: giving an array a capacity of 0 is ok
                    bool[] isAreaFiltersToApply = new bool[enabledTextures];

                    for (int texIdx = 0; texIdx < enabledTextures; texIdx++)
                    {
                        LBTerrainTexture terrainTexture = terrainTexturesListNoDisabled[texIdx];
                        if (terrainTexture != null)
                        {
                            isAreaFiltersToApply[texIdx] = LBTextureFilter.Contains(terrainTexture.filterList, LBTextureFilter.FilterType.Area);
                        }
                        else { isAreaFiltersToApply[texIdx] = false; }
                    }

                    #endregion

                    #region Initial Stencils
                    // Stencil LBLayerFilter variables
                    Vector2 stencilLayerPosN = new Vector2();
                    LBMapPoint arrayPoint = new LBMapPoint(0, 0);
                    int stencilLayerResolution = 0;
                    int stencilLayerPixel = 0;
                    bool[] isStencilLayerFiltersToApply = new bool[enabledTextures];
#if LB_COMPUTE
                    LBStencilLayer lbStencilLayer = null;
#endif

                    for (int sl = 0; sl < enabledTextures; sl++)
                    {
                        // Are there any Stencil Layer filters for this texture type?
                        isStencilLayerFiltersToApply[sl] = (landscape != null) && LBTextureFilter.Contains(terrainTexturesListNoDisabled[sl].filterList, LBTextureFilter.FilterType.StencilLayer);
                        if (isStencilLayerFiltersToApply[sl])
                        {
                            // Preload the stencil data
                            if (terrainTexturesListNoDisabled[sl].filterList != null)
                            {
                                foreach (LBTextureFilter lbFilter in terrainTexturesListNoDisabled[sl].filterList)
                                {
                                    if (lbFilter != null)
                                    {
                                        // Is this a valid Stencil Filter?
                                        if (lbFilter.filterType == LBTextureFilter.FilterType.StencilLayer && !string.IsNullOrEmpty(lbFilter.lbStencilGUID) && !string.IsNullOrEmpty(lbFilter.lbStencilLayerGUID))
                                        {
                                            // If the temporary class instance isn't defined, look it up and validate it is in the current landscape
                                            if (lbFilter.lbStencil == null)
                                            {
                                                lbFilter.lbStencil = LBStencil.GetStencilInLandscape(landscape, lbFilter.lbStencilGUID, true);
                                            }

                                            if (lbFilter.lbStencil != null)
                                            {
                                                // Find the Stencil Layer for this Layer Filter and populate the temporary class instance
                                                lbFilter.lbStencilLayer = lbFilter.lbStencil.GetStencilLayerByGUID(lbFilter.lbStencilLayerGUID);

                                                if (lbFilter.lbStencilLayer != null)
                                                {
                                                    // Load the USHORT data (Compute uses the uncompressed textures)
                                                    // This can take 1-3 seconds on a 4K stencil layer
                                                    if (lbFilter.lbStencilLayer.layerArray == null && !isTexComputeEnabled)
                                                    {
                                                        lbFilter.lbStencilLayer.AllocLayerArray();
                                                        lbFilter.lbStencilLayer.UnCompressToUShort();
                                                    }

                                                    // Cache the layer resolution
                                                    if (isTexComputeEnabled)
                                                    {
                                                        lbFilter.stencilLayerResolution = (int)lbFilter.lbStencilLayer.layerResolution;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    #endregion

                    #region Imported Texture Data (from non-LB terrains)
                    // Imported data variables
                    List<LBTerrainData> lbTerrainDataList = new List<LBTerrainData>();
                    bool[] isTerrainAlphaDataValid = new bool[enabledTextures];
                    int numValidImportedTextures = 0;
                    int terrainAlphaDataResolution = 0;

                    // Check to see if the LBTerrainData.textureAlphaMapData is valid for Imported texture types
                    if (isTerrainAlphaDataValid != null)
                    {
                        for (int tt = 0; tt < enabledTextures; tt++)
                        {
                            isTerrainAlphaDataValid[tt] = false;

                            if (terrainTexturesListNoDisabled[tt].texturingMode == LBTerrainTexture.TexturingMode.Imported && terrainTexturesListNoDisabled[tt].lbTerrainDataList != null)
                            {
                                LBTerrainData lbTerrainData = terrainTexturesListNoDisabled[tt].lbTerrainDataList.Find(td => td.sourceTerrainDataName == tData.name);

                                // Validate LBTerrainData for Texture
                                if (lbTerrainData != null)
                                {
                                    // Get the alphamap resolution for the first terrain data (and assume all others are the same)
                                    if (tt == 0) { terrainAlphaDataResolution = lbTerrainData.TextureSplatResolution; }
                                    // The compute shader can cater for differences between the imported texture resolution and the terrain alphamap resolution
                                    isTerrainAlphaDataValid[tt] = lbTerrainData.ValidateTextureAlphamapData(landscape, isTexComputeEnabled, true);
                                    if (isTerrainAlphaDataValid[tt]) { lbTerrainDataList.Add(lbTerrainData); numValidImportedTextures++; }
                                }
                            }

                            // Add an empty LBTerrainData instance to the list to preserve the order and size of the list
                            if (!isTerrainAlphaDataValid[tt]) { lbTerrainDataList.Add(new LBTerrainData()); }
                        }
                    }
                    #endregion

                    #region Landscape-scoped data
                    // The slope on 
                    Terrain[] landscapeTerrains = new Terrain[0];
                    TerrainData[] terrainDataArray = new TerrainData[0];
                    Rect[] terrainRectsArray = new Rect[0];
                    int numTerrains = 0;
                    bool useLandscapeSlope = false;
                    Vector2 landscapePosN2D = Vector3.zero;
                    float landscapeWidth = 0f;
                    float landscapeLength = 0f;

                    // If a landscape is supplied, we want to check the edges with the same terrain to ensure both sides of the terrain
                    // edges use the same slope and height values.
                    if (landscape != null)
                    {
                        landscape.SetLandscapeTerrains(true);

                        if (!isTexComputeEnabled)
                        {
                            landscapeTerrains = landscape.landscapeTerrains;
                            numTerrains = (landscapeTerrains == null ? 0 : landscapeTerrains.Length);
                            landscapeWidth = landscape.size.x;
                            landscapeLength = landscape.size.y;
                            if (numTerrains > 1)
                            {
                                useLandscapeSlope = true;
                                // Create arrays for terrain data and terrain rects
                                terrainDataArray = new TerrainData[numTerrains];
                                terrainRectsArray = new Rect[numTerrains];
                                for (int i = 0; i < numTerrains; i++)
                                {
                                    terrainDataArray[i] = landscapeTerrains[i].terrainData;
                                    if (terrainDataArray[i] == null) { useLandscapeSlope = false; break; }
                                    Vector3 landscapePositionVector = landscapeTerrains[i].transform.position - landscapePosition;
                                    terrainRectsArray[i] = Rect.MinMaxRect(landscapePositionVector.x, landscapePositionVector.z, landscapePositionVector.x + landscapeTerrains[i].terrainData.size.x + 0.005f,
                                        landscapePositionVector.z + landscapeTerrains[i].terrainData.size.z + 0.005f);
                                }
                            }
                        }
                    }
                    #endregion

                    #region Alphamp Less1 variables
                    float alphamapWidthLess1F = (float)(alphamapWidth - 1);
                    float alphamapHeightLess1F = (float)(alphamapHeight - 1);
                    int alphamapWidthLess1 = alphamapWidth - 1;
                    int alphamapHeightLess1 = alphamapHeight - 1;
                    #endregion

                    #region Reset Garbage Collection
                    System.GC.Collect();
                    #endregion

                    // Alphamaps are read and updated in Unity as a 3D array of splat values [x,y,smIdx].
                    // The third dimension corresponds to the number or position of the splatmap texture (SplatPrototype).

                    #region Compute

#if LB_COMPUTE

                    #region Init Compute Shader
                    // Compute variables
                    ComputeShader shaderTex = null;
                    ComputeBuffer cbufHeightsIn = null;
                    ComputeBuffer cbufHeightLandscape = null;
                    ComputeBuffer cbufSplatMaps = null; // In and Out
                    ComputeBuffer cbufLBPathCurve = null;
                    ComputeBuffer cbufLBTexRules = null;
                    ComputeBuffer cbufLBTextures = null;
                    ComputeBuffer cbufLBFilters = null;
                    Vector4[] pkKeyFrames = null;
                    Vector4 cvec4AreaRect = Vector4.zero;
                    Texture2D terrainNormalsTex = null;
                    Texture2D map = null;
                    Texture2DArray mapsTex2DArray = null;
                    Texture2DArray importedTex2DArray = null;
                    // There are 128x128, 256x256, 512x512, 1Kx1K, 2Kx2K, 4Kx4K and 8Kx8K Text2DArrays for stencil layers
                    List<Texture2DArray> stencilLayerTex2DArrayList = new List<Texture2DArray>(7);
                    LBCSFilter[] lbcsFilter = null;
                    List<string> stencilLayerGUIDList = null;
                    // Each unique stencil layer resolution has a list of stencil layer GUIDs
                    List<List<string>> stencilLayerArrayGUIDList = new List<List<string>>();

                    bool is4KSplat = alphamapWidth >= 4096;

                    // Must match LB_TEX_NUM_THREADS/LB_TEX_NUM_THREADS_4K in LBCSTex.compute
                    // OSX Metal seems to have a limit of 256. Not sure if this is hardware dependent.
                    // Currently 512 is required if using 4K alphamap/splatmap resolution. To avoid this in the future
                    // the compute shader would need to process chunks rather than the whole 4096x4096 block
                    int cskTexPerlinNumThreads = is4KSplat ? 512 : 256;

                    if (isTexComputeEnabled)
                    {
                        shaderTex = (ComputeShader)Resources.Load(LBCSTex, typeof(ComputeShader));
                        #if UNITY_EDITOR
                        if (shaderTex == null) { Debug.LogWarning("ERROR: " + methodName + " " + LBCSTex + ".shader not found. Please Report"); }
                        #endif
                    }

                    #endregion

                    try
                    {
                        if (isTexComputeEnabled && shaderTex != null && numSplatTextures > 0)
                        {
                            //float csStart = Time.realtimeSinceStartup;

                            #region Initialise data arrays
                            heightmapResolution = tData.heightmapResolution;
                            int sqrHeightmapResolution = heightmapResolution * heightmapResolution;

                            // Create terrain-scoped heightmap as a 1-dimensional array
                            float[] heightMap1D = new float[sqrHeightmapResolution];
                            int heightMap1DSize = (heightMap1D == null ? 0 : heightMap1D.Length);

                            // For 256 terrains this would be approx 1GB
                            bool isCurvatureRules = terrainTexturesListNoDisabled.Exists(tx => tx.texturingMode == LBTerrainTexture.TexturingMode.HeightInclinationCurvature);
                            int heightMapLandscape1DSize = isCurvatureRules ? landscape.GetTotalHeightmapSize(false, 65, terrainSize3D) : 1;
                            float[] heightMapLandscape1D = new float[heightMapLandscape1DSize];
                            heightMapLandscape1DSize = heightMapLandscape1D.Length;

                            // Create splatmap as a 1-dimensional array
                            // All splatmaps (alphalayers) will be in the same array.
                            // Size of a single splatmap layer
                            int splatMap1DSize = alphamapHeight * alphamapWidth;
                            // Size of all splatmap layers
                            int splatMaps1DSizeTarget = splatMap1DSize * numSplatTextures;
                            float[] splatMaps1D = new float[splatMaps1DSizeTarget];

                            int splatMaps1DSize = (splatMaps1D == null ? 0 : splatMaps1D.Length);

                            // Create concatinated ruleArray buffer. Pack all 4 ruleArrays into the same array
                            int pkrulesArray1DSize = numSplatTextures * 4;
                            float[] pkrulesArray = new float[pkrulesArray1DSize];
                            pkrulesArray1DSize = (pkrulesArray == null ? 0 : pkrulesArray.Length);

                            #endregion

                            // Validate the size of the arrays
                            if (heightMap1DSize == (sqrHeightmapResolution) && splatMaps1DSize == splatMaps1DSizeTarget && pkrulesArray1DSize == (numSplatTextures * 4))
                            {
                                // Get the index to the Method in the compute shader
                                int kTexPerlinIdx = shaderTex.FindKernel(is4KSplat ? CSKTexPerlin4K : CSKTexPerlin);

                                #region Get Heightmap data
                                // Copy data from 2D heightmap to 1D array - Size is in bytes
                                System.Buffer.BlockCopy(tData.GetHeights(0, 0, heightmapResolution, heightmapResolution), 0, heightMap1D, 0, sizeof(float) * sqrHeightmapResolution);

                                #endregion

                                #region Get Slope data

                                // Copy terrain normals into a texture
                                terrainNormalsTex = GetSlopeTexture2D(landscape, landscapePosition, tData, worldPosition, alphamapWidth, alphamapHeight, "LB_CSTex_TN");
                                #if UNITY_EDITOR
                                if (terrainNormalsTex == null) { Debug.LogWarning("ERROR: " + methodName + " - could not get terrain normals. Please Report"); }
                                #endif
                                #endregion

                                #region Create Buffers
                                // Copy 1D heightmap data into the computebuffer
                                cbufHeightsIn = new ComputeBuffer(sqrHeightmapResolution, sizeof(float), ComputeBufferType.Default);

                                // Create the flat splatmap buffer
                                cbufSplatMaps = new ComputeBuffer(splatMaps1DSizeTarget, sizeof(float), ComputeBufferType.Default);

                                // Create landscape-scoped low-res heights buffer
                                cbufHeightLandscape = new ComputeBuffer(heightMapLandscape1DSize, sizeof(float), ComputeBufferType.Default);

                                // Create a buffer to hold the LBTexRule struct used in shader
                                int sizeLBTexRule = System.Runtime.InteropServices.Marshal.SizeOf(new LBTexRule());
                                cbufLBTexRules = new ComputeBuffer(numSplatTextures, sizeLBTexRule, ComputeBufferType.Default);

                                // Create a buffer to hold the LBTexture struct used in shader
                                int sizeLBTexture = System.Runtime.InteropServices.Marshal.SizeOf(new LBCSTexture());
                                cbufLBTextures = new ComputeBuffer(numSplatTextures, sizeLBTexture, ComputeBufferType.Default);
                                //Debug.Log("[DEBUG] sizeLBTexture: " + sizeLBTexture);

                                // Count the number of filters used in all the active LBTerrainTextures
                                int numFiltersAllTextures = 0;
                                for (int smTexIdx = 0; smTexIdx < numSplatTextures; smTexIdx++)
                                {
                                    // If LBTerrainTexture is null, add 0
                                    // If filterList is null, add 0
                                    // If stencil filter but no layer, add 0
                                    // If stencil filter with layer GUID, add 1
                                    // If area filter, add 1
                                    numFiltersAllTextures += (terrainTexturesListNoDisabled[smTexIdx] == null ? 0 : terrainTexturesListNoDisabled[smTexIdx].filterList == null ? 0 : terrainTexturesListNoDisabled[smTexIdx].filterList.Count(f => (f.filterType == LBTextureFilter.FilterType.StencilLayer && !string.IsNullOrEmpty(f.lbStencilGUID)) || f.filterType == LBTextureFilter.FilterType.Area));
                                }

                                // Create the buffer to hold the LBCSFilter struct used in the shader
                                int sizeLBCSFilter = System.Runtime.InteropServices.Marshal.SizeOf(new LBCSFilter());
                                if (numFiltersAllTextures > 0)
                                {
                                    cbufLBFilters = new ComputeBuffer(numFiltersAllTextures, sizeLBCSFilter, ComputeBufferType.Default);
                                    // Create the struct used to hold the LBTextureFilter data
                                    lbcsFilter = new LBCSFilter[numFiltersAllTextures];
                                    // Create a list to store the unique stencil layer GUIDs
                                    stencilLayerGUIDList = new List<string>();
                                    // Add an empty list of string for each possible stencil layer resolution
                                    for (int g = 0; g < 7; g++) { stencilLayerArrayGUIDList.Add(new List<string>(7)); }
                                }
                                else
                                {
                                    // Create dummy filter buffer and list of filters
                                    cbufLBFilters = new ComputeBuffer(1, sizeLBCSFilter, ComputeBufferType.Default);
                                    lbcsFilter = new LBCSFilter[1];
                                }
                                //Debug.Log("Num of filters: " + numFilters);

                                #endregion

                                if (cbufHeightsIn != null && cbufSplatMaps != null && cbufLBTexRules != null && cbufLBTextures != null && terrainNormalsTex != null)
                                {
                                    #region Get LBMap textures

                                    // All map textures must be the same size, so first get the min/max widths and heights as Vector4.
                                    // x = MinWidth, y = MinHeight, z = MaxWidth, w = MaxHeight
                                    Vector4 minmaxLBMapSize = LBTerrainTexture.GetMinMaxMapSize(terrainTexturesListNoDisabled);
                                    // Set the max width/height of Map textures which will become the target size for all Maps
                                    int targetMapWidth = Mathf.RoundToInt(minmaxLBMapSize.z);
                                    int targetMapHeight = Mathf.RoundToInt(minmaxLBMapSize.w);

                                    // Are there any maps used in Map or HeightInclinationMap texturingmode?
                                    // NOTE: There is a limit of 2GB per Texture2DArray. width x height x depth x textureFormatBytes x num textures
                                    if (minmaxLBMapSize.w >= 0f)
                                    {
                                        List<LBTerrainTexture> mapOnlyTextureList = terrainTexturesListNoDisabled.FindAll(tt => !tt.isDisabled && (tt.texturingMode == LBTerrainTexture.TexturingMode.Map || tt.texturingMode == LBTerrainTexture.TexturingMode.HeightInclinationMap) && tt.map != null);
                                        int numMaps = (mapOnlyTextureList == null ? 0 : mapOnlyTextureList.Count);

                                        mapsTex2DArray = new Texture2DArray(Mathf.RoundToInt(minmaxLBMapSize.z), Mathf.RoundToInt(minmaxLBMapSize.w), numMaps, TextureFormat.ARGB32, false, true);
                                        if (mapsTex2DArray != null)
                                        {
                                            mapsTex2DArray.hideFlags = HideFlags.DontSave;

                                            for (int mpIdx = 0; mpIdx < numMaps; mpIdx++)
                                            {
                                                map = mapOnlyTextureList[mpIdx].map;

                                                // Is the map already the correct size?
                                                if (map.width == targetMapWidth && map.height == targetMapHeight)
                                                {
                                                    // Does the GPU support texture to texture copies? (Basic)
                                                    // Metal may not support Graphics.CopyTexture.
                                                    if (SystemInfo.copyTextureSupport == UnityEngine.Rendering.CopyTextureSupport.None)
                                                    {
                                                        //Debug.LogWarning("WARNING: " + methodName + " this platform does not support fast texture copy.");

                                                        // Copy texture on CPU into Texture2DArray (much slow)
                                                        mapsTex2DArray.SetPixels(map.GetPixels(0), mpIdx, 0);
                                                        mapsTex2DArray.Apply();
                                                    }
                                                    // Copy texture on GPU into Texture2DArray (fast)
                                                    else { Graphics.CopyTexture(map, 0, mapsTex2DArray, mpIdx); }

                                                    //Debug.Log("Map " + map.name + " copied to texArray " + mpIdx);
                                                }
                                                else
                                                {
                                                    // Upscale texture to match the max size of map textures
                                                    // Create an empty texture with the original size
                                                    Texture2D resizedMapTex = new Texture2D(map.width, map.height, TextureFormat.ARGB32, false, true);
                                                    if (resizedMapTex != null)
                                                    {
                                                        // Check if we need to do slow CPU copies
                                                        if (SystemInfo.copyTextureSupport == UnityEngine.Rendering.CopyTextureSupport.None)
                                                        {
                                                            // Populate it with the original map pixels
                                                            resizedMapTex.SetPixels(map.GetPixels(0), 0);
                                                            resizedMapTex.Apply();
                                                            // Resize
                                                            LBTextureOperations.TexturePointScale(resizedMapTex, targetMapWidth, targetMapHeight);
                                                            // Copy texture on CPU into Texture2DArray (much slow)
                                                            mapsTex2DArray.SetPixels(resizedMapTex.GetPixels(0), mpIdx, 0);
                                                            mapsTex2DArray.Apply();
                                                        }
                                                        else
                                                        {
                                                            // Populate it with the original map pixels
                                                            Graphics.CopyTexture(map, 0, resizedMapTex, 0);
                                                            // Resize
                                                            LBTextureOperations.TexturePointScale(resizedMapTex, targetMapWidth, targetMapHeight);
                                                            // Copy texture on GPU into Texture2DArray (fast)
                                                            Graphics.CopyTexture(resizedMapTex, 0, mapsTex2DArray, mpIdx);
                                                        }

                                                        LBTextureOperations.DestroyTexture2D(ref resizedMapTex);

                                                        //Debug.Log("Map " + map.name + " resized and copied to texArray " + mpIdx);
                                                    }
                                                }
                                            }

                                            // Assign the array of maps to the compute shader
                                            if (numMaps > 0) { shaderTex.SetTexture(kTexPerlinIdx, CSmapsTex2DArray, mapsTex2DArray); }
                                        }
                                        else
                                        {
                                            // Create dummy texture to keep Compute Shader happy
                                            mapsTex2DArray = new Texture2DArray(1, 1, 1, TextureFormat.ARGB32, false, true);
                                            shaderTex.SetTexture(kTexPerlinIdx, CSmapsTex2DArray, mapsTex2DArray);
                                        }
                                    }
                                    else // No LBMaps textures
                                    {
                                        // Create dummy texture to keep Compute Shader happy
                                        mapsTex2DArray = new Texture2DArray(1, 1, 1, TextureFormat.ARGB32, false, true);
                                        shaderTex.SetTexture(kTexPerlinIdx, CSmapsTex2DArray, mapsTex2DArray);
                                    }

                                    #endregion

                                    #region Get Texture Filters (Stencil Layers + Area)

                                    // Discover number textures required for each stencil layer resolution
                                    // This isn't very scalable and probably should be done some more generic way
                                    int numStencilLayerTex128 = LBTerrainTexture.GetNumStencilLayersByResolution(terrainTexturesListNoDisabled, 128);
                                    int numStencilLayerTex256 = LBTerrainTexture.GetNumStencilLayersByResolution(terrainTexturesListNoDisabled, 256);
                                    int numStencilLayerTex512 = LBTerrainTexture.GetNumStencilLayersByResolution(terrainTexturesListNoDisabled, 512);
                                    int numStencilLayerTex1024 = LBTerrainTexture.GetNumStencilLayersByResolution(terrainTexturesListNoDisabled, 1024);
                                    int numStencilLayerTex2048 = LBTerrainTexture.GetNumStencilLayersByResolution(terrainTexturesListNoDisabled, 2048);
                                    int numStencilLayerTex4096 = LBTerrainTexture.GetNumStencilLayersByResolution(terrainTexturesListNoDisabled, 4096);
                                    int numStencilLayerTex8192 = LBTerrainTexture.GetNumStencilLayersByResolution(terrainTexturesListNoDisabled, 8192);

                                    // Store them in a temp list along with their StencilLayerGUID
                                    // Position in list will be the ID assigned to them in the Filter struct

                                    // Link filters to a LBTerrainTexture (there can be multiple Filters per LBTerrainTexture)

                                    if (stencilLayerGUIDList != null && lbcsFilter != null && lbcsFilter.Length == numFiltersAllTextures && cbufLBFilters != null)
                                    {
                                        LBTerrainTexture lbTerrainTexture = null;
                                        int lcFilterIdx = 0;

                                        // Create the texture arrays to hold the unique compressed stencil layer textures
                                        // Create a minimum of 1 in each array (cannot have an array size of zero)
                                        // If there is no stencil for a certain resolution, create a dummy Texture2DArray with a 1x1 Texture to conserve GPU memory
                                        if (numStencilLayerTex128 < 1) { stencilLayerTex2DArrayList.Add(new Texture2DArray(1, 1, 1, TextureFormat.ARGB32, false, true)); }
                                        else { stencilLayerTex2DArrayList.Add(new Texture2DArray(128, 128, numStencilLayerTex128, TextureFormat.ARGB32, false, true)); }
                                        if (numStencilLayerTex256 < 1) { stencilLayerTex2DArrayList.Add(new Texture2DArray(1, 1, 1, TextureFormat.ARGB32, false, true)); }
                                        else { stencilLayerTex2DArrayList.Add(new Texture2DArray(256, 256, numStencilLayerTex256, TextureFormat.ARGB32, false, true)); }
                                        if (numStencilLayerTex512 < 1) { stencilLayerTex2DArrayList.Add(new Texture2DArray(1, 1, 1, TextureFormat.ARGB32, false, true)); }
                                        else { stencilLayerTex2DArrayList.Add(new Texture2DArray(512, 512, numStencilLayerTex512, TextureFormat.ARGB32, false, true)); }
                                        if (numStencilLayerTex1024 < 1) { stencilLayerTex2DArrayList.Add(new Texture2DArray(1, 1, 1, TextureFormat.ARGB32, false, true)); }
                                        else { stencilLayerTex2DArrayList.Add(new Texture2DArray(1024, 1024, numStencilLayerTex1024, TextureFormat.ARGB32, false, true)); }
                                        if (numStencilLayerTex2048 < 1) { stencilLayerTex2DArrayList.Add(new Texture2DArray(1, 1, 1, TextureFormat.ARGB32, false, true)); }
                                        else { stencilLayerTex2DArrayList.Add(new Texture2DArray(2048, 2048, numStencilLayerTex2048, TextureFormat.ARGB32, false, true)); }
                                        if (numStencilLayerTex4096 < 1) { stencilLayerTex2DArrayList.Add(new Texture2DArray(1, 1, 1, TextureFormat.ARGB32, false, true)); }
                                        else { stencilLayerTex2DArrayList.Add(new Texture2DArray(4096, 4096, numStencilLayerTex4096, TextureFormat.ARGB32, false, true)); }
                                        if (numStencilLayerTex8192 < 1) { stencilLayerTex2DArrayList.Add(new Texture2DArray(1, 1, 1, TextureFormat.ARGB32, false, true)); }
                                        else { stencilLayerTex2DArrayList.Add(new Texture2DArray(8192, 8192, numStencilLayerTex8192, TextureFormat.ARGB32, false, true)); }

                                        int numSLayerTex2DArrays = stencilLayerTex2DArrayList.Count;

                                        for (int i = 0; i < numSLayerTex2DArrays; i++) { stencilLayerTex2DArrayList[i].hideFlags = HideFlags.DontSave; }

                                        // Track the current index with the Texture2DArrays so we can know which slot to copy the compressed texture into.
                                        // The currArrayIdx is aligned to the stencilLayerTex2DArrayList. So curArrayIdx[0] stores the position in the
                                        // 128x128 Texture2Array for stencilLayerTex2DArrayList[0]. currArrrayIdx[1] is for the Texture2DArrays containing 256x256 textures etc.
                                        int[] currArrayIdx = new int[7];
                                        // Initialise array
                                        if (currArrayIdx != null) { for (int i = 0; i < currArrayIdx.Length; i++) { currArrayIdx[i] = -1; } }

                                        for (int smTexIdx = 0; smTexIdx < numSplatTextures; smTexIdx++)
                                        {
                                            lbTerrainTexture = terrainTexturesListNoDisabled[smTexIdx];

                                            // Get number of LBTerrainFilters for this LBTerrainTexture
                                            int numFilters = lbTerrainTexture.filterList == null ? 0 : lbTerrainTexture.filterList.Count(f => (f.filterType == LBTextureFilter.FilterType.StencilLayer && !string.IsNullOrEmpty(f.lbStencilGUID)) || f.filterType == LBTextureFilter.FilterType.Area);

                                            // For each filter, increment the overall filter index counter
                                            for (int fIdx = 0; fIdx < numFilters && lcFilterIdx < numFiltersAllTextures; fIdx++, lcFilterIdx++)
                                            {
                                                lbTextureFilter = lbTerrainTexture.filterList[fIdx];
                                                //Debug.Log("[DEBUG] lbcs filter index: " + lcFilterIdx);

                                                // Common properties
                                                lbcsFilter[lcFilterIdx].filterMode = (int)lbTextureFilter.filterMode;
                                                // Link this filter to the LBTerrainTexture (there can be multiple filters per LBTerrainTexture)
                                                lbcsFilter[lcFilterIdx].lbTexIdx = (uint)smTexIdx;
                                                lbcsFilter[lcFilterIdx].minHeight = 0f;
                                                lbcsFilter[lcFilterIdx].maxHeight = 1f;
                                                lbcsFilter[lcFilterIdx].minInclination = 0f;
                                                lbcsFilter[lcFilterIdx].maxInclination = 1f;

                                                // There may be an issue if the GUID is not a valid Stencil Layer GUID
                                                // Filter.lbStencil and Filter.lbStencilLayer properties are pre-loaded above.
                                                // These non-serializable properties are used for compute and non-compute.
                                                if (lbTextureFilter.filterType == LBTextureFilter.FilterType.StencilLayer)
                                                {
                                                    lbStencilLayer = lbTextureFilter.lbStencilLayer;

                                                    if (lbStencilLayer != null)
                                                    {
                                                        // Get the layer resolution and convert it to an index for faster lookup
                                                        stencilLayerResolution = (int)lbStencilLayer.layerResolution;
                                                        int stencilLayerResolutionIdx = -1;

                                                        // There might be a better way of doing this via the position in the enum.
                                                        switch (stencilLayerResolution)
                                                        {
                                                            case 128: stencilLayerResolutionIdx = 0; break;
                                                            case 256: stencilLayerResolutionIdx = 1; break;
                                                            case 512: stencilLayerResolutionIdx = 2; break;
                                                            case 1024: stencilLayerResolutionIdx = 3; break;
                                                            case 2048: stencilLayerResolutionIdx = 4; break;
                                                            case 4096: stencilLayerResolutionIdx = 5; break;
                                                            case 8092: stencilLayerResolutionIdx = 6; break;
                                                        }

                                                        // If it doesn't already exist, add it to the list of unique Stencil Layer GUIDs
                                                        if (!stencilLayerGUIDList.Exists(guid => guid == lbTextureFilter.lbStencilLayerGUID))
                                                        {
                                                            // Add the stencil layer data to the Texture2DArray
                                                            if (lbStencilLayer.compressedTexture != null && stencilLayerResolutionIdx >= 0)
                                                            {
                                                                Texture2DArray texture2DArray = null;

                                                                // Add stencil layer GUID to the list of unique Stencil Layer GUIDs
                                                                stencilLayerGUIDList.Add(lbTextureFilter.lbStencilLayerGUID.ToString());

                                                                // Add stencil layer GUID to list of unique GUIDs for this resolution so we can easily look it up for other filters
                                                                stencilLayerArrayGUIDList[stencilLayerResolutionIdx].Add(lbTextureFilter.lbStencilLayerGUID.ToString());

                                                                //Debug.Log("[DEBUG] Add new GUID " + lbTextureFilter.lbStencilLayerGUID + " for " + stencilLayerResolutionIdx + " " + lbStencilLayer.LayerName);

                                                                texture2DArray = stencilLayerTex2DArrayList[stencilLayerResolutionIdx];
                                                                if (texture2DArray != null)
                                                                {
                                                                    currArrayIdx[stencilLayerResolutionIdx]++;
                                                                    LBTextureOperations.CopyTextureTo2DArray(ref texture2DArray, lbStencilLayer.compressedTexture, currArrayIdx[stencilLayerResolutionIdx], true);
                                                                }
                                                            }
                                                        }
                                                        // Populate the struct used to hold the LBTextureFilter data
                                                        lbcsFilter[lcFilterIdx].csfilterType = 3;

                                                        // Get the position within the list
                                                        if (stencilLayerResolution < 0) { lbcsFilter[lcFilterIdx].stencilLayerTex2DArrIdx = -1; }
                                                        else
                                                        {
                                                            lbcsFilter[lcFilterIdx].stencilLayerTex2DArrIdx = stencilLayerArrayGUIDList[stencilLayerResolutionIdx].FindIndex(guid => guid == lbTextureFilter.lbStencilLayerGUID);
                                                            //Debug.Log("[DEBUG] Tex " + (smTexIdx + 1) + " sten lyr: " + lbStencilLayer.LayerName + " res: " + stencilLayerResolution + " guididx: " + lbcsFilter[lcFilterIdx].stencilLayerTex2DArrIdx);
                                                        }

                                                        // Set stencil layer resolution to 128 if the layer wasn't found.
                                                        lbcsFilter[lcFilterIdx].stencilLayerResolution = (lbTextureFilter.lbStencilLayer == null ? 128 : (int)lbTextureFilter.lbStencilLayer.layerResolution);

                                                        // This is not an Area filter so set to dimensions of landscape
                                                        lbcsFilter[lcFilterIdx].areaRect.x = 0;
                                                        lbcsFilter[lcFilterIdx].areaRect.y = 0;
                                                        lbcsFilter[lcFilterIdx].areaRect.z = landscapeSize.x;
                                                        lbcsFilter[lcFilterIdx].areaRect.w = landscapeSize.y;
                                                    }
                                                }
                                                else if (lbTextureFilter.filterType == LBTextureFilter.FilterType.Area)
                                                {
                                                    // Populate the struct used to hold the LBTextureFilter data
                                                    lbcsFilter[lcFilterIdx].csfilterType = 4;
                                                    // Add the area as boundary points. This becomes a float4 in the compute shader
                                                    lbcsFilter[lcFilterIdx].areaRect.x = lbTextureFilter.areaRect.xMin;
                                                    lbcsFilter[lcFilterIdx].areaRect.y = lbTextureFilter.areaRect.yMin;
                                                    lbcsFilter[lcFilterIdx].areaRect.z = lbTextureFilter.areaRect.xMax;
                                                    lbcsFilter[lcFilterIdx].areaRect.w = lbTextureFilter.areaRect.yMax;
                                                    // This is not a stencil filter
                                                    lbcsFilter[lcFilterIdx].stencilLayerTex2DArrIdx = -1;
                                                    lbcsFilter[lcFilterIdx].stencilLayerResolution = 1024;

                                                    //Debug.Log(" [DEBUG] Area filter: mode: " + lbcsFilter[lcFilterIdx].filterMode + " areaRect: " + lbcsFilter[lcFilterIdx].areaRect);
                                                }
                                            }
                                        }

                                        // Set and Populate texture filter buffer
                                        shaderTex.SetBuffer(kTexPerlinIdx, CSlbFilters, cbufLBFilters);
                                        cbufLBFilters.SetData(lbcsFilter);
                                        // Set the sum of the number of filters for all the LBTerrainTextures
                                        shaderTex.SetInt(CSnumlbFilters, numFiltersAllTextures);
                                        //Debug.Log("FilterVariables: [" + CSnumlbFilters + "] " + numFiltersAllTextures);

                                        // Assign the Texture2DArrays to the compute shader
                                        CopyStencilLayerTex2DArrayListToShader(stencilLayerTex2DArrayList, shaderTex, kTexPerlinIdx);
                                    }
                                    else
                                    {
                                        ConfigDummyStencilLayerTex2DArrayList(stencilLayerTex2DArrayList, shaderTex, kTexPerlinIdx);
                                        // Copy empty Filters to shader
                                        shaderTex.SetBuffer(kTexPerlinIdx, CSlbFilters, cbufLBFilters);
                                        cbufLBFilters.SetData(lbcsFilter);
                                        shaderTex.SetInt(CSnumlbFilters, 0);
                                    }

                                    #endregion

                                    #region Set and Populate buffers as required
                                    // Set the heights buffer to be used by the TexPerlin method in the shader
                                    shaderTex.SetBuffer(kTexPerlinIdx, CSheightsIn, cbufHeightsIn);
                                    // Copy the data into the shader
                                    cbufHeightsIn.SetData(heightMap1D);

                                    // Set the splatmaps buffer to be used by the TexPerlin method in the shader
                                    shaderTex.SetBuffer(kTexPerlinIdx, CSsplatMaps, cbufSplatMaps);

                                    // Rules Struct array buffer
                                    shaderTex.SetBuffer(kTexPerlinIdx, CSlbTexRules, cbufLBTexRules);
                                    cbufLBTexRules.SetData(lbTexRulesArray);

                                    // Low-res landscape-wide heightmap
                                    if (isCurvatureRules && heightMapLandscape1DSize > 1)
                                    {
                                        GetLandscapeScopedHeightmap(landscape, ref heightMapLandscape1D, 65, true);
                                    }
                                    shaderTex.SetBuffer(kTexPerlinIdx, CSheightsLandscape, cbufHeightLandscape);
                                    // Copy the landscape-scoped low-res heights to the shader (or a dummy version with 1 float)
                                    cbufHeightLandscape.SetData(heightMapLandscape1D);
                                    shaderTex.SetInt(CShmapLandscapeRes, (int)Mathf.Sqrt(heightMapLandscape1DSize));
                                    #endregion

                                    #region Create Imported Texture arrays

                                    if (numValidImportedTextures > 0)
                                    {
                                        // TODO - compress data by storing up to 4 LBTexture imported data in each Texture2D in the array
                                        importedTex2DArray = new Texture2DArray(terrainAlphaDataResolution, terrainAlphaDataResolution, numValidImportedTextures, TextureFormat.ARGB32, false, true);

                                        if (LBTerrainData.PopulateTexture2DArray(ref importedTex2DArray, lbTerrainDataList, ref isTerrainAlphaDataValid))
                                        {
                                            shaderTex.SetTexture(kTexPerlinIdx, CStexImportedTex2DArray, importedTex2DArray);
                                        }
                                        #if UNITY_EDITOR
                                        else { Debug.LogWarning("ERROR: " + methodName + " could not populate Texture2DArray for imported LBTextures. PLEASE REPORT"); }
                                        #endif
                                    }
                                    else
                                    {
                                        // Create dummy texture to keep Compute Shader happy
                                        importedTex2DArray = new Texture2DArray(1, 1, 1, TextureFormat.ARGB32, false, true);
                                    }

                                    if (importedTex2DArray != null)
                                    {
                                        mapsTex2DArray.hideFlags = HideFlags.DontSave;
                                        shaderTex.SetTexture(kTexPerlinIdx, CStexImportedTex2DArray, importedTex2DArray);
                                    }


                                    #endregion

                                    #region Populate the struct used to hold the per-LBTerrainTexture data
                                    LBCSTexture[] lbcsTextures = new LBCSTexture[numSplatTextures];
                                    int numLBMapTextures = 0;
                                    // Reset number of valid imported textures so we can assign them in compute shader
                                    numValidImportedTextures = 0;
                                    for (int smTexIdx = 0; smTexIdx < numSplatTextures; smTexIdx++)
                                    {
                                        LBCSTexture lbcsTexture = new LBCSTexture();
                                        LBTerrainTexture lbTerrainTexture = terrainTexturesListNoDisabled[smTexIdx];
                                        if (smTexIdx < enabledTextures && lbTerrainTexture != null)
                                        {
                                            lbcsTexture.texturingMode = (uint)lbTerrainTexture.texturingMode;
                                            lbcsTexture.strength = lbTerrainTexture.strength;
                                            // Bools aren't blittable so cannot use in struct for compute shader. So used ints (0=false, 1=true)
                                            lbcsTexture.useNoise = (lbTerrainTexture.useNoise ? 1 : 0);
                                            lbcsTexture.noiseTileSize = lbTerrainTexture.noiseTileSize;
                                            lbcsTexture.noiseOffset = lbTerrainTexture.noiseOffset;
                                            // Use Int for Bools
                                            lbcsTexture.isMinimalBlendingEnabled = lbTerrainTexture.isMinimalBlendingEnabled ? 1 : 0;
                                            lbcsTexture.isAreaFiltersToApply = isAreaFiltersToApply[smTexIdx] ? 1 : 0;
                                            lbcsTexture.isStencilLayerFiltersToApply = isStencilLayerFiltersToApply[smTexIdx] ? 1 : 0;

                                            // Is this Map or Height, Inclination & Map?
                                            // Only LBTerrainTextures with a Map are stored in the Texture2DArray
                                            if (((int)lbTerrainTexture.texturingMode == 4 || (int)lbTerrainTexture.texturingMode == 5) && lbTerrainTexture.map != null)
                                            {
                                                lbcsTexture.mapTexArrayIdx = numLBMapTextures;
                                                // All maps should be resized (if required) above
                                                lbcsTexture.mapTexWidth = (uint)targetMapWidth;
                                                lbcsTexture.mapTexHeight = (uint)targetMapHeight;
                                                // Use int for bool
                                                lbcsTexture.mapInverse = (lbTerrainTexture.mapInverse ? 1 : 0);
                                                lbcsTexture.importedTexArrayIdx = -1;
                                                numLBMapTextures++;
                                            }
                                            else
                                            {
                                                // Other Texturing modes don't use the map Texture2DArray index
                                                lbcsTexture.mapTexArrayIdx = -1;

                                                // Imported Textures
                                                if ((int)lbTerrainTexture.texturingMode == 20)
                                                {
                                                    if (isTerrainAlphaDataValid[smTexIdx])
                                                    {
                                                        lbcsTexture.importedTexArrayIdx = numValidImportedTextures;
                                                        lbcsTexture.importedTexWidth = (uint)terrainAlphaDataResolution;
                                                        numValidImportedTextures++;
                                                    }
                                                    else
                                                    {
                                                        lbcsTexture.importedTexArrayIdx = -1;
                                                        // Default dummy values
                                                        lbcsTexture.texturingMode = 999;
                                                    }
                                                }
                                                else
                                                {
                                                    // Other Texturing modes do not use the imported Texture2DArray index
                                                    lbcsTexture.importedTexArrayIdx = -1;
                                                }
                                            }

                                            //Debug.Log("Tex " + (smTexIdx + 1) + ": texMode is " + lbcsTexture.texturingMode + " total texs: " + numSplatTextures + " strength: " + lbcsTexture.strength);
                                        }
                                        else
                                        {
                                            #if UNITY_EDITOR
                                            Debug.LogWarning("ERROR: " + methodName + " could not send Texturing information to compute shader for Texture " + (smTexIdx + 1));
                                            #endif
                                            // Default dummy values
                                            lbcsTexture.texturingMode = 999;
                                        }

                                        lbcsTextures[smTexIdx] = lbcsTexture;
                                    }
                                    shaderTex.SetBuffer(kTexPerlinIdx, CSlbTextures, cbufLBTextures);
                                    // Copy the LBCSTexture data into the compute shader
                                    cbufLBTextures.SetData(lbcsTextures);

                                    #endregion

                                    #region Curves
                                    // Texture curves
                                    int numKeyFrames = 0;

                                    pkKeyFrames = LBCurve.GetComputeKeyFrames(LBPath.GetDefaultBlendCurve);
                                    numKeyFrames = (pkKeyFrames == null ? 0 : pkKeyFrames.Length);
                                    if (numKeyFrames > 0)
                                    {
                                        cbufLBPathCurve = new ComputeBuffer(numKeyFrames, sizeof(float) * 4, ComputeBufferType.Default);
                                        if (cbufLBPathCurve != null) { shaderTex.SetBuffer(kTexPerlinIdx, CSlbPathCurve, cbufLBPathCurve); cbufLBPathCurve.SetData(pkKeyFrames); }
                                    }
                                    #if UNITY_EDITOR
                                    else { Debug.LogWarning("ERROR " + methodName + " - could not send LBMap curve data to texture compute shader."); }
                                    #endif
                                    shaderTex.SetInt(CSlbPathCurveNumKeys, numKeyFrames);

                                    #endregion

                                    #region Set shader variables
                                    // Terrain variables
                                    shaderTex.SetInt(CSheightmapResolution, heightmapResolution);
                                    shaderTex.SetFloat(CSterrainWidth, terrainSize.x);
                                    shaderTex.SetFloat(CSterrainLength, terrainSize.y);
                                    shaderTex.SetFloat(CSterrainHeight, terrainHeight);
                                    shaderTex.SetVector(CSterrainWorldPos, worldPosition);
                                    shaderTex.SetTexture(kTexPerlinIdx, CSterrainNormals, terrainNormalsTex);
                                    // Landscape variables
                                    shaderTex.SetVector(CSlandscapePos, landscapePosition);
                                    shaderTex.SetVector(CSlandscapeSize, landscapeSize);
                                    // Splatmap variables
                                    shaderTex.SetInt(CSnumSplatTextures, numSplatTextures);
                                    shaderTex.SetInt(CSalphaMapWidth, alphamapWidth);
                                    shaderTex.SetInt(CSalphaMapLength, alphamapHeight);

                                    // Unused variables (used in TexModGroup)
                                    shaderTex.SetInt(CSnumTerrainsWide, 1);
                                    shaderTex.SetInt(CSterrainIdx, 0);

                                    #endregion

                                    #region Execute the compute shader

                                    int threadGroupX = Mathf.CeilToInt(splatMap1DSize / cskTexPerlinNumThreads);
                                    shaderTex.Dispatch(kTexPerlinIdx, threadGroupX, 1, 1);

                                    // Retrieve the splatmaps
                                    cbufSplatMaps.GetData(splatMaps1D);

                                    // Copy shader 1D data to 3D alphamap array
                                    for (int smTexIdx = 0; smTexIdx < numSplatTextures; smTexIdx++)
                                    {
                                        for (int y = 0; y < alphamapHeight; y++)
                                        {
                                            for (int x = 0; x < alphamapWidth; x++)
                                            {
                                                alphamap[x, y, smTexIdx] = splatMaps1D[(splatMap1DSize * smTexIdx) + (alphamapHeight * y) + x];
                                            }
                                        }
                                    }

                                    #endregion
                                }

                                //Debug.Log("[DEBUG] Tex Compute phase finished " + System.DateTime.Now.ToLongTimeString() + " duration: " + (Time.realtimeSinceStartup - csStart).ToString("0.0000") + "s");
                            }
                        }

                        // Set texturing data (if no LBTerrainTextures enabled set to 0)
                        tData.SetAlphamaps(0, 0, alphamap);
                    }
                    catch (System.Exception ex)
                    {
                        #if UNITY_EDITOR
                        Debug.LogWarning("ERROR " + methodName + " - could not texture landscape with GPU - " + ex.Message);
                        #else
                        if (ex != null) {}
                        #endif
                    }

                    #region Free Resources
                    finally
                    {
                        if (cbufHeightsIn != null) { cbufHeightsIn.Release(); cbufHeightsIn = null; }
                        if (cbufHeightLandscape != null) { cbufHeightLandscape.Release(); cbufHeightLandscape = null; }
                        if (cbufSplatMaps != null) { cbufSplatMaps.Release(); cbufSplatMaps = null; }
                        if (cbufLBPathCurve != null) { cbufLBPathCurve.Release(); cbufLBPathCurve = null; }
                        if (cbufLBTexRules != null) { cbufLBTexRules.Release(); cbufLBTexRules = null; }
                        if (cbufLBTextures != null) { cbufLBTextures.Release(); cbufLBTextures = null; }
                        if (cbufLBFilters != null) { cbufLBFilters.Release(); cbufLBFilters = null; }

                        // Dispose any Texture2Ds
                        if (terrainNormalsTex != null) { LBTextureOperations.DestroyTexture2D(ref terrainNormalsTex); }
                        if (mapsTex2DArray != null) { LBTextureOperations.DestroyTexture2DArray(ref mapsTex2DArray); }
                        if (importedTex2DArray != null) { LBTextureOperations.DestroyTexture2DArray(ref importedTex2DArray); }

                        int numStencilLayerArrays = (stencilLayerTex2DArrayList == null ? 0 : stencilLayerTex2DArrayList.Count);

                        for (int slArrayIdx = numStencilLayerArrays - 1; slArrayIdx >= 0; slArrayIdx--)
                        {
                            Texture2DArray texture2DArray = stencilLayerTex2DArrayList[slArrayIdx];
                            if (texture2DArray != null) { LBTextureOperations.DestroyTexture2DArray(ref texture2DArray); }
                            // Check if was correctly disposed
                            #if UNITY_EDITOR
                            if (stencilLayerTex2DArrayList[slArrayIdx] != null) { Debug.LogWarning("ERROR: " + methodName + " - stencillayer tex2Darray" + slArrayIdx + "  not released correctly"); }
                            #endif
                        }
                        if (stencilLayerTex2DArrayList != null) { stencilLayerTex2DArrayList.Clear(); }

                    }
                    #endregion

#endif

                    #endregion

                    #region Non-Compute

                    if (!isTexComputeEnabled)
                    {
                        #region Non-Compute variables
                        float heightN;
                        #endregion

                        #region Curvature Variables
                        // 4 surrounding height points
                        float h1XN, h1ZN, h2XN, h2ZN, h3XN, h3ZN, h4XN, h4ZN;
                        float h1 = 0f, h2 = 0f, h3 = 0f, h4 = 0f;
                        Vector2 hOffsetPos = Vector2.zero;
                        #endregion

                        // Loop through alphamap points
                        for (int y = 0; y < alphamapHeight; y++)
                        {
                            for (int x = 0; x < alphamapWidth; x++)
                            {
                                // Get terrain normalised position of alphamap point - values between 0.0 and 1.0
                                xPos = (float)x / alphamapWidthLess1F;
                                yPos = (float)y / alphamapHeightLess1F;

                                // Find the world-space coordinates of this alphamap position (used or Area and Stencil Layer filters)
                                worldPoint.x = (yPos * terrainSize.x) + worldPosition.x;
                                worldPoint.y = (xPos * terrainSize.y) + worldPosition.z;

                                if (landscape != null)
                                {
                                    landscapePoint.x = worldPoint.x - landscape.start.x;
                                    landscapePoint.y = worldPoint.y - landscape.start.z;
                                }
                                else
                                {
                                    landscapePoint.x = worldPoint.x - landscapePosition.x;
                                    landscapePoint.y = worldPoint.y - landscapePosition.z;
                                }

                                // If a landscape is supplied, check the edges with the same terrain to ensure both sides of the terrain
                                // edges use the same values. Only check the edges, as this method is slightly slower than checking the current terrain.
                                if (useLandscapeSlope && (x == 0 || x == alphamapWidthLess1 || y == 0 || y == alphamapHeightLess1))
                                {
                                    landscapePosN2D = landscape.NormalisePointFromWorldPos2DFast(worldPoint);
                                    GetLandscapeInterpolatedData(terrainDataArray, terrainRectsArray, new Vector2(landscapePosN2D.x * landscapeWidth, landscapePosN2D.y * landscapeLength), ref height, ref angle);
                                    // add small value to ensure range that includes 0 height works
                                    height += 0.00001f;
                                    // add small value to ensure range that includes 0 angle works
                                    angle += 0.00001f;
                                }
                                else
                                {
                                    // Interpolate between textures based on height (add small value to ensure range that includes 0 height works)
                                    height = tData.GetInterpolatedHeight(yPos, xPos) + 0.00001f;
                                    // Interpolate between textures based on steepness (add small value to ensure range that includes 0 angle works)
                                    angle = tData.GetSteepness(yPos, xPos) + 0.00001f;
                                }

                                heightN = height / terrainHeight;

                                for (int smTexIdx = 0; smTexIdx < numSplatTextures; smTexIdx++)
                                {
                                    // Set blend weight for each texture
                                    #region Height Rule
                                    if (terrainTexturesListNoDisabled[smTexIdx].texturingMode == LBTerrainTexture.TexturingMode.Height)
                                    {
                                        blendWeights[smTexIdx] = texturingCurve.Evaluate(Mathf.InverseLerp(lbTexRulesArray[smTexIdx].minHeightN, lbTexRulesArray[smTexIdx].maxHeightN, heightN));
                                    }
                                    #endregion

                                    #region Inclination Rule
                                    else if (terrainTexturesListNoDisabled[smTexIdx].texturingMode == LBTerrainTexture.TexturingMode.Inclination)
                                    {
                                        blendWeights[smTexIdx] = texturingCurve.Evaluate(Mathf.InverseLerp(lbTexRulesArray[smTexIdx].minInclination, lbTexRulesArray[smTexIdx].maxInclination, angle));
                                    }
                                    #endregion

                                    #region Height and Inclination Rules
                                    else if (terrainTexturesListNoDisabled[smTexIdx].texturingMode == LBTerrainTexture.TexturingMode.HeightAndInclination)
                                    {
                                        blendWeights[smTexIdx] = texturingCurve.Evaluate(Mathf.InverseLerp(lbTexRulesArray[smTexIdx].minHeightN, lbTexRulesArray[smTexIdx].maxHeightN, heightN))
                                                          * texturingCurve.Evaluate(Mathf.InverseLerp(lbTexRulesArray[smTexIdx].minInclination, lbTexRulesArray[smTexIdx].maxInclination, angle));
                                    }
                                    #endregion

                                    #region Height Inclination Curvature Rules
                                    else if (terrainTexturesListNoDisabled[smTexIdx].texturingMode == LBTerrainTexture.TexturingMode.HeightInclinationCurvature)
                                    {
                                        blendWeights[smTexIdx] = texturingCurve.Evaluate(Mathf.InverseLerp(lbTexRulesArray[smTexIdx].minHeightN, lbTexRulesArray[smTexIdx].maxHeightN, heightN))
                                                          * texturingCurve.Evaluate(Mathf.InverseLerp(lbTexRulesArray[smTexIdx].minInclination, lbTexRulesArray[smTexIdx].maxInclination, angle));

                                        // Check curvature
                                        if (blendWeights[smTexIdx] > 0f)
                                        {
                                            // Get 4 surrounding points x and y are reversed for alphamap
                                            h1XN = yPos;
                                            h1ZN = xPos - lbTexRulesArray[smTexIdx].curvatureDistanceZN;
                                            h2XN = yPos;
                                            h2ZN = xPos + lbTexRulesArray[smTexIdx].curvatureDistanceZN;
                                            h3XN = yPos - lbTexRulesArray[smTexIdx].curvatureDistanceXN;
                                            h3ZN = xPos;
                                            h4XN = yPos + lbTexRulesArray[smTexIdx].curvatureDistanceXN;
                                            h4ZN = xPos;

                                            if (h1ZN >= 0f) { h1 = tData.GetInterpolatedHeight(h1XN, h1ZN) / terrainHeight; }
                                            else
                                            {
                                                hOffsetPos.x = landscapePoint.x;
                                                hOffsetPos.y = landscapePoint.y - (lbTexRulesArray[smTexIdx].curvatureDistanceZN * terrainSize.y);
                                                GetLandscapeInterpolatedData(terrainDataArray, terrainRectsArray, hOffsetPos, ref h1);
                                                h1 /= terrainHeight;
                                            }

                                            if (h2ZN <= 1f) { h2 = tData.GetInterpolatedHeight(h2XN, h2ZN) / terrainHeight; }
                                            else
                                            {
                                                hOffsetPos.x = landscapePoint.x;
                                                hOffsetPos.y = landscapePoint.y + (lbTexRulesArray[smTexIdx].curvatureDistanceZN * terrainSize.y);
                                                GetLandscapeInterpolatedData(terrainDataArray, terrainRectsArray, hOffsetPos, ref h2);
                                                h2 /= terrainHeight;
                                            }

                                            if (h3XN >= 0f) { h3 = tData.GetInterpolatedHeight(h3XN, h3ZN) / terrainHeight; }
                                            else
                                            {
                                                hOffsetPos.x = landscapePoint.x - (lbTexRulesArray[smTexIdx].curvatureDistanceXN * terrainSize.x);
                                                hOffsetPos.y = landscapePoint.y;
                                                GetLandscapeInterpolatedData(terrainDataArray, terrainRectsArray, hOffsetPos, ref h3);
                                                h3 /= terrainHeight;
                                            }

                                            if (h4XN <= 1f) { h4 = tData.GetInterpolatedHeight(h4XN, h4ZN) / terrainHeight; }
                                            else
                                            {
                                                hOffsetPos.x = landscapePoint.x + (lbTexRulesArray[smTexIdx].curvatureDistanceXN * terrainSize.x);
                                                hOffsetPos.y = landscapePoint.y;
                                                GetLandscapeInterpolatedData(terrainDataArray, terrainRectsArray, hOffsetPos, ref h4);
                                                h4 /= terrainHeight;
                                            }

                                            if (lbTexRulesArray[smTexIdx].isCurvatureConcave == 1)
                                            {
                                                // If Avg is NOT above the current point by height difference, then it is NOT concave
                                                if (((h1 + h2 + h3 + h4) / 4f) < heightN + lbTexRulesArray[smTexIdx].curvatureMinHeightDiffN) { blendWeights[smTexIdx] = 0f; }
                                            }
                                            else
                                            {
                                                // If Avg is NOT below the current point by height difference, then it is NOT convex
                                                if (((h1 + h2 + h3 + h4) / 4f) > heightN + lbTexRulesArray[smTexIdx].curvatureMinHeightDiffN) { blendWeights[smTexIdx] = 0f; }
                                            }
                                        }
                                    }
                                    #endregion

                                    #region Constant Influence Rule
                                    else if (terrainTexturesListNoDisabled[smTexIdx].texturingMode == LBTerrainTexture.TexturingMode.ConstantInfluence)
                                    {
                                        blendWeights[smTexIdx] = 1f;
                                    }
                                    #endregion

                                    #region  Map or HeightInclinationMap

                                    else if (terrainTexturesListNoDisabled[smTexIdx].texturingMode == LBTerrainTexture.TexturingMode.Map ||
                                             terrainTexturesListNoDisabled[smTexIdx].texturingMode == LBTerrainTexture.TexturingMode.HeightInclinationMap)
                                    {
                                        if (terrainTexturesListNoDisabled[smTexIdx].map != null)
                                        {
                                            // If position in alphamap matches position in map image, Blend Weight = 1, else = 0
                                            if (lbMapList.Count > smTexIdx) { lbMap = lbMapList[smTexIdx]; }
                                            else { lbMap = null; }

                                            if (lbMap != null)
                                            {
                                                mapPoint = lbMap.GetMapPositionFromTerrainPosition(xPos, yPos, startX, endX, startY, endY);

                                                // Was this map created with a LB Map Path?
                                                if (terrainTexturesListNoDisabled[smTexIdx].mapIsPath)
                                                {
                                                    // Compare the normalised terrain coordinates to the point on the Map texture (PNG image) 
                                                    pixelVariationNormalised = lbMap.GetPixelColourVariationNormalised(mapPoint.x, mapPoint.y, Color.clear);

                                                    if (pixelVariationNormalised == 1f) { if (lbMap.inverse) { blendWeights[smTexIdx] = 1f; } else { blendWeights[smTexIdx] = 0f; } }
                                                    else if (pixelVariationNormalised > 0.001f)
                                                    {
                                                        if (lbMap.inverse)
                                                        {
                                                            blendWeights[smTexIdx] = lbMap.toleranceBlendCurve.Evaluate(pixelVariationNormalised);
                                                        }
                                                        else
                                                        {
                                                            blendWeights[smTexIdx] = lbMap.toleranceBlendCurve.Evaluate(1f - pixelVariationNormalised);
                                                        }
                                                    }
                                                    // If exact pixel in map is white (exact match) blendweight is 1. If inverse = 0.
                                                    else { if (lbMap.inverse) { blendWeights[smTexIdx] = 0f; } else { blendWeights[smTexIdx] = 1f; } }

                                                }
                                                else
                                                {
                                                    // Check if the pixel in the map is the same as the mapColour within the Tolerance factor
                                                    // If lbMap.useAdvancedTolerance is true, tolerance will use the separate RGBA tolerance values (and will compare alpha)
                                                    if (lbMap.IsMapPixelMatchToMapColour(mapPoint.x, mapPoint.y, terrainTexturesListNoDisabled[smTexIdx].useAdvancedMapTolerance, true))
                                                    {
                                                        if (lbMap.useAdvancedTolerance)
                                                        {
                                                            if (lbMap.IsPixelColourExactMatch(true))
                                                            {
                                                                blendWeights[smTexIdx] = 1f;
                                                            }
                                                            else
                                                            {
                                                                // Use tolerance weighted averages
                                                                pixelTolerance = lbMap.GetToleranceWeightedAvg();
                                                                pixelColourAvgVariation = lbMap.GetPixelColourVariationNormalisedWeightedAvg() * 255f;
                                                                blendWeights[smTexIdx] = lbMap.toleranceBlendCurve.Evaluate(1f - (pixelColourAvgVariation / (pixelTolerance + 0.001f)));

                                                                if (lbMap.inverse) { blendWeights[smTexIdx] = 1 - blendWeights[smTexIdx]; }
                                                            }
                                                        }
                                                        else
                                                        {
                                                            // If the pixel varies from the target colour but is still within the tolerance,
                                                            // we want to proportionally reduce the weight
                                                            pixelColourAvgVariation = lbMap.GetPixelColourAvgVariation(false);

                                                            if (pixelColourAvgVariation > 0.01f)
                                                            {
                                                                if (lbMap.inverse)
                                                                {
                                                                    // Not sure why this doesn't reverse blend
                                                                    blendWeights[smTexIdx] = lbMap.toleranceBlendCurve.Evaluate(pixelColourAvgVariation / ((float)lbMap.tolerance + 0.001f));
                                                                }
                                                                else
                                                                {
                                                                    blendWeights[smTexIdx] = lbMap.toleranceBlendCurve.Evaluate(1f - (pixelColourAvgVariation / ((float)lbMap.tolerance + 0.001f)));
                                                                }
                                                            }
                                                            // Pixel on map was an exact match to the mapColour
                                                            else { blendWeights[smTexIdx] = 1f; }
                                                        }
                                                    }
                                                    // Pixel on the Map didn't match one user selected
                                                    else { blendWeights[smTexIdx] = 0f; }
                                                }
                                            }
                                            // Couldn't create LBMap
                                            else { blendWeights[smTexIdx] = 0f; }

                                            if (terrainTexturesListNoDisabled[smTexIdx].texturingMode == LBTerrainTexture.TexturingMode.HeightInclinationMap)
                                            {
                                                // Multiply the Map result with the Height and Inclination result
                                                blendWeights[smTexIdx] *= texturingCurve.Evaluate(Mathf.InverseLerp(lbTexRulesArray[smTexIdx].minHeightN, lbTexRulesArray[smTexIdx].maxHeightN, heightN))
                                                          * texturingCurve.Evaluate(Mathf.InverseLerp(lbTexRulesArray[smTexIdx].minInclination, lbTexRulesArray[smTexIdx].maxInclination, angle));

                                            }
                                        }
                                        // TexturingMode is Map but user hasn't added a map Texture
                                        else { blendWeights[smTexIdx] = 0f; }
                                    }
                                    #endregion

                                    #region Imported
                                    else if (terrainTexturesListNoDisabled[smTexIdx].texturingMode == LBTerrainTexture.TexturingMode.Imported)
                                    {
                                        if (isTerrainAlphaDataValid[smTexIdx])
                                        {
                                            if (lbTerrainDataList[smTexIdx] != null)
                                            {
                                                blendWeights[smTexIdx] = lbTerrainDataList[smTexIdx].textureAlphaMapData[y * alphamapWidth + x];
                                            }
                                            else { blendWeights[smTexIdx] = 0f; }
                                        }
                                        else { blendWeights[smTexIdx] = 0f; }
                                    }
                                    #endregion

                                    // Check filters
                                    includePoint = true;

                                    #region Area Filters
                                    if (blendWeights[smTexIdx] > 0.001f && isAreaFiltersToApply[smTexIdx])
                                    {
                                        if (terrainTexturesListNoDisabled[smTexIdx].filterList != null)
                                        {
                                            // If there are no filters in the list texture this point
                                            includePoint = (terrainTexturesListNoDisabled[smTexIdx].filterList.Count == 0);

                                            // Should we include this point? (v1.3.0 only supports Area filters)
                                            for (textureFilterIndex = 0; textureFilterIndex < terrainTexturesListNoDisabled[smTexIdx].filterList.Count; textureFilterIndex++)
                                            {
                                                lbTextureFilter = terrainTexturesListNoDisabled[smTexIdx].filterList[textureFilterIndex];

                                                if (lbTextureFilter != null)
                                                {
                                                    // Check the Area filters
                                                    if (lbTextureFilter.filterType == LBTextureFilter.FilterType.Area)
                                                    {
                                                        // Compare it to the area filter
                                                        // NOTE: We're not using Rect.Contains(Vector2) because the top and right boundaries are ignored
                                                        if (landscapePoint.x >= lbTextureFilter.areaRect.xMin && landscapePoint.x <= lbTextureFilter.areaRect.xMax &&
                                                            landscapePoint.y >= lbTextureFilter.areaRect.yMin && landscapePoint.y <= lbTextureFilter.areaRect.yMax)
                                                        {
                                                            includePointCurrentFilter = true;
                                                        }
                                                        else
                                                        {
                                                            includePointCurrentFilter = false;
                                                        }

                                                        if (lbTextureFilter.filterMode == LBTextureFilter.FilterMode.AND)
                                                        {
                                                            if (includePointCurrentFilter)
                                                            {
                                                                if (textureFilterIndex == 0) { includePoint = true; }
                                                                else
                                                                {
                                                                    // If the point has been included with a previous filter it will still be included
                                                                    // and we don't need to do anything here.

                                                                    // Because this an AND, if it hasn't already been included by another filter, it
                                                                    // will never be included.
                                                                    if (!includePoint) { break; }
                                                                }
                                                            }
                                                            // With the AND operator, if this point is not in the area we should not texture it
                                                            else { includePoint = false; break; }
                                                        }
                                                        else if (lbTextureFilter.filterMode == LBTextureFilter.FilterMode.NOT)
                                                        {
                                                            if (!includePointCurrentFilter) { includePoint = true; }
                                                            else { includePoint = false; break; }
                                                        }

                                                        // If using Filter1 OR Filter 2 OR.. any "hit" will satisfy the criteria and there is no need
                                                        // to test any other area filters.
                                                        else if (includePointCurrentFilter && lbTextureFilter.filterMode == LBTextureFilter.FilterMode.OR)
                                                        {
                                                            includePoint = true;
                                                        }
                                                    }
                                                }
                                            }
                                            if (!includePoint) { blendWeights[smTexIdx] = 0f; }
                                        }
                                    } // end check area filters
                                    #endregion

                                    #region Stencil Layer Filters

                                    if (blendWeights[smTexIdx] > 0.001f && isStencilLayerFiltersToApply[smTexIdx])
                                    {
                                        // If there are no filters in the list texture this point
                                        includePoint = (terrainTexturesListNoDisabled[smTexIdx].filterList.Count == 0);

                                        foreach (LBTextureFilter lbFilter in terrainTexturesListNoDisabled[smTexIdx].filterList)
                                        {
                                            // The layerArray should have been pre-populated for StencilLayer filters
                                            // Check for lbFilter.lbStencilLayer != null in case user deleted the Stencil Layer in the scene
                                            if (lbFilter.filterType == LBTextureFilter.FilterType.StencilLayer && lbFilter.lbStencilLayer != null && lbFilter.lbStencilLayer.layerArray != null)
                                            {
                                                // Get the value of the Stencil layer at this point in the terrain
                                                stencilLayerResolution = (int)lbFilter.lbStencilLayer.layerResolution;
                                                // Get the normalised position in the landscape
                                                stencilLayerPosN = landscape.NormalisePointFromWorldPos2DFast(worldPoint);
                                                // Get the point within the stencil layer USHORT array
                                                arrayPoint.x = Mathf.RoundToInt(stencilLayerPosN.x * (stencilLayerResolution - 1f));
                                                arrayPoint.y = Mathf.RoundToInt((1f - stencilLayerPosN.y) * (stencilLayerResolution - 1f));

                                                // Ensure it isn't outside the range of the USHORT array
                                                arrayPoint.x = Mathf.Clamp(arrayPoint.x, 0, stencilLayerResolution - 1);
                                                arrayPoint.y = Mathf.Clamp(arrayPoint.y, 0, stencilLayerResolution - 1);

                                                /// TODO - might be able to improve texture stencil layer blend using a curve
                                                stencilLayerPixel = lbFilter.lbStencilLayer.layerArray[arrayPoint.x, arrayPoint.y];

                                                if (lbFilter.filterMode == LBTextureFilter.FilterMode.AND)
                                                {
                                                    includePoint = (stencilLayerPixel > 0);

                                                    // Blend based on texture stencil layer pixel value
                                                    if (!includePoint) { blendWeights[smTexIdx] = 0f; break; }
                                                    else
                                                    {
                                                        // Lerp between 0 and blendWeights[z]
                                                        blendWeights[smTexIdx] = Mathf.LerpUnclamped(0f, blendWeights[smTexIdx], stencilLayerPixel / 65535f);
                                                    }
                                                }
                                                else if (lbFilter.filterMode == LBTextureFilter.FilterMode.NOT)
                                                {
                                                    includePoint = (stencilLayerPixel < 65535);

                                                    if (!includePoint) { blendWeights[smTexIdx] = 0f; break; }
                                                    else
                                                    {
                                                        // Lerp between blendWeights[z] and 0 (reverse of the AND blending)
                                                        blendWeights[smTexIdx] = Mathf.LerpUnclamped(blendWeights[smTexIdx], 0f, stencilLayerPixel / 65535f);
                                                    }
                                                }
                                            }
                                        }
                                    }

                                    #endregion

                                    #region Noise
                                    if (terrainTexturesListNoDisabled[smTexIdx].useNoise && includePoint)
                                    {
                                        // Get a perlin noise value for this point in the landscape
                                        textureNoiseTileSize = terrainTexturesListNoDisabled[smTexIdx].noiseTileSize;
                                        // For correct noise across terrain boundaries xPos and yPos must be switched (like it is in worldPoint)
                                        // Get the noise with Octaves = 5
                                        noiseValue = Mathf.Abs(LBNoise.PerlinFractalNoise((worldPoint.x + terrainTexturesListNoDisabled[smTexIdx].noiseOffset) / textureNoiseTileSize, (worldPoint.y + terrainTexturesListNoDisabled[smTexIdx].noiseOffset) / textureNoiseTileSize, 5) - 0.5f) * 4f;

                                        // Limit noise value between 0.1 and 1
                                        noiseValue = Mathf.Clamp(noiseValue, 0.1f, 1f);

                                        // Minimal Blending
                                        if (terrainTexturesListNoDisabled[smTexIdx].isMinimalBlendingEnabled)
                                        {
                                            blendWeights[smTexIdx] *= noiseValue;
                                            if (blendWeights[smTexIdx] < 0.1f) { blendWeights[smTexIdx] = 0.01f; }
                                            else if (blendWeights[smTexIdx] > 0.49f) { blendWeights[smTexIdx] = 1.0f; }
                                        }
                                        else
                                        {
                                            blendWeights[smTexIdx] *= noiseValue;
                                        }
                                    }

                                    #endregion

                                    // Multiply the result by the strength of this LBTerrainTexture
                                    blendWeights[smTexIdx] *= terrainTexturesListNoDisabled[smTexIdx].strength;
                                }

                                #region Normalise Blending
                                // Normalise each blend weight so that the sum of all blend weights is 1
                                normFactor = blendWeights.Sum();
                                for (int z = 0; z < numSplatTextures; z++)
                                {
                                    alphamap[x, y, z] = blendWeights[z] / normFactor;
                                }
                                #endregion
                            }

                            // Set texturing data
                            tData.SetAlphamaps(0, 0, alphamap);
                        }
                    }
                    #endregion
                }
            }

            if (showTiming)
            {
                Debug.Log("Time taken for terrain texturing: " + (Time.realtimeSinceStartup - tStart).ToString("0.000") + " seconds");
            }

            return tData;
        }

        /// <summary>
        /// Export the splatmap texture data from a terrain into the correct location in the supplied image.
        /// The splatmap texture is determined by the zero-based alphaMapIndex.
        /// numTerrains is the number of terrains in the landscape.
        /// terrainRow, terrainCol represents location within the landscape "grid" of terrains.
        /// </summary>
        /// <param name="landscape"></param>
        /// <param name="numTerrains"></param>
        /// <param name="terrain"></param>
        /// <param name="terrainRow"></param>
        /// <param name="terrainCol"></param>
        /// <param name="alphaMapIndex"></param>
        /// <param name="image"></param>
        /// <param name="channel"></param>
        /// <param name="showErrors"></param>
        public static void ExportTextureFromSplatmap(LBLandscape landscape, int numTerrains, Terrain terrain, int terrainRow, int terrainCol, int alphaMapIndex, Texture2D image, string channel, bool showErrors)
        {
            string methodName = "LBLandscapeTerrain.ExportTextureFromSplatmap";

            // Validation
            if (landscape == null) { if (showErrors) { Debug.LogWarning("ERROR " + methodName + " - landscape script object is null"); } }
            else if (numTerrains < 1) { if (showErrors) { Debug.LogWarning("ERROR " + methodName + " - numTerrains is invalid"); } }
            else if (terrain == null) { if (showErrors) { Debug.LogWarning("ERROR " + methodName + " - terrain is null"); } }
            else if (terrain.terrainData == null) { if (showErrors) { Debug.LogWarning("ERROR " + methodName + " - terrain has no data"); } }
            else if (image == null) { if (showErrors) { Debug.LogWarning("ERROR " + methodName + " - image to update is null"); } }
            else if (image.width < 2 || image.height < 2) { if (showErrors) { Debug.LogWarning("ERROR " + methodName + " - image dimensions are invalid"); } }
            else if (string.IsNullOrEmpty(channel)) { if (showErrors) { Debug.LogWarning("ERROR " + methodName + " - (output) channel must be R,G,B, or A"); } }
            else
            {
                TerrainData tData = terrain.terrainData;

                int numberAlphaMapLayers = tData.alphamapLayers;
                int alphamapWidth = tData.alphamapWidth;
                int alphamapHeight = tData.alphamapHeight;

                float alphamapWidthFminus1 = alphamapWidth - 1;
                float alphamapHeightFminus1 = alphamapHeight - 1;

                bool isRedChannel = channel == "R";
                bool isGreenChannel = channel == "G";
                bool isBlueChannel = channel == "B";
                //bool isAlphaChannel = channel == "A";

                float alphaMapValue = 0f;
                int imageWidth = image.width;
                int imageHeight = image.height;

                int numTerrainsWide = Mathf.RoundToInt(Mathf.Sqrt(numTerrains));
                float numTerrainsWideF = (float)numTerrainsWide;

                // Get the normalised (0-1) bounds of this terrain within the output image bounds
                float startZ = numTerrains == 1 ? 0f : ((float)terrainCol / numTerrainsWideF);
                float endZ = numTerrains == 1 ? 1f : startZ + (1f / numTerrainsWideF);
                float startX = numTerrains == 1 ? 0f : ((float)terrainRow / numTerrainsWideF);
                float endX = numTerrains == 1 ? 1f : startX + (1f / numTerrainsWideF);

                Color32 pixel = new Color32(0, 0, 0, 255);
                Color32[] pixels = image.GetPixels32();

                float[,,] alphamap = tData.GetAlphamaps(0, 0, alphamapWidth, alphamapHeight);

                if (alphamap != null)
                {
                    for (int x = 0; x < imageWidth; x++)
                    {
                        // Get the 0-1 x value of this pixel
                        float xDecimal = (float)x / (float)(imageWidth - 1);
                        // If this pixel is within the x bounds of this terrain...
                        if (xDecimal >= startX && xDecimal <= endX)
                        {
                            for (int z = 0; z < imageHeight; z++)
                            {
                                // Get the 0-1 y value of this pixel
                                float zDecimal = (float)z / (float)(imageHeight - 1);
                                // If this pixel is within the y bounds of this terrain...
                                if (zDecimal >= startZ && zDecimal <= endZ)
                                {
                                    // Get the normalised (0-1) position of the pixel in relation to the terrain
                                    float xDecimal2 = (xDecimal - startX) / (endX - startX);
                                    float zDecimal2 = (zDecimal - startZ) / (endZ - startZ);

                                    // Get the value of the alphamap at this point
                                    alphaMapValue = alphamap[Mathf.RoundToInt(xDecimal2 * alphamapWidthFminus1), Mathf.RoundToInt(zDecimal2 * alphamapHeightFminus1), alphaMapIndex];

                                    if (isRedChannel) { pixel.r = (byte)(alphaMapValue * 255f); }
                                    else if (isGreenChannel) { pixel.g = (byte)(alphaMapValue * 255f); }
                                    else if (isBlueChannel) { pixel.b = (byte)(alphaMapValue * 255f); }
                                    else { pixel.a = (byte)(alphaMapValue * 255f); }

                                    pixels[x * imageWidth + z] = pixel;
                                }
                            }
                        }
                    }

                    // This is pretty slow, and therefore needs to be done only when necessary
                    // i.e. not within a tight loop
                    image.SetPixels32(pixels);
                    image.Apply();
                }
            }

        }

        /// <summary>
        /// Create a texture from a terrain's splatmap (alphamap).
        /// Each terrain can have up to 12 textures (4 per splatmap)
        /// splatmapIndex = 0 for first 4 textures
        /// splatmapIndex = 1 for second 4 textures
        /// splatmapIndex = 2 for third 4 textures
        /// See also LBLandscapeOperations.GetSplatmapsFromLandscape()
        /// </summary>
        /// <param name="landscape"></param>
        /// <param name="terrain"></param>
        /// <param name="packedSplatMapIndex"></param>
        /// <param name="showErrors"></param>
        /// <returns></returns>
        public static Texture2D GetTextureFromSplatmap(LBLandscape landscape, Terrain terrain, int packedSplatMapIndex, bool showErrors)
        {
            Texture2D texture = null;
            string methodName = "LBLandscapeTerrain.GetTextureFromSplatmap";

            // Validation
            if (landscape == null) { if (showErrors) { Debug.LogWarning("ERROR " + methodName + " - landscape script object is null"); } }
            else if (terrain == null) { if (showErrors) { Debug.LogWarning("ERROR " + methodName + " - terrain is null"); } }
            else
            {
                TerrainData tData = terrain.terrainData;

                int numberAlphaMapLayers = tData.alphamapLayers;
                int alphamapWidth = tData.alphamapWidth;
                int alphamapHeight = tData.alphamapHeight;

                // We can pack up to 4 alphamaps into one 2D texture (one alphmap for each of the r,b,g,a channels)
                int alphamapOffset = packedSplatMapIndex * 4;

                float[,,] alphamap = tData.GetAlphamaps(0, 0, alphamapWidth, alphamapHeight);

                if (numberAlphaMapLayers > alphamapOffset)
                {
                    //Debug.Log("INFO: LBLandscapeTerrain.GetTextureFromSplatmap - num alphalayers:" + numberAlphaMapLayers + " trn Res:" + tData.heightmapResolution + " alphares:" + alphamapWidth);

                    texture = new Texture2D(tData.heightmapResolution - 1, tData.heightmapResolution - 1, TextureFormat.RGBA32, false, true);
                    if (texture == null) { Debug.LogWarning("ERROR " + methodName + " - could not create new texture"); }
                    else
                    {
                        Color32 pixel = new Color32();
                        Color32[] pixels = new Color32[texture.width * texture.height];

                        // Give the texture a name so we can use it later
                        texture.name = terrain.name + "_splat" + packedSplatMapIndex.ToString();

                        int alphaX, alphaZ;
                        float xPosN, zPosN;

                        for (int x = 0; x < texture.width; x++)
                        {
                            for (int z = 0; z < texture.height; z++)
                            {
                                // Get the normalised position on the terrain
                                xPosN = 1.0f * x / (texture.width - 1);
                                zPosN = 1.0f * z / (texture.height - 1);

                                // Get the alphamap position
                                alphaX = Mathf.FloorToInt(xPosN * (alphamapWidth - 1f));
                                alphaZ = Mathf.FloorToInt(zPosN * (alphamapHeight - 1f));

                                // Pack the data from up to four splatmap textures into a single output texture pixel.
                                pixel.r = (byte)(alphamap[alphaX, alphaZ, alphamapOffset] * 255f);
                                if (numberAlphaMapLayers > alphamapOffset + 1) { pixel.g = (byte)(alphamap[alphaX, alphaZ, alphamapOffset + 1] * 255f); } else { pixel.g = 0; }
                                if (numberAlphaMapLayers > alphamapOffset + 2) { pixel.b = (byte)(alphamap[alphaX, alphaZ, alphamapOffset + 2] * 255f); } else { pixel.b = 0; }
                                if (numberAlphaMapLayers > alphamapOffset + 3) { pixel.a = (byte)(alphamap[alphaX, alphaZ, alphamapOffset + 3] * 255f); } else { pixel.a = 0; }

                                pixels[x * texture.width + z] = pixel;
                            }
                        }
                        texture.SetPixels32(pixels);
                        texture.Apply(false, false);
                    }
                }
            }

            return texture;
        }

        /// <summary>
        /// Get the name of the dominant texture on the landscape at this world position location.
        /// Can optionally compare the height of the terrain (with a tolerance level) with the
        /// Y-axis world position of the locationWorldPos of the object or character controller.
        /// NOTE: Currently doesn't support Non-Square Terrains but could be fixed...
        /// </summary>
        /// <param name="landscape"></param>
        /// <param name="locationWorldPos"></param>
        /// <param name="isCheckHeight"></param>
        /// <param name="heightTolerance"></param>
        /// <param name="showErrors"></param>
        /// <returns></returns>
        public static string GetTextureNameAtPosition(LBLandscape landscape, Vector3 locationWorldPos, bool isCheckHeight, float heightTolerance, bool showErrors)
        {
            string textureName = string.Empty;

            Terrain[] landscapeTerrains;
            TerrainData tData;
            Vector3 worldPosition;
            //int heightmapResolution = 0;
            float terrainWidth = 0f;

            Rect terrainRect;

            if (landscape != null)
            {
                GameObject landscapeGameObject = landscape.gameObject;

                if (landscapeGameObject != null)
                {
                    // Get the terrains attached to the landscape
                    landscapeTerrains = landscapeGameObject.GetComponentsInChildren<Terrain>();

                    if (landscapeTerrains != null)
                    {
                        // Loop through all the terrains in the landscape until we find the one that contains the point required
                        for (int index = 0; index < landscapeTerrains.Length; index++)
                        {
                            tData = landscapeTerrains[index].terrainData;
                            worldPosition = landscapeTerrains[index].transform.position;

                            // Terrain width (x) and length (z) are always the same in LB (EXCEPT when Non-Square Terrains is enabled....)
                            terrainWidth = tData.size.x;
                            //heightmapResolution = tData.heightmapResolution;

                            // Get the rectange boundary of the terrain
                            terrainRect = Rect.MinMaxRect(worldPosition.x, worldPosition.z, worldPosition.x + terrainWidth, worldPosition.z + terrainWidth);

                            // Is the point within this terrain?
                            if (locationWorldPos.x >= terrainRect.xMin && locationWorldPos.x <= terrainRect.xMax && locationWorldPos.z >= terrainRect.yMin && locationWorldPos.z <= terrainRect.yMax)
                            {
                                // Convert point into a normalised position on the terrain
                                float xPosN = Mathf.InverseLerp(worldPosition.x, worldPosition.x + terrainWidth, locationWorldPos.x);
                                float zPosN = Mathf.InverseLerp(worldPosition.z, worldPosition.z + terrainWidth, locationWorldPos.z);

                                // Retrieve alphamap metadata
                                int alphamapWidth = tData.alphamapWidth;
                                int alphamapHeight = tData.alphamapHeight;
                                int numberAlphaMapLayers = tData.alphamapLayers;

#if UNITY_2018_3_OR_NEWER
                                TerrainLayer[] terrainLayers = tData.terrainLayers;
                                if (numberAlphaMapLayers > 0 && terrainLayers != null)
#else
                                SplatPrototype[] splatPrototypes = tData.splatPrototypes;
                                if (numberAlphaMapLayers > 0 && splatPrototypes != null)
#endif
                                {
                                    // Get position of point in alphamap
                                    int alphaX = Mathf.FloorToInt(xPosN * (alphamapWidth - 1f));
                                    int alphaZ = Mathf.FloorToInt(zPosN * (alphamapHeight - 1f));

                                    // Get the alphamap layers for this point in the terrain
                                    float[,,] alphamap = tData.GetAlphamaps(alphaX, alphaZ, 1, 1);

                                    if (alphamap != null)
                                    {
                                        float maxWeight = 0f;
                                        int maxLayer = -1;

                                        for (int l = 0; l < numberAlphaMapLayers; l++)
                                        {
                                            // The array is very small so this should be fast
                                            if (alphamap[0, 0, l] > maxWeight) { maxLayer = l; maxWeight = alphamap[0, 0, l]; }
                                        }

#if UNITY_2018_3_OR_NEWER
                                        if (maxLayer >= 0 && maxLayer < terrainLayers.Length)
#else
                                        if (maxLayer >= 0 && maxLayer < splatPrototypes.Length)
#endif
                                        {
                                            if (isCheckHeight)
                                            {
                                                // Get position in heightmap
                                                //int x = Mathf.RoundToInt(xPosN * (heightmapResolution - 1));
                                                //int z = Mathf.RoundToInt(zPosN * (heightmapResolution - 1));

                                                // Get the height of the terrain at this position in landscape
                                                float height = tData.GetInterpolatedHeight(xPosN, zPosN) * tData.size.y;

                                                // If the height doesn't fall within the parameter provided, exit loop and return an empty result.
                                                if (height < locationWorldPos.y - heightTolerance || height > locationWorldPos.y + heightTolerance) { break; }
                                            }

                                            // Find the texture
#if UNITY_2018_3_OR_NEWER
                                            TerrainLayer terrainLayer = terrainLayers[maxLayer];
                                            if (terrainLayer != null)
                                            {
                                                if (terrainLayer.diffuseTexture != null) { textureName = terrainLayer.diffuseTexture.name; }
                                            }
#else
                                            SplatPrototype splatPrototype = splatPrototypes[maxLayer];
                                            if (splatPrototypes != null)
                                            {
                                                if (splatPrototype.texture != null) { textureName = splatPrototype.texture.name; }
                                            }
#endif
                                        }
                                    }
                                }
                                break;
                            }
                        }
                    }
                    else if (showErrors) { Debug.LogWarning("LBLandscapeTerrain.GetTextureNameAtPosition - no terrains attached to selected landscape"); }
                }
                else if (showErrors) { Debug.LogWarning("LBLandscapeTerrain.GetTextureNameAtPosition - landscape parent gameobject is null"); }
            }
            else if (showErrors) { Debug.LogWarning("LBLandscapeTerrain.GetTextureNameAtPosition - landscape script object is null"); }

            return textureName;
        }

        /// <summary>
        /// Does the texture exist at this position? If so, does it have a minimum strength?
        /// Texture Strength is relative to other textures at same location is in the range 0.0 to 1.0.
        /// Can optionally compare the height of the terrain (with a tolerance level) and the
        /// Y-axis world position of the locationWorldPos of the object or character controller.
        /// NOTE: Currently doesn't support Non-Square Terrains but could be fixed...
        /// </summary>
        /// <param name="landscape"></param>
        /// <param name="locationWorldPos"></param>
        /// <param name="textureName"></param>
        /// <param name="isCheckHeight"></param>
        /// <param name="heightTolerance"></param>
        /// <param name="minTextureWeight"></param>
        /// <param name="showErrors"></param>
        /// <returns></returns>
        public static bool IsTextureNameAtPosition(LBLandscape landscape, Vector3 locationWorldPos, string textureName, bool isCheckHeight, float heightTolerance, float minTextureWeight, bool showErrors)
        {
            bool isSuccessful = false;

            Terrain[] landscapeTerrains;
            TerrainData tData;
            Vector3 worldPosition;
            float terrainWidth = 0f;

            Rect terrainRect;

            if (landscape != null)
            {
                GameObject landscapeGameObject = landscape.gameObject;

                if (landscapeGameObject != null)
                {
                    // Get the terrains attached to the landscape
                    landscapeTerrains = landscapeGameObject.GetComponentsInChildren<Terrain>();

                    if (landscapeTerrains != null)
                    {
                        // Loop through all the terrains in the landscape until we find the one that contains the point required
                        for (int index = 0; index < landscapeTerrains.Length; index++)
                        {
                            tData = landscapeTerrains[index].terrainData;
                            worldPosition = landscapeTerrains[index].transform.position;

                            // Terrain width (x) and length (z) are always the same in LB (EXCEPT where Non-Square Terrains is enabled)
                            terrainWidth = tData.size.x;

                            // Get the rectange boundary of the terrain
                            terrainRect = Rect.MinMaxRect(worldPosition.x, worldPosition.z, worldPosition.x + terrainWidth, worldPosition.z + terrainWidth);

                            // Is the point within this terrain?
                            if (locationWorldPos.x >= terrainRect.xMin && locationWorldPos.x <= terrainRect.xMax && locationWorldPos.z >= terrainRect.yMin && locationWorldPos.z <= terrainRect.yMax)
                            {
                                // Convert point into a normalised position on the terrain
                                float xPosN = Mathf.InverseLerp(worldPosition.x, worldPosition.x + terrainWidth, locationWorldPos.x);
                                float zPosN = Mathf.InverseLerp(worldPosition.z, worldPosition.z + terrainWidth, locationWorldPos.z);

                                // If we need to check the height and it doesn't match, get out early.
                                if (isCheckHeight)
                                {
                                    // Get the height of the terrain at this position in landscape
                                    float height = tData.GetInterpolatedHeight(xPosN, zPosN) * tData.size.y;

                                    // If the height doesn't fall within the parameter provided, exit loop and return an empty result.
                                    if (height < locationWorldPos.y - heightTolerance || height > locationWorldPos.y + heightTolerance) { break; }
                                }

                                // Retrieve alphamap metadata
                                int alphamapWidth = tData.alphamapWidth;
                                int alphamapHeight = tData.alphamapHeight;
                                int numberAlphaMapLayers = tData.alphamapLayers;

#if UNITY_2018_3_OR_NEWER
                                TerrainLayer[] terrainLayers = tData.terrainLayers;
                                if (numberAlphaMapLayers > 0 && terrainLayers != null)
#else
                                SplatPrototype[] splatPrototypes = tData.splatPrototypes;
                                if (numberAlphaMapLayers > 0 && splatPrototypes != null)
#endif
                                {
                                    // Get position of point in alphamap
                                    int alphaX = Mathf.FloorToInt(xPosN * (alphamapWidth - 1f));
                                    int alphaZ = Mathf.FloorToInt(zPosN * (alphamapHeight - 1f));

                                    // Get the alphamap layers for this point in the terrain
                                    float[,,] alphamap = tData.GetAlphamaps(alphaX, alphaZ, 1, 1);

                                    // Should always be same number of textures as alphamap layers
#if UNITY_2018_3_OR_NEWER
                                    if (alphamap != null && terrainLayers.Length == numberAlphaMapLayers)
#else
                                    if (alphamap != null && splatPrototypes.Length == numberAlphaMapLayers)
#endif
                                    {
                                        string textureNameLCase = textureName.ToLower();
                                        for (int l = 0; l < numberAlphaMapLayers; l++)
                                        {
                                            // Find the texture
#if UNITY_2018_3_OR_NEWER
                                            TerrainLayer terrainLayer = terrainLayers[l];
                                            if (terrainLayer != null)
                                            {
                                                if (terrainLayer.diffuseTexture != null && terrainLayer.diffuseTexture.name.ToLower() == textureNameLCase)
                                                {
                                                    // Check the relative weight of this texture at this position
                                                    isSuccessful = (alphamap[0, 0, l] >= minTextureWeight);
                                                    break;
                                                }
                                            }
#else
                                            SplatPrototype splatPrototype = splatPrototypes[l];
                                            if (splatPrototypes != null)
                                            {
                                                // Is this the texture we are looking for?
                                                if (splatPrototype.texture != null && splatPrototype.texture.name.ToLower() == textureNameLCase)
                                                {
                                                    // Check the relative weight of this texture at this position
                                                    isSuccessful = (alphamap[0, 0, l] >= minTextureWeight);
                                                    break;
                                                }
                                            }
#endif
                                        }
                                    }
                                }
                                break;
                            }
                        }
                    }
                    else if (showErrors) { Debug.LogError("LBLandscapeTerrain.IsTextureNameAtPosition - no terrains attached to selected landscape"); }
                }
                else if (showErrors) { Debug.LogError("LBLandscapeTerrain.IsTextureNameAtPosition - landscape parent gameobject is null"); }
            }
            else if (showErrors) { Debug.LogError("LBLandscapeTerrain.IsTextureNameAtPosition - landscape script object is null"); }

            return isSuccessful;
        }

        #endregion

        #region Static Tree Methods

        /// <summary>
        /// Returns the TerrainData after populating it with trees.
        /// The landscape parm is required for LBFilter.StencilLayer and curvature rules.
        /// Call LBStencil.FreeStencilResources(landscape, true) after calling this method if
        /// a LBFilterType.StencilLayer was used.
        /// </summary>
        /// <param name="tData"></param>
        /// <param name="terrainTreesList"></param>
        /// <param name="maxTreesPerSquareKilometre"></param>
        /// <param name="worldPosition"></param>
        /// <param name="landscapeSize"></param>
        /// <param name="landscapePosition"></param>
        /// <param name="treePlacementSpeed"></param>
        /// <param name="showTiming"></param>
        /// <param name="landscape"></param>
        /// <returns></returns>
        public static TerrainData PopulateTerrainWithTrees(TerrainData tData, List<LBTerrainTree> terrainTreesList, int maxTreesPerSquareKilometre,
                                                           Vector3 worldPosition, Vector2 landscapeSize, Vector3 landscapePosition,
                                                           LBTerrainTree.TreePlacementSpeed treePlacementSpeed = LBTerrainTree.TreePlacementSpeed.FastestPlacement,
                                                           bool showTiming = false, LBLandscape landscape = null)
        {
            float tStart = Time.realtimeSinceStartup;
            if (tData != null)
            {
                UnityEngine.Random.InitState(0);

                // Remove disabled trees from the list. Create new list so we don't affect original in LBLandscape
                // Also remove trees with no prefab
                List<LBTerrainTree> terrainTreesListNoDisabled = new List<LBTerrainTree>(terrainTreesList);
                for (int i = terrainTreesListNoDisabled.Count - 1; i >= 0; i--)
                {
                    if (terrainTreesListNoDisabled[i].isDisabled || terrainTreesListNoDisabled[i].prefab == null)
                    {
                        terrainTreesListNoDisabled.Remove(terrainTreesListNoDisabled[i]);
                    }
                }

                // Randomly set the noiseoffset based on the tilesize
                // NOTE: This means it will not line up with the texture or grass noise, nor will it align across terrain boundaries
                // To align across terrain boundaries it would need to be set once per landscape before calling PopulateTerrainWithTrees()
                for (int t = 0; t < terrainTreesListNoDisabled.Count; t++)
                {
                    terrainTreesListNoDisabled[t].noiseOffset = UnityEngine.Random.Range(0f, terrainTreesListNoDisabled[t].noiseTileSize);
                }

                #region Variables declared outside tree creation loop for performance purposes
                Vector2 terrainSize = new Vector2(tData.size.x, tData.size.z);
                float terrainWidth = tData.size.x;
                float terrainHeight = tData.size.y;
                float thisTreeProximitySquared = 0f;
                Vector3 offset = Vector3.zero;
                float treeNoiseTileSize = 0f, noiseValue = 0f;
                float minTreeHeight = 0f, maxTreeHeight = 0f;

                // Used for LBFilter
                Vector2 worldPoint = Vector2.zero;
                bool includePoint = true;
                bool includePointCurrentFilter = false;

                // Texture Map variables
                LBMapPoint mapPoint;
                LBMap lbMap;
                float pixelVariationNormalised = 0f;

                // Get the normalised (0-1) bounds of this terrain within the landscape (used for Map)
                float startX = ((worldPosition.x - landscapePosition.x) / landscapeSize.x);
                float endX = startX + (tData.size.x / landscapeSize.x);
                float startZ = ((worldPosition.z - landscapePosition.z) / landscapeSize.y);
                float endZ = startZ + (tData.size.z / landscapeSize.y);

                // Alphamap variables for use with LBFilter.FilterType.Texture
                float[,,] alphamap = new float[1, 1, 1];
                List<LBTerrainTexture> alphamapTerrainTexturesList = null;
                int textureIndex = 0;
                float alphaBlendWeight = 0f;
                int alphamapX = 0, alphamapZ = 0;

                float treetypeNOffsetY = 0f;     // The normalised distance, each tree of the same type is offset from the ground
                #endregion

                // Populate terrain with trees
                if (terrainTreesListNoDisabled != null)
                {
                    // Set trees to use from landscape trees list
                    List<TreeInstance> treeInstances = new List<TreeInstance>();
                    tData.treeInstances = treeInstances.ToArray();
                    tData.treePrototypes = LBTerrainTree.ToTreePrototypeList(terrainTreesListNoDisabled).ToArray();

                    if (terrainTreesListNoDisabled.Count > 0)
                    {
                        // Only create this list the first time it is used (the list is cleared after each terrain is processed)
                        if (lbTerrainTreeInstanceList == null) { lbTerrainTreeInstanceList = new List<LBTerrainTreeInstance>(); }

                        #region Determine if Filters Apply
                        // Are their any Texture LBFilters applied?
                        bool isTextureFiltersToApply = false;
                        foreach (LBTerrainTree lbtt in terrainTreesListNoDisabled)
                        {
                            if (lbtt != null)
                            {
                                isTextureFiltersToApply = LBFilter.Contains(lbtt.filterList, LBFilter.FilterType.Texture);
                                if (isTextureFiltersToApply) { break; }
                            }
                        }

                        // There are texture filters so pre-load the alphamaps for this terrain
                        // NOTE: This could consume a fair amount of RAM on large terrains with many alphamaps
                        if (isTextureFiltersToApply)
                        {
#if UNITY_2018_3_OR_NEWER
                            alphamapTerrainTexturesList = LBTerrainTexture.ToLBTerrainTextureList(tData.terrainLayers);
#else
                            alphamapTerrainTexturesList = LBTerrainTexture.ToLBTerrainTextureList(tData.splatPrototypes);
#endif
                            alphamap = tData.GetAlphamaps(0, 0, tData.alphamapWidth, tData.alphamapHeight);
                        }

                        bool[] isAreaFiltersToApply = new bool[terrainTreesListNoDisabled.Count];
                        // Are their any Area LBFilters applied?
                        for (int i = 0; i < terrainTreesListNoDisabled.Count; i++)
                        {
                            LBTerrainTree lbtt = terrainTreesListNoDisabled[i];
                            if (lbtt != null)
                            {
                                isAreaFiltersToApply[i] = LBFilter.Contains(lbtt.filterList, LBFilter.FilterType.Area);
                                if (isAreaFiltersToApply[i]) { continue; }
                            }
                        }
                        #endregion

                        #region Pre-load list of Maps
                        List<LBMap> lbMapList = new List<LBMap>();
                        // Pre-create a list of maps - some maps may not be applicable but this could improve performance
                        // There will be no need to create a map for each point for those Textures that use a map
                        foreach (LBTerrainTree terrainTree in terrainTreesListNoDisabled)
                        {
                            if (terrainTree != null)
                            {
                                lbMap = new LBMap(terrainTree.map, terrainTree.mapColour, terrainTree.mapTolerance);
                                lbMap.toleranceBlendCurve = terrainTree.mapToleranceBlendCurve;
                                lbMap.inverse = terrainTree.mapInverse;
                                lbMapList.Add(lbMap);
                            }
                        }
                        lbMap = null;
                        #endregion

                        #region Create arrays for each tree type
                        int[] numberOfTreesCreated = new int[terrainTreesListNoDisabled.Count];
                        int[] numberOfTreeAttempts = new int[terrainTreesListNoDisabled.Count];
                        int[] targetNumberOfTrees = new int[terrainTreesListNoDisabled.Count];
                        int[] maxTreeIterations = new int[terrainTreesListNoDisabled.Count];
                        float[] minProximitySquaredArray = new float[terrainTreesListNoDisabled.Count];
                        bool[] isStencilLayerFiltersToApply = new bool[terrainTreesListNoDisabled.Count];
                        #endregion

                        float preSqmFactor = terrainWidth * terrainWidth / 1000000f;

                        // Get terrain area rectangle
                        Rect terrainRect = Rect.MinMaxRect(worldPosition.x, worldPosition.z, worldPosition.x + terrainWidth, worldPosition.z + terrainWidth);

                        for (int i = 0; i < terrainTreesListNoDisabled.Count; i++)
                        {
                            #region Calc target number of trees
                            // Get the target number of trees for each tree type
                            targetNumberOfTrees[i] = Mathf.RoundToInt(preSqmFactor * terrainTreesListNoDisabled[i].maxTreesPerSqrKm);
                            // Check area filters
                            if (terrainTreesListNoDisabled[i].filterList != null)
                            {
                                foreach (LBFilter lbFilter in terrainTreesListNoDisabled[i].filterList)
                                {
                                    if (lbFilter != null)
                                    {
                                        if (lbFilter.filterType == LBFilter.FilterType.Area)
                                        {
                                            if (!lbFilter.GetWorldSpaceAreaRect(landscapePosition).Overlaps(terrainRect))
                                            {
                                                // If the area filter rect is not on this terrain, don't try to create any trees
                                                targetNumberOfTrees[i] = 0;
                                            }
                                        }
                                    }
                                }
                            }
                            // Performing more iterations will result in more accurate placement resulting in the number of trees in the
                            // landscape being much closer to the number requesting (however, placement will be slower).
                            if (treePlacementSpeed == LBTerrainTree.TreePlacementSpeed.BestPlacement)
                            {
                                maxTreeIterations[i] = targetNumberOfTrees[i] * 256;
                            }
                            else if (treePlacementSpeed == LBTerrainTree.TreePlacementSpeed.FastPlacement)
                            {
                                maxTreeIterations[i] = targetNumberOfTrees[i] * 8;
                            }
                            else { maxTreeIterations[i] = targetNumberOfTrees[i]; }
                            #endregion

                            // Pre-populate a lookup array of tree minProximity normalized Squared values
                            float thisTreeProximityN = (terrainTreesListNoDisabled[i].minProximity / terrainWidth);
                            minProximitySquaredArray[i] = thisTreeProximityN * thisTreeProximityN;

                            #region Are there any Stencil Layer filters for this tree type?
                            isStencilLayerFiltersToApply[i] = (targetNumberOfTrees[i] > 0) && landscape != null && LBFilter.Contains(terrainTreesListNoDisabled[i].filterList, LBFilter.FilterType.StencilLayer);
                            if (isStencilLayerFiltersToApply[i])
                            {
                                // Preload the stencil data
                                if (terrainTreesListNoDisabled[i].filterList != null)
                                {
                                    foreach (LBFilter lbFilter in terrainTreesListNoDisabled[i].filterList)
                                    {
                                        if (lbFilter != null)
                                        {
                                            // Currently all stencil filters are AND
                                            // Is this a valid Stencil Filter?
                                            if (lbFilter.filterType == LBFilter.FilterType.StencilLayer && !string.IsNullOrEmpty(lbFilter.lbStencilGUID) && !string.IsNullOrEmpty(lbFilter.lbStencilLayerGUID))
                                            {
                                                // If the temporary class instance isn't defined, look it up and validate it is in the current landscape
                                                if (lbFilter.lbStencil == null)
                                                {
                                                    lbFilter.lbStencil = LBStencil.GetStencilInLandscape(landscape, lbFilter.lbStencilGUID, true);
                                                }

                                                if (lbFilter.lbStencil != null)
                                                {
                                                    // Find the Stencil Layer for this Layer Filter and populate the temporary class instance
                                                    lbFilter.lbStencilLayer = lbFilter.lbStencil.GetStencilLayerByGUID(lbFilter.lbStencilLayerGUID);

                                                    // Load the USHORT data
                                                    if (lbFilter.lbStencilLayer != null)
                                                    {
                                                        if (lbFilter.lbStencilLayer.layerArray == null)
                                                        {
                                                            lbFilter.lbStencilLayer.AllocLayerArray();
                                                            lbFilter.lbStencilLayer.UnCompressToUShort();
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion

                            #region cache Curvature variables
                            if (terrainTreesListNoDisabled[i].treePlacingMode == LBTerrainTree.TreePlacingMode.HeightInclinationCurvature)
                            {
                                // Get curvature distance as a normalised terrain distance
                                terrainTreesListNoDisabled[i].curvatureDistanceXN = terrainTreesListNoDisabled[i].curvatureDistance / terrainSize.x;
                                terrainTreesListNoDisabled[i].curvatureDistanceZN = terrainTreesListNoDisabled[i].curvatureDistance / terrainSize.y;
                            }
                            #endregion
                        }

                        #region Landscape-scoped data
                        // The slope on 
                        Terrain[] landscapeTerrains = new Terrain[0];
                        TerrainData[] terrainDataArray = new TerrainData[0];
                        Rect[] terrainRectsArray = new Rect[0];
                        int numTerrains = 0;
                        bool useLandscapeHeight = false;

                        // If a landscape is supplied, we want to check the edges with the same terrain to ensure both sides of the terrain
                        // edges use the same slope and height values.
                        // Also need to use with curvature rules to avoid false positives on along terrain borders
                        if (landscape != null)
                        {
                            landscape.SetLandscapeTerrains(true);
                            landscapeTerrains = landscape.landscapeTerrains;
                            numTerrains = (landscapeTerrains == null ? 0 : landscapeTerrains.Length);
                            if (numTerrains > 1)
                            {
                                useLandscapeHeight = true;
                                // Create arrays for terrain data and terrain rects
                                terrainDataArray = new TerrainData[numTerrains];
                                terrainRectsArray = new Rect[numTerrains];
                                for (int i = 0; i < numTerrains; i++)
                                {
                                    terrainDataArray[i] = landscapeTerrains[i].terrainData;
                                    if (terrainDataArray[i] == null) { useLandscapeHeight = false; break; }
                                    Vector3 landscapePositionVector = landscapeTerrains[i].transform.position - landscapePosition;
                                    terrainRectsArray[i] = Rect.MinMaxRect(landscapePositionVector.x, landscapePositionVector.z, landscapePositionVector.x + landscapeTerrains[i].terrainData.size.x + 0.005f,
                                        landscapePositionVector.z + landscapeTerrains[i].terrainData.size.z + 0.005f);
                                }
                            }
                        }
                        #endregion

                        #region Stencil LBLayerFilter variables
                        Vector2 stencilLayerPosN = new Vector2();
                        LBMapPoint arrayPoint = new LBMapPoint(0, 0);
                        int stencilLayerResolution = 0;
                        int stencilLayerPixel = 0;
                        int hashValue = 0;
                        LB_Extension.XXHash xxHash = new LB_Extension.XXHash(37761);
                        #endregion

                        #region Add trees with TreePlacingMode = Imported
                        for (int i = 0; i < terrainTreesListNoDisabled.Count; i++)
                        {
                            if (terrainTreesListNoDisabled[i].treePlacingMode == LBTerrainTree.TreePlacingMode.Imported)
                            {
                                if (terrainTreesListNoDisabled[i].lbTerrainDataList != null)
                                {
                                    // Find the matching tree data (assumes all terrains in the landscape have unique names)
                                    LBTerrainData lbTerrainData = terrainTreesListNoDisabled[i].lbTerrainDataList.Find(td => td.sourceTerrainDataName == tData.name);
                                    if (lbTerrainData == null) { Debug.LogWarning("ERROR: LBLandscapeTerrain.PopulateWithTrees - could not find LBTerrainData for " + tData.name); }
                                    else
                                    {
                                        if (lbTerrainData.lbTerrainTreeInstanceExtList != null)
                                        {
                                            //Debug.Log("INFO LBLandscapeTerrain.PopulateWithTrees " + lbTerrainData.lbTerrainTreeInstanceExtList.Count + " " + terrainTreesListNoDisabled[i].prefab.name + " imported trees in " + tData.name);

                                            List<TreeInstance> treeInstanceList = LBTerrainTreeInstanceExt.ToTreeInstanceList(lbTerrainData.lbTerrainTreeInstanceExtList, i);
                                            if (treeInstanceList != null)
                                            {
                                                int numImportTrees = treeInstanceList.Count;
                                                if (numImportTrees > 0)
                                                {
                                                    List<TreeInstance> tmpTreeInstanceList = new List<TreeInstance>();

                                                    for (int impTreeIdx = 0; impTreeIdx < numImportTrees; impTreeIdx++)
                                                    {
                                                        TreeInstance treeInstance = treeInstanceList[impTreeIdx];

                                                        // Should the tree be randomly tinted to provide colour variation in a forest?
                                                        if (terrainTreesListNoDisabled[i].isTinted)
                                                        {
                                                            // Randomise colour
                                                            treeInstance.color = Color.Lerp(Color.white, terrainTreesListNoDisabled[i].tintColour, UnityEngine.Random.Range(0f, terrainTreesListNoDisabled[i].maxTintStrength));
                                                        }
                                                        else { treeInstance.color = Color.white; }
                                                        // Set lightmap colour
                                                        treeInstance.lightmapColor = Color.white;
                                                        tmpTreeInstanceList.Add(treeInstance);
                                                    }

                                                    treeInstances.AddRange(tmpTreeInstanceList.ToArray());

                                                    List<LBTerrainTreeInstance> templbTerrainTreeInstanceList = LBTerrainTreeInstanceExt.ToLBTerrainTreeInstanceList(lbTerrainData.lbTerrainTreeInstanceExtList);
                                                    if (templbTerrainTreeInstanceList != null)
                                                    {
                                                        //Debug.Log("INFO LBLandscapeTerrain.PopulateWithTrees Adding " + templbTerrainTreeInstanceList.Count + " tree instance positions for " + terrainTreesListNoDisabled[i].prefab.name + " imported trees to " + tData.name);

                                                        lbTerrainTreeInstanceList.AddRange(templbTerrainTreeInstanceList);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        #endregion

                        #region Curvature rules
                        // 4 surrounding height points
                        float h1XN, h1ZN, h2XN, h2ZN, h3XN, h3ZN, h4XN, h4ZN;
                        float h1 = 0f, h2 = 0f, h3 = 0f, h4 = 0f;
                        Vector2 hOffsetPos = Vector2.zero;
                        #endregion

                        #region Reset Garbage Collection
                        System.GC.Collect();
                        #endregion

                        bool stillCreatingTrees = true;

                        while (stillCreatingTrees)
                        {
                            // By default set stillCreatingTrees to false - if trees are being created in the loop it will be set to true
                            stillCreatingTrees = false;

                            // Loop through each tree type, attempting to create 1 of each tree
                            for (int i = 0; i < terrainTreesListNoDisabled.Count; i++)
                            {
                                // Check if we've already created enough of this type of tree
                                // Skip tree types of placementmode = Imported.
                                if (numberOfTreesCreated[i] >= targetNumberOfTrees[i] || numberOfTreeAttempts[i] >= maxTreeIterations[i] || terrainTreesListNoDisabled[i].treePlacingMode == LBTerrainTree.TreePlacingMode.Imported)
                                {
                                    // If we've created enough trees, continue to the next tree type in the for loop
                                    continue;
                                }

                                // Increment the number of tree attempts
                                numberOfTreeAttempts[i]++;
                                stillCreatingTrees = true;

                                // Create a new tree instance
                                TreeInstance newTree = new TreeInstance();
                                // Select tree type to use
                                newTree.prototypeIndex = i;
                                // Nominate a random x,z coordinate on the terrain
                                offset = new Vector3(UnityEngine.Random.value, 0f, UnityEngine.Random.value);

                                // Find that coordinate's height and steepness
                                offset.y = tData.GetInterpolatedHeight(offset.x, offset.z) / terrainHeight;
                                angle = tData.GetSteepness(offset.x, offset.z);
                                createTree = false;

                                // The normalised distance, each tree of the same type is offset from the ground
                                // This get's applied to the tree position when it is created.
                                treetypeNOffsetY = terrainTreesListNoDisabled[i].offsetY / terrainHeight;

                                // Find the landscape world-space coordinates of this tree position
                                worldPoint.x = (offset.x * terrainSize.x) + worldPosition.x;
                                worldPoint.y = (offset.z * terrainSize.y) + worldPosition.z;

                                #region Height Rules
                                if (terrainTreesListNoDisabled[i].treePlacingMode == LBTerrainTree.TreePlacingMode.Height)
                                {
                                    // If the height is between the tree's min and max height, create the tree
                                    createTree = offset.y >= terrainTreesListNoDisabled[i].minHeight
                                                    && offset.y <= terrainTreesListNoDisabled[i].maxHeight;
                                }
                                #endregion

                                #region Inclination Rules
                                else if (terrainTreesListNoDisabled[i].treePlacingMode == LBTerrainTree.TreePlacingMode.Inclination)
                                {
                                    // If the inclination is between the tree's min and max height, create the tree
                                    createTree = angle >= terrainTreesListNoDisabled[i].minInclination
                                                    && angle <= terrainTreesListNoDisabled[i].maxInclination;
                                }
                                #endregion

                                #region HeightInclination Rules
                                else if (terrainTreesListNoDisabled[i].treePlacingMode == LBTerrainTree.TreePlacingMode.HeightAndInclination)
                                {
                                    // If height is between the tree's min and max height and the inclination is between the tree's min and max height,
                                    // create the tree
                                    createTree = offset.y >= terrainTreesListNoDisabled[i].minHeight
                                                    && offset.y <= terrainTreesListNoDisabled[i].maxHeight
                                                    && angle >= terrainTreesListNoDisabled[i].minInclination
                                                    && angle <= terrainTreesListNoDisabled[i].maxInclination;
                                }
                                #endregion

                                #region ConstantInfluence Rule
                                else if (terrainTreesListNoDisabled[i].treePlacingMode == LBTerrainTree.TreePlacingMode.ConstantInfluence)
                                {
                                    // Always create the tree
                                    createTree = true;
                                }
                                #endregion

                                #region HeightInclinationCurve Rules
                                else if (terrainTreesListNoDisabled[i].treePlacingMode == LBTerrainTree.TreePlacingMode.HeightInclinationCurvature)
                                {
                                    // If height is between the tree's min and max height and the inclination is between the tree's min and max height,
                                    // consider the tree for phase 2 (checking curvature)
                                    createTree = offset.y >= terrainTreesListNoDisabled[i].minHeight
                                                    && offset.y <= terrainTreesListNoDisabled[i].maxHeight
                                                    && angle >= terrainTreesListNoDisabled[i].minInclination
                                                    && angle <= terrainTreesListNoDisabled[i].maxInclination;

                                    // Only check curvature if faster height and inclination rules apply
                                    if (createTree)
                                    {
                                        // Get 4 surrounding points
                                        h1XN = offset.x;
                                        h1ZN = offset.z - terrainTreesListNoDisabled[i].curvatureDistanceZN;
                                        h2XN = offset.x;
                                        h2ZN = offset.z + terrainTreesListNoDisabled[i].curvatureDistanceZN;
                                        h3XN = offset.x - terrainTreesListNoDisabled[i].curvatureDistanceXN;
                                        h3ZN = offset.z;
                                        h4XN = offset.x + terrainTreesListNoDisabled[i].curvatureDistanceXN;
                                        h4ZN = offset.z;

                                        if (h1ZN >= 0f) { h1 = tData.GetInterpolatedHeight(h1XN, h1ZN) / terrainHeight; }
                                        else if (useLandscapeHeight)
                                        {
                                            hOffsetPos.x = worldPoint.x;
                                            hOffsetPos.y = worldPoint.y - (terrainTreesListNoDisabled[i].curvatureDistanceZN * terrainSize.y);
                                            GetLandscapeInterpolatedData(terrainDataArray, terrainRectsArray, hOffsetPos, ref h1);
                                            h1 /= terrainHeight;
                                        }
                                        else { h1 = offset.y; }

                                        if (h2ZN <= 1f) { h2 = tData.GetInterpolatedHeight(h2XN, h2ZN) / terrainHeight; }
                                        else if (useLandscapeHeight)
                                        {
                                            hOffsetPos.x = worldPoint.x;
                                            hOffsetPos.y = worldPoint.y + (terrainTreesListNoDisabled[i].curvatureDistanceZN * terrainSize.y);
                                            GetLandscapeInterpolatedData(terrainDataArray, terrainRectsArray, hOffsetPos, ref h2);
                                            h2 /= terrainHeight;
                                        }
                                        else { h2 = offset.y; }

                                        if (h3XN >= 0f) { h3 = tData.GetInterpolatedHeight(h3XN, h3ZN) / terrainHeight; }
                                        else if (useLandscapeHeight)
                                        {
                                            hOffsetPos.x = worldPoint.x - (terrainTreesListNoDisabled[i].curvatureDistanceXN * terrainSize.x);
                                            hOffsetPos.y = worldPoint.y;
                                            GetLandscapeInterpolatedData(terrainDataArray, terrainRectsArray, hOffsetPos, ref h3);
                                            h3 /= terrainHeight;
                                        }
                                        else { h3 = offset.y; }

                                        if (h4XN <= 1f) { h4 = tData.GetInterpolatedHeight(h4XN, h4ZN) / terrainHeight; }
                                        else if (useLandscapeHeight)
                                        {
                                            hOffsetPos.x = worldPoint.x + (terrainTreesListNoDisabled[i].curvatureDistanceXN * terrainSize.x);
                                            hOffsetPos.y = worldPoint.y;
                                            GetLandscapeInterpolatedData(terrainDataArray, terrainRectsArray, hOffsetPos, ref h4);
                                            h4 /= terrainHeight;
                                        }
                                        else { h4 = offset.y; }

                                        if (terrainTreesListNoDisabled[i].isCurvatureConcave)
                                        {
                                            // Avg is above the current point by height difference
                                            createTree = ((h1 + h2 + h3 + h4) / 4f) > offset.y + (terrainTreesListNoDisabled[i].curvatureMinHeightDiff / terrainHeight);
                                        }
                                        else
                                        {
                                            // Avg is below the current point by height difference
                                            createTree = ((h1 + h2 + h3 + h4) / 4f) < offset.y + (terrainTreesListNoDisabled[i].curvatureMinHeightDiff / terrainHeight);
                                        }
                                    }
                                }
                                #endregion

                                #region Map Rules
                                else if (terrainTreesListNoDisabled[i].treePlacingMode == LBTerrainTree.TreePlacingMode.Map ||
                                         terrainTreesListNoDisabled[i].treePlacingMode == LBTerrainTree.TreePlacingMode.HeightInclinationMap)
                                {
                                    if (terrainTreesListNoDisabled[i].map != null)
                                    {
                                        // Determine height and inclination first, as it is faster than map

                                        // If height is between the tree's min and max height and the inclination is between the tree's min and max height,
                                        // create the tree
                                        createTree = (terrainTreesListNoDisabled[i].treePlacingMode == LBTerrainTree.TreePlacingMode.Map ||
                                                        (offset.y >= terrainTreesListNoDisabled[i].minHeight
                                                        && offset.y <= terrainTreesListNoDisabled[i].maxHeight
                                                        && angle >= terrainTreesListNoDisabled[i].minInclination
                                                        && angle <= terrainTreesListNoDisabled[i].maxInclination));

                                        if (createTree)
                                        {
                                            // Use a LBMap object, so that we can determine if a tree should be placed in the landscape with the offset generated
                                            if (lbMapList.Count > i) { lbMap = lbMapList[i]; }
                                            else { lbMap = null; }

                                            if (lbMap != null)
                                            {
                                                // Tree would be placed at offset.x, offset.z on the horizontal plane. Compare this to the colour on the Map texture (PNG image)

                                                // Convert the normalised terrain coordinates into a point on the Map texture
                                                mapPoint = lbMap.GetMapPositionFromTerrainPosition(offset.z, offset.x, startX, endX, startZ, endZ);

                                                // Was this map created with a LB Map Path?
                                                if (terrainTreesListNoDisabled[i].mapIsPath)
                                                {
                                                    // Compare the normalised terrain coordinates to the point on the Map texture (PNG image) 
                                                    pixelVariationNormalised = lbMap.GetPixelColourVariationNormalised(mapPoint.x, mapPoint.y, Color.clear);

                                                    if (pixelVariationNormalised == 1f) { if (lbMap.inverse) { createTree = true; } else { createTree = false; } }
                                                    else if (pixelVariationNormalised > 0.001f)
                                                    {
                                                        if (lbMap.inverse)
                                                        {
                                                            createTree = (lbMap.toleranceBlendCurve.Evaluate(pixelVariationNormalised) > 0.5f);
                                                        }
                                                        else
                                                        {
                                                            createTree = (lbMap.toleranceBlendCurve.Evaluate(1f - pixelVariationNormalised) > 0.5f);
                                                        }
                                                    }
                                                    // If exact pixel in map is white (exact match) place tree. If inverse don't place tree.
                                                    else { if (lbMap.inverse) { createTree = false; } else { createTree = true; } }
                                                }
                                                else
                                                {
                                                    // Check if the pixel in the map is the same as the mapColour within the Tolerance factor
                                                    // If inverse is enabled, the opposite will be returned
                                                    createTree = lbMap.IsMapPixelMatchToMapColour(mapPoint.x, mapPoint.y, false, true);
                                                }
                                            }
                                            else { createTree = false; }
                                        }
                                    }
                                    // If there is no map texture supplied, then don't create trees
                                    else { createTree = false; }
                                }
                                #endregion

                                #region Noise
                                if (createTree && terrainTreesListNoDisabled[i].useNoise)
                                {
                                    // Get a perlin noise value for this point in the landscape
                                    treeNoiseTileSize = terrainTreesListNoDisabled[i].noiseTileSize;
                                    coords.x = worldPoint.x + terrainTreesListNoDisabled[i].noiseOffset;
                                    coords.y = worldPoint.y + terrainTreesListNoDisabled[i].noiseOffset;
                                    noiseValue = Mathf.Abs(LBNoise.PerlinFractalNoise(coords.x / treeNoiseTileSize, coords.y / treeNoiseTileSize, 5) - 0.5f) * 4f;
                                    // If the noise value is less than (1 - tree cutoff value) don't create the tree
                                    if (noiseValue < 1f - terrainTreesListNoDisabled[i].treePlacementCutoff) { createTree = false; }
                                }
                                #endregion

                                #region Area Filter
                                // Check area filters before texture filters and before tree proximity
                                if (createTree && isAreaFiltersToApply[i])
                                {
                                    if (terrainTreesListNoDisabled[i].filterList != null)
                                    {
                                        if (terrainTreesListNoDisabled[i].filterList.Count > 0) { includePoint = false; }

                                        foreach (LBFilter lbFilter in terrainTreesListNoDisabled[i].filterList)
                                        {
                                            if (lbFilter != null)
                                            {
                                                // Only deal with Area filters here. Any texture filters will be handled
                                                // after all Area filters have been assessed.
                                                if (lbFilter.filterType == LBFilter.FilterType.Area)
                                                {
                                                    // Convert the filter AreaRect into worldspace to adjust for offset landscapes
                                                    Rect areaRectWorldSpace = lbFilter.GetWorldSpaceAreaRect(landscapePosition);

                                                    // Compare it to the area filter
                                                    // NOTE: We're not using Rect.Contains(Vector2) because the top and right boundaries are ignored
                                                    if (worldPoint.x >= areaRectWorldSpace.xMin && worldPoint.x <= areaRectWorldSpace.xMax &&
                                                        worldPoint.y >= areaRectWorldSpace.yMin && worldPoint.y <= areaRectWorldSpace.yMax)
                                                    {
                                                        includePointCurrentFilter = true;
                                                    }
                                                    else
                                                    {
                                                        includePointCurrentFilter = false;
                                                    }

                                                    if (lbFilter.filterMode == LBFilter.FilterMode.AND)
                                                    {
                                                        if (includePointCurrentFilter)
                                                        {
                                                            if (lbFilter == terrainTreesListNoDisabled[i].filterList[0]) { includePoint = true; }
                                                            else
                                                            {
                                                                // If the point has been included with a previous filter it will still be included
                                                                // and we don't need to do anything here.

                                                                // Because this an AND, if it hasn't already been included by another filter, it
                                                                // will never be included and we .
                                                                if (!includePoint) { break; }
                                                            }
                                                        }
                                                        // With the AND operator, if this point is not in the area we should not add tree
                                                        else { includePoint = false; break; }
                                                    }

                                                    // If using Filter1 OR Filter 2 OR..
                                                    else if (includePointCurrentFilter && lbFilter.filterMode == LBFilter.FilterMode.OR)
                                                    {
                                                        includePoint = true;
                                                    }

                                                    else if (lbFilter.filterMode == LBFilter.FilterMode.NOT)
                                                    {
                                                        // If this is in a NOT area, we should never include this tree
                                                        if (includePointCurrentFilter) { includePoint = false; break; }
                                                        // If not in the current area, then we should still continue to consider it
                                                        else { includePoint = true; }
                                                    }
                                                }
                                            }
                                        }
                                        createTree = includePoint;
                                    }
                                }
                                #endregion

                                #region Proximity
                                if (createTree)
                                {
                                    // Fastest to look up the array outside List.FindIndex()
                                    thisTreeProximitySquared = minProximitySquaredArray[i];

                                    // 10.21 secs
                                    // NOTE: This doesn't check the proximity using the found tree's proximity to the one being currently placed.
                                    //if (treeInstances.FindIndex(t => (((offset.x - t.position.x) * (offset.x - t.position.x)) + ((offset.z - t.position.z) * (offset.z - t.position.z))) < thisTreeProximitySquared) > 0) { createTree = false; };

                                    // 14.21 secs - adding the extra check for different types of trees adds an extra 40% processing time.
                                    // The if/then/else for (t.minProximityNormalisedSquared > thisTreeProximitySquared) is 12% faster than Mathf.Max(t.minProximityNormalisedSquared, thisTreeProximitySquared)
                                    if (lbTerrainTreeInstanceList.FindIndex(t => (((offset.x - t.position.x) * (offset.x - t.position.x)) + ((offset.z - t.position.z) * (offset.z - t.position.z)))
                                                    < (t.minProximityNormalisedSquared > thisTreeProximitySquared ? t.minProximityNormalisedSquared : thisTreeProximitySquared)) >= 0) { createTree = false; };
                                }
                                #endregion

                                #region Check the StencilLayer filters
                                if (createTree && isStencilLayerFiltersToApply[i])
                                {
                                    foreach (LBFilter lbFilter in terrainTreesListNoDisabled[i].filterList)
                                    {
                                        // The layerArray should have been pre-populated for StencilLayer filters
                                        // Check for lbFilter.lbStencilLayer != null in case user deleted the Stencil Layer in the scene
                                        if (lbFilter.filterType == LBFilter.FilterType.StencilLayer && lbFilter.lbStencilLayer != null && lbFilter.lbStencilLayer.layerArray != null)
                                        {
                                            // Get the value of the Stencil layer at this point in the terrain
                                            stencilLayerResolution = (int)lbFilter.lbStencilLayer.layerResolution;
                                            // Get the normalised position in the landscape
                                            stencilLayerPosN = landscape.NormalisePointFromWorldPos2DFast(worldPoint);
                                            // Get the point within the stencil layer USHORT array
                                            arrayPoint.x = Mathf.RoundToInt(stencilLayerPosN.x * (stencilLayerResolution - 1f));
                                            arrayPoint.y = Mathf.RoundToInt((1f - stencilLayerPosN.y) * (stencilLayerResolution - 1f));

                                            // Ensure it it's outside the range of the USHORT array
                                            arrayPoint.x = Mathf.Clamp(arrayPoint.x, 0, stencilLayerResolution - 1);
                                            arrayPoint.y = Mathf.Clamp(arrayPoint.y, 0, stencilLayerResolution - 1);

                                            /// TODO - might be able to improve tree stencil layer blend using a curve
                                            stencilLayerPixel = lbFilter.lbStencilLayer.layerArray[arrayPoint.x, arrayPoint.y];

                                            if (lbFilter.filterMode == LBFilter.FilterMode.AND)
                                            {
                                                // Randomise the chance of placement based on tree stencil layer pixel value
                                                if (stencilLayerPixel < 1) { createTree = false; break; }
                                                else
                                                {
                                                    // The hash, this case, takes the point in the stencil as input data
                                                    hashValue = xxHash.Range(0, 65535, arrayPoint.x, arrayPoint.y);

                                                    if (hashValue > stencilLayerPixel) { createTree = false; break; }
                                                }
                                            }
                                            // Assume NOT
                                            else
                                            {
                                                // Randomise the chance of placement based on tree stencil layer pixel value
                                                if (stencilLayerPixel > 65534) { createTree = false; break; }
                                                else
                                                {
                                                    // The hash, this case, takes the point in the stencil as input data
                                                    hashValue = xxHash.Range(0, 65535, arrayPoint.x, arrayPoint.y);

                                                    if (hashValue < stencilLayerPixel) { createTree = false; break; }
                                                }
                                            }
                                        }
                                    }
                                }
                                #endregion

                                #region Check texture filters - this could be relatively slow, so do it last
                                if (createTree && isTextureFiltersToApply)
                                {
                                    if (terrainTreesListNoDisabled[i].filterList != null)
                                    {
                                        foreach (LBFilter lbFilter in terrainTreesListNoDisabled[i].filterList)
                                        {
                                            if (lbFilter != null)
                                            {
                                                if (lbFilter.filterType == LBFilter.FilterType.Texture && lbFilter.terrainTexture != null)
                                                {
                                                    if (lbFilter.terrainTexture.texture != null)
                                                    {
                                                        // Does this texture exist in the current alphamaps (splatprototypes)?
                                                        // We can't simply find the matching LBTerrainTexture with FindIndex(ftx => ftx == lbFilter.terrainTexture)
                                                        // because a splatprototype only contains texture, normalmap, metallic, smoothness and tileSize fields
                                                        textureIndex = alphamapTerrainTexturesList.FindIndex(ftx => ftx.texture == lbFilter.terrainTexture.texture &&
                                                                                                                    ftx.normalMap == lbFilter.terrainTexture.normalMap &&
                                                                                                                    ftx.metallic == lbFilter.terrainTexture.metallic &&
                                                                                                                    ftx.smoothness == lbFilter.terrainTexture.smoothness &&
                                                                                                                    ftx.tileSize == lbFilter.terrainTexture.tileSize);



                                                        if (textureIndex >= 0)
                                                        {
                                                            // Get the potential position of this tree in the alphamaps
                                                            // offset is the normalised x,y,z potential position of the tree on the terrain
                                                            alphamapX = Mathf.Clamp(Mathf.RoundToInt(offset.x * (float)tData.alphamapWidth), 0, tData.alphamapWidth - 1);
                                                            alphamapZ = Mathf.Clamp(Mathf.RoundToInt(offset.z * (float)tData.alphamapHeight), 0, tData.alphamapHeight - 1);

                                                            // What is the blend value in the alphamap for this texture
                                                            alphaBlendWeight = alphamap[alphamapZ, alphamapX, textureIndex];

                                                            // For FilterMode.OR we would need to remember this result and determine tree placement after
                                                            // processing all filters. Currently, only AND is supported.
                                                            // Don't place trees where the blendweight is below 0.5
                                                            if (alphaBlendWeight < 0.5f && lbFilter.filterMode == LBFilter.FilterMode.AND)
                                                            {
                                                                createTree = false;
                                                                break;
                                                            }
                                                            else if (alphaBlendWeight > 0.1f && lbFilter.filterMode == LBFilter.FilterMode.NOT)
                                                            {
                                                                createTree = false;
                                                                break;
                                                            }
                                                        }
                                                        else
                                                        {
                                                            // No match found in current splatprototypes
                                                            // For FilterMode.OR we would need to remember this result and determine tree placement after
                                                            // processing all filters. Currently, only AND is supported.
                                                            if (lbFilter.filterMode == LBFilter.FilterMode.AND)
                                                            {
                                                                createTree = false;
                                                                break;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                #endregion

                                #region Create Tree
                                // Go ahead and create the tree
                                if (createTree)
                                {
                                    newTree.position = offset;

                                    // Add Y-Axis normalised height offset. Typically so trees can be sunk down slighty, especially on steep slopes
                                    newTree.position.y += treetypeNOffsetY;

                                    // Should the tree be randomly tinted to provide colour variation in a forest?
                                    if (terrainTreesListNoDisabled[i].isTinted)
                                    {
                                        // Randomise colour default maxTintStrength is 0.2
                                        newTree.color = Color.Lerp(Color.white, terrainTreesListNoDisabled[i].tintColour, UnityEngine.Random.Range(0f, terrainTreesListNoDisabled[i].maxTintStrength));
                                    }
                                    else { newTree.color = Color.white; }
                                    // Set lightmap colour
                                    newTree.lightmapColor = Color.white;
                                    if (terrainTreesListNoDisabled[i].treeScalingMode == LBTerrainTree.TreeScalingMode.RandomScaling)
                                    {
                                        // Randomise height
                                        newTree.heightScale = UnityEngine.Random.Range(terrainTreesListNoDisabled[i].minScale, terrainTreesListNoDisabled[i].maxScale);
                                        if (terrainTreesListNoDisabled[i].lockWidthToHeight)
                                        {
                                            // Lock width-to-height ratio
                                            newTree.widthScale = newTree.heightScale;
                                        }
                                        else
                                        {
                                            // Randomise width
                                            newTree.widthScale = UnityEngine.Random.Range(terrainTreesListNoDisabled[i].minScale, terrainTreesListNoDisabled[i].maxScale);
                                        }
                                    }
                                    else if (terrainTreesListNoDisabled[i].treeScalingMode == LBTerrainTree.TreeScalingMode.ScaleByTerrainHeight)
                                    {
                                        minTreeHeight = 0f;
                                        maxTreeHeight = 1f;
                                        if (terrainTreesListNoDisabled[i].treePlacingMode == LBTerrainTree.TreePlacingMode.Height ||
                                            terrainTreesListNoDisabled[i].treePlacingMode == LBTerrainTree.TreePlacingMode.HeightAndInclination ||
                                            terrainTreesListNoDisabled[i].treePlacingMode == LBTerrainTree.TreePlacingMode.HeightInclinationMap)
                                        {
                                            minTreeHeight = terrainTreesListNoDisabled[i].minHeight;
                                            maxTreeHeight = terrainTreesListNoDisabled[i].maxHeight;
                                        }
                                        newTree.heightScale = Mathf.Lerp(terrainTreesListNoDisabled[i].minScale,
                                                                        terrainTreesListNoDisabled[i].maxScale,
                                                                        Mathf.InverseLerp(minTreeHeight, maxTreeHeight, offset.y));
                                        newTree.widthScale = newTree.heightScale;
                                    }
                                    // Randomise rotation (rotation is in radians, so it is 0-2Pi)
                                    newTree.rotation = UnityEngine.Random.Range(0f, 2f * Mathf.PI);
                                    // Add the tree to the terrain
                                    treeInstances.Add(newTree);
                                    numberOfTreesCreated[i]++;
                                    //placedTreeProximities.Add(terrainTreesListNoDisabled[i].minProximity);
                                    lbTerrainTreeInstanceList.Add(new LBTerrainTreeInstance(offset, terrainTreesListNoDisabled[i].minProximity, minProximitySquaredArray[i]));
                                }
                                #endregion
                            }
                        }
                        if (lbTerrainTreeInstanceList != null) { lbTerrainTreeInstanceList.Clear(); }
                    }

                    tData.treeInstances = treeInstances.ToArray();
                    tData.RefreshPrototypes();
                }
            }

            if (showTiming)
            {
                Debug.Log("Time taken for terrain tree placement: " + (Time.realtimeSinceStartup - tStart).ToString("0.000") + " seconds");
            }

            return tData;
        }

        #endregion

        #region Static Grass Methods

        /// <summary>
        /// Returns the TerrainData after populating it with grass.
        /// The landscape parm is required for LBFilter.StencilLayer.
        /// Call LBStencil.FreeStencilResources(landscape, true) after calling this method if
        /// a LBFilterType.StencilLayer was used.
        /// </summary>
        /// <returns>The terrain with grass.</returns>
        /// <param name="tData">T data.</param>
        /// <param name="terrainGrassListNoDisabled">Terrain grass list.</param>
        public static TerrainData PopulateTerrainWithGrass(TerrainData tData, List<LBTerrainGrass> terrainGrassList, Vector3 worldPosition, Vector2 landscapeSize,
                      Vector3 landscapePosition, bool showTiming = false, LBLandscape landscape = null)
        {
            float tStart = Time.realtimeSinceStartup;
            if (tData != null)
            {
                LBRandom lbRandom = new LBRandom();
                // Set a seed value
                if (lbRandom != null)
                {
                    // Use the x-axis of the terrain as the random generator seed.
                    lbRandom.SetSeed(Mathf.RoundToInt(worldPosition.x));
                }
                else { UnityEngine.Random.InitState(0); }

#if LB_COMPUTE
                string methodName = "LBLandscapeTerrain.PopulateTerrainWithGrass";
#endif

                // Remove disabled grass from the list. Create new list so we don't affect original in LBLandscape
                // Remove grasses with missing Map textures
                List<LBTerrainGrass> terrainGrassListNoDisabled = new List<LBTerrainGrass>(terrainGrassList);
                for (int i = terrainGrassListNoDisabled.Count - 1; i >= 0; i--)
                {
                    if (terrainGrassListNoDisabled[i].isDisabled) { terrainGrassListNoDisabled.Remove(terrainGrassListNoDisabled[i]); }

                    // Exclude Grass' with missing Maps - means we don't need to test in x,y loop which saves time
                    else if ((terrainGrassListNoDisabled[i].grassPlacingMode == LBTerrainGrass.GrassPlacingMode.Map ||
                             terrainGrassListNoDisabled[i].grassPlacingMode == LBTerrainGrass.GrassPlacingMode.HeightInclinationMap) && terrainGrassListNoDisabled[i].map == null)
                    { terrainGrassListNoDisabled.Remove(terrainGrassListNoDisabled[i]); }
                }

                #region Pre-defined variables
                float noiseValue = 0f;
                int minDetailDensity = 0;
                int maxDetailDensity = 0;
                LBTerrainGrass lbTerrainGrass;
                int numDetailTypes = 0;

                Vector3 terrainSize3D = tData.size;
                float terrainWidth = terrainSize3D.x;
                float terrainHeight = terrainSize3D.y;
                float terrainLength = terrainSize3D.z;

                // Used for LBFilter
                Vector2 worldPoint = Vector2.zero;
                bool includePoint = true;
                bool includePointCurrentFilter = false;

                // Texture Map variables
                LBMapPoint mapPoint;
                LBMap lbMap;
                float pixelVariationNormalised = 0f;

                // Get the normalised (0-1) bounds of this terrain within the landscape
                float startX = ((worldPosition.x - landscapePosition.x) / landscapeSize.x);
                float endX = startX + (terrainWidth / landscapeSize.x);
                float startY = ((worldPosition.z - landscapePosition.z) / landscapeSize.y);
                float endY = startY + (terrainLength / landscapeSize.y);

                // Alphamap variables for use with LBFilter.FilterType.Texture
                float[,,] alphamap = new float[1, 1, 1];
                List<LBTerrainTexture> alphamapTerrainTexturesList = null;
                int textureIndex = 0;
                float alphaBlendWeight = 0f;
                int alphamapX = 0, alphamapZ = 0;

                // Imported data variables
                LBTerrainData lbTerrainData = null;
                bool isTerrainGrassDataValid = false;
                #endregion

                // Populate terrain with grass
                if (terrainGrassListNoDisabled != null)
                {
                    #region Set grass to use from landscape grass list
                    tData.detailPrototypes = LBTerrainGrass.ToDetailPrototypeList(terrainGrassListNoDisabled).ToArray();
                    numDetailTypes = (tData.detailPrototypes == null ? 0 : tData.detailPrototypes.Length);

                    // Imported grass may have a different Detail Resolution than the LB default
                    if (terrainGrassListNoDisabled.Exists(grs => grs.grassPlacingMode == LBTerrainGrass.GrassPlacingMode.Imported))
                    {
                        int detailResolution = 1024;
                        // Get the first imported grass
                        lbTerrainGrass = terrainGrassListNoDisabled.Find(grs => grs.grassPlacingMode == LBTerrainGrass.GrassPlacingMode.Imported);
                        if (lbTerrainGrass != null)
                        {
                            detailResolution = LBTerrainData.GetGrassDetailResolution(landscape, tData, lbTerrainGrass.lbTerrainDataList, false);
                        }

                        tData.SetDetailResolution(detailResolution, 16);
                    }
                    // Set the LB Default Detail Resolution
                    else if (tData.detailResolution < 128)
                    {
                        tData.SetDetailResolution(1024, 16);
                    }

                    // Get the detail width and height (which should be the same as resolution)
                    int detailWidthInt = tData.detailWidth;
                    int detailHeightInt = tData.detailHeight;

                    float detailWidth = (float)detailWidthInt;
                    float detailHeight = (float)detailHeightInt;

                    #endregion

#if !(UNITY_STANDALONE_OSX || UNITY_STANDALONE_WIN || UNITY_XBOXONE || UNITY_WSA_10_0)
                    bool isGrassComputeEnabled = false;
#else
                    bool isGrassComputeEnabled = (landscape == null ? false : landscape.useGPUGrass);
#endif

                    #region Are their any Texture LBFilter's applied?
                    bool isTextureFiltersToApply = false;
                    foreach (LBTerrainGrass lbtg in terrainGrassListNoDisabled)
                    {
                        if (lbtg != null)
                        {
                            if (!lbtg.isDisabled)
                            {
                                isTextureFiltersToApply = LBFilter.Contains(lbtg.filterList, LBFilter.FilterType.Texture);
                                if (isTextureFiltersToApply) { break; }
                            }
                        }
                    }
                    #endregion

                    #region SplatMaps (alphamaps for texture filters)
                    // There are texture filters so pre-load the alphamaps for this terrain
                    // NOTE: This could consume a fair amount of RAM on large terrains with many alphamaps
                    if (isTextureFiltersToApply)
                    {
#if UNITY_2018_3_OR_NEWER
                        alphamapTerrainTexturesList = LBTerrainTexture.ToLBTerrainTextureList(tData.terrainLayers);
#else
                        alphamapTerrainTexturesList = LBTerrainTexture.ToLBTerrainTextureList(tData.splatPrototypes);
#endif
                        alphamap = tData.GetAlphamaps(0, 0, tData.alphamapWidth, tData.alphamapHeight);
                    }
                    #endregion

                    #region Are their any Area LBFilters applied?
                    bool isAreaFiltersToApply = false;
                    foreach (LBTerrainGrass lbtg in terrainGrassListNoDisabled)
                    {
                        if (lbtg != null)
                        {
                            if (!lbtg.isDisabled)
                            {
                                isAreaFiltersToApply = LBFilter.Contains(lbtg.filterList, LBFilter.FilterType.Area);
                                if (isAreaFiltersToApply) { break; }
                            }
                        }
                    }
                    #endregion

                    #region LBMaps
                    List<LBMap> lbMapList = new List<LBMap>();
                    // Pre-create a list of maps - some maps may not be applicable but this could improve performance
                    // There will be no need to create a map for each point for those Textures that use a map
                    foreach (LBTerrainGrass lbtg in terrainGrassListNoDisabled)
                    {
                        if (lbtg != null)
                        {
                            lbMap = new LBMap(lbtg.map, lbtg.mapColour, lbtg.mapTolerance);
                            lbMap.inverse = lbtg.mapInverse;
                            lbMap.toleranceBlendCurve = lbtg.mapToleranceBlendCurve;
                            lbMapList.Add(lbMap);
                        }
                    }
                    lbMap = null;
                    #endregion

                    AnimationCurve grassPopulationCurve = LBCurve.SetCurveFromPreset(LBCurve.FilterCurvePreset.WideRange);

                    int detailTerrainSizeFactor = Mathf.RoundToInt((terrainWidth / 1000f) * (terrainWidth / 1000f));
                    if (detailTerrainSizeFactor < 1) { detailTerrainSizeFactor = 1; }

                    #region Landscape-scoped data
                    Terrain[] landscapeTerrains = new Terrain[0];
                    TerrainData[] terrainDataArray = new TerrainData[0];
                    Rect[] terrainRectsArray = new Rect[0];
                    int numTerrains = 0;
                    bool useLandscapeHeights = false;

                    // If a landscape is supplied, we want to check the edges with the same terrain to ensure both sides of the terrain
                    // edges use the same slope and height values.
                    if (landscape != null)
                    {
                        landscape.SetLandscapeTerrains(true);
                        if (!isGrassComputeEnabled)
                        {
                            landscapeTerrains = landscape.landscapeTerrains;
                            numTerrains = (landscapeTerrains == null ? 0 : landscapeTerrains.Length);
                            if (numTerrains > 1)
                            {
                                useLandscapeHeights = true;
                                // Create arrays for terrain data and terrain rects
                                terrainDataArray = new TerrainData[numTerrains];
                                terrainRectsArray = new Rect[numTerrains];
                                for (int i = 0; i < numTerrains; i++)
                                {
                                    terrainDataArray[i] = landscapeTerrains[i].terrainData;
                                    if (terrainDataArray[i] == null) { useLandscapeHeights = false; break; }
                                    Vector3 landscapePositionVector = landscapeTerrains[i].transform.position - landscapePosition;
                                    terrainRectsArray[i] = Rect.MinMaxRect(landscapePositionVector.x, landscapePositionVector.z, landscapePositionVector.x + landscapeTerrains[i].terrainData.size.x + 0.005f,
                                        landscapePositionVector.z + landscapeTerrains[i].terrainData.size.z + 0.005f);
                                }
                            }
                        }
                    }
                    #endregion

                    #region Stencil LBFilter variables
                    Vector2 stencilLayerPosN = new Vector2();
                    LBMapPoint arrayPoint = new LBMapPoint(0, 0);
                    int stencilLayerResolution = 0;
                    int stencilLayerPixel = 0;
                    #endregion

                    #region Init Compute

#if LB_COMPUTE

                    // Compute variables
                    int kGrassPerlinIdx = -1;
                    int detailMap1DSize = detailWidthInt * detailHeightInt;
                    int[] detailMap1D = null;
                    ComputeBuffer cbufDetailMap = null;
                    ComputeBuffer cbufHeightsIn = null;
                    ComputeBuffer cbufHeightLandscape = null;
                    ComputeBuffer cbufLBFilters = null;
                    Vector4 cvec4AreaRect = Vector4.zero;
                    Vector4 cvec4MinMaxRange = Vector4.zero;
                    Texture2D terrainNormalsTex = null;
                    Texture2D dummyTex = null;
                    bool isGrassComputeSetup = false;

                    // There are 128x128, 256x256, 512x512, 1Kx1K, 2Kx2K, 4Kx4K and 8Kx8K Text2DArrays for stencil layers
                    List<Texture2DArray> stencilLayerTex2DArrayList = new List<Texture2DArray>(7);
                    LBCSFilter[] lbcsFilter = null;
                    List<string> stencilLayerGUIDList = null;
                    // Each unique stencil layer resolution has a list of stencil layer GUIDs
                    List<List<string>> stencilLayerArrayGUIDList = new List<List<string>>();
                    LBStencilLayer lbStencilLayer = null;
                    LBFilter lbGFilter = null;

                    int cskGrassPerlinNumThreads = 256; // Must match LB_GRASS_NUM_THREADS in LBCSGrass.compute
                    ComputeShader shaderGrass = null;
                    float[] heightMap1D = null;

                    if (isGrassComputeEnabled && numDetailTypes > 0)
                    {
                        try
                        {
                            shaderGrass = (ComputeShader)Resources.Load(LBCSGrass, typeof(ComputeShader));
                            if (shaderGrass == null) { Debug.LogWarning("ERROR: " + methodName + " " + LBCSGrass + ".shader not found. Please Report"); }
                            else
                            {
                                // Setup items that only need to be loaded once and used across (potentially) multiple Grasses
                                // Get the index to the Method in the compute shader
                                kGrassPerlinIdx = shaderGrass.FindKernel(CSKGrassPerlin);

                                #region Get Terrain Heightmap data
                                heightmapResolution = tData.heightmapResolution;
                                int sqrHeightmapResolution = heightmapResolution * heightmapResolution;

                                // Create heightmap as a 1-dimensional array
                                heightMap1D = new float[sqrHeightmapResolution];
                                int heightMap1DSize = (heightMap1D == null ? 0 : heightMap1D.Length);

                                if (heightMap1DSize == (sqrHeightmapResolution))
                                {
                                    // Copy data from 2D heightmap to 1D array - Size is in bytes
                                    System.Buffer.BlockCopy(tData.GetHeights(0, 0, heightmapResolution, heightmapResolution), 0, heightMap1D, 0, sizeof(float) * sqrHeightmapResolution);
                                }

                                // Create heightsIn computebuffer
                                cbufHeightsIn = new ComputeBuffer(sqrHeightmapResolution, sizeof(float), ComputeBufferType.Default);

                                #endregion

                                #region Get whole landscape low-res Heightmap data
                                // For 256 terrains this would be approx 1GB
                                bool isCurvatureRules = terrainGrassListNoDisabled.Exists(tx => tx.grassPlacingMode == LBTerrainGrass.GrassPlacingMode.HeightInclinationCurvature);
                                int heightMapLandscape1DSize = isCurvatureRules ? landscape.GetTotalHeightmapSize(false, 65, terrainSize3D) : 1;
                                float[] heightMapLandscape1D = new float[heightMapLandscape1DSize];
                                heightMapLandscape1DSize = heightMapLandscape1D.Length;

                                // Create landscape-scoped low-res heights buffer
                                cbufHeightLandscape = new ComputeBuffer(heightMapLandscape1DSize, sizeof(float), ComputeBufferType.Default);

                                // Low-res landscape-wide heightmap
                                if (isCurvatureRules && heightMapLandscape1DSize > 1)
                                {
                                    GetLandscapeScopedHeightmap(landscape, ref heightMapLandscape1D, 65, true);
                                }
                                shaderGrass.SetBuffer(kGrassPerlinIdx, CSheightsLandscape, cbufHeightLandscape);
                                // Copy the landscape-scoped low-res heights to the shader (or a dummy version with 1 float)
                                cbufHeightLandscape.SetData(heightMapLandscape1D);
                                shaderGrass.SetInt(CShmapLandscapeRes, (int)Mathf.Sqrt(heightMapLandscape1DSize));

                                #endregion

                                #region Assign height buffer to GrassPerlin method and copy in height data
                                shaderGrass.SetBuffer(kGrassPerlinIdx, CSheightsIn, cbufHeightsIn);

                                // Copy height data into shader
                                cbufHeightsIn.SetData(heightMap1D);
                                #endregion

                                #region Get Slope data
                                // Copy terrain normals into a texture
                                terrainNormalsTex = GetSlopeTexture2D(landscape, landscapePosition, tData, worldPosition, detailWidthInt, detailHeightInt, "LB_CSGrass_TN");
                                if (terrainNormalsTex == null) { Debug.LogWarning("ERROR: " + methodName + " - could not get terrain normals. Please Report"); }
                                #endregion

                                #region Set common compute shader variables
                                // Set terrain variables
                                shaderGrass.SetFloat(CSterrainWidth, terrainWidth);
                                shaderGrass.SetFloat(CSterrainLength, terrainLength);
                                shaderGrass.SetVector(CSterrainWorldPos, worldPosition);
                                shaderGrass.SetTexture(kGrassPerlinIdx, CSterrainNormals, terrainNormalsTex);
                                // Set landscape variables
                                shaderGrass.SetVector(CSlandscapePos, landscapePosition);
                                shaderGrass.SetVector(CSlandscapeSize, landscapeSize);
                                // Set Random gen variables
                                //shaderGrass.SetFloat(CSran1Seed, lbRandom.Range(0.1f, 1f));
                                // Detail Density variables
                                shaderGrass.SetInt(CSdetailWidth, detailWidthInt);
                                shaderGrass.SetInt(CSdetailHeight, detailHeightInt);
                                #endregion

                                #region Create Dummy Texture
                                // Create a dummy small texture that can be used in-place of a Map if a Map isn't required.
                                // This should satisfy the compute shader
                                dummyTex = new Texture2D(1, 1, TextureFormat.ARGB32, false, true);
                                #endregion

                                // Create once and re-use for each detail density map (which are all the same size)
                                detailMap1D = new int[detailMap1DSize];

                                isGrassComputeSetup = (cbufHeightsIn != null && cbufHeightLandscape != null && terrainNormalsTex != null && detailMap1D != null);
                            }
                        }
                        catch (System.Exception ex)
                        {
                            Debug.LogWarning("ERROR " + methodName + " - could not configure landscape for Grass using GPU - " + ex.Message);
                        }
                        finally
                        {
                            // If this phase didn't complete, free up resources
                            if (!isGrassComputeSetup)
                            {
                                if (cbufHeightsIn != null) { cbufHeightsIn.Release(); cbufHeightsIn = null; }
                                if (cbufHeightLandscape != null) { cbufHeightLandscape.Release(); cbufHeightLandscape = null; }
                                if (cbufLBFilters != null) { cbufLBFilters.Release(); cbufLBFilters = null; }
                                if (terrainNormalsTex != null) { LBTextureOperations.DestroyTexture2D(ref terrainNormalsTex); }
                                if (dummyTex != null) { LBTextureOperations.DestroyTexture2D(ref dummyTex); }
                            }
                        }
                    }

#endif

                    #endregion

                    #region Reset Garbage Collection
                    System.GC.Collect();
                    #endregion

                    // For each detail type specified...
                    for (int i = 0; i < numDetailTypes; i++)
                    {
                        lbTerrainGrass = terrainGrassListNoDisabled[i];
                        int[,] detailDensityMap2D = new int[detailWidthInt, detailHeightInt];

                        #region Groups-only GrassPlacementMode
                        // If there grass will only be used in Groups, we need to clear the density map here for this prototype
                        // This will also be faster than doing all the usual processing
                        if (lbTerrainGrass.grassPlacingMode == LBTerrainGrass.GrassPlacingMode.GroupsOnly)
                        {
                            // Update the whole terrain with 0 values
                            tData.SetDetailLayer(0, 0, i, detailDensityMap2D);

                            // Go to the next Grass/Detail prototype
                            continue;
                        }
                        #endregion

                        #region Per-GrassType variables
                        // Store variables defining min-max rules and their corresponding measurements 
                        float minH = lbTerrainGrass.minPopulatedHeight;
                        float maxH = lbTerrainGrass.maxPopulatedHeight;
                        // Ensure minPopulatedHeight of 0 evaluates ok
                        if (minH == 0f) { minH = -0.01f; }
                        //float diffH = (maxH - minH) / 2f;
                        //float midH = (maxH + minH) / 2f;
                        float minI = lbTerrainGrass.minInclination;
                        float maxI = lbTerrainGrass.maxInclination;
                        // Ensure minInclination of 0 evaluates ok
                        if (minI == 0f) { minI = -1f; }
                        //float diffI = (maxI - minI) / 2f;
                        //float midI = (maxI + minI) / 2f;
                        // Change detail density to work on a basis of actual world size
                        minDetailDensity = lbTerrainGrass.minDensity * detailTerrainSizeFactor;
                        maxDetailDensity = lbTerrainGrass.density * detailTerrainSizeFactor;
                        LBTerrainGrass.GrassPlacingMode grassPlacingMode = lbTerrainGrass.grassPlacingMode;
#if LB_COMPUTE
                        int grassPlacingModeInt = (int)grassPlacingMode;
#endif
                        LBTerrainGrass.GrassPatchFadingMode grassPatchFadingMode = lbTerrainGrass.grassPatchFadingMode;
                        // Curvature values
                        int isCurvatureConcave = (lbTerrainGrass.isCurvatureConcave ? 1 : 0);
                        float curvatureMinHeightDiffN = lbTerrainGrass.curvatureMinHeightDiff / terrainHeight;
                        float curvatureDistanceXN = lbTerrainGrass.curvatureDistance / terrainWidth;
                        float curvatureDistanceZN = lbTerrainGrass.curvatureDistance / terrainLength;
                        // Noise values
                        bool grassUseNoise = lbTerrainGrass.useNoise;
                        float grassNoiseTileSize = lbTerrainGrass.noiseTileSize;
                        float grassPlacementCutoff = lbTerrainGrass.grassPlacementCutoff;
                        int grassNoiseOctaves = lbTerrainGrass.noiseOctaves;
                        // A multiplier is used so that the maximum value of the noise is the same for any number of octaves
                        float grassNoiseMultiplier = 1f / (1f - LBNoise.IntPow(0.5f, grassNoiseOctaves));
                        #endregion

                        #region Preload Stencil Layers
                        // Are there any Stencil Layer filters for this grass type?
                        bool isStencilLayerFiltersToApply = LBFilter.Contains(lbTerrainGrass.filterList, LBFilter.FilterType.StencilLayer);
                        if (isStencilLayerFiltersToApply)
                        {
                            // Preload the stencil data
                            if (lbTerrainGrass.filterList != null)
                            {
                                foreach (LBFilter lbFilter in lbTerrainGrass.filterList)
                                {
                                    if (lbFilter != null)
                                    {
                                        // Currently all stencil filters are AND
                                        // Is this a valid Stencil Filter?
                                        if (lbFilter.filterType == LBFilter.FilterType.StencilLayer && !string.IsNullOrEmpty(lbFilter.lbStencilGUID) && !string.IsNullOrEmpty(lbFilter.lbStencilLayerGUID))
                                        {
                                            // If the temporary class instance isn't defined, look it up and validate it is in the current landscape
                                            if (lbFilter.lbStencil == null)
                                            {
                                                lbFilter.lbStencil = LBStencil.GetStencilInLandscape(landscape, lbFilter.lbStencilGUID, true);
                                            }

                                            if (lbFilter.lbStencil != null)
                                            {
                                                // Find the Stencil Layer for this Layer Filter and populate the temporary class instance
                                                lbFilter.lbStencilLayer = lbFilter.lbStencil.GetStencilLayerByGUID(lbFilter.lbStencilLayerGUID);

                                                // Load the USHORT data
                                                if (lbFilter.lbStencilLayer != null)
                                                {
                                                    if (lbFilter.lbStencilLayer.layerArray == null && !isGrassComputeEnabled)
                                                    {
                                                        lbFilter.lbStencilLayer.AllocLayerArray();
                                                        lbFilter.lbStencilLayer.UnCompressToUShort();
                                                    }
                                                }

                                                // Cache the layer resolution
                                                if (isGrassComputeEnabled)
                                                {
                                                    lbFilter.stencilLayerResolution = (int)lbFilter.lbStencilLayer.layerResolution;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        #endregion

                        #region Load Imported Grass Data
                        // If this is an imported grass type, look up the imported grass data
                        if (lbTerrainGrass.grassPlacingMode == LBTerrainGrass.GrassPlacingMode.Imported)
                        {
                            isTerrainGrassDataValid = false;
                            lbTerrainData = lbTerrainGrass.lbTerrainDataList.Find(td => td.sourceTerrainDataName == tData.name);

                            // Validate LBTerrainData for Grass
                            if (lbTerrainData != null)
                            {
                                isTerrainGrassDataValid = lbTerrainData.ValidateGrassDetailData(landscape, true);
                            }
                        }
                        #endregion

                        #region Grass Compute

#if LB_COMPUTE

                        if (isGrassComputeEnabled && isGrassComputeSetup)
                        {
                            try
                            {
                                #region Detail Density Map Buffer

                                cbufDetailMap = new ComputeBuffer(detailWidthInt * detailHeightInt, sizeof(int), ComputeBufferType.Default);
                                if (cbufDetailMap != null)
                                {
                                    // Assign the buffer to the shader method
                                    shaderGrass.SetBuffer(kGrassPerlinIdx, CSdetailDensityMap, cbufDetailMap);
                                }

                                #endregion

                                #region Get Filters (Stencil and Area)
                                int numFilters = (lbTerrainGrass.filterList == null ? 0 : lbTerrainGrass.filterList.Count(f => (f.filterType == LBFilter.FilterType.StencilLayer && !string.IsNullOrEmpty(f.lbStencilGUID)) || f.filterType == LBFilter.FilterType.Area || f.filterType == LBFilter.FilterType.Texture));

                                // Create the buffer to hold the LBCSFilter struct used in the shader
                                int sizeLBCSFilter = System.Runtime.InteropServices.Marshal.SizeOf(new LBCSFilter());
                                if (numFilters > 0)
                                {
                                    cbufLBFilters = new ComputeBuffer(numFilters, sizeLBCSFilter, ComputeBufferType.Default);
                                    // Create the struct used to hold the LBTextureFilter data
                                    lbcsFilter = new LBCSFilter[numFilters];
                                    // Create a list to store the unique stencil layer GUIDs
                                    if (stencilLayerGUIDList == null) { stencilLayerGUIDList = new List<string>(); }
                                    else { stencilLayerGUIDList.Clear(); }
                                    // Add an empty list of string for each possible stencil layer resolution
                                    for (int g = 0; g < 7; g++) { stencilLayerArrayGUIDList.Add(new List<string>(7)); }
                                }
                                else
                                {
                                    // Create dummy filter buffer and list of filters
                                    cbufLBFilters = new ComputeBuffer(1, sizeLBCSFilter, ComputeBufferType.Default);
                                    lbcsFilter = new LBCSFilter[1];
                                }

                                // Discover number textures required for each stencil layer resolution
                                // This isn't very scalable and probably should be done some more generic way
                                int numStencilLayerTex128 = LBTerrainGrass.GetNumStencilLayersByResolution(lbTerrainGrass.filterList, 128);
                                int numStencilLayerTex256 = LBTerrainGrass.GetNumStencilLayersByResolution(lbTerrainGrass.filterList, 256);
                                int numStencilLayerTex512 = LBTerrainGrass.GetNumStencilLayersByResolution(lbTerrainGrass.filterList, 512);
                                int numStencilLayerTex1024 = LBTerrainGrass.GetNumStencilLayersByResolution(lbTerrainGrass.filterList, 1024);
                                int numStencilLayerTex2048 = LBTerrainGrass.GetNumStencilLayersByResolution(lbTerrainGrass.filterList, 2048);
                                int numStencilLayerTex4096 = LBTerrainGrass.GetNumStencilLayersByResolution(lbTerrainGrass.filterList, 4096);
                                int numStencilLayerTex8192 = LBTerrainGrass.GetNumStencilLayersByResolution(lbTerrainGrass.filterList, 8192);

                                int lcFilterIdx = 0;

                                // Create the texture arrays to hold the unique compressed stencil layer textures
                                // Create a minimum of 1 in each array (cannot have an array size of zero)
                                // If there is no stencil for a certain resolution, create a dummy Texture2DArray with a 1x1 Texture to conserve GPU memory
                                if (numStencilLayerTex128 < 1) { stencilLayerTex2DArrayList.Add(new Texture2DArray(1, 1, 1, TextureFormat.ARGB32, false, true)); }
                                else { stencilLayerTex2DArrayList.Add(new Texture2DArray(128, 128, numStencilLayerTex128, TextureFormat.ARGB32, false, true)); }
                                if (numStencilLayerTex256 < 1) { stencilLayerTex2DArrayList.Add(new Texture2DArray(1, 1, 1, TextureFormat.ARGB32, false, true)); }
                                else { stencilLayerTex2DArrayList.Add(new Texture2DArray(256, 256, numStencilLayerTex256, TextureFormat.ARGB32, false, true)); }
                                if (numStencilLayerTex512 < 1) { stencilLayerTex2DArrayList.Add(new Texture2DArray(1, 1, 1, TextureFormat.ARGB32, false, true)); }
                                else { stencilLayerTex2DArrayList.Add(new Texture2DArray(512, 512, numStencilLayerTex512, TextureFormat.ARGB32, false, true)); }
                                if (numStencilLayerTex1024 < 1) { stencilLayerTex2DArrayList.Add(new Texture2DArray(1, 1, 1, TextureFormat.ARGB32, false, true)); }
                                else { stencilLayerTex2DArrayList.Add(new Texture2DArray(1024, 1024, numStencilLayerTex1024, TextureFormat.ARGB32, false, true)); }
                                if (numStencilLayerTex2048 < 1) { stencilLayerTex2DArrayList.Add(new Texture2DArray(1, 1, 1, TextureFormat.ARGB32, false, true)); }
                                else { stencilLayerTex2DArrayList.Add(new Texture2DArray(2048, 2048, numStencilLayerTex2048, TextureFormat.ARGB32, false, true)); }
                                if (numStencilLayerTex4096 < 1) { stencilLayerTex2DArrayList.Add(new Texture2DArray(1, 1, 1, TextureFormat.ARGB32, false, true)); }
                                else { stencilLayerTex2DArrayList.Add(new Texture2DArray(4096, 4096, numStencilLayerTex4096, TextureFormat.ARGB32, false, true)); }
                                if (numStencilLayerTex8192 < 1) { stencilLayerTex2DArrayList.Add(new Texture2DArray(1, 1, 1, TextureFormat.ARGB32, false, true)); }
                                else { stencilLayerTex2DArrayList.Add(new Texture2DArray(8192, 8192, numStencilLayerTex8192, TextureFormat.ARGB32, false, true)); }

                                int numSLayerTex2DArrays = stencilLayerTex2DArrayList.Count;

                                for (int txAIdx = 0; txAIdx < numSLayerTex2DArrays; txAIdx++) { stencilLayerTex2DArrayList[txAIdx].hideFlags = HideFlags.DontSave; }

                                // Track the current index with the Texture2DArrays so we can know which slot to copy the compressed texture into.
                                // The currArrayIdx is aligned to the stencilLayerTex2DArrayList. So curArrayIdx[0] stores the position in the
                                // 128x128 Texture2Array for stencilLayerTex2DArrayList[0]. currArrrayIdx[1] is for the Texture2DArrays containing 256x256 textures etc.
                                int[] currArrayIdx = new int[7];
                                // Initialise array
                                if (currArrayIdx != null) { for (int txAIdx = 0; txAIdx < currArrayIdx.Length; txAIdx++) { currArrayIdx[txAIdx] = -1; } }

                                #region Populate Filter structures
                                // For each filter, increment the overall filter index counter
                                for (int fIdx = 0; fIdx < numFilters && lcFilterIdx < numFilters; fIdx++, lcFilterIdx++)
                                {
                                    lbGFilter = lbTerrainGrass.filterList[fIdx];

                                    // Common properties
                                    lbcsFilter[lcFilterIdx].filterMode = (int)lbGFilter.filterMode;
                                    lbcsFilter[lcFilterIdx].csfilterType = 999; // Some default number which will be ignored in the shader
                                    // Defaults
                                    lbcsFilter[lcFilterIdx].minHeight = 0f;
                                    lbcsFilter[lcFilterIdx].maxHeight = 1f;
                                    lbcsFilter[lcFilterIdx].minInclination = 0f;
                                    lbcsFilter[lcFilterIdx].maxInclination = 1f;
                                    lbcsFilter[lcFilterIdx].lbTexIdx = 0;
                                    lbcsFilter[lcFilterIdx].areaRect.x = 0;
                                    lbcsFilter[lcFilterIdx].areaRect.y = 0;
                                    lbcsFilter[lcFilterIdx].areaRect.z = landscapeSize.x;
                                    lbcsFilter[lcFilterIdx].areaRect.w = landscapeSize.y;

                                    #region Stencil Filter
                                    if (lbGFilter.filterType == LBFilter.FilterType.StencilLayer && lbGFilter.lbStencilLayer != null)
                                    {
                                        lbStencilLayer = lbGFilter.lbStencilLayer;
                                        if (lbStencilLayer != null)
                                        {
                                            lbcsFilter[lcFilterIdx].csfilterType = 3;

                                            // Get the layer resolution and convert it to an index for faster lookup
                                            stencilLayerResolution = (int)lbStencilLayer.layerResolution;
                                            int stencilLayerResolutionIdx = -1;

                                            // There might be a better way of doing this via the position in the enum.
                                            switch (stencilLayerResolution)
                                            {
                                                case 128: stencilLayerResolutionIdx = 0; break;
                                                case 256: stencilLayerResolutionIdx = 1; break;
                                                case 512: stencilLayerResolutionIdx = 2; break;
                                                case 1024: stencilLayerResolutionIdx = 3; break;
                                                case 2048: stencilLayerResolutionIdx = 4; break;
                                                case 4096: stencilLayerResolutionIdx = 5; break;
                                                case 8092: stencilLayerResolutionIdx = 6; break;
                                            }

                                            // If it doesn't already exist, add it to the list of unique Stencil Layer GUIDs
                                            if (!stencilLayerGUIDList.Exists(guid => guid == lbGFilter.lbStencilLayerGUID))
                                            {
                                                // Add the stencil layer data to the Texture2DArray
                                                if (lbStencilLayer.compressedTexture != null && stencilLayerResolutionIdx >= 0)
                                                {
                                                    Texture2DArray texture2DArray = null;

                                                    // Add stencil layer GUID to the list of unique Stencil Layer GUIDs
                                                    stencilLayerGUIDList.Add(lbGFilter.lbStencilLayerGUID.ToString());

                                                    // Add stencil layer GUID to list of unique GUIDs for this resolution so we can easily look it up for other filters
                                                    stencilLayerArrayGUIDList[stencilLayerResolutionIdx].Add(lbGFilter.lbStencilLayerGUID.ToString());

                                                    //Debug.Log("[DEBUG] Add new GUID " + lbGFilter.lbStencilLayerGUID + " for " + stencilLayerResolutionIdx + " " + lbStencilLayer.LayerName);

                                                    texture2DArray = stencilLayerTex2DArrayList[stencilLayerResolutionIdx];
                                                    if (texture2DArray != null)
                                                    {
                                                        currArrayIdx[stencilLayerResolutionIdx]++;
                                                        LBTextureOperations.CopyTextureTo2DArray(ref texture2DArray, lbStencilLayer.compressedTexture, currArrayIdx[stencilLayerResolutionIdx], true);
                                                    }
                                                }
                                            }

                                            // Get the position within the list
                                            if (stencilLayerResolution < 0) { lbcsFilter[lcFilterIdx].stencilLayerTex2DArrIdx = -1; }
                                            else
                                            {
                                                lbcsFilter[lcFilterIdx].stencilLayerTex2DArrIdx = stencilLayerArrayGUIDList[stencilLayerResolutionIdx].FindIndex(guid => guid == lbGFilter.lbStencilLayerGUID);
                                                //Debug.Log("[DEBUG] Grass " + (i + 1) + " sten lyr: " + lbStencilLayer.LayerName + " res: " + stencilLayerResolution + " guididx: " + lbcsFilter[lcFilterIdx].stencilLayerTex2DArrIdx);
                                            }

                                            // Set stencil layer resolution to 128 if the layer wasn't found.
                                            lbcsFilter[lcFilterIdx].stencilLayerResolution = (lbGFilter.lbStencilLayer == null ? 128 : (int)lbGFilter.lbStencilLayer.layerResolution);
                                        }
                                    }
                                    #endregion

                                    #region Area Filter
                                    else if (lbGFilter.filterType == LBFilter.FilterType.Area)
                                    {
                                        // Populate the struct used to hold the LBTextureFilter data
                                        lbcsFilter[lcFilterIdx].csfilterType = 4;
                                        // Add the area as boundary points. This becomes a float4 in the compute shader
                                        lbcsFilter[lcFilterIdx].areaRect.x = lbGFilter.areaRect.xMin;
                                        lbcsFilter[lcFilterIdx].areaRect.y = lbGFilter.areaRect.yMin;
                                        lbcsFilter[lcFilterIdx].areaRect.z = lbGFilter.areaRect.xMax;
                                        lbcsFilter[lcFilterIdx].areaRect.w = lbGFilter.areaRect.yMax;
                                        // This is not a stencil filter
                                        lbcsFilter[lcFilterIdx].stencilLayerTex2DArrIdx = -1;
                                        lbcsFilter[lcFilterIdx].stencilLayerResolution = 1024;
                                    }
                                    #endregion

                                    #region Texture Filter (not yet supported)
                                    else if (lbGFilter.filterType == LBFilter.FilterType.Texture && lbGFilter.terrainTexture != null)
                                    {
                                        // Currently unsupported in the Grass Compute Shader
                                        lbcsFilter[lcFilterIdx].csfilterType = 5;
                                        // This is not a stencil filter
                                        lbcsFilter[lcFilterIdx].stencilLayerTex2DArrIdx = -1;
                                        lbcsFilter[lcFilterIdx].stencilLayerResolution = 1024;
                                    }
                                    #endregion

                                    #region Filter - other
                                    else
                                    {
                                        // This is not a stencil, area, or Texture filter
                                        lbcsFilter[lcFilterIdx].stencilLayerTex2DArrIdx = -1;
                                        lbcsFilter[lcFilterIdx].stencilLayerResolution = 1024;
                                    }
                                    #endregion
                                }

                                #endregion

                                #region Set Filters in Shader
                                // Set and Populate grass filter buffer
                                shaderGrass.SetBuffer(kGrassPerlinIdx, CSlbFilters, cbufLBFilters);
                                cbufLBFilters.SetData(lbcsFilter);
                                // Set the sum of the number of filters for this LBGrass
                                shaderGrass.SetInt(CSnumlbFilters, numFilters);
                                //Debug.Log("FilterVariables: [" + CSnumlbFilters + "] " + numFilters);

                                // Assign the Texture2DArrays to the compute shader
                                if (numSLayerTex2DArrays > 0) { shaderGrass.SetTexture(kGrassPerlinIdx, CSstencilLayer128Tex2DArray, stencilLayerTex2DArrayList[0]); }
                                if (numSLayerTex2DArrays > 1) { shaderGrass.SetTexture(kGrassPerlinIdx, CSstencilLayer256Tex2DArray, stencilLayerTex2DArrayList[1]); }
                                if (numSLayerTex2DArrays > 2) { shaderGrass.SetTexture(kGrassPerlinIdx, CSstencilLayer512Tex2DArray, stencilLayerTex2DArrayList[2]); }
                                if (numSLayerTex2DArrays > 3) { shaderGrass.SetTexture(kGrassPerlinIdx, CSstencilLayer1024Tex2DArray, stencilLayerTex2DArrayList[3]); }
                                if (numSLayerTex2DArrays > 4) { shaderGrass.SetTexture(kGrassPerlinIdx, CSstencilLayer2048Tex2DArray, stencilLayerTex2DArrayList[4]); }
                                if (numSLayerTex2DArrays > 5) { shaderGrass.SetTexture(kGrassPerlinIdx, CSstencilLayer4096Tex2DArray, stencilLayerTex2DArrayList[5]); }
                                if (numSLayerTex2DArrays > 6) { shaderGrass.SetTexture(kGrassPerlinIdx, CSstencilLayer8192Tex2DArray, stencilLayerTex2DArrayList[6]); }
                                #endregion

                                #endregion

                                #region Set variables in compute shader

                                shaderGrass.SetInt(CSheightmapResolution, heightmapResolution);
                                // Set LBTerrainGrass variables
                                shaderGrass.SetInt(CSgrassPlacingMode, grassPlacingModeInt);
                                shaderGrass.SetBool(CSgrassDontFade, (lbTerrainGrass.grassPatchFadingMode == LBTerrainGrass.GrassPatchFadingMode.DontFade));
                                shaderGrass.SetBool(CSuseNoise, grassUseNoise);
                                shaderGrass.SetFloat(CSnoiseTileSize, grassNoiseTileSize);
                                shaderGrass.SetInt(CSnoiseOctaves, grassNoiseOctaves);
                                shaderGrass.SetFloat(CSgrassPlacementCutoff, grassPlacementCutoff);
                                shaderGrass.SetFloat(CSgrassNoiseMultiplier, grassNoiseMultiplier);
                                shaderGrass.SetInt(CSminDensity, minDetailDensity);
                                shaderGrass.SetInt(CSmaxDensity, maxDetailDensity);
                                shaderGrass.SetFloat(CSminH, minH);
                                shaderGrass.SetFloat(CSmaxH, maxH);
                                shaderGrass.SetFloat(CSminI, minI);
                                shaderGrass.SetFloat(CSmaxI, maxI);
                                shaderGrass.SetInt(CSisCurvatureConcave, isCurvatureConcave);
                                shaderGrass.SetFloat(CScurvatureMinHeightDiffN, curvatureMinHeightDiffN);
                                shaderGrass.SetFloat(CScurvatureDistanceXN, curvatureDistanceXN);
                                shaderGrass.SetFloat(CScurvatureDistanceZN, curvatureDistanceZN);
                                // If this rule includes a Map texture, add the texture to the shader,
                                // else assign a 1x1 dummy Texture2D
                                if ((grassPlacingModeInt == 4 || grassPlacingModeInt == 5) && lbTerrainGrass.map != null)
                                {
                                    shaderGrass.SetTexture(kGrassPerlinIdx, CSmapTex, lbTerrainGrass.map);
                                    shaderGrass.SetInt(CSmapTexWidth, lbTerrainGrass.map.width);
                                    shaderGrass.SetInt(CSmapTexHeight, lbTerrainGrass.map.height);
                                }
                                else
                                {
                                    shaderGrass.SetTexture(kGrassPerlinIdx, CSmapTex, dummyTex);
                                    shaderGrass.SetInt(CSmapTexWidth, 1);
                                    shaderGrass.SetInt(CSmapTexHeight, 1);
                                }
                                shaderGrass.SetBool(CSmapInverse, lbTerrainGrass.mapInverse);
                                shaderGrass.SetBool(CSisAreaFilters, isAreaFiltersToApply);
                                shaderGrass.SetBool(CSisStencilLayerFilters, isStencilLayerFiltersToApply);
                                shaderGrass.SetBool(CSisTextureFilters, isTextureFiltersToApply);
                                #endregion

                                #region Execute the compute shader
                                if (cbufDetailMap != null)
                                {
                                    int threadGroupX = Mathf.CeilToInt(detailWidthInt * detailHeightInt / cskGrassPerlinNumThreads);
                                    shaderGrass.Dispatch(kGrassPerlinIdx, threadGroupX, 1, 1);

                                    // Retrieve the DetailMap from shader
                                    cbufDetailMap.GetData(detailMap1D);

                                    // TODO convert to faster System.Buffer.BlockCopy()
                                    // Copy shader 1D data to 2D detail density array
                                    for (int y = 0; y < detailHeightInt; y++)
                                    {
                                        for (int x = 0; x < detailWidthInt; x++)
                                        {
                                            detailDensityMap2D[x, y] = detailMap1D[(detailHeightInt * y) + x];
                                        }
                                    }
                                }

                                #endregion
                            }
                            catch (System.Exception ex)
                            {
                                Debug.LogWarning("ERROR " + methodName + " - could not populate landscape with Grass using GPU - " + ex.Message);
                            }
                            finally
                            {
                                #region Release Resources
                                if (cbufDetailMap != null) { cbufDetailMap.Release(); cbufDetailMap = null; }
                                if (cbufLBFilters != null) { cbufLBFilters.Release(); cbufLBFilters = null; }

                                int numStencilLayerArrays = (stencilLayerTex2DArrayList == null ? 0 : stencilLayerTex2DArrayList.Count);

                                for (int slArrayIdx = numStencilLayerArrays - 1; slArrayIdx >= 0; slArrayIdx--)
                                {
                                    Texture2DArray texture2DArray = stencilLayerTex2DArrayList[slArrayIdx];
                                    if (texture2DArray != null) { LBTextureOperations.DestroyTexture2DArray(ref texture2DArray); }
                                    // Check if was correctly disposed
                                    if (stencilLayerTex2DArrayList[slArrayIdx] != null) { Debug.LogWarning("ERROR: " + methodName + " - stencillayer tex2Darray" + slArrayIdx + "  not released correctly"); }
                                }
                                if (stencilLayerTex2DArrayList != null) { stencilLayerTex2DArrayList.Clear(); }

                                if (stencilLayerGUIDList != null) { stencilLayerGUIDList.Clear(); }
                                if (stencilLayerArrayGUIDList != null) { stencilLayerArrayGUIDList.Clear(); }
                                #endregion
                            }
                        }

#endif

                        #endregion

                        //Debug.Log("[DEBUG] Grass " + (i + 1) + " I: " + minI + "," + maxI + " h: " + minH + "," + maxH);

                        #region Grass Non-Compute
                        if (!isGrassComputeEnabled)
                        {
                            #region Non-Compute variables
                            float heightN;
                            #endregion

                            #region Curvature Variables
                            // 4 surrounding height points
                            float h1XN, h1ZN, h2XN, h2ZN, h3XN, h3ZN, h4XN, h4ZN;
                            float h1 = 0f, h2 = 0f, h3 = 0f, h4 = 0f;
                            Vector2 hOffsetPos = Vector2.zero;
                            #endregion

                            for (int y = 0; y < detailHeightInt; y++)
                            {
                                for (int x = 0; x < detailWidthInt; x++)
                                {
                                    #region Get position of this grass/detail point
                                    // Get "terrain position" of grass detail point - values between 0 and 1
                                    xPos = (float)x / (detailWidth - 1f);
                                    yPos = (float)y / (detailHeight - 1f);

                                    // Find the world-space coordinates of this grass patch
                                    // NOTE: the reversed xPos, yPos. This is because the values in Get/SetDetailLayer are y,x (not x,y)
                                    // Used for Area and Stencil filters
                                    worldPoint.x = (yPos * terrainWidth) + worldPosition.x;
                                    worldPoint.y = (xPos * terrainWidth) + worldPosition.z;
                                    #endregion

                                    // Interpolate between grass based on height
                                    height = tData.GetInterpolatedHeight(yPos, xPos);
                                    // Get the angle or steepness of this point on terrain
                                    angle = tData.GetSteepness(yPos, xPos);

                                    heightN = height / terrainHeight;

                                    #region Height Rule
                                    if (grassPlacingMode == LBTerrainGrass.GrassPlacingMode.Height)
                                    {
                                        detailFactor = grassPopulationCurve.Evaluate(Mathf.InverseLerp(minH, maxH, heightN));
                                    }
                                    #endregion

                                    #region Inclination Rule
                                    else if (grassPlacingMode == LBTerrainGrass.GrassPlacingMode.Inclination)
                                    {
                                        detailFactor = grassPopulationCurve.Evaluate(Mathf.InverseLerp(minI, maxI, angle));
                                    }
                                    #endregion

                                    #region Height Inclination Rules
                                    else if (grassPlacingMode == LBTerrainGrass.GrassPlacingMode.HeightAndInclination)
                                    {
                                        detailFactor = grassPopulationCurve.Evaluate(Mathf.InverseLerp(minH, maxH, heightN))
                                               * grassPopulationCurve.Evaluate(Mathf.InverseLerp(minI, maxI, angle));
                                    }
                                    #endregion

                                    #region Height Inclination Curvature Rules
                                    else if (grassPlacingMode == LBTerrainGrass.GrassPlacingMode.HeightInclinationCurvature)
                                    {
                                        detailFactor = grassPopulationCurve.Evaluate(Mathf.InverseLerp(minH, maxH, heightN))
                                               * grassPopulationCurve.Evaluate(Mathf.InverseLerp(minI, maxI, angle));

                                        if (detailFactor > 0f)
                                        {
                                            // Get 4 surrounding points x and y are reversed for detailmap
                                            h1XN = yPos;
                                            h1ZN = xPos - curvatureDistanceZN;
                                            h2XN = yPos;
                                            h2ZN = xPos + curvatureDistanceZN;
                                            h3XN = yPos - curvatureDistanceXN;
                                            h3ZN = xPos;
                                            h4XN = yPos + curvatureDistanceXN;
                                            h4ZN = xPos;

                                            if (h1ZN >= 0f) { h1 = tData.GetInterpolatedHeight(h1XN, h1ZN) / terrainHeight; }
                                            else if (useLandscapeHeights)
                                            {
                                                hOffsetPos.x = worldPoint.x;
                                                hOffsetPos.y = worldPoint.y - (curvatureDistanceZN * terrainLength);
                                                GetLandscapeInterpolatedData(terrainDataArray, terrainRectsArray, hOffsetPos, ref h1);
                                                h1 /= terrainHeight;
                                            }
                                            else { h1 = heightN; }

                                            if (h2ZN <= 1f) { h2 = tData.GetInterpolatedHeight(h2XN, h2ZN) / terrainHeight; }
                                            else if (useLandscapeHeights)
                                            {
                                                hOffsetPos.x = worldPoint.x;
                                                hOffsetPos.y = worldPoint.y + (curvatureDistanceZN * terrainLength);
                                                GetLandscapeInterpolatedData(terrainDataArray, terrainRectsArray, hOffsetPos, ref h2);
                                                h2 /= terrainHeight;
                                            }
                                            else { h2 = heightN; }

                                            if (h3XN >= 0f) { h3 = tData.GetInterpolatedHeight(h3XN, h3ZN) / terrainHeight; }
                                            else if (useLandscapeHeights)
                                            {
                                                hOffsetPos.x = worldPoint.x - (curvatureDistanceXN * terrainWidth);
                                                hOffsetPos.y = worldPoint.y;
                                                GetLandscapeInterpolatedData(terrainDataArray, terrainRectsArray, hOffsetPos, ref h3);
                                                h3 /= terrainHeight;
                                            }
                                            else { h3 = heightN; }

                                            if (h4XN <= 1f) { h4 = tData.GetInterpolatedHeight(h4XN, h4ZN) / terrainHeight; }
                                            else if (useLandscapeHeights)
                                            {
                                                hOffsetPos.x = worldPoint.x + (curvatureDistanceXN * terrainWidth);
                                                hOffsetPos.y = worldPoint.y;
                                                GetLandscapeInterpolatedData(terrainDataArray, terrainRectsArray, hOffsetPos, ref h4);
                                                h4 /= terrainHeight;
                                            }
                                            else { h4 = heightN; }

                                            if (isCurvatureConcave == 1)
                                            {
                                                // If Avg is NOT above the current point by height difference, then it is NOT concave
                                                if (((h1 + h2 + h3 + h4) / 4f) < heightN + curvatureMinHeightDiffN) { detailFactor = 0f; }
                                            }
                                            else
                                            {
                                                // If Avg is NOT below the current point by height difference, then it is NOT convex
                                                if (((h1 + h2 + h3 + h4) / 4f) > heightN + curvatureMinHeightDiffN) { detailFactor = 0f; }
                                            }
                                        }
                                    }
                                    #endregion

                                    #region Constant Influence Rule
                                    else if (grassPlacingMode == LBTerrainGrass.GrassPlacingMode.ConstantInfluence)
                                    {
                                        detailFactor = 1f;
                                    }
                                    #endregion

                                    #region PlacementMode - Map or HeightInclinationMap
                                    else if (grassPlacingMode == LBTerrainGrass.GrassPlacingMode.Map ||
                                             grassPlacingMode == LBTerrainGrass.GrassPlacingMode.HeightInclinationMap)
                                    {
                                        // If position in detailMap matches position in map image, detailFactor = 0->1, else = 0
                                        if (lbMapList.Count > i) { lbMap = lbMapList[i]; }
                                        else { lbMap = null; }

                                        if (lbMap != null)
                                        {
                                            mapPoint = lbMap.GetMapPositionFromTerrainPosition(xPos, yPos, startX, endX, startY, endY);

                                            // Check if this map comes from a LB Map Path
                                            if (lbTerrainGrass.mapIsPath)
                                            {
                                                // Compare the normalised terrain coordinates to the point on the Map texture (PNG image) 
                                                pixelVariationNormalised = lbMap.GetPixelColourVariationNormalised(mapPoint.x, mapPoint.y, Color.clear);

                                                if (pixelVariationNormalised == 1f) { if (lbMap.inverse) { detailFactor = 1f; } else { detailFactor = 0f; } }
                                                else if (pixelVariationNormalised > 0.001f)
                                                {
                                                    if (lbMap.inverse)
                                                    {
                                                        detailFactor = lbMap.toleranceBlendCurve.Evaluate(pixelVariationNormalised);
                                                    }
                                                    else
                                                    {
                                                        detailFactor = lbMap.toleranceBlendCurve.Evaluate(1f - pixelVariationNormalised);
                                                    }
                                                }
                                                // If exact pixel in map is white (exact match) detailFactor is 1. If inverse = 0.
                                                else { if (lbMap.inverse) { detailFactor = 0f; } else { detailFactor = 1f; } }
                                            }
                                            else
                                            {
                                                // Check if the pixel in the map is the same as the mapColour within the Tolerance factor
                                                // Return the opposite if mapInverse is enabled.
                                                if (lbMap.IsMapPixelMatchToMapColour(mapPoint.x, mapPoint.y, false, true))
                                                {
                                                    detailFactor = 1f;
                                                }
                                                else { detailFactor = 0f; }
                                            }
                                        }
                                        // If we couldn't create a LBMap instance, set detailFactor to 0
                                        else { detailFactor = 0f; }

                                        if (grassPlacingMode == LBTerrainGrass.GrassPlacingMode.HeightInclinationMap)
                                        {
                                            // Multiply the map result (detailFactor), by the Height and Inclination result
                                            detailFactor *= grassPopulationCurve.Evaluate(Mathf.InverseLerp(minH, maxH, heightN))
                                               * grassPopulationCurve.Evaluate(Mathf.InverseLerp(minI, maxI, angle));
                                        }
                                    }
                                    #endregion

                                    #region PlacementMode - Imported
                                    else if (grassPlacingMode == LBTerrainGrass.GrassPlacingMode.Imported && isTerrainGrassDataValid)
                                    {
                                        detailFactor = lbTerrainData.grassDetailDensityData[y * detailWidthInt + x];
                                    }
                                    #endregion

                                    else { detailFactor = 0f; }

                                    #region Noise
                                    if (grassUseNoise)
                                    {
                                        // Get a perlin noise value for this point in the landscape
                                        coords.x = worldPosition.x + (terrainWidth * xPos);
                                        coords.y = worldPosition.z + (terrainWidth * yPos);
                                        // A multiplier (grassNoiseMultiplier) is used so that the maximum value of the noise is the
                                        // same for any number of octaves
                                        //grassNoiseMultiplier = 0.025f;
                                        noiseValue = Mathf.Abs((LBNoise.PerlinFractalNoise(coords.x / grassNoiseTileSize,
                                         coords.y / grassNoiseTileSize, grassNoiseOctaves) * grassNoiseMultiplier) - 0.5f) * 4f;
                                        // If the noise value is less than (1 - grass cutoff value) set the grass density to 0
                                        if (noiseValue < 1f - grassPlacementCutoff) { detailFactor = 0f; }
                                    }
                                    #endregion

                                    #region DontFade
                                    if (grassPatchFadingMode == LBTerrainGrass.GrassPatchFadingMode.DontFade)
                                    {
                                        // Restrict grass density to "on" or "off"
                                        if (detailFactor > 0.01f) { detailFactor = 1f; }
                                        else { detailFactor = 0f; }
                                    }
                                    #endregion

                                    #region Check area filters before texture filters
                                    if (detailFactor > 0.01f && isAreaFiltersToApply)
                                    {
                                        if (lbTerrainGrass.filterList != null)
                                        {
                                            if (lbTerrainGrass.filterList.Count > 0) { includePoint = false; }
                                            else { includePoint = true; }

                                            foreach (LBFilter lbFilter in lbTerrainGrass.filterList)
                                            {
                                                if (lbFilter != null)
                                                {
                                                    // Only deal with Area filters here. Any texture filters will be handled
                                                    // after all Area filters have been assessed.
                                                    if (lbFilter.filterType == LBFilter.FilterType.Area)
                                                    {
                                                        // Convert the filter AreaRect into worldspace to adjust for offset landscapes
                                                        Rect areaRectWorldSpace = lbFilter.GetWorldSpaceAreaRect(landscapePosition);

                                                        // Compare it to the area filter
                                                        // NOTE: We're not using Rect.Contains(Vector2) because the top and right boundaries are ignored
                                                        if (worldPoint.x >= areaRectWorldSpace.xMin && worldPoint.x <= areaRectWorldSpace.xMax &&
                                                            worldPoint.y >= areaRectWorldSpace.yMin && worldPoint.y <= areaRectWorldSpace.yMax)
                                                        {
                                                            includePointCurrentFilter = true;
                                                        }
                                                        else
                                                        {
                                                            includePointCurrentFilter = false;
                                                        }

                                                        if (lbFilter.filterMode == LBFilter.FilterMode.AND)
                                                        {
                                                            if (includePointCurrentFilter)
                                                            {
                                                                if (lbFilter == lbTerrainGrass.filterList[0]) { includePoint = true; }
                                                                else
                                                                {
                                                                    // If the point has been included with a previous filter it will still be included
                                                                    // and we don't need to do anything here.

                                                                    // Because this an AND, if it hasn't already been included by another filter, it
                                                                    // will never be included and we .
                                                                    if (!includePoint) { break; }
                                                                }
                                                            }
                                                            // With the AND operator, if this point is not in the area we should not texture it
                                                            else { includePoint = false; break; }
                                                        }

                                                        // If using Filter1 OR Filter 2 OR..
                                                        else if (includePointCurrentFilter && lbFilter.filterMode == LBFilter.FilterMode.OR)
                                                        {
                                                            includePoint = true;
                                                        }

                                                        else if (lbFilter.filterMode == LBFilter.FilterMode.NOT)
                                                        {
                                                            // If this is in a NOT area, we should never include this tree
                                                            if (includePointCurrentFilter) { includePoint = false; break; }
                                                            // If not in the current area, then we should still continue to consider it
                                                            else { includePoint = true; }
                                                        }
                                                    }
                                                }
                                            }
                                            // Has this grass patch been filtered out?
                                            if (!includePoint) { detailFactor = 0f; }
                                        }
                                    }
                                    #endregion

                                    #region Check the StencilLayer filters
                                    if (detailFactor > 0.01f && isStencilLayerFiltersToApply)
                                    {
                                        if (lbTerrainGrass.filterList.Count > 0) { includePoint = false; }
                                        else { includePoint = true; }

                                        foreach (LBFilter lbFilter in lbTerrainGrass.filterList)
                                        {
                                            // The layerArray should have been pre-populated for StencilLayer filters
                                            // Check for lbFilter.lbStencilLayer != null in case user deleted the Stencil Layer in the scene
                                            if (lbFilter.filterType == LBFilter.FilterType.StencilLayer && lbFilter.lbStencilLayer != null && lbFilter.lbStencilLayer.layerArray != null)
                                            {
                                                // Get the value of the Stencil layer at this point in the terrain
                                                stencilLayerResolution = (int)lbFilter.lbStencilLayer.layerResolution;
                                                // Get the normalised position in the landscape
                                                stencilLayerPosN = landscape.NormalisePointFromWorldPos2DFast(worldPoint);
                                                // Get the point within the stencil layer USHORT array
                                                arrayPoint.x = Mathf.RoundToInt(stencilLayerPosN.x * (stencilLayerResolution - 1f));
                                                arrayPoint.y = Mathf.RoundToInt((1f - stencilLayerPosN.y) * (stencilLayerResolution - 1f));

                                                // Ensure it it's outside the range of the USHORT array
                                                arrayPoint.x = Mathf.Clamp(arrayPoint.x, 0, stencilLayerResolution - 1);
                                                arrayPoint.y = Mathf.Clamp(arrayPoint.y, 0, stencilLayerResolution - 1);

                                                /// TODO - might be able to improve grass stencil layer blend using a curve
                                                stencilLayerPixel = lbFilter.lbStencilLayer.layerArray[arrayPoint.x, arrayPoint.y];

                                                if (lbFilter.filterMode == LBFilter.FilterMode.AND)
                                                {
                                                    includePoint = (stencilLayerPixel > 0);

                                                    // Randomise the chance of placement based on grass stencil layer pixel value
                                                    if (!includePoint) { detailFactor = 0f; break; }
                                                    else
                                                    {
                                                        // Lerp between 0 and detailFactor
                                                        detailFactor = Mathf.LerpUnclamped(0f, detailFactor, stencilLayerPixel / 65535f);
                                                    }
                                                }
                                                else if (lbFilter.filterMode == LBFilter.FilterMode.NOT)
                                                {
                                                    includePoint = (stencilLayerPixel < 65535);

                                                    // Randomise the chance of placement based on texture stencil layer pixel value
                                                    if (!includePoint) { detailFactor = 0f; break; }
                                                    else
                                                    {
                                                        // Lerp between detailFactor and 0 (reverse of the AND blending)
                                                        detailFactor = Mathf.LerpUnclamped(detailFactor, 0f, stencilLayerPixel / 65535f);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    #endregion

                                    #region Check Texture filters - this could be relatively slow, so do it last
                                    if (detailFactor > 0.01f && isTextureFiltersToApply)
                                    {
                                        if (lbTerrainGrass.filterList != null)
                                        {
                                            foreach (LBFilter lbFilter in lbTerrainGrass.filterList)
                                            {
                                                if (lbFilter != null)
                                                {
                                                    if (lbFilter.filterType == LBFilter.FilterType.Texture && lbFilter.terrainTexture != null)
                                                    {
                                                        if (lbFilter.terrainTexture.texture != null)
                                                        {
                                                            // Does this texture exist in the current alphamaps (splatprototypes)?
                                                            // We can't simply find the matching LBTerrainTexture with FindIndex(ftx => ftx == lbFilter.terrainTexture)
                                                            // because a splatprototype only contains texture, normalmap, metallic, smoothness and tileSize fields
                                                            textureIndex = alphamapTerrainTexturesList.FindIndex(ftx => ftx.texture == lbFilter.terrainTexture.texture &&
                                                                                                                        ftx.normalMap == lbFilter.terrainTexture.normalMap &&
                                                                                                                        ftx.metallic == lbFilter.terrainTexture.metallic &&
                                                                                                                        ftx.smoothness == lbFilter.terrainTexture.smoothness &&
                                                                                                                        ftx.tileSize == lbFilter.terrainTexture.tileSize);



                                                            if (textureIndex >= 0)
                                                            {
                                                                // Get the potential position of this grass in the alphamaps
                                                                // xPos/yPos is the normalised x,y potential position of the grass on the terrain
                                                                alphamapX = Mathf.Clamp(Mathf.RoundToInt(xPos * (float)tData.alphamapWidth), 0, tData.alphamapWidth - 1);
                                                                alphamapZ = Mathf.Clamp(Mathf.RoundToInt(yPos * (float)tData.alphamapHeight), 0, tData.alphamapHeight - 1);

                                                                // What is the blend value in the alphamap for this texture
                                                                alphaBlendWeight = alphamap[alphamapX, alphamapZ, textureIndex];

                                                                // For FilterMode.OR we would need to remember this result and determine grass placement after
                                                                // processing all filters. Currently, only AND is supported.
                                                                // Don't place grass where the blendweight is below 0.5
                                                                if (alphaBlendWeight < 0.5f && lbFilter.filterMode == LBFilter.FilterMode.AND)
                                                                {
                                                                    detailFactor = 0f;
                                                                    break;
                                                                }
                                                                else if (alphaBlendWeight > 0.1f && lbFilter.filterMode == LBFilter.FilterMode.NOT)
                                                                {
                                                                    detailFactor = 0f;
                                                                    break;
                                                                }
                                                            }
                                                            else
                                                            {
                                                                // No match found in current splatprototypes
                                                                // For FilterMode.OR we would need to remember this result and determine grass placement after
                                                                // processing all filters. Currently, only AND is supported.
                                                                if (lbFilter.filterMode == LBFilter.FilterMode.AND)
                                                                {
                                                                    detailFactor = 0f;
                                                                    break;
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    } // end check Texture filters
                                    #endregion

                                    detailDensityMap2D[x, y] = Mathf.RoundToInt(lbRandom.Range(minDetailDensity, maxDetailDensity) * detailFactor);

                                    // pre-2.0.6 code
                                    //detailDensityMap2D[x, y] = Mathf.RoundToInt(UnityEngine.Random.Range(minDetailDensity, maxDetailDensity + 1) * detailFactor);
                                }
                            }
                        }
                        #endregion

                        tData.SetDetailLayer(0, 0, i, detailDensityMap2D);
                    }

                    #region Cleanup Grass Compute resources
#if LB_COMPUTE
                    // Free up Compute resources
                    if (cbufHeightsIn != null) { cbufHeightsIn.Release(); cbufHeightsIn = null; }
                    if (cbufHeightLandscape != null) { cbufHeightLandscape.Release(); cbufHeightLandscape = null; }
                    if (cbufLBFilters != null) { cbufLBFilters.Release(); cbufLBFilters = null; }
                    if (terrainNormalsTex != null) { LBTextureOperations.DestroyTexture2D(ref terrainNormalsTex); }
                    if (dummyTex != null) { LBTextureOperations.DestroyTexture2D(ref dummyTex); }
#endif
                    #endregion
                }
            }

            if (showTiming)
            {
                Debug.Log("Time taken for terrain grass population: " + (Time.realtimeSinceStartup - tStart).ToString("0.000") + " seconds");
            }

            return tData;
        }

        #endregion

        #region Static Mesh and Prefab Methods

        /// <summary>
        /// Returns the TerrainData after populating it with meshes
        /// If terrainName is empty, isTerrainFlattened is ignored for a mesh or prefab
        /// Call LBStencil.FreeStencilResources(landscape, true) after calling this method if
        /// a LBFilterType.StencilLayer was used.
        /// </summary>
        /// <param name="landscape"></param>
        /// <param name="tData"></param>
        /// <param name="terrainTransform"></param>
        /// <param name="landscapeTransform"></param>
        /// <param name="landscapeMeshList"></param>
        /// <param name="worldPosition"></param>
        /// <param name="landscapeSize"></param>
        /// <param name="landscapePosition"></param>
        /// <param name="showTiming"></param>
        /// <param name="terrainName"></param>
        /// <param name="meshPlacementSpeed"></param>
        /// <returns></returns>
        public static TerrainData PopulateTerrainWithMeshes(LBLandscape landscape, TerrainData tData, Transform terrainTransform, Transform landscapeTransform, List<LBLandscapeMesh> landscapeMeshList,
                                                            Vector3 worldPosition, Vector2 landscapeSize, Vector3 landscapePosition, bool showTiming, string terrainName = "", LBLandscapeMesh.MeshPlacementSpeed meshPlacementSpeed = LBLandscapeMesh.MeshPlacementSpeed.FastPlacement)
        {
            float tStart = Time.realtimeSinceStartup;
            if (tData != null && landscape != null)
            {
                UnityEngine.Random.InitState(0);

                // Randomly set the noiseoffset based on the tilesize
                // NOTE: This means it will not line up with the texture or grass noise, nor will it align across terrain boundaries
                // To align across terrain boundaries it would need to be set once per landscape before calling PopulateTerrainWithMeshes()
                for (int m = 0; m < landscapeMeshList.Count; m++)
                {
                    landscapeMeshList[m].noiseOffset = UnityEngine.Random.Range(0f, landscapeMeshList[m].noiseTileSize);
                }

                float terrainWidth = tData.size.x;
                float terrainLength = tData.size.z;
                float terrainHeight = tData.size.y;

                // Used for LBFilter
                Vector2 worldPoint = Vector2.zero;
                bool includePoint = true;
                bool includePointCurrentFilter = false;

                // Texture Map variables
                LBMapPoint mapPoint;
                LBMap lbMap;
                float pixelVariationNormalised = 0f;

                // Get the normalised (0-1) bounds of this terrain within the landscape
                float startX = ((worldPosition.x - landscapePosition.x) / landscapeSize.x);
                float endX = startX + (tData.size.x / landscapeSize.x);
                float startY = ((worldPosition.z - landscapePosition.z) / landscapeSize.y);
                float endY = startY + (tData.size.z / landscapeSize.y);

                // Alphamap variables for use with LBFilter.FilterType.Texture
                float[,,] alphamap = new float[1, 1, 1];
                List<LBTerrainTexture> alphamapTerrainTexturesList = null;
                int textureIndex = 0;
                float alphaBlendWeight = 0f;
                int alphamapX = 0, alphamapZ = 0;

                // Populate terrain with meshes
                if (landscapeMeshList != null)
                {
                    // Set up a mesh controller object for this terrain
                    GameObject terrainMeshControllerObj = new GameObject("Terrain Mesh Controller");
                    terrainMeshControllerObj.transform.parent = terrainTransform.parent;
                    LBTerrainMeshController terrainMeshController = terrainMeshControllerObj.AddComponent<LBTerrainMeshController>();
                    terrainMeshController.Initialise();

                    // Only create this list the first time it is used (the list is cleared after each terrain is processed)
                    // Stores Mesh Positions, Proximity and pre-computed Proximity Squared values
                    if (lbTerrainMeshInstanceList == null) { lbTerrainMeshInstanceList = new List<LBTerrainMeshInstance>(); }

                    GameObject prefabMeshGameObject = null;

                    // Get a reference to all the trees on the terrain
                    List<TreeInstance> treeInstancesList = new List<TreeInstance>();
                    treeInstancesList.AddRange(tData.treeInstances);

                    // Get a list of all the detail density maps (grass) on the terrain
                    List<int[,]> detailDensityMapList = new List<int[,]>();
                    int numberOfDetailLayers = tData.detailPrototypes.Length;
                    int detailWidth = tData.detailWidth;
                    int detailHeight = tData.detailHeight;
                    for (int d = 0; d < numberOfDetailLayers; d++)
                    {
                        detailDensityMapList.Add(tData.GetDetailLayer(0, 0, detailWidth, detailHeight, d));
                    }

                    // Are their any Texture LBFilter's applied?
                    bool isTextureFiltersToApply = false;
                    foreach (LBLandscapeMesh lblm in landscapeMeshList)
                    {
                        if (lblm != null)
                        {
                            if (!lblm.isDisabled)
                            {
                                isTextureFiltersToApply = LBFilter.Contains(lblm.filterList, LBFilter.FilterType.Texture);
                                if (isTextureFiltersToApply) { break; }
                            }
                        }
                    }

                    // There are texture filters so pre-load the alphamaps for this terrain
                    // NOTE: This could consume a fair amount of RAM on large terrains with many alphamaps
                    if (isTextureFiltersToApply)
                    {
#if UNITY_2018_3_OR_NEWER
                        alphamapTerrainTexturesList = LBTerrainTexture.ToLBTerrainTextureList(tData.terrainLayers);
#else
                        alphamapTerrainTexturesList = LBTerrainTexture.ToLBTerrainTextureList(tData.splatPrototypes);
#endif
                        alphamap = tData.GetAlphamaps(0, 0, tData.alphamapWidth, tData.alphamapHeight);
                    }

                    // Are their any Area LBFilters applied?
                    bool isAreaFiltersToApply = false;
                    foreach (LBLandscapeMesh lblm in landscapeMeshList)
                    {
                        if (lblm != null)
                        {
                            if (!lblm.isDisabled)
                            {
                                isAreaFiltersToApply = LBFilter.Contains(lblm.filterList, LBFilter.FilterType.Area);
                                if (isAreaFiltersToApply) { break; }
                            }
                        }
                    }

                    float[] minProximitySquaredArrayN = new float[landscapeMeshList.Count];
                    float[] minTreeProximitySquaredArrayN = new float[landscapeMeshList.Count];
                    float[] minTreeProximitySquaredArray = new float[landscapeMeshList.Count];
                    float thisMeshProximitySquaredN = 0f, thisMeshTreeProximitySquaredN = 0f;  // Normalised square values
                    float thisMeshTreeProximitySquared = 0f;    // Non-normalised square value in metres
                    float treeMeshDiffX = 0f, treeMeshDiffZ = 0f;
                    Vector3 treeInstancePosition = Vector3.zero;

                    // Rotation variables
                    Vector3 terrainNormal, rotatedForwardsDir, unitVector;
                    Vector2 randUnitVector;

                    List<LBMap> lbMapList = new List<LBMap>();
                    // 1. Pre-create a list of maps - some maps may not be applicable but this could improve performance
                    //    There will be no need to create a map for each point for those Textures that use a map
                    // 2. Pre-populate a lookup array of mesh minProximity normalized Squared values
                    for (int m = 0; m < landscapeMeshList.Count; m++)
                    {
                        LBLandscapeMesh lblm = landscapeMeshList[m];
                        if (lblm != null)
                        {
                            // Pre-create map
                            lbMap = new LBMap(lblm.map, lblm.mapColour, lblm.mapTolerance);
                            lbMap.inverse = lblm.mapInverse;
                            lbMap.toleranceBlendCurve = lblm.mapToleranceBlendCurve;
                            lbMapList.Add(lbMap);

                            // Pre-populate a lookup array with the mesh minProximity normalized Squared
                            float thisMeshProximityN = (lblm.minProximity / terrainWidth);
                            float thisTreeProximityN = (lblm.minTreeProximity / terrainWidth);
                            minProximitySquaredArrayN[m] = thisMeshProximityN * thisMeshProximityN;
                            minTreeProximitySquaredArrayN[m] = thisTreeProximityN * thisTreeProximityN;

                            // Non-normalised square distances used for clusters
                            minTreeProximitySquaredArray[m] = lblm.minTreeProximity * lblm.minTreeProximity;
                        }
                    }
                    lbMap = null;

                    float preSqmFactor = terrainWidth * terrainLength / 1000000f;

                    // If some meshes/prefabs will flatten the terrain, we need a reference to all terrains in the
                    // landscape, because some of the heightmap may be in an adjacent terrain.
                    Terrain[] landscapeTerrains = landscape.gameObject.GetComponentsInChildren<Terrain>();
                    int terrainIndex = 0;

                    // Use when isClustered = true
                    LBCluster lbCluster = null;
                    bool isClusterValidated = false;
                    Vector3 clusterObjPosition = Vector3.zero;

                    // Used with Prefabs
                    LBPrefabItem lbPrefabItem = null;
                    List<Component> componentList = new List<Component>();

                    // Stencil LBLayerFilter variables
                    Vector2 stencilLayerPosN = new Vector2();
                    LBMapPoint arrayPoint = new LBMapPoint(0, 0);
                    int stencilLayerResolution = 0;
                    int stencilLayerPixel = 0;
                    int hashValue = 0;
                    LB_Extension.XXHash xxHash = new LB_Extension.XXHash(37761);

                    for (int m = 0; m < landscapeMeshList.Count; m++)
                    {
                        combineMeshes = new List<CombineInstance>();
                        lbCluster = new LBCluster();
                        isClusterValidated = false;

                        if (landscapeMeshList[m].isDisabled) { continue; }
                        else if (landscapeMeshList[m].usePrefab)
                        {
                            if (landscapeMeshList[m].prefab == null) { continue; }
                            else
                            {
                                // Create a new GameObject for the prefabs
                                prefabMeshGameObject = new GameObject(terrainTransform.name + " (" + landscapeMeshList[m].prefab.name + ")");

                                if (prefabMeshGameObject != null)
                                {
                                    prefabMeshGameObject.transform.parent = landscape.gameObject.transform;
                                    lbPrefabItem = prefabMeshGameObject.AddComponent<LBPrefabItem>();
                                    if (lbPrefabItem != null) { lbPrefabItem.prefabItemType = LBPrefabItem.PrefabItemType.LegacyMeshPrefab; }
                                }
                            }
                        }

                        // Are their any Proximity LBFilters applied for this mesh/prefab?
                        bool isProximityFiltersToApply = LBFilter.Contains(landscapeMeshList[m].filterList, LBFilter.FilterType.Proximity);
                        if (isProximityFiltersToApply)
                        {
                            // Preload the gameobject positions
                            if (landscapeMeshList[m].filterList != null)
                            {
                                foreach (LBFilter lbFilter in landscapeMeshList[m].filterList)
                                {
                                    if (lbFilter != null)
                                    {
                                        // Currently all proximity filters are AND
                                        if (lbFilter.filterType == LBFilter.FilterType.Proximity)
                                        {
                                            lbFilter.objectPositionProximityCacheList = landscape.GetGameObjectPositions(lbFilter.layerMask, lbFilter.filterByTag);
                                            lbFilter.minProximitySquared = lbFilter.minProximity * lbFilter.minProximity;
                                        }
                                    }
                                }
                            }
                        }

                        // Are there any Stencil Layer filters for this mesh/prefab
                        bool isStencilLayerFiltersToApply = LBFilter.Contains(landscapeMeshList[m].filterList, LBFilter.FilterType.StencilLayer);
                        if (isStencilLayerFiltersToApply)
                        {
                            // Preload the stencil data
                            if (landscapeMeshList[m].filterList != null)
                            {
                                foreach (LBFilter lbFilter in landscapeMeshList[m].filterList)
                                {
                                    if (lbFilter != null)
                                    {
                                        // Currently all stencil filters are AND
                                        // Is this a valid Stencil Filter?
                                        if (lbFilter.filterType == LBFilter.FilterType.StencilLayer && !string.IsNullOrEmpty(lbFilter.lbStencilGUID) && !string.IsNullOrEmpty(lbFilter.lbStencilLayerGUID))
                                        {
                                            // If the temporary class instance isn't defined, look it up and validate it is in the current landscape
                                            if (lbFilter.lbStencil == null)
                                            {
                                                lbFilter.lbStencil = LBStencil.GetStencilInLandscape(landscape, lbFilter.lbStencilGUID, true);
                                            }

                                            if (lbFilter.lbStencil != null)
                                            {
                                                // Find the Stencil Layer for this Layer Filter and populate the temporary class instance
                                                lbFilter.lbStencilLayer = lbFilter.lbStencil.GetStencilLayerByGUID(lbFilter.lbStencilLayerGUID);

                                                // Load the USHORT data
                                                if (lbFilter.lbStencilLayer != null)
                                                {
                                                    if (lbFilter.lbStencilLayer.layerArray == null)
                                                    {
                                                        lbFilter.lbStencilLayer.AllocLayerArray();
                                                        lbFilter.lbStencilLayer.UnCompressToUShort();
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }

                        bool isTerrainFlatten = (landscapeMeshList[m].isTerrainFlattened && landscapeTerrains != null && !string.IsNullOrEmpty(terrainName));

                        int targetNumberOfMeshes = Mathf.RoundToInt(preSqmFactor * landscapeMeshList[m].maxMeshes);
                        int numberOfMeshesCreated = 0;
                        int maxMeshIterations = targetNumberOfMeshes;
                        if (meshPlacementSpeed == LBLandscapeMesh.MeshPlacementSpeed.FastPlacement) { maxMeshIterations *= 8; }
                        else if (meshPlacementSpeed == LBLandscapeMesh.MeshPlacementSpeed.BestPlacement) { maxMeshIterations *= 256; }

                        for (int i = 0; i < maxMeshIterations && numberOfMeshesCreated < targetNumberOfMeshes; i++)
                        {
                            // Nominate a random x,z coordinate on the terrain
                            Vector3 offset = new Vector3(UnityEngine.Random.value, 0f, UnityEngine.Random.value);
                            // Find that coordinate's height and steepness
                            offset.y = tData.GetInterpolatedHeight(offset.x, offset.z) / terrainHeight;
                            angle = tData.GetSteepness(offset.x, offset.z);
                            createMesh = false;
                            if (landscapeMeshList[m].meshPlacingMode == LBLandscapeMesh.MeshPlacingMode.Height)
                            {
                                // If the height is between the mesh's min and max height, create the mesh
                                createMesh = offset.y >= landscapeMeshList[m].minHeight
                                                && offset.y <= landscapeMeshList[m].maxHeight;
                            }
                            else if (landscapeMeshList[m].meshPlacingMode == LBLandscapeMesh.MeshPlacingMode.Inclination)
                            {
                                // If the inclination is between the mesh's min and max height, create the mesh
                                createMesh = angle >= landscapeMeshList[m].minInclination
                                                && angle <= landscapeMeshList[m].maxInclination;
                            }
                            else if (landscapeMeshList[m].meshPlacingMode == LBLandscapeMesh.MeshPlacingMode.HeightAndInclination)
                            {
                                // If height is between the mesh's min and max height and the inclination is between the mesh's min and max height,
                                // create the mesh
                                createMesh = offset.y >= landscapeMeshList[m].minHeight
                                                && offset.y <= landscapeMeshList[m].maxHeight
                                                && angle >= landscapeMeshList[m].minInclination
                                                && angle <= landscapeMeshList[m].maxInclination;
                            }
                            else if (landscapeMeshList[m].meshPlacingMode == LBLandscapeMesh.MeshPlacingMode.ConstantInfluence)
                            {
                                // Always create the mesh
                                createMesh = true;
                            }
                            else if (landscapeMeshList[m].meshPlacingMode == LBLandscapeMesh.MeshPlacingMode.Map ||
                                     landscapeMeshList[m].meshPlacingMode == LBLandscapeMesh.MeshPlacingMode.HeightInclinationMap)
                            {
                                if (landscapeMeshList[m].map != null)
                                {
                                    // If height is between the mesh's min and max height and the inclination is between the mesh's min and max height,
                                    // create the mesh
                                    createMesh = (landscapeMeshList[m].meshPlacingMode == LBLandscapeMesh.MeshPlacingMode.Map ||
                                                    (offset.y >= landscapeMeshList[m].minHeight
                                                    && offset.y <= landscapeMeshList[m].maxHeight
                                                    && angle >= landscapeMeshList[m].minInclination
                                                    && angle <= landscapeMeshList[m].maxInclination));

                                    // If the mesh meets the height and inclination criteria, then test the (slower) map criteria
                                    if (createMesh)
                                    {
                                        // Create a LBMap object, so that we can determine if a mesh should be placed in the landscape with the offset generated
                                        if (lbMapList.Count > m) { lbMap = lbMapList[m]; }
                                        else { lbMap = null; }

                                        if (lbMap != null)
                                        {
                                            // Mesh would be placed at offset.x, offset,z on the horizontal plane. Compare this to the colour on the Map texture (PNG image)

                                            // Convert the normalised terrain coordinates into a point on the Map texture
                                            mapPoint = lbMap.GetMapPositionFromTerrainPosition(offset.z, offset.x, startX, endX, startY, endY);

                                            if (landscapeMeshList[m].mapIsPath)
                                            {

                                                // Compare the normalised terrain coordinates to the point on the Map texture (PNG image) 
                                                pixelVariationNormalised = lbMap.GetPixelColourVariationNormalised(mapPoint.x, mapPoint.y, Color.clear);

                                                if (pixelVariationNormalised == 1f) { if (lbMap.inverse) { createMesh = true; } else { createMesh = false; } }
                                                else if (pixelVariationNormalised > 0.001f)
                                                {
                                                    if (lbMap.inverse)
                                                    {
                                                        createMesh = (lbMap.toleranceBlendCurve.Evaluate(pixelVariationNormalised) > 0.5f);
                                                    }
                                                    else
                                                    {
                                                        createMesh = (lbMap.toleranceBlendCurve.Evaluate(1f - pixelVariationNormalised) > 0.5f);
                                                    }
                                                }
                                                // If exact pixel in map is white (exact match) place mesh. If inverse don't place mesh.
                                                else { if (lbMap.inverse) { createMesh = false; } else { createMesh = true; } }
                                            }
                                            else
                                            {
                                                // Check if the pixel in the map is the same as the mapColour within the Tolerance factor
                                                // Return the opposite if mapInverse is enabled.
                                                createMesh = lbMap.IsMapPixelMatchToMapColour(mapPoint.x, mapPoint.y, false, true);
                                            }
                                        }
                                        else { createMesh = false; }
                                    }
                                }
                                // If there is no map texture supplied, then don't create mesh
                                else { createMesh = false; }
                            }

                            // Find the world-space coordinates of this mesh position
                            // This is used for AreaFilters and Use Noise
                            worldPoint.x = (offset.x * terrainWidth) + worldPosition.x;
                            worldPoint.y = (offset.z * terrainLength) + worldPosition.z;

                            if (createMesh && landscapeMeshList[m].useNoise)
                            {
                                // Get a perlin noise value for this point in the landscape
                                float meshNoiseTileSize = landscapeMeshList[m].noiseTileSize;
                                coords.x = worldPoint.x + landscapeMeshList[m].noiseOffset;
                                coords.y = worldPoint.y + landscapeMeshList[m].noiseOffset;
                                float noiseValue = Mathf.Abs(LBNoise.PerlinFractalNoise(coords.x / meshNoiseTileSize, coords.y / meshNoiseTileSize, 5) - 0.5f) * 4f;
                                // If the noise value is less than (1 - mesh cutoff value) don't create the mesh
                                if (noiseValue < 1f - landscapeMeshList[m].meshPlacementCutoff) { createMesh = false; }
                            }

                            // Check area filters before texture filters and before mesh proximity
                            if (createMesh && isAreaFiltersToApply)
                            {
                                if (landscapeMeshList[m].filterList != null)
                                {
                                    if (landscapeMeshList[m].filterList.Count > 0) { includePoint = false; }

                                    foreach (LBFilter lbFilter in landscapeMeshList[m].filterList)
                                    {
                                        if (lbFilter != null)
                                        {
                                            // Only deal with Area filters here. Any texture filters will be handled
                                            // after all Area filters have been assessed.
                                            if (lbFilter.filterType == LBFilter.FilterType.Area)
                                            {
                                                // Convert the filter AreaRect into worldspace to adjust for offset landscapes
                                                Rect areaRectWorldSpace = lbFilter.GetWorldSpaceAreaRect(landscapePosition);

                                                // Compare it to the area filter
                                                // NOTE: We're not using Rect.Contains(Vector2) because the top and right boundaries are ignored
                                                if (worldPoint.x >= areaRectWorldSpace.xMin && worldPoint.x <= areaRectWorldSpace.xMax &&
                                                    worldPoint.y >= areaRectWorldSpace.yMin && worldPoint.y <= areaRectWorldSpace.yMax)
                                                {
                                                    includePointCurrentFilter = true;
                                                }
                                                else
                                                {
                                                    includePointCurrentFilter = false;
                                                }

                                                if (lbFilter.filterMode == LBFilter.FilterMode.AND)
                                                {
                                                    if (includePointCurrentFilter)
                                                    {
                                                        if (lbFilter == landscapeMeshList[m].filterList[0]) { includePoint = true; }
                                                        else
                                                        {
                                                            // If the point has been included with a previous filter it will still be included
                                                            // and we don't need to do anything here.

                                                            // Because this an AND, if it hasn't already been included by another filter, it
                                                            // will never be included and we .
                                                            if (!includePoint) { break; }
                                                        }
                                                    }
                                                    // With the AND operator, if this point is not in the area we should not add include the mesh
                                                    else { includePoint = false; break; }
                                                }

                                                // If using Filter1 OR Filter 2 OR..
                                                else if (includePointCurrentFilter && lbFilter.filterMode == LBFilter.FilterMode.OR)
                                                {
                                                    includePoint = true;
                                                }

                                                else if (lbFilter.filterMode == LBFilter.FilterMode.NOT)
                                                {
                                                    // If this is in a NOT area, we should never include this mesh
                                                    if (includePointCurrentFilter) { includePoint = false; break; }
                                                    // If not in the current area, then we should still continue to consider it
                                                    else { includePoint = true; }
                                                }
                                            }
                                        }
                                    }
                                    createMesh = includePoint;
                                }
                            }

                            // Fastest to look up the array outside List.FindIndex()
                            thisMeshProximitySquaredN = minProximitySquaredArrayN[m];

                            if (createMesh)
                            {
                                // Check if this mesh/prefab position is too close to another one of the same type (doesn't consider objects within the same cluster)
                                if (lbTerrainMeshInstanceList.FindIndex(msh => (((offset.x - msh.position.x) * (offset.x - msh.position.x)) + ((offset.z - msh.position.z) * (offset.z - msh.position.z)))
                                        < (msh.minProximityNormalisedSquared > thisMeshProximitySquaredN ? msh.minProximityNormalisedSquared : thisMeshProximitySquaredN)) >= 0) { createMesh = false; };
                            }

                            // Check Texture filters - this could be relatively slow, so do it last
                            if (createMesh && isTextureFiltersToApply)
                            {
                                if (landscapeMeshList[m].filterList != null)
                                {
                                    foreach (LBFilter lbFilter in landscapeMeshList[m].filterList)
                                    {
                                        if (lbFilter != null)
                                        {
                                            if (lbFilter.filterType == LBFilter.FilterType.Texture && lbFilter.terrainTexture != null)
                                            {
                                                if (lbFilter.terrainTexture.texture != null)
                                                {
                                                    // Does this texture exist in the current alphamaps (splatprototypes)?
                                                    // We can't simply find the matching LBTerrainTexture with FindIndex(ftx => ftx == lbFilter.terrainTexture)
                                                    // because a splatprototype only contains texture, normalmap, metallic, smoothness and tileSize fields
                                                    textureIndex = alphamapTerrainTexturesList.FindIndex(ftx => ftx.texture == lbFilter.terrainTexture.texture &&
                                                                                                                ftx.normalMap == lbFilter.terrainTexture.normalMap &&
                                                                                                                ftx.metallic == lbFilter.terrainTexture.metallic &&
                                                                                                                ftx.smoothness == lbFilter.terrainTexture.smoothness &&
                                                                                                                ftx.tileSize == lbFilter.terrainTexture.tileSize);



                                                    if (textureIndex >= 0)
                                                    {
                                                        // Get the potential position of this mesh in the alphamaps
                                                        // offset is the normalised x,y,z potential position of the tree on the terrain
                                                        alphamapX = Mathf.Clamp(Mathf.RoundToInt(offset.x * (float)tData.alphamapWidth), 0, tData.alphamapWidth - 1);
                                                        alphamapZ = Mathf.Clamp(Mathf.RoundToInt(offset.z * (float)tData.alphamapHeight), 0, tData.alphamapHeight - 1);

                                                        // What is the blend value in the alphamap for this texture
                                                        alphaBlendWeight = alphamap[alphamapZ, alphamapX, textureIndex];

                                                        // For FilterMode.OR we would need to remember this result and determine mesh placement after
                                                        // processing all filters. Currently, only AND is supported.
                                                        // Don't place mesh where the blendweight is below 0.5
                                                        if (alphaBlendWeight < 0.5f && lbFilter.filterMode == LBFilter.FilterMode.AND)
                                                        {
                                                            createMesh = false;
                                                            break;
                                                        }
                                                        else if (alphaBlendWeight > 0.1f && lbFilter.filterMode == LBFilter.FilterMode.NOT)
                                                        {
                                                            createMesh = false;
                                                            break;
                                                        }
                                                    }
                                                    else
                                                    {
                                                        // No match found in current splatprototypes
                                                        // For FilterMode.OR we would need to remember this result and determine mesh placement after
                                                        // processing all filters. Currently, only AND is supported.
                                                        if (lbFilter.filterMode == LBFilter.FilterMode.AND)
                                                        {
                                                            createMesh = false;
                                                            break;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }

                            // Need to get position mesh will potentially be placed before checking the proximity filters
                            // which store other object positions in world space
                            if (createMesh)
                            {
                                // Terrain will be slightly slower, so deal with separately to non-aligned rotation
                                if (landscapeMeshList[m].isTerrainAligned)
                                {
                                    terrainNormal = tData.GetInterpolatedNormal(offset.x, offset.z);

                                    if (landscapeMeshList[m].randomiseYRotation)
                                    {
                                        randUnitVector = UnityEngine.Random.insideUnitCircle.normalized;
                                        rotatedForwardsDir = Vector3.ProjectOnPlane(new Vector3(randUnitVector.x, 0f, randUnitVector.y), terrainNormal);
                                    }
                                    else
                                    {
                                        unitVector = Quaternion.Euler(0f, landscapeMeshList[m].fixedYRotation, 0f) * Vector3.forward;
                                        rotatedForwardsDir = Vector3.ProjectOnPlane(unitVector, terrainNormal);
                                    }

                                    meshRotation.SetLookRotation(rotatedForwardsDir, terrainNormal);

                                    meshRotation *= Quaternion.Euler(landscapeMeshList[m].XRotation, 0f, landscapeMeshList[m].ZRotation);
                                }
                                else if (landscapeMeshList[m].randomiseYRotation)
                                {
                                    meshRotation = Quaternion.Euler(landscapeMeshList[m].XRotation, UnityEngine.Random.Range(0f, 360f), landscapeMeshList[m].ZRotation);
                                }
                                else
                                {
                                    meshRotation = Quaternion.Euler(landscapeMeshList[m].XRotation, landscapeMeshList[m].fixedYRotation, landscapeMeshList[m].ZRotation);
                                }

                                // Scale the mesh
                                meshScale = Vector3.one * UnityEngine.Random.Range(landscapeMeshList[m].minScale, landscapeMeshList[m].maxScale);

                                // If this mesh will flatten the terrain, raise or lower the Y offset of the mesh position.
                                if (isTerrainFlatten)
                                {
                                    offset.y += (landscapeMeshList[m].flattenHeightOffset / terrainHeight);
                                    offset.y = Mathf.Clamp01(offset.y);
                                }

                                if (landscapeMeshList[m].usePrefab)
                                {
                                    // Set the prefab position - note that this is different from the one used for meshes.
                                    meshPosition = new Vector3(offset.x * terrainWidth, offset.y * terrainHeight, offset.z * terrainLength) + terrainTransform.position + Vector3.Scale(landscapeMeshList[m].offset, meshScale);
                                }
                                else
                                {
                                    // Position the mesh
                                    meshPosition = new Vector3(offset.x * terrainWidth, offset.y * terrainHeight, offset.z * terrainLength) + terrainTransform.position - landscapeTransform.position + Vector3.Scale(landscapeMeshList[m].offset, meshScale);
                                }
                            }

                            // Proximity and Stencil Layer filters
                            if (createMesh && (isProximityFiltersToApply || isStencilLayerFiltersToApply))
                            {
                                if (landscapeMeshList[m].filterList != null)
                                {
                                    foreach (LBFilter lbFilter in landscapeMeshList[m].filterList)
                                    {
                                        if (lbFilter != null)
                                        {
                                            // Currently all proximity and stencil layer filters are AND
                                            if (lbFilter.filterType == LBFilter.FilterType.Proximity)
                                            {
                                                if (lbFilter.objectPositionProximityCacheList != null)
                                                {
                                                    // If this mesh is too close to another object which has the matching Unity Layer and Tag to the proximity filter
                                                    // do not add it to the scene
                                                    if (lbFilter.objectPositionProximityCacheList.FindIndex(objPos => (((meshPosition.x - objPos.x) * (meshPosition.x - objPos.x)) + ((meshPosition.z - objPos.z) * (meshPosition.z - objPos.z)))
                                                         < lbFilter.minProximitySquared) >= 0) { createMesh = false; break; };
                                                }
                                            }
                                            // The layerArray should have been pre-populated for StencilLayer filters
                                            // Check for lbFilter.lbStencilLayer != null in case user deleted the Stencil Layer in the scene
                                            else if (lbFilter.filterType == LBFilter.FilterType.StencilLayer && lbFilter.lbStencilLayer != null && lbFilter.lbStencilLayer.layerArray != null)
                                            {
                                                // Get the value of the Stencil layer at this point in the terrain
                                                stencilLayerResolution = (int)lbFilter.lbStencilLayer.layerResolution;
                                                // Get the normalised position in the landscape
                                                stencilLayerPosN = landscape.NormalisePointFromWorldPos2DFast(worldPoint);
                                                // Get the point within the stencil layer USHORT array
                                                arrayPoint.x = Mathf.RoundToInt(stencilLayerPosN.x * (stencilLayerResolution - 1f));
                                                arrayPoint.y = Mathf.RoundToInt((1f - stencilLayerPosN.y) * (stencilLayerResolution - 1f));

                                                // Ensure it it's outside the range of the USHORT array
                                                arrayPoint.x = Mathf.Clamp(arrayPoint.x, 0, stencilLayerResolution - 1);
                                                arrayPoint.y = Mathf.Clamp(arrayPoint.y, 0, stencilLayerResolution - 1);

                                                /// TODO - might be able to improve mesh stencil layer blend using a curve
                                                stencilLayerPixel = lbFilter.lbStencilLayer.layerArray[arrayPoint.x, arrayPoint.y];

                                                /// Randomise the chance of placement based on mesh stencil layer pixel value
                                                if (stencilLayerPixel < 1) { createMesh = false; break; }
                                                else
                                                {
                                                    // The hash, this case, takes the point in the stencil as input data
                                                    hashValue = xxHash.Range(0, 65535, arrayPoint.x, arrayPoint.y);

                                                    if (hashValue > stencilLayerPixel) { createMesh = false; break; }
                                                }
                                            }
                                        }
                                    }
                                }
                            }

                            if (createMesh)
                            {
                                // Do we need to flatten the terrain under this mesh/prefab?
                                if (isTerrainFlatten)
                                {
                                    // Get the rectangle that defines the circular area that will be flattened
                                    Rect flattenRect = Rect.MinMaxRect(meshPosition.x - landscapeMeshList[m].flattenDistance, meshPosition.z - landscapeMeshList[m].flattenDistance, meshPosition.x + landscapeMeshList[m].flattenDistance, meshPosition.z + landscapeMeshList[m].flattenDistance);

                                    for (terrainIndex = 0; terrainIndex < landscapeTerrains.Length; terrainIndex++)
                                    {
                                        // Make sure we don't overwrite the current terrain data
                                        if (landscapeTerrains[terrainIndex].name.ToLower() == terrainName.ToLower())
                                        {
                                            tData = FlattenModifier(tData, offset.y, landscapeTerrains[terrainIndex].transform.position, flattenRect, true, landscapeMeshList[m].flattenBlendRate);
                                        }
                                        else
                                        {
                                            landscapeTerrains[terrainIndex].terrainData =
                                                FlattenModifier(landscapeTerrains[terrainIndex].terrainData, offset.y, landscapeTerrains[terrainIndex].transform.position, flattenRect, true, landscapeMeshList[m].flattenBlendRate);
                                        }
                                    }
                                }

                                if (landscapeMeshList[m].isClustered)
                                {
                                    Rect clusterBoundary = new Rect(meshPosition.x - landscapeMeshList[m].clusterDistance, meshPosition.z - landscapeMeshList[m].clusterDistance, landscapeMeshList[m].clusterDistance * 2f, landscapeMeshList[m].clusterDistance * 2f);

                                    if (lbCluster != null)
                                    {
                                        lbCluster.PopulateCluster(meshPosition, clusterBoundary, landscapeMeshList[m].minScale, landscapeMeshList[m].maxScale, landscapeMeshList[m].clusterDensity, landscapeMeshList[m].clusterResolution);

                                        // Do basic validation on the Cluster data
                                        if (lbCluster.positionList != null && lbCluster.scaleList != null)
                                        {
                                            isClusterValidated = (lbCluster.positionList.Count == lbCluster.scaleList.Count);
                                        }
                                    }
                                }

                                if (landscapeMeshList[m].usePrefab)
                                {
                                    // If the parent prefab gameobject was created, place the prefab in the scene.
                                    if (prefabMeshGameObject != null)
                                    {
                                        // Do we need to create a cluster of prefabs at this position?
                                        if (landscapeMeshList[m].isClustered)
                                        {
                                            if (isClusterValidated)
                                            {
                                                // Loop through the cluster positions
                                                for (int clusterIndex = 0; clusterIndex < lbCluster.positionList.Count; clusterIndex++)
                                                {
                                                    // Do we need to override the rotation for each each prefab in this cluster?

                                                    // Terrain Aligned will be slightly slower, so deal with separately to non-aligned rotation
                                                    if (landscapeMeshList[m].isTerrainAligned)
                                                    {
                                                        // Get the normalised position of the mesh or prefab on the terrain
                                                        float objPosXN = (lbCluster.positionList[clusterIndex].x - worldPosition.x) / terrainWidth;
                                                        float objPosZN = (lbCluster.positionList[clusterIndex].z - worldPosition.z) / terrainLength;

                                                        terrainNormal = tData.GetInterpolatedNormal(objPosXN, objPosZN);

                                                        if (landscapeMeshList[m].randomiseYRotation)
                                                        {
                                                            randUnitVector = UnityEngine.Random.insideUnitCircle.normalized;
                                                            rotatedForwardsDir = Vector3.ProjectOnPlane(new Vector3(randUnitVector.x, 0f, randUnitVector.y), terrainNormal);
                                                        }
                                                        else
                                                        {
                                                            unitVector = Quaternion.Euler(landscapeMeshList[m].XRotation, landscapeMeshList[m].fixedYRotation, landscapeMeshList[m].ZRotation) * Vector3.forward;
                                                            rotatedForwardsDir = Vector3.ProjectOnPlane(unitVector, terrainNormal);
                                                        }

                                                        meshRotation.SetLookRotation(rotatedForwardsDir, terrainNormal);

                                                        meshRotation *= Quaternion.Euler(landscapeMeshList[m].XRotation, 0f, landscapeMeshList[m].ZRotation);
                                                    }
                                                    // Set the rotation for the mesh (randomise y-axis if necessary)
                                                    else if (landscapeMeshList[m].randomiseYRotation)
                                                    {
                                                        meshRotation = Quaternion.Euler(landscapeMeshList[m].XRotation, UnityEngine.Random.Range(0f, 360f), landscapeMeshList[m].ZRotation);
                                                    }

                                                    clusterObjPosition.x = lbCluster.positionList[clusterIndex].x;
                                                    clusterObjPosition.y = GetHeight(landscape, new Vector2(lbCluster.positionList[clusterIndex].x, lbCluster.positionList[clusterIndex].z), false) + (Vector3.Scale(landscapeMeshList[m].offset, lbCluster.scaleList[clusterIndex]).y);
                                                    clusterObjPosition.z = lbCluster.positionList[clusterIndex].z;

#if UNITY_EDITOR
                                                    GameObject newPrefabInstance;
                                                    if (landscapeMeshList[m].isKeepPrefabConnection) { newPrefabInstance = (GameObject)UnityEditor.PrefabUtility.InstantiatePrefab(landscapeMeshList[m].prefab); }
                                                    else { newPrefabInstance = (GameObject)UnityEngine.Object.Instantiate(landscapeMeshList[m].prefab, clusterObjPosition, meshRotation); }
#else
                                                GameObject newPrefabInstance = (GameObject)UnityEngine.Object.Instantiate(landscapeMeshList[m].prefab, clusterObjPosition, meshRotation);
#endif

                                                    //GameObject newPrefabInstance = (GameObject)UnityEngine.Object.Instantiate(landscapeMeshList[m].prefab, clusterObjPosition, meshRotation);
                                                    if (newPrefabInstance != null)
                                                    {
#if UNITY_EDITOR
                                                        if (landscapeMeshList[m].isKeepPrefabConnection)
                                                        {
                                                            newPrefabInstance.transform.position = clusterObjPosition;
                                                            newPrefabInstance.transform.localRotation = meshRotation;
                                                        }
#endif

                                                        newPrefabInstance.transform.parent = prefabMeshGameObject.transform;
                                                        newPrefabInstance.transform.localScale = lbCluster.scaleList[clusterIndex];
                                                        landscape.numberOfMeshPrefabs++;
                                                        numberOfMeshesCreated++;

                                                        // Should the prefab meshes be combined? A new mesh is created for each mesh filter within the prefab
                                                        // See LBLandscapeMeshControllers.BuildCombineMeshes()
                                                        if (landscapeMeshList[m].isCombineMesh)
                                                        {
                                                            // Create a new Combine Instance
                                                            CombineInstance newCombineInstance = new CombineInstance();
                                                            // Create the "transform" from the calculated values above (no need to set the mesh here)
                                                            newCombineInstance.transform = Matrix4x4.TRS(clusterObjPosition - landscapePosition, meshRotation, lbCluster.scaleList[clusterIndex]);
                                                            // Add the Combine Instance into the list
                                                            combineMeshes.Add(newCombineInstance);

                                                            // Remove the mesh renderers from the prefab
                                                            MeshRenderer[] prefabMeshRenderers = newPrefabInstance.GetComponentsInChildren<MeshRenderer>(true);
                                                            if (prefabMeshRenderers != null)
                                                            {
                                                                // Loop backwards through the mesh renderers and remove them from the instantiated prefab
                                                                for (int mR = prefabMeshRenderers.Length - 1; mR >= 0; mR--)
                                                                {
                                                                    GameObject.DestroyImmediate(prefabMeshRenderers[mR]);
                                                                }
                                                            }

                                                            // Remove the mesh filters from the prefab
                                                            MeshFilter[] prefabMeshFilters = newPrefabInstance.GetComponentsInChildren<MeshFilter>(true);
                                                            if (prefabMeshFilters != null)
                                                            {
                                                                // Loop backwards through the mesh filters and remove them from the instantiated prefab
                                                                for (int mF = prefabMeshFilters.Length - 1; mF >= 0; mF--)
                                                                {
                                                                    GameObject.DestroyImmediate(prefabMeshFilters[mF]);
                                                                }
                                                            }
                                                        }

                                                        if (landscapeMeshList[m].isCreateCollider)
                                                        {
                                                            // Remove the colliders from the prefab
                                                            Collider[] prefabColliders = newPrefabInstance.GetComponentsInChildren<Collider>(true);
                                                            if (prefabColliders != null)
                                                            {
                                                                // Loop backwards through the colliders and remove them from the instantiated prefab
                                                                for (int mF = prefabColliders.Length - 1; mF >= 0; mF--)
                                                                {
                                                                    GameObject.DestroyImmediate(prefabColliders[mF]);
                                                                }
                                                            }
                                                        }

                                                        #region Remove Empty Gameobjects for CombineMesh
                                                        if (newPrefabInstance != null && landscapeMeshList[m].isCombineMesh && landscapeMeshList[m].isRemoveEmptyGameObjects)
                                                        {
                                                            // Whether to remove empty gameobjects when combining Meshes. This can reduce the number of
                                                            // GameObjects in the scene if the prefabs don't contain additional scripts or components.
                                                            // Check this last because if isCreateCollider was on, then the existing colliders may have
                                                            // been last items to remove.
                                                            if (componentList == null) { componentList = new List<Component>(); }
                                                            else { componentList.Clear(); }

                                                            newPrefabInstance.GetComponentsInChildren(componentList);

                                                            // If there are no non-transform components, delete the instantiated prefab from the scene
                                                            // This is very fast if some do exist as it looks for only the first it that is not a Transform
                                                            if (!componentList.Exists(c => c.GetType() != typeof(Transform))) { GameObject.DestroyImmediate(newPrefabInstance); }
                                                        }
                                                        #endregion
                                                    }
                                                }
                                            }
                                        }
                                        else
                                        {
                                            // Non-clustered single prefab to instantiate
#if UNITY_EDITOR
                                            GameObject newPrefabInstance;
                                            if (landscapeMeshList[m].isKeepPrefabConnection) { newPrefabInstance = (GameObject)UnityEditor.PrefabUtility.InstantiatePrefab(landscapeMeshList[m].prefab); }
                                            else { newPrefabInstance = (GameObject)UnityEngine.Object.Instantiate(landscapeMeshList[m].prefab, meshPosition, meshRotation); }
#else
                                        GameObject newPrefabInstance = (GameObject)UnityEngine.Object.Instantiate(landscapeMeshList[m].prefab, meshPosition, meshRotation);
#endif
                                            if (newPrefabInstance != null)
                                            {
#if UNITY_EDITOR
                                                if (landscapeMeshList[m].isKeepPrefabConnection)
                                                {
                                                    newPrefabInstance.transform.position = meshPosition;
                                                    newPrefabInstance.transform.localRotation = meshRotation;
                                                }
#endif
                                                newPrefabInstance.transform.parent = prefabMeshGameObject.transform;
                                                newPrefabInstance.transform.localScale = meshScale;
                                                landscape.numberOfMeshPrefabs++;
                                                numberOfMeshesCreated++;

                                                // Should the prefab meshes be combined? A new mesh is created for each mesh filter within the prefab
                                                // See LBLandscapeMeshController.BuildCombineMeshes()
                                                if (landscapeMeshList[m].isCombineMesh)
                                                {
                                                    // Create a new Combine Instance
                                                    CombineInstance newCombineInstance = new CombineInstance();
                                                    // Create the "transform" from the calculated values above (no need to set the mesh here)
                                                    newCombineInstance.transform = Matrix4x4.TRS(meshPosition - landscapePosition, meshRotation, meshScale);
                                                    // Add the Combine Instance into the list
                                                    combineMeshes.Add(newCombineInstance);

                                                    // Remove the mesh renderers from the prefab
                                                    MeshRenderer[] prefabMeshRenderers = newPrefabInstance.GetComponentsInChildren<MeshRenderer>(true);
                                                    if (prefabMeshRenderers != null)
                                                    {
                                                        // Loop backwards through the mesh renderers and remove them from the instantiated prefab
                                                        for (int mR = prefabMeshRenderers.Length - 1; mR >= 0; mR--)
                                                        {
                                                            GameObject.DestroyImmediate(prefabMeshRenderers[mR]);
                                                        }
                                                    }

                                                    // Remove the mesh filters from the prefab
                                                    MeshFilter[] prefabMeshFilters = newPrefabInstance.GetComponentsInChildren<MeshFilter>(true);
                                                    if (prefabMeshFilters != null)
                                                    {
                                                        // Loop backwards through the mesh filters and remove them from the instantiated prefab
                                                        for (int mF = prefabMeshFilters.Length - 1; mF >= 0; mF--)
                                                        {
                                                            GameObject.DestroyImmediate(prefabMeshFilters[mF]);
                                                        }
                                                    }
                                                }

                                                if (landscapeMeshList[m].isCreateCollider)
                                                {
                                                    // If combining all the prefab meshes, we need to remove any existing colliders
                                                    // They will be added to the combined meshes in LBLandscapeMeshController.BuildCombineMeshes()
                                                    if (landscapeMeshList[m].isCombineMesh)
                                                    {
                                                        // Remove the colliders from the prefab
                                                        Collider[] prefabColliders = newPrefabInstance.GetComponentsInChildren<Collider>(true);
                                                        if (prefabColliders != null)
                                                        {
                                                            // Loop backwards through the colliders and remove them from the instantiated prefab
                                                            for (int mF = prefabColliders.Length - 1; mF >= 0; mF--)
                                                            {
                                                                GameObject.DestroyImmediate(prefabColliders[mF]);
                                                            }
                                                        }
                                                    }
                                                }

                                                #region Remove Empty Gameobjects for CombineMesh
                                                if (newPrefabInstance != null && landscapeMeshList[m].isCombineMesh && landscapeMeshList[m].isRemoveEmptyGameObjects)
                                                {
                                                    // Whether to remove empty gameobjects when combining Meshes. This can reduce the number of
                                                    // GameObjects in the scene if the prefabs don't contain additional scripts or components.
                                                    // Check this last because if isCreateCollider was on, then the existing colliders may have
                                                    // been last items to remove.
                                                    if (componentList == null) { componentList = new List<Component>(); }
                                                    else { componentList.Clear(); }

                                                    newPrefabInstance.GetComponentsInChildren(componentList);

                                                    // If there are no non-transform components, delete the instantiated prefab from the scene
                                                    // This is very fast if some do exist as it looks for only the first it that is not a Transform
                                                    if (!componentList.Exists(c => c.GetType() != typeof(Transform))) { GameObject.DestroyImmediate(newPrefabInstance); }
                                                }
                                                #endregion
                                            }
                                        }
                                    }
                                }
                                else // Meshes
                                {
                                    // Do we need to create a cluster of meshes at this position?
                                    if (landscapeMeshList[m].isClustered)
                                    {
                                        // Validate the cluster for this mesh
                                        if (isClusterValidated)
                                        {
                                            // Loop through the cluster positions
                                            for (int clusterIndex = 0; clusterIndex < lbCluster.positionList.Count; clusterIndex++)
                                            {
                                                // Do we need to override the rotation for each each mesh in this cluster?

                                                // Terrain Aligned will be slightly slower, so deal with separately to non-aligned rotation
                                                if (landscapeMeshList[m].isTerrainAligned)
                                                {
                                                    // Get the normalised position of the mesh or prefab on the terrain
                                                    float objPosXN = (lbCluster.positionList[clusterIndex].x - worldPosition.x) / terrainWidth;
                                                    float objPosZN = (lbCluster.positionList[clusterIndex].z - worldPosition.z) / terrainLength;

                                                    terrainNormal = tData.GetInterpolatedNormal(objPosXN, objPosZN);

                                                    if (landscapeMeshList[m].randomiseYRotation)
                                                    {
                                                        randUnitVector = UnityEngine.Random.insideUnitCircle.normalized;
                                                        rotatedForwardsDir = Vector3.ProjectOnPlane(new Vector3(randUnitVector.x, 0f, randUnitVector.y), terrainNormal);
                                                    }
                                                    else
                                                    {
                                                        unitVector = Quaternion.Euler(landscapeMeshList[m].XRotation, landscapeMeshList[m].fixedYRotation, landscapeMeshList[m].ZRotation) * Vector3.forward;
                                                        rotatedForwardsDir = Vector3.ProjectOnPlane(unitVector, terrainNormal);
                                                    }

                                                    meshRotation.SetLookRotation(rotatedForwardsDir, terrainNormal);

                                                    meshRotation *= Quaternion.Euler(landscapeMeshList[m].XRotation, 0f, landscapeMeshList[m].ZRotation);
                                                }
                                                // Set the rotation for the mesh (randomise y-axis if necessary)
                                                else if (landscapeMeshList[m].randomiseYRotation)
                                                {
                                                    meshRotation = Quaternion.Euler(landscapeMeshList[m].XRotation, UnityEngine.Random.Range(0f, 360f), landscapeMeshList[m].ZRotation);
                                                }

                                                // Take into consideration the terrain height where the mesh will be placed
                                                clusterObjPosition.x = lbCluster.positionList[clusterIndex].x;
                                                clusterObjPosition.y = GetHeight(landscape, new Vector2(lbCluster.positionList[clusterIndex].x, lbCluster.positionList[clusterIndex].z), false) + (Vector3.Scale(landscapeMeshList[m].offset, lbCluster.scaleList[clusterIndex]).y);
                                                clusterObjPosition.z = lbCluster.positionList[clusterIndex].z;

                                                // Create a new Combine Instance
                                                CombineInstance newCombineInstance = new CombineInstance();
                                                // Designate the mesh
                                                newCombineInstance.mesh = landscapeMeshList[m].mesh;
                                                // Create the "transform" from the calculated values above
                                                newCombineInstance.transform = Matrix4x4.TRS(clusterObjPosition, meshRotation, lbCluster.scaleList[clusterIndex]);
                                                // Add the Combine Instance into the list
                                                combineMeshes.Add(newCombineInstance);
                                                landscape.numberOfMeshes++;
                                                numberOfMeshesCreated++;
                                            }
                                        }
                                    }
                                    else
                                    {
                                        // Create a new Combine Instance
                                        CombineInstance newCombineInstance = new CombineInstance();
                                        // Designate the mesh
                                        newCombineInstance.mesh = landscapeMeshList[m].mesh;
                                        // Create the "transform" from the calculated values above
                                        newCombineInstance.transform = Matrix4x4.TRS(meshPosition, meshRotation, meshScale);
                                        // Add the Combine Instance into the list
                                        combineMeshes.Add(newCombineInstance);
                                        landscape.numberOfMeshes++;
                                        numberOfMeshesCreated++;
                                    }
                                }

                                // Remember the normalised mesh position and minimum proximity
                                lbTerrainMeshInstanceList.Add(new LBTerrainMeshInstance(offset, landscapeMeshList[m].minProximity, minProximitySquaredArrayN[m]));

                                // Fastest to look up the array outside List.FindIndex()
                                thisMeshTreeProximitySquaredN = minTreeProximitySquaredArrayN[m];

                                // Non-normalised values (metres) is used in clusters
                                thisMeshTreeProximitySquared = minTreeProximitySquaredArray[m];

                                // Check to see if there are any trees too close to this mesh or prefab
                                for (int t = 0; t < treeInstancesList.Count; t++)
                                {
                                    // Access the tree instance in the list only once, it's much faster
                                    treeInstancePosition = treeInstancesList[t].position;

                                    if (landscapeMeshList[m].isClustered)
                                    {
                                        if (isClusterValidated)
                                        {
                                            for (int clusterIndex = 0; clusterIndex < lbCluster.positionList.Count; clusterIndex++)
                                            {
                                                // mesh or prefab position in a cluster is in WorldSpace, so convert tree position into WorldSpace too
                                                treeMeshDiffX = lbCluster.positionList[clusterIndex].x - (treeInstancePosition.x * terrainWidth + worldPosition.x);
                                                treeMeshDiffZ = lbCluster.positionList[clusterIndex].z - (treeInstancePosition.z * terrainLength + worldPosition.z);

                                                if (((treeMeshDiffX * treeMeshDiffX) + (treeMeshDiffZ * treeMeshDiffZ)) < thisMeshTreeProximitySquared)
                                                {
                                                    // If a tree is too close to this mesh or prefab, remove it
                                                    treeInstancesList.RemoveAt(t);
                                                    t--;
                                                    // Once a tree has been found to be too close, stop looking
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                    else
                                    {
                                        // When not in a cluster, the mesh or prefab position is normalised to the terrain. Values x,y,z are 0-1.
                                        // Offset and Tree position are already normalised.
                                        // Do the subtraction only once to gain a few 10ths of a second
                                        treeMeshDiffX = offset.x - treeInstancePosition.x;
                                        treeMeshDiffZ = offset.z - treeInstancePosition.z;
                                        //if (Vector3.Distance(treeInstancesList[t].position, offset) * terrainWidth < thisMeshProximity)
                                        // This is 46% faster than using Vector3.Distance() but not quite as accurate.
                                        if (((treeMeshDiffX * treeMeshDiffX) + (treeMeshDiffZ * treeMeshDiffZ)) < thisMeshTreeProximitySquaredN)
                                        {
                                            // If a tree is too close to this mesh or prefab, remove it
                                            treeInstancesList.RemoveAt(t);
                                            t--;
                                        }
                                    }
                                }

                                // Check to see if there are any trees too close to this mesh or prefab
                                // This is 20+% faster than looping through the tree instances however, having to then loop through
                                // the removal list seems to slow things down.
                                //List<TreeInstance> treesToRemove = treeInstancesList.FindAll(t => (((offset.x - t.position.x) * (offset.x - t.position.x)) + ((offset.z - t.position.z) * (offset.z - t.position.z)))
                                //                                                                    < thisMeshTreeProximitySquared);
                                //if (treesToRemove != null)
                                //{
                                //    foreach (TreeInstance treeInstance in treesToRemove)
                                //    {
                                //        treeInstancesList.Remove(treeInstance);
                                //    }
                                //}

                                if (landscapeMeshList[m].removeGrass)
                                {
                                    // Remove grass
                                    if (landscapeMeshList[m].isClustered)
                                    {
                                        if (isClusterValidated)
                                        {
                                            for (int clusterIndex = 0; clusterIndex < lbCluster.positionList.Count; clusterIndex++)
                                            {
                                                // Get the normalised position of the mesh or prefab on the terrain
                                                float objPosXN = (lbCluster.positionList[clusterIndex].x - worldPosition.x) / terrainWidth;
                                                float objPosZN = (lbCluster.positionList[clusterIndex].z - worldPosition.z) / terrainLength;

                                                // For now, ignore objects not in this terrain (could be expensive removing grass in another terrain)
                                                if (objPosXN < 0f || objPosXN > 1f || objPosZN < 0f || objPosZN > 1f) { continue; }

                                                // Get the mesh grass proximity (scale it by the random scaling of the mesh or prefab)
                                                meshGrassProximity = landscapeMeshList[m].minGrassProximity * lbCluster.scaleList[clusterIndex].x;

                                                // Find the start x and y coordinates of the grass patch to be removed
                                                detailXPos = Mathf.RoundToInt((objPosXN - (meshGrassProximity / terrainWidth)) * (detailWidth - 1));
                                                detailYPos = Mathf.RoundToInt((objPosZN - (meshGrassProximity / terrainLength)) * (detailHeight - 1));
                                                // Get the size of the grass patch
                                                detailPatchSize = Mathf.RoundToInt((meshGrassProximity / terrainWidth) * 2 * (detailWidth - 1));
                                                // Get the coordinates of the centre of the circle inscribed by the patch
                                                circCentre = new Vector2(detailXPos + (detailPatchSize * 0.5f), detailYPos + (detailPatchSize * 0.5f));
                                                // Get the radius of the circle
                                                circRadius = detailPatchSize * 0.5f;
                                                // Cycle through all the points in the patch
                                                for (int x = detailXPos; x < detailXPos + detailPatchSize; x++)
                                                {
                                                    for (int y = detailYPos; y < detailYPos + detailPatchSize; y++)
                                                    {
                                                        // Calculate the distance to the centre of the circle
                                                        circDist = Vector2.Distance(new Vector2(x, y), circCentre);
                                                        // Only attempt to remove grass if a) the coordinates are on the terrain
                                                        // and b) the coordinates aren't outside of the inscribed circle
                                                        if (x >= 0 && x < detailWidth && y >= 0 && y < detailWidth && circDist < circRadius)
                                                        {
                                                            // For each detail layer...
                                                            for (int d = 0; d < detailDensityMapList.Count; d++)
                                                            {
                                                                // ...set the detail density to 0
                                                                detailDensityMapList[d][y, x] = 0;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    else // Single mesh or prefabs
                                    {
                                        // Get the mesh grass proximity (scale it by the random scaling of the mesh)
                                        meshGrassProximity = landscapeMeshList[m].minGrassProximity * meshScale.x;
                                        // Find the start x and y coordinates of the grass patch to be removed
                                        detailXPos = Mathf.RoundToInt((offset.x - (meshGrassProximity / terrainWidth)) * (detailWidth - 1));
                                        detailYPos = Mathf.RoundToInt((offset.z - (meshGrassProximity / terrainLength)) * (detailHeight - 1));
                                        // Get the size of the grass patch
                                        detailPatchSize = Mathf.RoundToInt((meshGrassProximity / terrainWidth) * 2 * (detailWidth - 1));
                                        // Get the coordinates of the centre of the circle inscribed by the patch
                                        circCentre = new Vector2(detailXPos + (detailPatchSize * 0.5f), detailYPos + (detailPatchSize * 0.5f));
                                        // Get the radius of the circle
                                        circRadius = detailPatchSize * 0.5f;
                                        // Cycle through all the points in the patch
                                        for (int x = detailXPos; x < detailXPos + detailPatchSize; x++)
                                        {
                                            for (int y = detailYPos; y < detailYPos + detailPatchSize; y++)
                                            {
                                                // Calculate the distance to the centre of the circle
                                                circDist = Vector2.Distance(new Vector2(x, y), circCentre);
                                                // Only attempt to remove grass if a) the coordinates are on the terrain
                                                // and b) the coordinates aren't outside of the inscribed circle
                                                if (x >= 0 && x < detailWidth && y >= 0 && y < detailWidth && circDist < circRadius)
                                                {
                                                    // For each detail layer...
                                                    for (int d = 0; d < detailDensityMapList.Count; d++)
                                                    {
                                                        // ...set the detail density to 0
                                                        detailDensityMapList[d][y, x] = 0;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }

                        // Send the list of Combine Instances to the terrain mesh controller
                        if (combineMeshes != null)
                        {
                            //Debug.Log("INFO: LBLandscapeTerrain.PopulateTerrainWithMeshes - adding combined instance array for mesh " + m + " combineMeshes: " + combineMeshes.Count);
                            terrainMeshController.AddCombineInstanceArray(combineMeshes.ToArray(), null);
                        }

                        prefabMeshGameObject = null;

                        if (isProximityFiltersToApply)
                        {
                            // Clear gameobject positions list to free memory etc
                            if (landscapeMeshList[m].filterList != null)
                            {
                                foreach (LBFilter lbFilter in landscapeMeshList[m].filterList)
                                {
                                    if (lbFilter != null)
                                    {
                                        if (lbFilter.filterType == LBFilter.FilterType.Proximity)
                                        {
                                            lbFilter.objectPositionProximityCacheList.Clear();
                                            lbFilter.objectPositionProximityCacheList = null;
                                        }
                                    }
                                }
                            }
                        }
                    }

                    // Set the new TreeInstances array
                    tData.treeInstances = treeInstancesList.ToArray();

                    // Set the new detail density layer information
                    for (int d = 0; d < numberOfDetailLayers; d++)
                    {
                        tData.SetDetailLayer(0, 0, d, detailDensityMapList[d]);
                    }

                    if (lbTerrainMeshInstanceList != null) { lbTerrainMeshInstanceList.Clear(); }

                    tData.RefreshPrototypes();
                }
            }

            if (showTiming)
            {
                Debug.Log("Time taken for to place meshes in terrain: " + (Time.realtimeSinceStartup - tStart).ToString("0.000") + " seconds");
            }

            return tData;
        }

        /// <summary>
        /// Find all the PrefabItem components attached to child gameobjects under the landscape of LBPrefabItem.PrefabItemType
        /// and delete them from the scene. Defaults to remove all LegacyMeshPrefab within the landscape.
        /// </summary>
        /// <param name="landscape"></param>
        /// <param name="removeInactiveItems"></param>
        public static void RemoveExistingPrefabs(LBLandscape landscape, bool removeInactiveItems, LBPrefabItem.PrefabItemType prefabItemType = LBPrefabItem.PrefabItemType.LegacyMeshPrefab, string groupMemberGUID = null)
        {
            if (landscape != null)
            {
                LBPrefabItem[] prefabItems = landscape.GetComponentsInChildren<LBPrefabItem>(removeInactiveItems);

                if (prefabItems != null)
                {
                    List<Mesh> oldMeshList = new List<Mesh>(10);
                    List<MeshFilter> mfList = new List<MeshFilter>(5);
                    MeshFilter meshFilter = null;

                    for (int i = prefabItems.Length - 1; i >= 0; i--)
                    {
                        if (prefabItems[i].prefabItemType == prefabItemType && (string.IsNullOrEmpty(groupMemberGUID) || prefabItems[i].groupMemberGUID == groupMemberGUID))
                        {
                            // If this is an object path, get a list of any old surface meshes we need to delete from the scene
                            if (prefabItemType == LBPrefabItem.PrefabItemType.ObjPathPrefab || prefabItemType == LBPrefabItem.PrefabItemType.ObjPathDesignerPrefab)
                            {
                                prefabItems[i].GetComponentsInChildren<MeshFilter>(true, mfList);
                                int numMFilters = mfList == null ? 0 : mfList.Count;

                                for (int mFIdx = 0; mFIdx < numMFilters; mFIdx++)
                                {
                                    meshFilter = mfList[mFIdx];
                                    if (meshFilter != null && meshFilter.sharedMesh != null && meshFilter.name.Contains("Mesh"))
                                    {
                                        //Debug.Log("[DEBUG] found mesh to delete: " + meshFilter.sharedMesh.name);
                                        oldMeshList.Add(meshFilter.sharedMesh);
                                    }
                                }
                            }

                            #if UNITY_EDITOR
                            Object.DestroyImmediate(prefabItems[i].gameObject);
                            #else
                            Object.Destroy(prefabItems[i].gameObject);
                            #endif

                            // Clean up the now orphaned (surface) meshes that were attached to object paths
                            int numOldMeshes = oldMeshList == null ? 0 : oldMeshList.Count;
                            if (numOldMeshes > 0)
                            {
                                for (int mIdx = 0; mIdx < numOldMeshes; mIdx++)
                                {
                                    #if UNITY_EDITOR
                                    //Debug.Log("[DEBUG] deleting old mesh: " + oldMeshList[mIdx].name);
                                    Object.DestroyImmediate(oldMeshList[mIdx]);
                                    #else
                                    Object.Destroy(oldMeshList[mIdx]);
                                    #endif
                                }
                                oldMeshList.Clear();
                            }
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Enable or disable child gameobjects under the landscape of LBPrefabItem.PrefabItemType.
        /// Optionally enable/disable prefabs for a given GroupMember
        /// </summary>
        /// <param name="landscape"></param>
        /// <param name="prefabItemType"></param>
        /// <param name="isEnabled"></param>
        /// <param name="groupMemberGUID"></param>
        public static void EnableExistingPrefabs(LBLandscape landscape, LBPrefabItem.PrefabItemType prefabItemType, bool isEnabled, string groupMemberGUID = null)
        {
            if (landscape != null)
            {
                LBPrefabItem[] prefabItems = landscape.GetComponentsInChildren<LBPrefabItem>(true);

                if (prefabItems != null)
                {
                    for (int i = prefabItems.Length - 1; i >= 0; i--)
                    {
                        if (prefabItems[i].prefabItemType == prefabItemType && (string.IsNullOrEmpty(groupMemberGUID) || prefabItems[i].groupMemberGUID == groupMemberGUID))
                        {
                            prefabItems[i].gameObject.SetActive(isEnabled);
                        }
                    }
                }
            }
        }

        #endregion

        #region Static Groups Methods

        /// <summary>
        /// FROM LB 2.2.0 USES LBGroupVariables
        /// Populate a landscape with groups of member prefabs, trees, grass etc.
        /// NOTE: Texturing is not recommended with Imported Terrains where there are different
        /// textures in each terrain.
        /// When the GroupDesigner is enabled, this code is only called for Object Paths. All
        /// other placement is handled by the GroupDesigner.
        /// </summary>
        /// <param name="groupParams"></param>
        /// <returns></returns>
        public static bool PopulateLandscapeWithGroups(LBGroupParameters groupParams)
        {
            bool isSuccessful = false;

            string methodName = "LBLandscapeTerrain.PopulateTerrainWithGroups";
            float tStart = Time.realtimeSinceStartup;
            string landscapeName = "Unknown";

            // Perform some basic validation
            if (groupParams == null) { if (groupParams.showErrors) { Debug.LogWarning("ERROR " + methodName + " - LBGroupParms cannot be null. Please Report"); } }
            else if (groupParams.landscape == null) { if (groupParams.showErrors) { Debug.LogWarning("ERROR " + methodName + " - landscape cannot be null"); } }
            else if (string.IsNullOrEmpty(groupParams.landscape.name)) { if (groupParams.showErrors) { Debug.LogWarning("ERROR " + methodName + " - landscape name cannot be an empty string"); } }
            else if (groupParams.landscape.lbGroupList == null) { if (groupParams.showErrors) { Debug.LogWarning("ERROR " + methodName + " - the list of groups cannot be null. Please Report."); } }
            else
            {
                LBGroupVariables gVars = new LBGroupVariables(groupParams);

                #region Initial ProgressBar
                if (groupParams.showProgress && !gVars.isGroupDesignerEnabled && !gVars.isObjPathDesignerEnabled)
                {
                    // Call back to update the progress bar
                    groupParams.showProgressDelegate("Populating Landscape With Groups", "Initialising", 0.01f);
                }
                #endregion

                // Don't continue if some of the terrain data is not properly defined
                if (!gVars.terrainDataIsNotNull) { if (groupParams.showErrors) { Debug.LogWarning("ERROR " + methodName + " - some terrain data is invalid or could not be found. Please Report."); } }
                else if (gVars.terrainDataArray == null || gVars.terrainRectsArray == null) { if (groupParams.showErrors) { Debug.LogWarning("ERROR " + methodName + " - failed to create terrainData/terrainRects array. Please Report."); } }
                else if (gVars.terrainDataArray.Length == 0 || gVars.terrainRectsArray.Length == 0) { if (groupParams.showErrors) { Debug.LogWarning("ERROR " + methodName + " - failed to populate terrainData/terrainRects array. Please Report."); } }
                else
                {
                    // Get the list of Groups to use
                    // Create new active groups list so we don't affect the original in LBLandscape
                    gVars.activeGroupList = LBGroup.GetActiveGroupList(gVars.lbGroupParams.landscape.lbGroupList);
                    gVars.numActiveGroups = gVars.activeGroupList == null ? 0 : gVars.activeGroupList.Count;                 

                    //gVars.SetActiveGroups();

                    if (gVars.numActiveGroups > 0)
                    {
                        #region Create and initialise variables - Part 2

                        // Random seed
                        UnityEngine.Random.InitState(0);

                        #if LB_COMPUTE
                        gVars.InitialiseObjPathComputeVariables();
                        #endif

                        gVars.InitialiseGroupProximity();
                        gVars.InitialiseMemberProximity();
                        gVars.InitialiseTreeProximity(methodName);
                        gVars.InitialiseGrassArrays();
                        gVars.InitialiseTextureArrays();

                        #endregion

                        // Set up a mesh controller object for this landscape
                        gVars.AddMeshController(methodName);

                        gVars.PreloadStencilData();

                        // Pre-fetch Vegetation Studio Pro settings
                        #if VEGETATION_STUDIO_PRO
                        gVars.PrefetchVSProSettings(methodName);
                        #endif

                        // If using the ObjPathDesigner, restict processing to the Group owner of the single ObjPath
                        if (gVars.isObjPathDesignerEnabled)
                        {
                            ProcessGroup(gVars.activeGroupList.FindIndex(grp => grp == gVars.lbGroupParams.lbObjPathParm.lbGroupOwner), -1, -1, false, gVars);
                        }
                        else
                        {
                            for (int i = 0; i < gVars.numActiveGroups; i++)
                            {
                                // SubGroups get processed from within the other groups UNLESS the user is editing the SubGroup from within the GroupDesigner
                                if (gVars.isGroupDesignerEnabled || gVars.activeGroupList[i].lbGroupType != LBGroup.LBGroupType.SubGroup) { ProcessGroup(i, -1, -1, false, gVars); }
                            } // End of active group list for-loop
                        }

                        #region Remove Trees

                        // Remove trees
                        if (!gVars.isGroupDesignerEnabled)
                        {
                            // Loop through all the terrains
                            for (int i = 0; i < gVars.numTerrains; i++)
                            {
                                if (groupParams.showProgress) { groupParams.showProgressDelegate("Populating Landscape With Groups", "Removing trees ", i / gVars.numTerrains); }

                                // Get and initialise terrain info
                                Terrain tTerrain = gVars.landscapeTerrains[i];
                                if (tTerrain == null) { Debug.LogWarning("ERROR " + methodName + " - terrain " + i.ToString() + " is invalid or could not be found. Please Report."); }
                                else
                                {
                                    TerrainData tTerrainData = tTerrain.terrainData;
                                    if (tTerrainData == null) { Debug.LogWarning("ERROR " + methodName + " - some terrain data is invalid or could not be found. Please Report."); }
                                    else
                                    {
                                        // There is probably a faster way of doing this...

                                        // Get the trees array
                                        TreeInstance[] terrainTreesArray = tTerrainData.treeInstances;
                                        List<TreeInstance> terrainTreesList = terrainTreesArray.ToList();
                                        int terrainTreesListLength = terrainTreesList.Count;
                                        int totalTreesRemoved = 0;
                                        bool removeTree = false;
                                        // Loop through the tree instances
                                        for (int t = 0; t < terrainTreesListLength; t++)
                                        {
                                            // Find out if the tree exists in the list of trees to be removed
                                            removeTree = gVars.treesToRemoveList.Exists(tr => tr.terrainIndex == i && tr.objectIndex == t);
                                            if (removeTree)
                                            {
                                                // Remove tree from the list
                                                // Adjust index to take into account trees already removed
                                                terrainTreesList.RemoveAt(t - totalTreesRemoved);
                                                // Increment count of trees removed from this terrain
                                                totalTreesRemoved++;
                                            }
                                        }
                                        // Set the new list back to the array
                                        tTerrainData.treeInstances = terrainTreesList.ToArray();
                                    }
                                }
                            }
                        }

                        #endregion

                        // TODO - Grass Compute Shader

                        #region Modify Grass

                        // Modify grass data
                        if (!gVars.isGroupDesignerEnabled)
                        {
                            // Loop through all the terrains
                            for (int i = 0; gVars.isRemoveGrassPresent && i < gVars.numTerrains; i++)
                            {
                                if (groupParams.showProgress) { groupParams.showProgressDelegate("Populating Landscape With Groups", "Removing grass ", i / gVars.numTerrains); }

                                Terrain tTerrain = gVars.landscapeTerrains[i];
                                if (tTerrain == null) { Debug.LogWarning("ERROR " + methodName + " - remove grass - terrain " + i.ToString() + " is invalid or could not be found. Please Report."); }
                                else
                                {
                                    TerrainData tTerrainData = tTerrain.terrainData;
                                    if (tTerrainData == null) { Debug.LogWarning("ERROR " + methodName + " - some terrain data is invalid or could not be found. Please Report."); }
                                    else
                                    {
                                        // Calculate the x and z shifts for this terrain
                                        int grassCoordZShift = (i % gVars.numTerrainsWide) * gVars.terrainDetailResolution;
                                        int grassCoordXShift = (int)((float)i / (float)gVars.numTerrainsWide) * gVars.terrainDetailResolution;
                                        // Initialise variables
                                        int l, x, z, grassArrayIndex;
                                        float grassAmountValue;
                                        // Loop through the grass layers
                                        for (l = 0; l < tTerrainData.detailPrototypes.Length; l++)
                                        {
                                            // Get the grass array for this layer
                                            int[,] terrainGrassArray = tTerrainData.GetDetailLayer(0, 0, tTerrainData.detailWidth, tTerrainData.detailHeight, l);
                                            // Calculate the index shift for this grass type in the grass addition array
                                            gVars.grassAdditionArrayIndexShift = l * gVars.totalGrassArrayCells;
                                            // Loop through the grass array
                                            for (x = 0; x < tTerrainData.detailWidth; x++)
                                            {
                                                for (z = 0; z < tTerrainData.detailHeight; z++)
                                                {
                                                    // Get original grass data
                                                    grassAmountValue = terrainGrassArray[z, x];
                                                    // Get index for grass arrays
                                                    grassArrayIndex = ((z + grassCoordZShift) * gVars.grassArrayCellsListWidth) + x + grassCoordXShift;
                                                    // Remove grass (initial pass)
                                                    grassAmountValue *= gVars.initialGrassRemovalArray[grassArrayIndex] / 255f;
                                                    // Add grass of this type
                                                    grassAmountValue += gVars.grassAdditionArray[grassArrayIndex + gVars.grassAdditionArrayIndexShift];
                                                    // Remove grass (final pass)
                                                    grassAmountValue *= gVars.finalGrassRemovalArray[grassArrayIndex] / 255f;
                                                    // Set new grass data to array
                                                    terrainGrassArray[z, x] = (int)grassAmountValue;
                                                }
                                            }
                                            // Set the grass array for this layer back to the terrain
                                            tTerrainData.SetDetailLayer(0, 0, l, terrainGrassArray);
                                        }
                                    }
                                }
                            }
                        }

                        #endregion

                        #region Modify Textures (Compute or Non-Compute)

                        // Modify texture data
                        if (!gVars.isGroupDesignerEnabled && (gVars.isTexturingPresent || gVars.isObjPathTexturingPresent))
                        {
#if !(UNITY_STANDALONE_OSX || UNITY_STANDALONE_WIN || UNITY_XBOXONE || UNITY_WSA_10_0)
                            bool isTexComputeEnabled = false;
#else
                            bool isTexComputeEnabled = (groupParams.landscape == null ? false : groupParams.landscape.useGPUTexturing);
#endif

                            #region Modify Textures Compute
                            if (isTexComputeEnabled)
                            {
#if LB_COMPUTE

                                try
                                {
                                    #region Compute Shader variables
                                    float[] splatMaps1D = null;
                                    int[] textureAdditionArrayInt = null;
                                    #endregion

                                    #region Init compute shader
                                    // Must match LB_TEX_NUM_THREADS/LB_TEX_NUM_THREADS_4K in LBCSTex.compute
                                    // OSX Metal seems to have a limit of 256. Not sure if this is hardware dependent.
                                    // Currently 512 is required if using 4K alphamap/splatmap resolution. To avoid this in the future
                                    // the compute shader would need to process chunks rather than the whole 4096x4096 block
                                    int cskTexPerlinNumThreads = gVars.terrainAlphamapResolution >= 4096 ? 512 : 256;
                                    int kTexModGroupIdx = -1;
                                    // Size of a single splatmap layer
                                    int splatMap1DSize = gVars.terrainAlphamapResolution * gVars.terrainAlphamapResolution;

                                    int splatMaps1DSize = 0;
                                    int splatMaps1DSizeTarget = -1;

                                    gVars.shaderTex = (ComputeShader)Resources.Load(LBCSTex, typeof(ComputeShader));
                                    if (gVars.shaderTex == null) { Debug.LogWarning("ERROR: " + methodName + " " + LBCSTex + ".shader not found. Please Report"); }
                                    else
                                    {
                                        kTexModGroupIdx = gVars.shaderTex.FindKernel(gVars.terrainAlphamapResolution >= 4096 ? CSKTexModGroup4K : CSKTexModGroup);

                                        // Create 1D array to store splatMaps = (alphares ^ 2) * numtextures
                                        splatMaps1DSizeTarget = splatMap1DSize * gVars.totalTextureAdditionArrays;
                                        splatMaps1D = new float[splatMaps1DSizeTarget];

                                        splatMaps1DSize = (splatMaps1D == null ? 0 : splatMaps1D.Length);

                                        // Create the flat splatmap buffer
                                        gVars.cbufSplatMaps = new ComputeBuffer(splatMaps1DSizeTarget, sizeof(float), ComputeBufferType.Default);

                                        // Set the splatmaps buffer to tbe used by the TexModGroup method in the shader
                                        gVars.shaderTex.SetBuffer(kTexModGroupIdx, CSsplatMaps, gVars.cbufSplatMaps);

                                        // ToDo - pack 4 bytes into a single int (currently uses too much space)
                                        textureAdditionArrayInt = new int[gVars.textureAdditionArraySize];

                                        // Copy the byte array into the int array (compute shaders don't support byte buffers)
                                        if (textureAdditionArrayInt.Length == gVars.textureAdditionArraySize)
                                        {
                                            for (int i = 0; i < gVars.textureAdditionArraySize; i++) { textureAdditionArrayInt[i] = (int)gVars.textureAdditionArray[i]; }
                                            gVars.cbufSplatAdditions = new ComputeBuffer(gVars.textureAdditionArraySize, sizeof(int), ComputeBufferType.Default);
                                            if (gVars.cbufSplatAdditions != null)
                                            {
                                                // Copy the data to the compute shader
                                                gVars.shaderTex.SetBuffer(kTexModGroupIdx, CSsplatAdditions, gVars.cbufSplatAdditions);
                                                gVars.cbufSplatAdditions.SetData(textureAdditionArrayInt);
                                            }
                                        }

                                        // Set compute shader variables which are same for all terrains
                                        gVars.shaderTex.SetInt(CSnumTerrainsWide, gVars.numTerrainsWide);
                                        gVars.shaderTex.SetInt(CSnumSplatTextures, gVars.totalTextureAdditionArrays);
                                        gVars.shaderTex.SetInt(CSalphaMapWidth, gVars.terrainAlphamapResolution);
                                        gVars.shaderTex.SetInt(CSalphaMapLength, gVars.terrainAlphamapResolution);

                                        // Unused variables (used by TexPerlin)
                                        gVars.shaderTex.SetInt(CSheightmapResolution, heightmapResolution);
                                        gVars.shaderTex.SetFloat(CSterrainWidth, 1f);
                                        gVars.shaderTex.SetFloat(CSterrainLength, 1f);
                                        gVars.shaderTex.SetFloat(CSterrainHeight, gVars.terrainHeight);
                                        gVars.shaderTex.SetVector(CSterrainWorldPos, Vector4.zero);
                                    }
                                    #endregion

                                    #region Process terrains
                                    if (splatMaps1DSize == splatMaps1DSizeTarget && gVars.cbufSplatMaps != null && gVars.cbufSplatAdditions != null && gVars.shaderTex != null)
                                    {
                                        for (int i = 0; i < gVars.numTerrains; i++)
                                        {
                                            if (groupParams.showProgress) { groupParams.showProgressDelegate("Populating Landscape With Groups", "Updating Textures on GPU ", i / gVars.numTerrains); }

                                            Terrain tTerrain = gVars.landscapeTerrains[i];
                                            if (tTerrain == null) { if (groupParams.showErrors) { Debug.LogWarning("ERROR " + methodName + " - modify textures - terrain " + i.ToString() + " is invalid or could not be found. Please Report."); } }
                                            else
                                            {
                                                TerrainData tTerrainData = tTerrain.terrainData;
                                                if (tTerrainData == null) { Debug.LogWarning("ERROR " + methodName + " - some terrain data is invalid or could not be found. Please Report."); }
                                                else
                                                {
                                                    #region Get Splatmaps and send to compute shader

                                                    // Retrieve the texture arrays from the terrain data
                                                    float[,,] terrainTextureArray = tTerrainData.GetAlphamaps(0, 0, gVars.terrainAlphamapResolution, gVars.terrainAlphamapResolution);

                                                    // Convert from 3D to 1D array
                                                    // Copy 3D alphamap array to shader 1D array
                                                    for (int smTexIdx = 0; smTexIdx < gVars.totalTextureAdditionArrays; smTexIdx++)
                                                    {
                                                        for (int z = 0; z < gVars.terrainAlphamapResolution; z++)
                                                        {
                                                            for (int x = 0; x < gVars.terrainAlphamapResolution; x++)
                                                            {
                                                                splatMaps1D[(splatMap1DSize * smTexIdx) + (gVars.terrainAlphamapResolution * z) + x] = terrainTextureArray[z, x, smTexIdx];
                                                            }
                                                        }
                                                    }
                                                    // Set compute shader variables
                                                    gVars.shaderTex.SetInt(CSterrainIdx, i);

                                                    // Copy 1D splatmaps array to shader
                                                    gVars.cbufSplatMaps.SetData(splatMaps1D);

                                                    #endregion

                                                    #region Execute the compute shader

                                                    int threadGroupX = Mathf.CeilToInt(splatMap1DSize / cskTexPerlinNumThreads);
                                                    gVars.shaderTex.Dispatch(kTexModGroupIdx, threadGroupX, 1, 1);

                                                    // Retrieve the splatmaps
                                                    gVars.cbufSplatMaps.GetData(splatMaps1D);

                                                    // Copy shader 1D data to 3D alphamap array
                                                    for (int smTexIdx = 0; smTexIdx < gVars.totalTextureAdditionArrays; smTexIdx++)
                                                    {
                                                        for (int z = 0; z < gVars.terrainAlphamapResolution; z++)
                                                        {
                                                            for (int x = 0; x < gVars.terrainAlphamapResolution; x++)
                                                            {
                                                                terrainTextureArray[z, x, smTexIdx] = splatMaps1D[(splatMap1DSize * smTexIdx) + (gVars.terrainAlphamapResolution * z) + x];
                                                            }
                                                        }
                                                    }

                                                    // Set the texture arrays back to the terrain
                                                    tTerrainData.SetAlphamaps(0, 0, terrainTextureArray);

                                                    #endregion
                                                }
                                            }
                                        }
                                    }
                                    #endregion

                                }
                                catch (System.Exception ex)
                                {
                                    Debug.LogWarning("ERROR " + methodName + " - could not texture landscape with GPU - " + ex.Message);
                                }
                                #region Free Resources
                                finally
                                {
                                    if (gVars.cbufSplatMaps != null) { gVars.cbufSplatMaps.Release(); gVars.cbufSplatMaps = null; }
                                    if (gVars.cbufSplatAdditions != null) { gVars.cbufSplatAdditions.Release(); gVars.cbufSplatAdditions = null; }
                                    if (gVars.shaderTex != null) { gVars.shaderTex = null; }
                                }
                                #endregion

#endif
                            }
                            #endregion

                            #region Modify Textures Non-Compute
                            // Loop through all the terrains
                            for (int i = 0; !isTexComputeEnabled && i < gVars.numTerrains; i++)
                            {
                                if (groupParams.showProgress) { groupParams.showProgressDelegate("Populating Landscape With Groups", "Updating Textures ", i / gVars.numTerrains); }

                                Terrain tTerrain = gVars.landscapeTerrains[i];
                                if (tTerrain == null) { Debug.LogWarning("ERROR " + methodName + " - remove grass - terrain " + i.ToString() + " is invalid or could not be found. Please Report."); }
                                else
                                {
                                    TerrainData tTerrainData = tTerrain.terrainData;
                                    if (tTerrainData == null) { Debug.LogWarning("ERROR " + methodName + " - some terrain data is invalid or could not be found. Please Report."); }
                                    else
                                    {
                                        // Calculate the x and z shifts for this terrain
                                        int textureCoordZShift = (i % gVars.numTerrainsWide) * gVars.terrainAlphamapResolution;
                                        int textureCoordXShift = (int)((float)i / (float)gVars.numTerrainsWide) * gVars.terrainAlphamapResolution;
                                        // Initialise variables
                                        int t, x, z, textureArrayIndex;
                                        float textureWeightsTotal = 0f;
                                        float newTextureStrength = 0f;
                                        // Retrieve the texture arrays from the terrain data
                                        float[,,] terrainTextureArray = tTerrainData.GetAlphamaps(0, 0, tTerrainData.alphamapWidth, tTerrainData.alphamapHeight);
                                        // Loop through the texture arrays (first looping through points)
                                        for (x = 0; x < tTerrainData.alphamapWidth; x++)
                                        {
                                            for (z = 0; z < tTerrainData.alphamapHeight; z++)
                                            {
                                                // Calculate base texture array index
                                                textureArrayIndex = ((z + textureCoordZShift) * gVars.textureArrayCellsListWidth) + x + textureCoordXShift;
                                                // Reset total weights to zero
                                                textureWeightsTotal = 0f;
                                                // Loop through the various textures and modify them
                                                for (t = 0; t < gVars.totalTextureAdditionArrays; t++)
                                                {
                                                    // Calculate a texture strength adjusted by the value of the texture addition array
                                                    // The component from the texture addition array is the overwhelming factor
                                                    // (it is stronger by a factor of ten)
                                                    newTextureStrength = terrainTextureArray[z, x, t] + (gVars.textureAdditionArray[textureArrayIndex] / 25.5f);
                                                    // Add this texture strength to the total
                                                    textureWeightsTotal += newTextureStrength;
                                                    // Set this new texture strength back to the array
                                                    terrainTextureArray[z, x, t] = newTextureStrength;
                                                    // Increment the texture array index so that the next time through the loop we 
                                                    // will be indexing the next texture
                                                    textureArrayIndex += gVars.totalTextureArrayCells;
                                                }
                                                // Loop through the various textures a second time to divide by total of adjusted weights
                                                for (t = 0; t < gVars.totalTextureAdditionArrays; t++)
                                                {
                                                    terrainTextureArray[z, x, t] /= textureWeightsTotal;
                                                }
                                            }
                                        }
                                        // Set the texture arrays back to the terrain
                                        tTerrainData.SetAlphamaps(0, 0, terrainTextureArray);
                                    }
                                }
                            }
                            #endregion

                        }

                        #endregion

                        isSuccessful = true;
                    }
                }
            }

            if (groupParams.landscape.showTiming)
            {
                Debug.Log("Time taken to place groups in landscape (" + landscapeName + "): " + (Time.realtimeSinceStartup - tStart).ToString("00.000") + " seconds");
            }

            return isSuccessful;
        }

        /// <summary>
        /// Called from PopulateLandscapeWithGroups(..) [NEW in LB 2.2.0]
        /// Process a single active group. This will allow a group to spawn subgroups.
        /// When SubGroups are instantiated from another Group, isChildGroup is true
        /// and they have a parentGpIdx which is the index in activeGroupList. All other
        /// scenarios should have parentGpIdx and parentGpMbrIdx set to -1 and set isChildGroup to false.
        /// When processing ObjPathSeries with useSubGroups enabled, this method calls itself.
        /// NOTE: When the GroupDesigner is enabled, this code is only called for Object Paths. All
        /// other placement is handled by the GroupDesigner.
        /// </summary>
        /// <param name="activeGpIdx"></param>
        /// <param name="parentGpIdx"></param>
        /// <param name="parentGpMbrIdx"></param>
        /// <param name="isChildGroup"></param>
        /// <param name="gVars"></param>
        private static void ProcessGroup(int activeGpIdx, int parentGpIdx, int parentGpMbrIdx, bool isChildGroup, LBGroupVariables gVars)
        {
            // Get out if basic validation fails
            if (gVars == null || gVars.numActiveGroups < 1 || gVars.numActiveGroups <= activeGpIdx) { return; }

            string methodName = "LBLandscapeTerrain.ProcessGroup";

            LBGroup lbGroup = gVars.activeGroupList[activeGpIdx];

            if (lbGroup == null)
            {
#if UNITY_EDITOR
                if (gVars.lbGroupParams.showErrors) { Debug.LogWarning(methodName + " could not find group within the active list. Index within list " + activeGpIdx); }
#endif
                return;
            }

            //Debug.Log("[DEBUG] ProcessGroup " + activeGpIdx + " " + lbGroup.groupName + " of type " + lbGroup.lbGroupType);

            #region Region variables
            // A region can be the whole landscape (e.g. LBGroupType.Uniform)
            // OR one of many LBGroupType.Clearing
            // OR a subgroup
            // OR a stencil layer
            int numRegions = 1, regionIdx = 0;
            #endregion

            #region Group variables

            bool isGroupPlacementPositionOk = false;
            //List of all heightmap positions. Each cell is 0 = unchecked, 1 = checked and passed, 2 = checked and failed
            List<byte> regionGroupPlacementList = new List<byte>();
            // If the heightmap resolution is 513, we'd need 512 cells x 512 cells, if it was 129 we'd need 128 x 128 cells.
            int regionGroupPlacementListSize = (gVars.landscapeHeightmapResolution - 1) * (gVars.landscapeHeightmapResolution - 1);
            bool isRuleMatched = false;
            // List of cell positions that have a matching rule. e.g. 5 means the sixth item in the placement list matches the rule
            List<int> regionGroupCellBucketList = new List<int>();
            int regionGroupCellBucketListSize = 0;
            int ruleStatusIdx = 0, cellIdx = 0;
            List<Vector3> groupPosNList = new List<Vector3>();
            List<Rect> groupRectList = new List<Rect>();
            List<float> groupRadiusList = new List<float>();
            int numGroupPositions = 0, numGroupRadii = 0, numGroupRects = 0;
            float clearingRadius = 0f;
            Vector3 groupPositionNormalised = Vector3.zero;
            Vector3 groupPosition = Vector3.zero;  // This is the position in Landscape-space from the bottom left of the landscape (in metres)
            Vector3 groupPositionWS = Vector3.zero;  // Same as groupPosition but in world-space. So groupPosition + landscapePosition
            bool isGroupTypeUniform = true, isGroupTypeProceduralClearing = false, isGroupTypeManualClearing = false, isGroupTypeSubGroup = false;
            #endregion

            #region Cell variables
            Vector3 cellPos = Vector3.zero;         // Place within the landscape within a cell
            Vector3 cellPosN = Vector3.zero;        // Place within the landscape within a cell, normalised (0-1.0f)
            Vector2 subGroupPos2D = Vector2.zero;   // Place within a subgroup offset from centre in metres
            int xHeightmap = 0;
            int zHeightmap = 0;
            Vector3 landscapePosN = Vector3.zero;   // 0-1.0
            Vector3 landscapePos = Vector3.zero;    // 0-landscapewidth/height/length
            float thisTerrainPointSteepness = 0f;
            float thisTerrainPointHeight = 0f;
            #endregion

            #region Member variables
            LBGroupMember lbGroupMember = null;
            LBGroupMember lbGroupMemberToPlace = null;
            LBGroupMember lbGroupMemberSeriesOverride = null;
            int numGroupMembers = 0;
            bool isMemberPlacementPositionOk = false;   // This is set for Prefab members and SubGroup placement
            // List of all heightmap positions. Each cell is 0 = unchecked, 1 = checked and passed, 2 = checked and failed
            List<byte> regionMemberPlacementList = new List<byte>();
            byte cellStatus = 0;
            //byte cellStatusNotTested = 0;  // Not used in our code at the moment as this is the default
            byte cellStatusRulePassed = 1;
            byte cellStatusRuleFailed = 2;
            // List of cell positions that have a matching rule. e.g. 5 means the sixth item in the placement list matches the rule
            List<int> regionMemberCellBucketList = new List<int>();
            int regionMemberPlacementListSize = regionGroupPlacementListSize;
            int regionMemberCellBucketListSize = 0;
            int mRIdx = 0, mFIdx = 0, pColIdx = 0, mAIdx = 0;
            bool isPlacedInCentre = false;
            Vector3 posRelativeToGroup = Vector3.zero;          // Position of the cell relative to the centre of the clearing
            Vector3 posRelativeToGroupN = Vector3.zero;         // Position (normalised) of the cell relative to the centre of the clearing
            Vector3 proximityObjectPos = Vector3.zero;          // Position variable used in proximity calculations
            bool isZoneEdgeFillEnabled = false;
            Vector3 firstZonePositionN = Vector3.zero;          // Normalised position of a zone within the landscape
                                                                // Combine instances 2D list used for object path combined meshes
            List<List<CombineInstance>> objPathCombineMeshesList = new List<List<CombineInstance>>();
            int numActiveMainObjPrefabList = 0;                 // Temp variable only used for CombineInstances
            int numObjPathCombineMeshesList = 0;
            #endregion

            #region SubGroup variables
            LBGroup subGroupToPlace = null;
            bool isSubGroupPlacementOk = false;
            bool createSubGroup = false;
            LBGroup parentGroup = null;
            LBGroupMember parentGroupMember = null;
            #endregion

            #region Vegetation Studio Pro variables
#if VEGETATION_STUDIO_PRO
            GameObject vspZoneGameObject = null;
            AwesomeTechnologies.VegetationMaskArea vegetationMaskArea = null;
            Vector3 zonePosGroupSpacem = Vector3.zero;
            Vector3 groupPosWorldSpace = Vector3.zero;
            float zoneWidthm = 0f, zoneLengthm = 0f;
            List<Vector3> polygonPointList = new List<Vector3>(10);
            AwesomeTechnologies.VegetationSystem.Biomes.BiomeMaskArea biomeMaskArea = null;
            LBBiome lbBiome = null;
#endif
            #endregion

            #region Zone Variables
            int zoneListIndex = 0;
            LBGroupZone thisZone;
            bool positionInsideZone = false;
            float orZoneBlendFactor = 1f;
            float notZoneBlendFactor = 1f;
            bool includedOrZone, includedNotZone;
            float totalZoneBlendFactor = 1f;
            float zoneBlendFactor = 1f;
            //bool cellSatisfiesZoneRules = false;
            bool cellSatisfiesOrZoneRules = false, cellSatisfiesNotZoneRules = false;
            float sqrDistToZoneCentre = 0f;
            float distToZoneCentreX = 0f;
            float distToZoneCentreZ = 0f;
            float distToZoneEdge = 0f;
            #endregion

            #region Clearing variables
            int clearingPlacementListWidth = 0;
            int clearingMinXIndex = 0;
            int clearingMinZIndex = 0;
            float clearingRotationY = 0f;
            #endregion

            #region Prefab variables
            bool createPrefab = false;
            Vector3 prefabPosition = Vector3.one;   // World space location where prefab will be placed in the landscape
            Quaternion prefabRotation = Quaternion.identity;
            float prefabRotationY = 0f;
            Vector3 prefabScale = Vector3.one;
            Vector3 prefabOffset = Vector3.zero;
            GameObject memberPrefabGameObject = null;
            LBPrefabItem lbPrefabItem = null;
            List<Component> componentList = new List<Component>();
            System.Type typeMeshRenderer = typeof(MeshRenderer);
            System.Type typeMeshFilter = typeof(MeshFilter);
            System.Type typeAnimator = typeof(Animator);
            #endregion

            #region Flatten variables
            List<Vector3> flattenPosNList = new List<Vector3>();
            List<Rect> flattenRectList = new List<Rect>();
            List<float> flattenBlendRateList = new List<float>();
            #endregion

            #region Rotation variables
            Vector3 thisTerrainPointNormal = Vector3.up, unitVector;
            #endregion

            #region Random Numbers
            LBRandom lbRandomObjPathSparse = null;
            LBRandom lbRandomObjPathSelection = null;
            LBRandom lbRandomPrefabXZRotation = null;
            LBRandom lbRandomObjPathCoreTexNoiseOffset = null;
            LBRandom lbRandomObjPathSurrTexNoiseOffset = null;
            float objPathCoreTexNoiseOffset = 0f, objPathSurrTexNoiseOffset = 0f;
            #endregion

            #region Object Path Variables
            // Point, Forward, Right and Distance lists are used for both Prefabs and SubGroups in an ObjPathSeries.
            List<Vector3> objPathPrefabPointList = new List<Vector3>(100);
            List<Vector3> objPathPrefabForwardsList = new List<Vector3>(100);
            List<Vector3> objPathPrefabRightList = new List<Vector3>(100);
            List<float> objPathPrefabDistancesList = new List<float>(100);
            List<LBObjPrefab> activeMainObjPrefabList = new List<LBObjPrefab>();
            List<LBObjSubGroup> activeMainObjSubGroupList = new List<LBObjSubGroup>();
            #endregion

            #region Group-scoped Placement

            #region Initialise Group-scoped Placement
            // Cache grouptype as a bool for faster access.
            isGroupTypeUniform = lbGroup.lbGroupType == LBGroup.LBGroupType.Uniform;
            isGroupTypeManualClearing = lbGroup.lbGroupType == LBGroup.LBGroupType.ManualClearing;
            isGroupTypeProceduralClearing = lbGroup.lbGroupType == LBGroup.LBGroupType.ProceduralClearing;
            isGroupTypeSubGroup = lbGroup.lbGroupType == LBGroup.LBGroupType.SubGroup;

            // Create a group-scoped region placement array
            regionGroupPlacementList.Clear();
            regionGroupCellBucketList.Clear();

            regionGroupPlacementList.AddRange(new byte[regionGroupPlacementListSize]);

            // Fill the rule list with all potential cells (start with a full list of cells)
            for (int grpmbrIdx = 0; grpmbrIdx < regionGroupPlacementListSize; grpmbrIdx++)
            {
                regionGroupCellBucketList.Add(grpmbrIdx);
            }

            int numberOfGroupsCreated = 0;
            int targetNumberOfGroups = Mathf.RoundToInt(gVars.perSqrKmFactor * lbGroup.maxGroupSqrKm);
            int maxGroupIterations = targetNumberOfGroups;
            regionGroupCellBucketListSize = regionGroupCellBucketList.Count;

            // Re-initialise group lists - currently only applies to Clearings and SubGroups
            groupPosNList.Clear();
            groupRectList.Clear();
            flattenBlendRateList.Clear();
            groupRadiusList.Clear();
            numGroupPositions = 0;
            numGroupRadii = 0;
            numGroupRects = 0;
            #endregion

            #region Child Configuration
            // SubGroups can be spawned from:
            // 1. Uniform Group Object Paths OR
            // 2. Clearing Group Object Paths being created in the scene
            // 3. Clearing Group Object Paths in the GroupDesigner
            // All can be created with or without the ObjectPath Designer enabled.
            if (isChildGroup && parentGpIdx >= 0 && parentGpMbrIdx >= 0)
            {
                // Find the parent group
                parentGroup = gVars.activeGroupList[parentGpIdx];
                if (parentGroup != null) { parentGroupMember = parentGroup.groupMemberList[parentGpMbrIdx]; }
            }
            #endregion

            // Should this group be placed in the landscape (or GroupDesigner)?
            #region Clearing and subgroup placement in GroupDesigner
            if (gVars.isGroupDesignerEnabled && (isGroupTypeManualClearing || isGroupTypeProceduralClearing || isGroupTypeSubGroup))
            {
                if (isChildGroup)
                {
                    if (parentGroup == null)
                    {
                        numGroupPositions = 0;
#if UNITY_EDITOR
                        if (gVars.lbGroupParams.showErrors) { Debug.Log(methodName + " " + lbGroup.groupName + " child group doesn't have a parent group. PLEASE REPORT"); }
#endif
                    }
                    else
                    {
                        // This is one or more SubGroups which have been placed within a clearing group in the GroupDesigner
                        // They could be along an ObjPath in the GroupDesigner OR PlaceInCentre OR procedurally placed.
                        numGroupPositions = lbGroup.positionList == null ? 0 : lbGroup.positionList.Count;
                        for (int sgIdx = 0; sgIdx < numGroupPositions; sgIdx++)
                        {
                            cellPos = lbGroup.positionList[sgIdx];

                            // NOT SURE if the position of the subgroup should scale up/down with the variable radius or not...
                            cellPosN.x = cellPos.x / parentGroup.maxClearingRadius;
                            cellPosN.z = cellPos.z / parentGroup.maxClearingRadius;
                            cellPosN.y = (cellPos.y - gVars.lbGroupParams.designerOffsetY) / gVars.terrainHeight;
                            groupPosNList.Add(cellPosN);

                            // Get the radius for this clearing. Always use Random, even when min/max the same - for more predictable results.
                            clearingRadius = UnityEngine.Random.Range(lbGroup.minClearingRadius, lbGroup.maxClearingRadius);
                            groupRadiusList.Add(clearingRadius);
                        }
                    }
                }
                else
                {
                    numGroupPositions = 1;
                    clearingRadius = lbGroup.maxClearingRadius;

                    cellPos = new Vector3(0f, gVars.lbGroupParams.designerOffsetY, 0f);
                    // cellPosN is the normalised (0-1.0f) clearing position within the GroupDesigner (Group max Radius)
                    cellPosN.x = cellPos.x / clearingRadius;
                    cellPosN.z = cellPos.z / clearingRadius;
                    cellPosN.y = cellPos.y / gVars.terrainHeight;

                    // Remember the normalised position of this clearing group or subgroup
                    groupPosNList.Add(cellPosN);
                    groupRadiusList.Add(clearingRadius);
                }

                numGroupRects = 0;
                numGroupRadii = groupRadiusList.Count;
            }
            #endregion

            #region Procedural Clearing placement
            else if (isGroupTypeProceduralClearing)
            {
                // Group placement loop
                for (int gItn = 0; gItn < maxGroupIterations && numberOfGroupsCreated < targetNumberOfGroups; gItn++)
                {
                    // Are they any potential cells left that we could place a group into?
                    if (regionGroupCellBucketListSize < 1) { break; }
                    {
                        #region Group Placement Rules

                        // Find a random cell in the list of potential cells
                        cellIdx = UnityEngine.Random.Range(0, regionGroupCellBucketListSize);
                        ruleStatusIdx = regionGroupCellBucketList[cellIdx];

                        // Get the current status of this cell
                        cellStatus = regionGroupPlacementList[ruleStatusIdx];

                        // Has cell already been checked and failed rule test?
                        if (cellStatus == cellStatusRuleFailed) { continue; }
                        // Has the cell been checked?
                        else
                        {
                            // Check the group rules

                            // Convert rule into a position on the terrain
                            zHeightmap = ((int)(ruleStatusIdx / (gVars.landscapeHeightmapResolution - 1)));
                            xHeightmap = (ruleStatusIdx % (gVars.landscapeHeightmapResolution - 1));

                            // Get the normalised position (bottom-left) for this heightmap cell in the terrain
                            landscapePosN.x = xHeightmap / (gVars.landscapeHeightmapResolutionF - 1f);
                            landscapePosN.z = zHeightmap / (gVars.landscapeHeightmapResolutionF - 1f);

                            // Assume not tested (if already passed, no need to do another else)
                            if (cellStatus != cellStatusRulePassed)
                            {
                                // Find that coordinate's height and steepness
                                GetLandscapeInterpolatedData(gVars.terrainDataArray, gVars.terrainRectsArray, new Vector2(landscapePosN.x * gVars.landscapeWidth, landscapePosN.z * gVars.landscapeLength), ref thisTerrainPointHeight, ref thisTerrainPointSteepness);
                                landscapePosN.y = thisTerrainPointHeight / gVars.terrainHeight;

                                // Determine if this cell in the terrain complies with the Group-scoped rule
                                isRuleMatched = landscapePosN.y >= lbGroup.minHeight && landscapePosN.y <= lbGroup.maxHeight &&
                                                thisTerrainPointSteepness >= lbGroup.minInclination && thisTerrainPointSteepness <= lbGroup.maxInclination;

                                cellStatus = isRuleMatched ? cellStatusRulePassed : cellStatusRuleFailed;
                                regionGroupPlacementList[ruleStatusIdx] = cellStatus;

                                // If failed placement rules, remove cell from potential list and go to next iteration
                                if (cellStatus == cellStatusRuleFailed)
                                {
                                    regionGroupCellBucketList.RemoveAt(cellIdx);
                                    regionGroupCellBucketListSize--;
                                    continue;
                                }
                            }
                        }

                        #endregion

                        // This is cell complies with the rules.
                        landscapePos.x = landscapePosN.x * gVars.landscapeWidth;
                        landscapePos.z = landscapePosN.z * gVars.landscapeLength;
                        landscapePos.y = 0f; // unused

                        // Find the location within the cell (cells are the size of the heightmap pixels)
                        cellPos.x = UnityEngine.Random.Range(landscapePos.x, landscapePos.x + gVars.terrainHeightmapCellSize.x);
                        cellPos.z = UnityEngine.Random.Range(landscapePos.z, landscapePos.z + gVars.terrainHeightmapCellSize.z);
                        GetLandscapeInterpolatedData(gVars.terrainDataArray, gVars.terrainRectsArray, new Vector2(cellPos.x, cellPos.z), ref thisTerrainPointHeight);
                        cellPos.y = thisTerrainPointHeight;

                        // cellPosN is the normalised (0-1.0f) clearing position within the landscape
                        cellPosN.x = cellPos.x / gVars.landscapeWidth;
                        cellPosN.z = cellPos.z / gVars.landscapeLength;
                        cellPosN.y = cellPos.y / gVars.terrainHeight;

                        // Basic group placement position looks okay
                        isGroupPlacementPositionOk = true;

                        // Get the radius for this clearing. Always use Random, even when min/max the same - for more predictable results.
                        clearingRadius = UnityEngine.Random.Range(lbGroup.minClearingRadius, lbGroup.maxClearingRadius);

                        #region Group-level Stencil Filters
                        // Check the Stencil Filters (if any)
                        if (isGroupTypeProceduralClearing && gVars.isStencilLayerFiltersToApply[activeGpIdx])
                        {
                            // Get the normalised position in the landscape
                            gVars.stencilLayerPosN.x = cellPosN.x;
                            gVars.stencilLayerPosN.y = cellPosN.z;

                            if (LBFilter.IsPointFilteredByStencils(lbGroup.filterList, gVars.stencilLayerPosN)) { isGroupPlacementPositionOk = false; continue; }
                            // Are we trying to filter placement based on the whole area of the Group?
                            else if (lbGroup.isClearingRadiusFiltered)
                            {
                                // Check the parimeter
                                Vector2 clearingRadiusN = new Vector2(clearingRadius / gVars.landscapeWidth, clearingRadius / gVars.landscapeLength);
                                // Top of clearing
                                gVars.stencilLayerPosN.y = cellPosN.z + clearingRadiusN.y > 1f ? 1f : cellPosN.z + clearingRadiusN.y;
                                if (LBFilter.IsPointFilteredByStencils(lbGroup.filterList, gVars.stencilLayerPosN)) { isGroupPlacementPositionOk = false; continue; }
                                else
                                {
                                    // Bottom of clearing
                                    gVars.stencilLayerPosN.y = cellPosN.z - clearingRadiusN.y < 0f ? 0f : cellPosN.z - clearingRadiusN.y;
                                    if (LBFilter.IsPointFilteredByStencils(lbGroup.filterList, gVars.stencilLayerPosN)) { isGroupPlacementPositionOk = false; continue; }
                                    else
                                    {
                                        // Right of clearing
                                        gVars.stencilLayerPosN.x = cellPosN.x + clearingRadiusN.x > 1f ? 1f : cellPosN.x + clearingRadiusN.x;
                                        gVars.stencilLayerPosN.y = cellPosN.z;
                                        if (LBFilter.IsPointFilteredByStencils(lbGroup.filterList, gVars.stencilLayerPosN)) { isGroupPlacementPositionOk = false; continue; }
                                        else
                                        {
                                            // Left of clearing
                                            gVars.stencilLayerPosN.x = cellPosN.x - clearingRadiusN.x < 0f ? 0f : cellPosN.x - clearingRadiusN.x;
                                            if (LBFilter.IsPointFilteredByStencils(lbGroup.filterList, gVars.stencilLayerPosN)) { isGroupPlacementPositionOk = false; continue; }
                                            else
                                            {
                                                // Calculate 2D offset on x,y for the quadrants of the circle (Group)
                                                // x^2 + y^2 = r^2. Use the middle of the quadrants so x = y.  = Sqrt(r^2 / 2)
                                                float filterOffset = Mathf.Sqrt(clearingRadius * clearingRadius / 2f);
                                                Vector2 filterOffsetN = new Vector2(filterOffset / gVars.landscapeWidth, filterOffset / gVars.landscapeLength);

                                                // Top Right of circle (Group)
                                                gVars.stencilLayerPosN.x = cellPosN.x + filterOffsetN.x > 1f ? 1f : cellPosN.x + filterOffsetN.x;
                                                gVars.stencilLayerPosN.y = cellPosN.z + filterOffsetN.y > 1f ? 1f : cellPosN.z + filterOffsetN.y;
                                                if (LBFilter.IsPointFilteredByStencils(lbGroup.filterList, gVars.stencilLayerPosN)) { isGroupPlacementPositionOk = false; continue; }
                                                else
                                                {
                                                    // Bottom Right
                                                    gVars.stencilLayerPosN.y = cellPosN.z - filterOffsetN.y < 0f ? 0f : cellPosN.z - filterOffsetN.y;
                                                    if (LBFilter.IsPointFilteredByStencils(lbGroup.filterList, gVars.stencilLayerPosN)) { isGroupPlacementPositionOk = false; continue; }
                                                    else
                                                    {
                                                        // Bottom Left
                                                        gVars.stencilLayerPosN.x = cellPosN.x - filterOffsetN.x < 0f ? 0f : cellPosN.x - filterOffsetN.x;
                                                        if (LBFilter.IsPointFilteredByStencils(lbGroup.filterList, gVars.stencilLayerPosN)) { isGroupPlacementPositionOk = false; continue; }
                                                        else
                                                        {
                                                            // Top Left
                                                            gVars.stencilLayerPosN.y = cellPosN.z + filterOffsetN.y > 1f ? 1f : cellPosN.z + filterOffsetN.y;
                                                            if (LBFilter.IsPointFilteredByStencils(lbGroup.filterList, gVars.stencilLayerPosN)) { isGroupPlacementPositionOk = false; continue; }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        #endregion

                        #region Group Proximity

                        if (isGroupPlacementPositionOk)
                        {
                            // Find which cell we are in
                            gVars.proximityGroupCellXCoord = (int)(cellPosN.x * gVars.proximityGroupCellsListWidth);
                            gVars.proximityGroupCellZCoord = (int)(cellPosN.z * gVars.proximityGroupCellsListWidth);
                            if (gVars.proximityGroupCellXCoord >= gVars.proximityGroupCellsListWidth) { gVars.proximityGroupCellXCoord = gVars.proximityGroupCellsListWidth - 1; }
                            if (gVars.proximityGroupCellZCoord >= gVars.proximityGroupCellsListWidth) { gVars.proximityGroupCellZCoord = gVars.proximityGroupCellsListWidth - 1; }
                            gVars.thisGroupProximityCellIndex = gVars.proximityGroupCellXCoord + (gVars.proximityGroupCellZCoord * gVars.proximityGroupCellsListWidth);
                            if (gVars.thisGroupProximityCellIndex < 0) { gVars.thisGroupProximityCellIndex = 0; }
                            else if (gVars.thisGroupProximityCellIndex >= gVars.totalProximityGroupCells) { gVars.thisGroupProximityCellIndex = gVars.totalProximityGroupCells - 1; }

                            // Get a new list to store object proximities in
                            gVars.thisGroupProximitiesList.Clear();
                            // Add the object proximities from this cell
                            gVars.thisGroupProximitiesList.AddRange(gVars.groupProximitiesList[gVars.thisGroupProximityCellIndex]);
                            // Then add the object proximities from any surrounding cells
                            if (gVars.proximityGroupCellXCoord > 0)
                            {
                                // Bottom left cell
                                if (gVars.proximityGroupCellZCoord > 0) { gVars.thisGroupProximitiesList.AddRange(gVars.groupProximitiesList[gVars.thisGroupProximityCellIndex - gVars.proximityGroupCellsListWidth - 1]); }
                                // Top left cell
                                if (gVars.proximityGroupCellZCoord < gVars.proximityGroupCellsListWidth - 1) { gVars.thisGroupProximitiesList.AddRange(gVars.groupProximitiesList[gVars.thisGroupProximityCellIndex + gVars.proximityGroupCellsListWidth - 1]); }
                                // Centre left cell
                                gVars.thisGroupProximitiesList.AddRange(gVars.groupProximitiesList[gVars.thisGroupProximityCellIndex - 1]);
                            }
                            if (gVars.proximityGroupCellXCoord < gVars.proximityGroupCellsListWidth - 1)
                            {
                                // Bottom right cell
                                if (gVars.proximityGroupCellZCoord > 0) { gVars.thisGroupProximitiesList.AddRange(gVars.groupProximitiesList[gVars.thisGroupProximityCellIndex - gVars.proximityGroupCellsListWidth + 1]); }
                                // Top right cell
                                if (gVars.proximityGroupCellZCoord < gVars.proximityGroupCellsListWidth - 1) { gVars.thisGroupProximitiesList.AddRange(gVars.groupProximitiesList[gVars.thisGroupProximityCellIndex + gVars.proximityGroupCellsListWidth + 1]); }
                                // Centre right cell
                                gVars.thisGroupProximitiesList.AddRange(gVars.groupProximitiesList[gVars.thisGroupProximityCellIndex + 1]);
                            }
                            // Bottom centre cell
                            if (gVars.proximityGroupCellZCoord > 0) { gVars.thisGroupProximitiesList.AddRange(gVars.groupProximitiesList[gVars.thisGroupProximityCellIndex - gVars.proximityGroupCellsListWidth]); }
                            // Top centre cell
                            if (gVars.proximityGroupCellZCoord < gVars.proximityGroupCellsListWidth - 1) { gVars.thisGroupProximitiesList.AddRange(gVars.groupProximitiesList[gVars.thisGroupProximityCellIndex + gVars.proximityGroupCellsListWidth]); }

                            // Then use this list to check if this mesh/prefab position is too close to another object
                            isGroupPlacementPositionOk = !gVars.thisGroupProximitiesList.Exists(msh => (((cellPos.x - msh.position.x) * (cellPos.x - msh.position.x)) + ((cellPos.z - msh.position.z) * (cellPos.z - msh.position.z)))
                                    < (msh.proximity + lbGroup.proximityExtent) * (msh.proximity + lbGroup.proximityExtent));
                        }

                        #endregion
                    }

                    // If group placement is validated, add the group
                    if (isGroupPlacementPositionOk)
                    {
                        #region Flattening Rect and Group Radius is recorded (is determined above)

                        if (lbGroup.isTerrainFlattened)
                        {
                            // Do cellPos first, then cellPosN which results in one less multiplication
                            cellPos.y += lbGroup.flattenHeightOffset;
                            cellPos.y = cellPos.y < 0 ? 0 : (cellPos.y > gVars.terrainHeight ? gVars.terrainHeight : cellPos.y);
                            cellPosN.y = cellPos.y / gVars.terrainHeight;
                        }

                        // Remember the normalised position of this (clearing) group
                        groupPosNList.Add(cellPosN);

                        // Get the radius for this clearing. Always use Random, even when min/max the same - for more predictable results.
                        //clearingRadius = UnityEngine.Random.Range(lbGroup.minClearingRadius, lbGroup.maxClearingRadius);

                        // Add the radius
                        groupRadiusList.Add(clearingRadius);

                        if (lbGroup.isTerrainFlattened)
                        {
                            // Get the rectangle that defines the circular area of the clearing that will be flattened
                            // NOTE: Adding the rect directly to the Add(..) isn't any faster.
                            Rect flattenRect = Rect.MinMaxRect(cellPos.x + gVars.landscapePosition.x - clearingRadius, cellPos.z + gVars.landscapePosition.z - clearingRadius, cellPos.x + gVars.landscapePosition.x + clearingRadius, cellPos.z + gVars.landscapePosition.z + clearingRadius);
                            groupRectList.Add(flattenRect);
                            flattenBlendRateList.Add(lbGroup.flattenBlendRate);
                        }

                        #endregion

                        #region Store Group Proximity Data In List

                        // If this group placement is OK, we have already calculated the correct cell for proximity
                        gVars.groupProximitiesList[gVars.thisGroupProximityCellIndex].Add(new LBObjectProximity(cellPos, lbGroup.proximityExtent));

                        #endregion

                        numberOfGroupsCreated++;
                    }
                }

                numGroupPositions = groupPosNList.Count;
                numGroupRects = groupRectList.Count;
                numGroupRadii = groupRadiusList.Count;

                if (numGroupPositions > 0 && numGroupRadii == numGroupPositions)
                {
                    if (lbGroup.isTerrainFlattened && numGroupRects > 0)
                    {
                        FlattenModifier(gVars.lbGroupParams.landscape, groupPosNList, groupRectList, flattenBlendRateList,
                                        gVars.lbGroupParams.showProgressDelegate, lbGroup.groupName, gVars.lbGroupParams.showErrors);
                    }
                }
            }
            #endregion

            #region Manual Clearing placement
            else if (isGroupTypeManualClearing || isGroupTypeSubGroup)
            {
                // Currently there is only 1 position for a SubGroup placement. However, a more optimised version would have a list of them.
                // SubGroups are very similar to Manual Clearings
                numGroupPositions = lbGroup.positionList == null ? 0 : lbGroup.positionList.Count;

                for (int manIdx = 0; manIdx < numGroupPositions; manIdx++)
                {
                    cellPos = lbGroup.positionList[manIdx];

                    // NOTE: SubGroups have their height set when they are placed along an Object Path in the parent Group
                    // Manual Groups need to sample the height of the terrain
                    if (isGroupTypeManualClearing)
                    {
                        GetLandscapeInterpolatedData(gVars.terrainDataArray, gVars.terrainRectsArray, new Vector2(cellPos.x, cellPos.z), ref thisTerrainPointHeight);
                        cellPos.y = thisTerrainPointHeight;
                    }

                    // cellPosN is the normalised (0-1.0f) clearing or subgroup position within the landscape
                    cellPosN.x = cellPos.x / gVars.landscapeWidth;
                    cellPosN.z = cellPos.z / gVars.landscapeLength;
                    cellPosN.y = cellPos.y / gVars.terrainHeight;

                    if (lbGroup.isTerrainFlattened)
                    {
                        // Do cellPos first, then cellPosN which results in one less multiplication
                        cellPos.y += lbGroup.flattenHeightOffset;
                        cellPos.y = cellPos.y < 0 ? 0 : (cellPos.y > gVars.terrainHeight ? gVars.terrainHeight : cellPos.y);
                        cellPosN.y = cellPos.y / gVars.terrainHeight;
                    }

                    // Remember the normalised position of this (manual clearing) group
                    groupPosNList.Add(cellPosN);

                    // Get the radius for this clearing. Always use Random, even when min/max the same - for more predictable results.
                    clearingRadius = UnityEngine.Random.Range(lbGroup.minClearingRadius, lbGroup.maxClearingRadius);
                    groupRadiusList.Add(clearingRadius);

                    if (lbGroup.isTerrainFlattened)
                    {
                        // Get the rectangle that defines the circular area of the clearing that will be flattened
                        // NOTE: Adding the rect directly to the Add(..) isn't any faster.
                        Rect flattenRect = Rect.MinMaxRect(cellPos.x + gVars.landscapePosition.x - clearingRadius, cellPos.z + gVars.landscapePosition.z - clearingRadius, cellPos.x + gVars.landscapePosition.x + clearingRadius, cellPos.z + gVars.landscapePosition.z + clearingRadius);
                        groupRectList.Add(flattenRect);
                        flattenBlendRateList.Add(lbGroup.flattenBlendRate);
                    }
                }

                numGroupRects = groupRectList.Count;
                numGroupRadii = groupRadiusList.Count;

                if (numGroupPositions > 0 && numGroupRadii == numGroupPositions)
                {
                    if (lbGroup.isTerrainFlattened && numGroupRects > 0)
                    {
                        FlattenModifier(gVars.lbGroupParams.landscape, groupPosNList, groupRectList, flattenBlendRateList,
                                        gVars.lbGroupParams.showProgressDelegate, lbGroup.groupName, gVars.lbGroupParams.showErrors);
                    }
                }
            }
            #endregion

            #endregion

            #region Get Number of Regions
            if (isGroupTypeUniform)
            {
                numRegions = 1;
                regionMemberPlacementListSize = regionGroupPlacementListSize;
                clearingRotationY = 0f;
            }
            else if (isGroupTypeProceduralClearing || isGroupTypeManualClearing)
            {
                numRegions = 0;
                if (numGroupPositions > 0)
                {
                    if (numGroupRadii == numGroupPositions) { numRegions = numGroupPositions; }
                    else { if (gVars.lbGroupParams.showErrors) { Debug.LogWarning("ERROR: " + methodName + " - clearing region list mismatch in " + lbGroup.groupName + ". Please report."); } }

                    // If user-set rotations, make sure the lists are synchronized to avoid issues.
                    if (isGroupTypeManualClearing && lbGroup.isFixedRotation) { lbGroup.SyncRotationList(); }
                }
            }
            else if (isGroupTypeSubGroup)
            {
                numRegions = 0;
                if (numGroupPositions > 0)
                {
                    if (numGroupRadii == numGroupPositions) { numRegions = numGroupPositions; }
                    else { if (gVars.lbGroupParams.showErrors) { Debug.LogWarning("ERROR: " + methodName + " - subgroup region list mismatch in " + lbGroup.groupName + ". Please report."); } }
                }
            }
            #endregion

            // Is texturing required for this group?
            bool isTexturingRequiredForGroup = lbGroup.textureList == null ? false : lbGroup.textureList.Exists(tx => !string.IsNullOrEmpty(tx.lbTerrainTextureGUID));
            // Is grass population required for this group?
            bool isGrassPopulationRequiredForGroup = lbGroup.grassList == null ? false : lbGroup.grassList.Exists(grs => !string.IsNullOrEmpty(grs.lbTerrainGrassGUID));

            // Loop through all the Group regions (clearing instances)
            for (regionIdx = 0; regionIdx < numRegions; regionIdx++)
            {
                #region Initialise Clearing Region

                if (isGroupTypeProceduralClearing || isGroupTypeManualClearing || isGroupTypeSubGroup)
                {
                    if (regionIdx < numGroupRadii)
                    {
                        // Each clearing can potentially be a different size
                        clearingRadius = groupRadiusList[regionIdx];
                        // Normalised position of the clearing within the landscape (or parent group in the GroupDesigner) (0.0-1.0)
                        groupPositionNormalised = groupPosNList[regionIdx];
                        if (gVars.isGroupDesignerEnabled && isChildGroup)
                        {
                            groupPosition.x = groupPositionNormalised.x * parentGroup.maxClearingRadius;
                            groupPosition.z = groupPositionNormalised.z * parentGroup.maxClearingRadius;
                            groupPositionWS.x = groupPosition.x;
                            groupPositionWS.y = 0f;
                            groupPositionWS.z = groupPosition.z;
                        }
                        else if (gVars.isGroupDesignerEnabled)
                        {
                            groupPosition.x = groupPositionNormalised.x * gVars.landscapeWidth;
                            groupPosition.z = groupPositionNormalised.z * gVars.landscapeLength;
                            groupPositionWS.x = groupPosition.x;
                            groupPositionWS.y = 0f;
                            groupPositionWS.z = groupPosition.z;
                        }
                        else
                        {
                            groupPosition.x = groupPositionNormalised.x * gVars.landscapeWidth;
                            groupPosition.z = groupPositionNormalised.z * gVars.landscapeLength;
                            groupPositionWS.x = groupPosition.x + gVars.landscapePosition.x;
                            groupPositionWS.y = gVars.landscapePosition.y;
                            groupPositionWS.z = groupPosition.z + gVars.landscapePosition.z;
                        }
                        // Calculate width and starting points of placement list
                        clearingPlacementListWidth = (int)((clearingRadius * 2f / gVars.landscapeWidth) * (gVars.landscapeHeightmapResolution - 1)) + 1;
                        clearingMinXIndex = (int)((groupPositionNormalised.x - (clearingRadius / gVars.landscapeWidth)) * (gVars.landscapeHeightmapResolution - 1));
                        clearingMinZIndex = (int)((groupPositionNormalised.z - (clearingRadius / gVars.landscapeLength)) * (gVars.landscapeHeightmapResolution - 1));

                        // Generate a random rotation for this clearing (used for "group space")
                        // NOTE: We run this for all group regions (even though it is not required) so we get more predictable results.
                        clearingRotationY = UnityEngine.Random.Range(lbGroup.startClearingRotationY, lbGroup.endClearingRotationY);

                        if (gVars.isGroupDesignerEnabled && !isChildGroup) { clearingRotationY = 0f; }
                        else if (isGroupTypeManualClearing && lbGroup.isFixedRotation)
                        {
                            // User has set fixed rotations for each region or instance of a manual clearing in the landscape
                            clearingRotationY = lbGroup.rotationYList[regionIdx];
                        }
                        else if (isGroupTypeSubGroup)
                        {
                            // Add the subgroup rotation to the rotation of the parent Group.
                            // This works in the scene AND in the GroupDesigner
                            clearingRotationY += lbGroup.subGroupRotationList[regionIdx].y;
                        }

                        #region Add SubGroup DesignerItem to GroupDesigner
                        #if UNITY_EDITOR && LB_EDITOR
                        if (gVars.isGroupDesignerEnabled && isChildGroup)
                        {
                            LBGroupDesignerItem lbGroupDesignerItem = LBGroupDesignerItem.CreateSubGroupItem(gVars.lbGroupParams.landscape.transform, parentGroup, parentGroupMember, lbGroup, new Vector3(groupPosition.x, gVars.lbGroupParams.designerOffsetY, groupPosition.z), lbGroup.subGroupRotationList[regionIdx], clearingRadius, regionIdx);
                            if (lbGroupDesignerItem != null) { }
                        }
                        #endif
                        #endregion

                        #region Vegetation Studio Pro Vegetation Biome and Mask Areas

                        #if VEGETATION_STUDIO_PRO
                        // Create Vegetation Mask Areas for whole group and/or from NOT Rectangle/Circle zones
                        if (!gVars.isGroupDesignerEnabled && gVars.lbGroupParams.landscape.useVegetationSystem)
                        {
                            // Calc group position in worldspace once, then apply to area nodes below
                            groupPosWorldSpace = groupPosition + gVars.landscapePosition;

                            #region Biome Mask Areas Group-level Filters
                            int numFilters = lbGroup.filterList == null ? 0 : lbGroup.filterList.Count;
                            for (int ftIdx = 0; ftIdx < numFilters; ftIdx++)
                            {
                                LBFilter lbFilter = lbGroup.filterList[ftIdx];
                                if (lbFilter != null && lbFilter.filterType == LBFilter.FilterType.Biome)
                                {
                                    // Create a Biome Mask Area of the whole group
                                    string maskName = "[BIOMEMASK] " + lbGroup.groupName + ".wholegroup." + (regionIdx + 1);

                                    biomeMaskArea = LBIntegration.VegetationStudioProCreateBiomeMaskArea(gVars.vsPro, maskName, gVars.lbGroupParams.landscape.transform, lbFilter.lbBiome);
                                    if (biomeMaskArea != null)
                                    {
                                        List<AwesomeTechnologies.VegetationSystem.Biomes.Node> areaNodes = biomeMaskArea.Nodes;
                                        AwesomeTechnologies.VegetationSystem.Biomes.Node areaNode;

                                        CircleToPolygon(polygonPointList, Vector3.zero, clearingRadius, false);
                                        int numPolygonPoints = polygonPointList == null ? 0 : polygonPointList.Count;
                                        areaNodes.Clear();
                                        for (int pptIdx = 0; pptIdx < numPolygonPoints; pptIdx++)
                                        {
                                            areaNode = new AwesomeTechnologies.VegetationSystem.Biomes.Node();
                                            if (areaNode != null)
                                            {
                                                // Apply clearing rotation if required in group-space
                                                if (clearingRotationY != 0f) { areaNode.Position = Quaternion.Euler(0f, clearingRotationY, 0f) * polygonPointList[pptIdx]; }
                                                else { areaNode.Position = polygonPointList[pptIdx]; }

                                                // Convert into world-space
                                                areaNode.Position += groupPosWorldSpace;

                                                areaNodes.Add(areaNode);
                                            }
                                        }
                                    }
                                }
                            }

                            #endregion

                            #region Biome Mask Areas for Zones
                            int numZones = lbGroup.zoneList == null ? 0 : lbGroup.zoneList.Count;
                            for (zoneListIndex = 0; zoneListIndex < numZones; zoneListIndex++)
                            {
                                thisZone = lbGroup.zoneList[zoneListIndex];
                                if (thisZone != null && thisZone.useBiome && thisZone.lbBiome != null)
                                {
                                    // Create a Biome Mask Area of the zone
                                    string maskName = "[BIOMEMASK] " + lbGroup.groupName + "." + (thisZone.zoneName == null ? "zone" : thisZone.zoneName) + "." + (regionIdx + 1);

                                    biomeMaskArea = LBIntegration.VegetationStudioProCreateBiomeMaskArea(gVars.vsPro, maskName, gVars.lbGroupParams.landscape.transform, thisZone.lbBiome);
                                    if (biomeMaskArea != null)
                                    {
                                        // The centrePoint (X and Z) is normalised to the group
                                        // Get position of zone within the Group in metres.
                                        // NOTE: Don't apply rotation here, as we need to apply it last.
                                        zonePosGroupSpacem.x = (thisZone.centrePointX * clearingRadius);
                                        zonePosGroupSpacem.z = (thisZone.centrePointZ * clearingRadius);

                                        List<AwesomeTechnologies.VegetationSystem.Biomes.Node> areaNodes = biomeMaskArea.Nodes;
                                        AwesomeTechnologies.VegetationSystem.Biomes.Node areaNode;

                                        if (thisZone.zoneType == LBGroupZone.LBGroupZoneType.circle)
                                        {
                                            CircleToPolygon(polygonPointList, zonePosGroupSpacem, thisZone.width * clearingRadius, false);
                                            int numPolygonPoints = polygonPointList == null ? 0 : polygonPointList.Count;
                                            areaNodes.Clear();
                                            for (int pptIdx = 0; pptIdx < numPolygonPoints; pptIdx++)
                                            {
                                                areaNode = new AwesomeTechnologies.VegetationSystem.Biomes.Node();
                                                if (areaNode != null)
                                                {
                                                    // Apply clearing rotation if required in group-space
                                                    if (clearingRotationY != 0f) { areaNode.Position = Quaternion.Euler(0f, clearingRotationY, 0f) * polygonPointList[pptIdx]; }
                                                    else { areaNode.Position = polygonPointList[pptIdx]; }

                                                    // Convert into world-space
                                                    areaNode.Position += groupPosWorldSpace;

                                                    areaNodes.Add(areaNode);
                                                }
                                            }
                                        }
                                        else if (thisZone.zoneType == LBGroupZone.LBGroupZoneType.rectangle)
                                        {
                                            // By default there should be four nodes
                                            if (areaNodes.Count == 4)
                                            {
                                                zoneWidthm = thisZone.width * clearingRadius / 2f;
                                                zoneLengthm = thisZone.length * clearingRadius / 2f;
                                                // Top left
                                                areaNodes[0].Position.x = zonePosGroupSpacem.x - zoneWidthm;
                                                areaNodes[0].Position.z = zonePosGroupSpacem.z + zoneLengthm;
                                                // Top right
                                                areaNodes[1].Position.x = zonePosGroupSpacem.x + zoneWidthm;
                                                areaNodes[1].Position.z = zonePosGroupSpacem.z + zoneLengthm;
                                                // Bottom right
                                                areaNodes[2].Position.x = zonePosGroupSpacem.x + zoneWidthm;
                                                areaNodes[2].Position.z = zonePosGroupSpacem.z - zoneLengthm;
                                                // Bottom left
                                                areaNodes[3].Position.x = zonePosGroupSpacem.x - zoneWidthm;
                                                areaNodes[3].Position.z = zonePosGroupSpacem.z - zoneLengthm;
                                                // Apply clearing rotation if required
                                                if (clearingRotationY != 0f)
                                                {
                                                    areaNodes[0].Position = Quaternion.Euler(0f, clearingRotationY, 0f) * areaNodes[0].Position;
                                                    areaNodes[1].Position = Quaternion.Euler(0f, clearingRotationY, 0f) * areaNodes[1].Position;
                                                    areaNodes[2].Position = Quaternion.Euler(0f, clearingRotationY, 0f) * areaNodes[2].Position;
                                                    areaNodes[3].Position = Quaternion.Euler(0f, clearingRotationY, 0f) * areaNodes[3].Position;
                                                }

                                                areaNodes[0].Position += groupPosWorldSpace;
                                                areaNodes[1].Position += groupPosWorldSpace;
                                                areaNodes[2].Position += groupPosWorldSpace;
                                                areaNodes[3].Position += groupPosWorldSpace;

                                                // It's ok for handles to be on when there is only 4 of them
                                                biomeMaskArea.ShowHandles = true;
                                            }
                                        }
                                    }
                                }
                            }
                            #endregion

                            #region Vegetation Mask Area of the whole group
                            if (lbGroup.isRemoveExistingGrass)
                            {
                                // Create a Vegetation Mask Area of the whole group
                                string maskName = "[VEGMASK] " + lbGroup.groupName + ".wholegroup." + (regionIdx + 1);
                                vegetationMaskArea = LBIntegration.VegetationStudioProCreateVegMaskArea(maskName, gVars.lbGroupParams.landscape.transform);

                                if (vegetationMaskArea != null)
                                {
                                    // Don't think we need this...
                                    vspZoneGameObject = vegetationMaskArea.gameObject;

                                    // Update settings for this Vegetation Mask Area
                                    vegetationMaskArea.RemoveTrees = false;
                                    vegetationMaskArea.RemoveLargeObjects = false;
                                    vegetationMaskArea.RemoveObjects = false;
                                    vegetationMaskArea.RemovePlants = false;
                                    vegetationMaskArea.RemoveGrass = true;
                                    vegetationMaskArea.AdditionalGrassPerimiter = 0f;
                                    vegetationMaskArea.AdditionalGrassPerimiterMax = lbGroup.removeExistingGrassBlendDist * clearingRadius;

                                    List<AwesomeTechnologies.Node> areaNodes = vegetationMaskArea.Nodes;
                                    AwesomeTechnologies.Node areaNode;

                                    CircleToPolygon(polygonPointList, Vector3.zero, clearingRadius, false);
                                    int numPolygonPoints = polygonPointList == null ? 0 : polygonPointList.Count;
                                    areaNodes.Clear();
                                    for (int pptIdx = 0; pptIdx < numPolygonPoints; pptIdx++)
                                    {
                                        areaNode = new AwesomeTechnologies.Node();
                                        if (areaNode != null)
                                        {
                                            // Apply clearing rotation if required in group-space
                                            if (clearingRotationY != 0f) { areaNode.Position = Quaternion.Euler(0f, clearingRotationY, 0f) * polygonPointList[pptIdx]; }
                                            else { areaNode.Position = polygonPointList[pptIdx]; }

                                            // Convert into world-space
                                            areaNode.Position += groupPosWorldSpace;

                                            areaNodes.Add(areaNode);
                                        }
                                    }
                                }
                            }
                            #endregion

                            #region Vegetation Mask Areas for Zones
                            if (isGrassPopulationRequiredForGroup)
                            {
                                List<string> grassZoneGUIDList = new List<string>();

                                // Loop through all the LBTerrainGrasses
                                // Get a distinct list of Zone GUIDs
                                for (gVars.grsIdx = 0; gVars.grsIdx < gVars.terrainGrassListSize; gVars.grsIdx++)
                                {
                                    // Is the LBTerrainGrass being used in this Group?
                                    LBGroupGrass lbGroupGrass = lbGroup.grassList.Find(gGx => gGx.lbTerrainGrassGUID == gVars.terrainGrassList[gVars.grsIdx].GUID);
                                    if (lbGroupGrass != null)
                                    {
                                        // Loop through all the zones for this LBGroupGrass
                                        for (zoneListIndex = 0; zoneListIndex < lbGroupGrass.zoneGUIDList.Count; zoneListIndex++)
                                        {
                                            // If this hasn't been added to the list already, add it now
                                            if (!grassZoneGUIDList.Exists(gz => gz == lbGroupGrass.zoneGUIDList[zoneListIndex]))
                                            {
                                                grassZoneGUIDList.Add(lbGroupGrass.zoneGUIDList[zoneListIndex]);
                                            }
                                        }
                                    }
                                }

                                // Process the list of distinct zones
                                int numGrassZones = (grassZoneGUIDList == null ? 0 : grassZoneGUIDList.Count);
                                for (zoneListIndex = 0; zoneListIndex < numGrassZones; zoneListIndex++)
                                {
                                    // Find the zone
                                    thisZone = lbGroup.zoneList.Find(z => z.GUID == grassZoneGUIDList[zoneListIndex]);
                                    string maskName = "[VEGMASK] " + lbGroup.groupName + "." + (thisZone.zoneName == null ? "zone" : thisZone.zoneName) + "." + (regionIdx + 1);

                                    vegetationMaskArea = LBIntegration.VegetationStudioProCreateVegMaskArea(maskName, gVars.lbGroupParams.landscape.transform);

                                    if (vegetationMaskArea != null)
                                    {
                                        // The centrePoint (X and Z) is normalised to the group
                                        // Get position of zone within the Group in metres.
                                        // NOTE: Don't apply rotation here, as we need to apply it last.
                                        zonePosGroupSpacem.x = (thisZone.centrePointX * clearingRadius);
                                        zonePosGroupSpacem.z = (thisZone.centrePointZ * clearingRadius);

                                        // Update settings for this Vegetation Mask Area
                                        vegetationMaskArea.RemoveTrees = false;
                                        vegetationMaskArea.RemoveLargeObjects = false;
                                        vegetationMaskArea.RemoveObjects = false;
                                        vegetationMaskArea.RemovePlants = false;
                                        vegetationMaskArea.RemoveGrass = true;

                                        // TODO - Add grasses to the mask area
                                        if (thisZone.zoneMode == LBGroupZone.ZoneMode.OR)
                                        {

                                        }

                                        List<AwesomeTechnologies.Node> areaNodes = vegetationMaskArea.Nodes;
                                        AwesomeTechnologies.Node areaNode;

                                        if (thisZone.zoneType == LBGroupZone.LBGroupZoneType.circle)
                                        {
                                            CircleToPolygon(polygonPointList, zonePosGroupSpacem, thisZone.width * clearingRadius, false);
                                            int numPolygonPoints = polygonPointList == null ? 0 : polygonPointList.Count;
                                            areaNodes.Clear();
                                            for (int pptIdx = 0; pptIdx < numPolygonPoints; pptIdx++)
                                            {
                                                areaNode = new AwesomeTechnologies.Node();
                                                if (areaNode != null)
                                                {
                                                    // Apply clearing rotation if required in group-space
                                                    if (clearingRotationY != 0f) { areaNode.Position = Quaternion.Euler(0f, clearingRotationY, 0f) * polygonPointList[pptIdx]; }
                                                    else { areaNode.Position = polygonPointList[pptIdx]; }

                                                    // Convert into world-space
                                                    areaNode.Position += groupPosWorldSpace;

                                                    areaNodes.Add(areaNode);
                                                }
                                            }
                                        }
                                        else if (thisZone.zoneType == LBGroupZone.LBGroupZoneType.rectangle)
                                        {
                                            // By default there should be four nodes
                                            if (areaNodes.Count == 4)
                                            {
                                                zoneWidthm = thisZone.width * clearingRadius / 2f;
                                                zoneLengthm = thisZone.length * clearingRadius / 2f;
                                                // Top left
                                                areaNodes[0].Position.x = zonePosGroupSpacem.x - zoneWidthm;
                                                areaNodes[0].Position.z = zonePosGroupSpacem.z + zoneLengthm;
                                                // Top right
                                                areaNodes[1].Position.x = zonePosGroupSpacem.x + zoneWidthm;
                                                areaNodes[1].Position.z = zonePosGroupSpacem.z + zoneLengthm;
                                                // Bottom right
                                                areaNodes[2].Position.x = zonePosGroupSpacem.x + zoneWidthm;
                                                areaNodes[2].Position.z = zonePosGroupSpacem.z - zoneLengthm;
                                                // Bottom left
                                                areaNodes[3].Position.x = zonePosGroupSpacem.x - zoneWidthm;
                                                areaNodes[3].Position.z = zonePosGroupSpacem.z - zoneLengthm;
                                                // Apply clearing rotation if required
                                                if (clearingRotationY != 0f)
                                                {
                                                    areaNodes[0].Position = Quaternion.Euler(0f, clearingRotationY, 0f) * areaNodes[0].Position;
                                                    areaNodes[1].Position = Quaternion.Euler(0f, clearingRotationY, 0f) * areaNodes[1].Position;
                                                    areaNodes[2].Position = Quaternion.Euler(0f, clearingRotationY, 0f) * areaNodes[2].Position;
                                                    areaNodes[3].Position = Quaternion.Euler(0f, clearingRotationY, 0f) * areaNodes[3].Position;
                                                }

                                                areaNodes[0].Position += groupPosWorldSpace;
                                                areaNodes[1].Position += groupPosWorldSpace;
                                                areaNodes[2].Position += groupPosWorldSpace;
                                                areaNodes[3].Position += groupPosWorldSpace;

                                                // It's ok for handles to be on when there is only 4 of them
                                                vegetationMaskArea.ShowHandles = true;
                                            }
                                        }
                                    }

                                }
                            }
                            #endregion
                        }

                        #endif

                        #endregion

                        #region Clearing Grass Removal

                        // If required, remove all grass from this clearing
                        if (lbGroup.isRemoveExistingGrass)
                        {
                            // Get the min, max and centre coordinates of the area which grass will be removed from
                            gVars.grassAreaNoBlendRadius = clearingRadius / (float)gVars.grassArrayCellSize;
                            gVars.grassAreaRadius = (int)(gVars.grassAreaNoBlendRadius * (1f + lbGroup.removeExistingGrassBlendDist));
                            if (gVars.grassAreaNoBlendRadius > gVars.grassAreaRadius) { gVars.grassAreaNoBlendRadius = gVars.grassAreaRadius; }
                            gVars.grassAreaCentreXIndex = (int)(groupPositionNormalised.x * gVars.grassArrayCellsListWidth);
                            gVars.grassAreaCentreZIndex = (int)(groupPositionNormalised.z * gVars.grassArrayCellsListWidth);
                            gVars.grassAreaMinXIndex = gVars.grassAreaCentreXIndex - gVars.grassAreaRadius;
                            gVars.grassAreaMaxXIndex = gVars.grassAreaCentreXIndex + gVars.grassAreaRadius;
                            gVars.grassAreaMinZIndex = gVars.grassAreaCentreZIndex - gVars.grassAreaRadius;
                            gVars.grassAreaMaxZIndex = gVars.grassAreaCentreZIndex + gVars.grassAreaRadius;

                            // Clamp area to within the bounds of the landscape
                            if (gVars.grassAreaMinXIndex < 0) { gVars.grassAreaMinXIndex = 0; }
                            if (gVars.grassAreaMaxXIndex > gVars.grassArrayCellsListWidth - 1) { gVars.grassAreaMaxXIndex = gVars.grassArrayCellsListWidth - 1; }
                            if (gVars.grassAreaMinZIndex < 0) { gVars.grassAreaMinZIndex = 0; }
                            if (gVars.grassAreaMaxZIndex > gVars.grassArrayCellsListWidth - 1) { gVars.grassAreaMaxZIndex = gVars.grassArrayCellsListWidth - 1; }

                            // Loop through the area cells
                            for (gVars.grassArrayCellXCoord = gVars.grassAreaMinXIndex; gVars.grassArrayCellXCoord <= gVars.grassAreaMaxXIndex; gVars.grassArrayCellXCoord++)
                            {
                                for (gVars.grassArrayCellZCoord = gVars.grassAreaMinZIndex; gVars.grassArrayCellZCoord <= gVars.grassAreaMaxZIndex; gVars.grassArrayCellZCoord++)
                                {
                                    // Get the distance to the centre of the removal area
                                    gVars.grassRemovalDist = (new Vector2(gVars.grassArrayCellXCoord - gVars.grassAreaCentreXIndex, gVars.grassArrayCellZCoord - gVars.grassAreaCentreZIndex)).magnitude / gVars.grassAreaNoBlendRadius;
                                    // The middle area (measured radially) has no blending
                                    if (gVars.grassRemovalDist < 1f) { gVars.grassRemovalBlendFactor = 0f; }
                                    // The rest of the area blends out towards the edge
                                    else if (lbGroup.removeExistingGrassBlendDist == 0f) { gVars.grassRemovalBlendFactor = 1f; }
                                    else { gVars.grassRemovalBlendFactor = Mathf.Clamp01((gVars.grassRemovalDist - 1f) * (1f / lbGroup.removeExistingGrassBlendDist)); }
                                    // Only calculate anything if we have to do blending
                                    if (gVars.grassRemovalBlendFactor < 1f)
                                    {
                                        // Calculate the cell index in the grass removal array
                                        gVars.thisGrassArrayCellIndex = (gVars.grassArrayCellZCoord * gVars.grassArrayCellsListWidth) + gVars.grassArrayCellXCoord;
                                        // Set the new value to the minimum of:
                                        // a) the current grass strength value, and
                                        // b) the calculated grass strength value
                                        if (gVars.grassRemovalBlendFactor * 255f < gVars.initialGrassRemovalArray[gVars.thisGrassArrayCellIndex])
                                        {
                                            gVars.initialGrassRemovalArray[gVars.thisGrassArrayCellIndex] = (byte)(gVars.grassRemovalBlendFactor * 255f);
                                        }
                                    }
                                }
                            }
                        }

                        #endregion

                        #region Clearing Tree Removal

                        if (lbGroup.isRemoveExistingTrees)
                        {
                            // Find which cell corresponds to the centre of this group instance
                            gVars.proximityTreeCellXCoord = (int)(groupPositionNormalised.x * gVars.proximityTreeCellsListWidth);
                            gVars.proximityTreeCellZCoord = (int)(groupPositionNormalised.z * gVars.proximityTreeCellsListWidth);
                            if (gVars.proximityTreeCellXCoord >= gVars.proximityTreeCellsListWidth) { gVars.proximityTreeCellXCoord = gVars.proximityTreeCellsListWidth - 1; }
                            if (gVars.proximityTreeCellZCoord >= gVars.proximityTreeCellsListWidth) { gVars.proximityTreeCellZCoord = gVars.proximityTreeCellsListWidth - 1; }

                            // Calculate the radius of the clearing in proximity tree cells
                            gVars.proximityTreeCellBlockHalfWidth = Mathf.CeilToInt(clearingRadius / gVars.proximityTreeCellSize);
                            gVars.proximityTreeCellMinXCoord = gVars.proximityTreeCellXCoord - gVars.proximityTreeCellBlockHalfWidth;
                            gVars.proximityTreeCellMaxXCoord = gVars.proximityTreeCellXCoord + gVars.proximityTreeCellBlockHalfWidth;
                            gVars.proximityTreeCellMinZCoord = gVars.proximityTreeCellZCoord - gVars.proximityTreeCellBlockHalfWidth;
                            gVars.proximityTreeCellMaxZCoord = gVars.proximityTreeCellZCoord + gVars.proximityTreeCellBlockHalfWidth;
                            // Clamp the block min-max coordinates to the bounds of the landscape
                            if (gVars.proximityTreeCellMinXCoord < 0) { gVars.proximityTreeCellMinXCoord = 0; }
                            if (gVars.proximityTreeCellMinZCoord < 0) { gVars.proximityTreeCellMinZCoord = 0; }
                            if (gVars.proximityTreeCellMaxXCoord >= gVars.proximityTreeCellsListWidth) { gVars.proximityTreeCellMaxXCoord = gVars.proximityTreeCellsListWidth - 1; }
                            if (gVars.proximityTreeCellMaxZCoord >= gVars.proximityTreeCellsListWidth) { gVars.proximityTreeCellMaxZCoord = gVars.proximityTreeCellsListWidth - 1; }

                            // Get a new list to store object proximities in
                            gVars.thisTreeProximitiesList.Clear();

                            // Add the tree proximities from the calculated block
                            for (gVars.proximityTreeCellXCoord = gVars.proximityTreeCellMinXCoord; gVars.proximityTreeCellXCoord <= gVars.proximityTreeCellMaxXCoord; gVars.proximityTreeCellXCoord++)
                            {
                                for (gVars.proximityTreeCellZCoord = gVars.proximityTreeCellMinZCoord; gVars.proximityTreeCellZCoord <= gVars.proximityTreeCellMaxZCoord; gVars.proximityTreeCellZCoord++)
                                {
                                    // Calculate cell index
                                    gVars.thisTreeProximityCellIndex = gVars.proximityTreeCellXCoord + (gVars.proximityTreeCellZCoord * gVars.proximityTreeCellsListWidth);
                                    // Add the tree proximities from this cell
                                    gVars.thisTreeProximitiesList.AddRange(gVars.treeProximitiesList[gVars.thisTreeProximityCellIndex]);
                                }
                            }

                            // Remove trees within the clearing radius
                            // Find all trees that are too close and add them to the list of trees to remove
                            gVars.thisTreesToRemoveList = gVars.thisTreeProximitiesList.FindAll(msh => (((groupPosition.x - msh.position.x) * (groupPosition.x - msh.position.x)) + ((groupPosition.z - msh.position.z) * (groupPosition.z - msh.position.z)))
                                    < clearingRadius * clearingRadius);
                            if (gVars.thisTreesToRemoveList.Count > 0)
                            {
                                // Then add them to a list of trees to be removed...
                                gVars.treesToRemoveList.AddRange(gVars.thisTreesToRemoveList);
                                // ... then remove them from the tree proximity list
                                // Is there a quicker way to do this, given that we already have the list of objects?
                                gVars.thisTreeProximitiesList.RemoveAll(msh => (((groupPosition.x - msh.position.x) * (groupPosition.x - msh.position.x)) + ((groupPosition.z - msh.position.z) * (groupPosition.z - msh.position.z)))
                                    < clearingRadius * clearingRadius);
                            }
                        }

                        #endregion

                        #region Clearing Add Ground Textures

                        // If required, add a texture to the ground in this clearing
                        if (isTexturingRequiredForGroup)
                        {
                            // Get the min, max and centre coordinates of the area which the texture will be added to
                            gVars.textureAreaNoBlendRadius = clearingRadius / (float)gVars.textureArrayCellSize;
                            gVars.textureAreaRadius = (int)(gVars.textureAreaNoBlendRadius * (1f + lbGroup.GetMaxTextureMinBlendDist()));
                            if (gVars.textureAreaNoBlendRadius > gVars.textureAreaRadius) { gVars.textureAreaNoBlendRadius = gVars.textureAreaRadius; }
                            gVars.textureAreaCentreXIndex = (int)(groupPositionNormalised.x * gVars.textureArrayCellsListWidth);
                            gVars.textureAreaCentreZIndex = (int)(groupPositionNormalised.z * gVars.textureArrayCellsListWidth);
                            gVars.textureAreaMinXIndex = gVars.textureAreaCentreXIndex - gVars.textureAreaRadius;
                            gVars.textureAreaMaxXIndex = gVars.textureAreaCentreXIndex + gVars.textureAreaRadius;
                            gVars.textureAreaMinZIndex = gVars.textureAreaCentreZIndex - gVars.textureAreaRadius;
                            gVars.textureAreaMaxZIndex = gVars.textureAreaCentreZIndex + gVars.textureAreaRadius;

                            // Clamp area to within the bounds of the landscape
                            if (gVars.textureAreaMinXIndex < 0) { gVars.textureAreaMinXIndex = 0; }
                            if (gVars.textureAreaMaxXIndex > gVars.textureArrayCellsListWidth - 1) { gVars.textureAreaMaxXIndex = gVars.textureArrayCellsListWidth - 1; }
                            if (gVars.textureAreaMinZIndex < 0) { gVars.textureAreaMinZIndex = 0; }
                            if (gVars.textureAreaMaxZIndex > gVars.textureArrayCellsListWidth - 1) { gVars.textureAreaMaxZIndex = gVars.textureArrayCellsListWidth - 1; }

                            // Loop through the area cells
                            for (gVars.textureArrayCellXCoord = gVars.textureAreaMinXIndex; gVars.textureArrayCellXCoord <= gVars.textureAreaMaxXIndex; gVars.textureArrayCellXCoord++)
                            {
                                for (gVars.textureArrayCellZCoord = gVars.textureAreaMinZIndex; gVars.textureArrayCellZCoord <= gVars.textureAreaMaxZIndex; gVars.textureArrayCellZCoord++)
                                {
                                    // Get the distance to the centre of the textured area
                                    gVars.texturePlacementDist = (new Vector2(gVars.textureArrayCellXCoord - gVars.textureAreaCentreXIndex, gVars.textureArrayCellZCoord - gVars.textureAreaCentreZIndex)).magnitude / gVars.textureAreaNoBlendRadius;

                                    // Loop through all the textures
                                    for (gVars.txIdx = 0; gVars.txIdx < gVars.terrainTextureListSize; gVars.txIdx++)
                                    {
                                        // Is this Texture from the Texturing tab, actually in the terrain as a splatprototype?
                                        if (gVars.terrainTextureArrayIndexList[gVars.txIdx] < 0) { continue; }
                                        else
                                        {
                                            // Is the LBTerrainTexture being used in this Group?
                                            LBGroupTexture lbGroupTexture = lbGroup.textureList.Find(gTx => gTx.lbTerrainTextureGUID == gVars.terrainTextureList[gVars.txIdx].GUID);
                                            if (lbGroupTexture != null)
                                            {
                                                if (lbGroupTexture.minBlendDist >= 0f)
                                                {
                                                    // The middle area (measured radially) has no blending
                                                    if (gVars.texturePlacementDist < 1f) { gVars.textureBlendFactor = 1f; }
                                                    // The rest of the area blends out from the edge
                                                    else if (lbGroupTexture.minBlendDist == 0f) { gVars.textureBlendFactor = 0f; }
                                                    else { gVars.textureBlendFactor = 1f - Mathf.Clamp01((gVars.texturePlacementDist - 1f) * (1f / lbGroupTexture.minBlendDist)); }
                                                }
                                                else
                                                {
                                                    // The middle area (measured radially) has no blending
                                                    if (gVars.texturePlacementDist < 1f + lbGroupTexture.minBlendDist) { gVars.textureBlendFactor = 1f; }
                                                    // The rest of the area blends out to the edge
                                                    else { gVars.textureBlendFactor = Mathf.Clamp01(Mathf.Clamp01(1f - gVars.texturePlacementDist) * (-1f / lbGroupTexture.minBlendDist)); }
                                                }

                                                // Once we have calculated clearing blending, multiply by additional blending for zones
                                                if (!lbGroupTexture.isWholeGroup && gVars.textureBlendFactor > 0f && lbGroupTexture.zoneGUIDList != null && lbGroupTexture.zoneGUIDList.Count > 0)
                                                {
                                                    #region Zone Blending

                                                    // Zones
                                                    // Check that the placement position is within any defined zones for this texture

                                                    // Get the position of the cell relative to the centre of the clearing
                                                    posRelativeToGroup.x = (((float)gVars.textureArrayCellXCoord / (float)gVars.textureArrayCellsListWidth) - groupPositionNormalised.x) * gVars.landscapeWidth;
                                                    posRelativeToGroup.z = (((float)gVars.textureArrayCellZCoord / (float)gVars.textureArrayCellsListWidth) - groupPositionNormalised.z) * gVars.landscapeLength;
                                                    // Get the group-space placement position
                                                    posRelativeToGroup = Quaternion.Euler(0f, -clearingRotationY, 0f) * posRelativeToGroup;

                                                    // Start with an initial zone blending factor of zero
                                                    //totalZoneBlendFactor = 0f;

                                                    // Start with an initial OR zone blending factor of zero
                                                    includedOrZone = false;
                                                    cellSatisfiesOrZoneRules = true;
                                                    orZoneBlendFactor = 0f;
                                                    // Start with an initial NOT zone blending factor of zero
                                                    includedNotZone = false;
                                                    cellSatisfiesNotZoneRules = true;
                                                    notZoneBlendFactor = 1f;

                                                    // Loop through the zones
                                                    for (zoneListIndex = 0; zoneListIndex < lbGroupTexture.zoneGUIDList.Count; zoneListIndex++)
                                                    {
                                                        // Get the zone from the group using the provided GUID
                                                        thisZone = lbGroup.zoneList.Find(z => z.GUID == lbGroupTexture.zoneGUIDList[zoneListIndex]);
                                                        // Comparer depends on zone type
                                                        if (thisZone.zoneType == LBGroupZone.LBGroupZoneType.circle)
                                                        {
                                                            // Circle - check distance to centre
                                                            // Compare the distance from the centre of the zone to the cell
                                                            // with the radius of the zone
                                                            // Both distances are squared distances for performance
                                                            sqrDistToZoneCentre = ((posRelativeToGroup.x - (thisZone.centrePointX * clearingRadius)) * (posRelativeToGroup.x - (thisZone.centrePointX * clearingRadius)))
                                                                + ((posRelativeToGroup.z - (thisZone.centrePointZ * clearingRadius)) * (posRelativeToGroup.z - (thisZone.centrePointZ * clearingRadius)));
                                                            positionInsideZone = sqrDistToZoneCentre < thisZone.width * clearingRadius * thisZone.width * clearingRadius;
                                                        }
                                                        else
                                                        {
                                                            // Rectangle - check min and max coordinates
                                                            // Currently assumes that the rectangles cannot be rotated in group space
                                                            // Check that the cell is between min and max coordinate limits
                                                            distToZoneCentreX = posRelativeToGroup.x - (thisZone.centrePointX * clearingRadius);
                                                            if (distToZoneCentreX < 0f) { distToZoneCentreX *= -1f; }
                                                            distToZoneCentreZ = posRelativeToGroup.z - (thisZone.centrePointZ * clearingRadius);
                                                            if (distToZoneCentreZ < 0f) { distToZoneCentreZ *= -1f; }
                                                            positionInsideZone = (distToZoneCentreX < thisZone.width * clearingRadius * 0.5f &&
                                                                                  distToZoneCentreZ < thisZone.length * clearingRadius * 0.5f);
                                                        }

                                                        if (thisZone.zoneMode == LBGroupZone.ZoneMode.OR)
                                                        {
                                                            // OR
                                                            includedOrZone = true;

                                                            //if (zoneListIndex == 0) { cellSatisfiesOrZoneRules = positionInsideZone; }
                                                            //else { cellSatisfiesOrZoneRules = cellSatisfiesOrZoneRules || positionInsideZone; }

                                                            cellSatisfiesOrZoneRules = cellSatisfiesOrZoneRules || positionInsideZone;

                                                            if (positionInsideZone)
                                                            {
                                                                // Calculate blend factor
                                                                if (thisZone.zoneType == LBGroupZone.LBGroupZoneType.circle)
                                                                {
                                                                    // Calculate distance (in metres) to the edge of the zone
                                                                    distToZoneEdge = (thisZone.width * clearingRadius) - Mathf.Sqrt(sqrDistToZoneCentre);
                                                                }
                                                                else
                                                                {
                                                                    // Calculate distance (in metres) to the edge of the zone
                                                                    distToZoneEdge = Mathf.Min((thisZone.width * clearingRadius * 0.5f) - distToZoneCentreX,
                                                                                                (thisZone.length * clearingRadius * 0.5f) - distToZoneCentreZ);
                                                                }

                                                                // Adjust blend factor to compensate for blend distance
                                                                if (lbGroupTexture.edgeBlendDist == 0f) { zoneBlendFactor = 1f; }
                                                                else { zoneBlendFactor = Mathf.Clamp01(distToZoneEdge / lbGroupTexture.edgeBlendDist); }

                                                                // Quadratic blend
                                                                zoneBlendFactor *= zoneBlendFactor;

                                                                // Apply blend factor - basically maximum of OR zone blend factors
                                                                if (zoneBlendFactor > orZoneBlendFactor) { orZoneBlendFactor = zoneBlendFactor; }
                                                            }
                                                        }
                                                        else
                                                        {
                                                            // NOT
                                                            includedNotZone = true;

                                                            //if (zoneListIndex == 0) { cellSatisfiesNotZoneRules = !positionInsideZone; }
                                                            //else if (positionInsideZone) { cellSatisfiesNotZoneRules = false; break; }

                                                            if (positionInsideZone) { cellSatisfiesNotZoneRules = false; }

                                                            if (!positionInsideZone)
                                                            {
                                                                // Calculate blend factor
                                                                if (thisZone.zoneType == LBGroupZone.LBGroupZoneType.circle)
                                                                {
                                                                    // Calculate distance (in metres) to the edge of the zone
                                                                    distToZoneEdge = Mathf.Sqrt(sqrDistToZoneCentre) - (thisZone.width * clearingRadius);
                                                                }
                                                                else
                                                                {
                                                                    // Calculate distance (in metres) to the edge of the zone
                                                                    distToZoneEdge = Mathf.Max(distToZoneCentreX - (thisZone.width * clearingRadius * 0.5f),
                                                                                               distToZoneCentreZ - (thisZone.length * clearingRadius * 0.5f));
                                                                }

                                                                // Adjust blend factor to compensate for blend distance
                                                                if (lbGroupTexture.edgeBlendDist == 0f) { zoneBlendFactor = 1f; }
                                                                else { zoneBlendFactor = Mathf.Clamp01(distToZoneEdge / lbGroupTexture.edgeBlendDist); }

                                                                // Quadratic blend
                                                                zoneBlendFactor *= zoneBlendFactor;

                                                                // Apply blend factor - basically minimum of NOT zone blend factors
                                                                if (zoneBlendFactor < notZoneBlendFactor) { notZoneBlendFactor = zoneBlendFactor; }
                                                            }
                                                        }
                                                    }

                                                    // Calculate total zone blend factor by combining contriubutions of OR and NOT zones
                                                    if (includedOrZone && includedNotZone)
                                                    {
                                                        // Use minimum value
                                                        if (orZoneBlendFactor > notZoneBlendFactor) { totalZoneBlendFactor = notZoneBlendFactor; }
                                                        else { totalZoneBlendFactor = orZoneBlendFactor; }
                                                    }
                                                    // Use OR value
                                                    else if (includedOrZone) { totalZoneBlendFactor = orZoneBlendFactor; }
                                                    // Use NOT value
                                                    else if (includedNotZone) { totalZoneBlendFactor = notZoneBlendFactor; }
                                                    // Use one
                                                    else { totalZoneBlendFactor = 1f; }

                                                    // If cell satisfies zone rules, multiply clearing blend factor by calculated zone blend factor
                                                    // If a zone type wasn't used it will have default value of true
                                                    if (cellSatisfiesOrZoneRules && cellSatisfiesNotZoneRules) { gVars.textureBlendFactor *= totalZoneBlendFactor; }
                                                    // If cell does not satisfy zone rules, set clearing blend factor to zero
                                                    else { gVars.textureBlendFactor = 0f; }

                                                    #endregion
                                                }
                                                else if (!lbGroupTexture.isWholeGroup && (lbGroupTexture.zoneGUIDList == null || lbGroupTexture.zoneGUIDList.Count == 0))
                                                {
                                                    // Not whole group and no zones
                                                    gVars.textureBlendFactor = 0f;
                                                }

                                                // Only calculate anything if we have to do blending
                                                if (gVars.textureBlendFactor > 0f)
                                                {
                                                    // Calculate noise if necessary
                                                    if (lbGroupTexture.useNoise)
                                                    {
                                                        // Multiply blend factor by 5-octave ridged noise at the given point
                                                        // This is done in landscape-space (not world space), as it does not need to join up with other
                                                        // landscapes placed side-by-side (clearings can't do that)
                                                        gVars.textureBlendFactor *= Mathf.Abs(LBNoise.PerlinFractalNoise(((float)gVars.textureArrayCellXCoord / (float)gVars.textureArrayCellsListWidth) * gVars.landscapeWidth / lbGroupTexture.noiseTileSize,
                                                            ((float)gVars.textureArrayCellZCoord / (float)gVars.textureArrayCellsListWidth) * gVars.landscapeLength / lbGroupTexture.noiseTileSize, 5) - 0.5f) * 4f;
                                                    }

                                                    // Calculate the cell index in the texture array
                                                    gVars.thisTextureArrayCellIndex = (gVars.textureArrayCellZCoord * gVars.textureArrayCellsListWidth) + gVars.textureArrayCellXCoord;
                                                    gVars.textureAdditionArrayIndexShift = gVars.totalTextureArrayCells * gVars.terrainTextureArrayIndexList[gVars.txIdx];

                                                    // Add the calculated blended texture amount to the array
                                                    gVars.textureAdditionArray[gVars.thisTextureArrayCellIndex + gVars.textureAdditionArrayIndexShift] += (byte)(gVars.textureBlendFactor * 255f * lbGroupTexture.strength);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }

                        #endregion

                        #region Clearing Add Grass

                        // If required, populate some grass in this clearing
                        if (isGrassPopulationRequiredForGroup)
                        {
                            // Get the min, max and centre coordinates of the area which the grass will be added to
                            gVars.grassAreaNoBlendRadius = clearingRadius / (float)gVars.grassArrayCellSize;
                            gVars.grassAreaRadius = (int)(gVars.grassAreaNoBlendRadius * (1f + lbGroup.GetMaxGrassMinBlendDist()));
                            if (gVars.grassAreaNoBlendRadius > gVars.grassAreaRadius) { gVars.grassAreaNoBlendRadius = gVars.grassAreaRadius; }
                            gVars.grassAreaCentreXIndex = (int)(groupPositionNormalised.x * gVars.grassArrayCellsListWidth);
                            gVars.grassAreaCentreZIndex = (int)(groupPositionNormalised.z * gVars.grassArrayCellsListWidth);
                            gVars.grassAreaMinXIndex = gVars.grassAreaCentreXIndex - gVars.grassAreaRadius;
                            gVars.grassAreaMaxXIndex = gVars.grassAreaCentreXIndex + gVars.grassAreaRadius;
                            gVars.grassAreaMinZIndex = gVars.grassAreaCentreZIndex - gVars.grassAreaRadius;
                            gVars.grassAreaMaxZIndex = gVars.grassAreaCentreZIndex + gVars.grassAreaRadius;

                            // Clamp area to within the bounds of the landscape
                            if (gVars.grassAreaMinXIndex < 0) { gVars.grassAreaMinXIndex = 0; }
                            if (gVars.grassAreaMaxXIndex > gVars.grassArrayCellsListWidth - 1) { gVars.grassAreaMaxXIndex = gVars.grassArrayCellsListWidth - 1; }
                            if (gVars.grassAreaMinZIndex < 0) { gVars.grassAreaMinZIndex = 0; }
                            if (gVars.grassAreaMaxZIndex > gVars.grassArrayCellsListWidth - 1) { gVars.grassAreaMaxZIndex = gVars.grassArrayCellsListWidth - 1; }

                            // Loop through the area cells
                            for (gVars.grassArrayCellXCoord = gVars.grassAreaMinXIndex; gVars.grassArrayCellXCoord <= gVars.grassAreaMaxXIndex; gVars.grassArrayCellXCoord++)
                            {
                                for (gVars.grassArrayCellZCoord = gVars.grassAreaMinZIndex; gVars.grassArrayCellZCoord <= gVars.grassAreaMaxZIndex; gVars.grassArrayCellZCoord++)
                                {
                                    // Get the distance to the centre of the textured area
                                    gVars.grassPlacementDist = (new Vector2(gVars.grassArrayCellXCoord - gVars.grassAreaCentreXIndex, gVars.grassArrayCellZCoord - gVars.grassAreaCentreZIndex)).magnitude / gVars.grassAreaNoBlendRadius;

                                    // Loop through all the grasses
                                    for (gVars.grsIdx = 0; gVars.grsIdx < gVars.terrainGrassListSize; gVars.grsIdx++)
                                    {
                                        // Is this Grass from the Grass tab, actually in the terrain as a detailPrototype?
                                        if (gVars.terrainGrassArrayIndexList[gVars.grsIdx] < 0) { continue; }
                                        else
                                        {
                                            // Is the LBTerrainGrass being used in this Group?
                                            LBGroupGrass lbGroupGrass = lbGroup.grassList.Find(gGx => gGx.lbTerrainGrassGUID == gVars.terrainGrassList[gVars.grsIdx].GUID);
                                            if (lbGroupGrass != null)
                                            {
                                                if (lbGroupGrass.minBlendDist >= 0f)
                                                {
                                                    // The middle area (measured radially) has no blending
                                                    if (gVars.grassPlacementDist < 1f) { gVars.grassPopulationBlendFactor = 1f; }
                                                    // The rest of the area blends out from the edge
                                                    else if (lbGroupGrass.minBlendDist == 0f) { gVars.grassPopulationBlendFactor = 0f; }
                                                    else { gVars.grassPopulationBlendFactor = 1f - Mathf.Clamp01((gVars.grassPlacementDist - 1f) * (1f / lbGroupGrass.minBlendDist)); }
                                                }
                                                else
                                                {
                                                    // The middle area (measured radially) has no blending
                                                    if (gVars.grassPlacementDist < 1f + lbGroupGrass.minBlendDist) { gVars.grassPopulationBlendFactor = 1f; }
                                                    // The rest of the area blends out to the edge
                                                    else { gVars.grassPopulationBlendFactor = Mathf.Clamp01(Mathf.Clamp01(1f - gVars.grassPlacementDist) * (-1f / lbGroupGrass.minBlendDist)); }
                                                }

                                                // Once we have calculated clearing blending, multiply by additional blending for zones
                                                if (!lbGroupGrass.isWholeGroup && gVars.grassPopulationBlendFactor > 0f && lbGroupGrass.zoneGUIDList != null && lbGroupGrass.zoneGUIDList.Count > 0)
                                                {
                                                    #region Zone Blending

                                                    // Zones
                                                    // Check that the placement position is within any defined zones for this grass

                                                    // Get the position of the cell relative to the centre of the clearing
                                                    posRelativeToGroup.x = (((float)gVars.grassArrayCellXCoord / (float)gVars.grassArrayCellsListWidth) - groupPositionNormalised.x) * gVars.landscapeWidth;
                                                    posRelativeToGroup.z = (((float)gVars.grassArrayCellZCoord / (float)gVars.grassArrayCellsListWidth) - groupPositionNormalised.z) * gVars.landscapeLength;
                                                    // Get the group-space placement position
                                                    posRelativeToGroup = Quaternion.Euler(0f, -clearingRotationY, 0f) * posRelativeToGroup;

                                                    // Start with an initial zone blending factor of zero
                                                    //totalZoneBlendFactor = 0f;

                                                    // Start with an initial OR zone blending factor of zero
                                                    includedOrZone = false;
                                                    cellSatisfiesOrZoneRules = true;
                                                    orZoneBlendFactor = 0f;
                                                    // Start with an initial NOT zone blending factor of zero
                                                    includedNotZone = false;
                                                    cellSatisfiesNotZoneRules = true;
                                                    notZoneBlendFactor = 1f;

                                                    // Loop through the zones
                                                    for (zoneListIndex = 0; zoneListIndex < lbGroupGrass.zoneGUIDList.Count; zoneListIndex++)
                                                    {
                                                        // Get the zone from the group using the provided GUID
                                                        thisZone = lbGroup.zoneList.Find(z => z.GUID == lbGroupGrass.zoneGUIDList[zoneListIndex]);
                                                        // Comparer depends on zone type
                                                        if (thisZone.zoneType == LBGroupZone.LBGroupZoneType.circle)
                                                        {
                                                            // Circle - check distance to centre
                                                            // Compare the distance from the centre of the zone to the cell
                                                            // with the radius of the zone
                                                            // Both distances are squared distances for performance
                                                            sqrDistToZoneCentre = ((posRelativeToGroup.x - (thisZone.centrePointX * clearingRadius)) * (posRelativeToGroup.x - (thisZone.centrePointX * clearingRadius)))
                                                                + ((posRelativeToGroup.z - (thisZone.centrePointZ * clearingRadius)) * (posRelativeToGroup.z - (thisZone.centrePointZ * clearingRadius)));
                                                            positionInsideZone = sqrDistToZoneCentre < thisZone.width * clearingRadius * thisZone.width * clearingRadius;
                                                        }
                                                        else
                                                        {
                                                            // Rectangle - check min and max coordinates
                                                            // Currently assumes that the rectangles cannot be rotated in group space
                                                            // Check that the cell is between min and max coordinate limits
                                                            distToZoneCentreX = posRelativeToGroup.x - (thisZone.centrePointX * clearingRadius);
                                                            if (distToZoneCentreX < 0f) { distToZoneCentreX *= -1f; }
                                                            distToZoneCentreZ = posRelativeToGroup.z - (thisZone.centrePointZ * clearingRadius);
                                                            if (distToZoneCentreZ < 0f) { distToZoneCentreZ *= -1f; }
                                                            positionInsideZone = (distToZoneCentreX < thisZone.width * clearingRadius * 0.5f &&
                                                                                  distToZoneCentreZ < thisZone.length * clearingRadius * 0.5f);
                                                        }

                                                        if (thisZone.zoneMode == LBGroupZone.ZoneMode.OR)
                                                        {
                                                            // OR
                                                            includedOrZone = true;

                                                            //if (zoneListIndex == 0) { cellSatisfiesOrZoneRules = positionInsideZone; }
                                                            //else { cellSatisfiesOrZoneRules = cellSatisfiesOrZoneRules || positionInsideZone; }

                                                            cellSatisfiesOrZoneRules = cellSatisfiesOrZoneRules || positionInsideZone;

                                                            if (positionInsideZone)
                                                            {
                                                                // Calculate blend factor
                                                                if (thisZone.zoneType == LBGroupZone.LBGroupZoneType.circle)
                                                                {
                                                                    // Calculate distance (in metres) to the edge of the zone
                                                                    distToZoneEdge = (thisZone.width * clearingRadius) - Mathf.Sqrt(sqrDistToZoneCentre);
                                                                }
                                                                else
                                                                {
                                                                    // Calculate distance (in metres) to the edge of the zone
                                                                    distToZoneEdge = Mathf.Min((thisZone.width * clearingRadius * 0.5f) - distToZoneCentreX,
                                                                                                (thisZone.length * clearingRadius * 0.5f) - distToZoneCentreZ);
                                                                }

                                                                // Adjust blend factor to compensate for blend distance
                                                                if (lbGroupGrass.edgeBlendDist == 0f) { zoneBlendFactor = 1f; }
                                                                else { zoneBlendFactor = Mathf.Clamp01(distToZoneEdge / lbGroupGrass.edgeBlendDist); }

                                                                // Quadratic blend
                                                                zoneBlendFactor *= zoneBlendFactor;

                                                                // Apply blend factor - basically maximum of OR zone blend factors
                                                                if (zoneBlendFactor > orZoneBlendFactor) { orZoneBlendFactor = zoneBlendFactor; }
                                                            }
                                                        }
                                                        else
                                                        {
                                                            // NOT
                                                            includedNotZone = true;

                                                            //if (zoneListIndex == 0) { cellSatisfiesNotZoneRules = !positionInsideZone; }
                                                            //else if (positionInsideZone) { cellSatisfiesNotZoneRules = false; break; }

                                                            if (positionInsideZone) { cellSatisfiesNotZoneRules = false; }

                                                            if (!positionInsideZone)
                                                            {
                                                                // Calculate blend factor
                                                                if (thisZone.zoneType == LBGroupZone.LBGroupZoneType.circle)
                                                                {
                                                                    // Calculate distance (in metres) to the edge of the zone
                                                                    distToZoneEdge = Mathf.Sqrt(sqrDistToZoneCentre) - (thisZone.width * clearingRadius);
                                                                }
                                                                else
                                                                {
                                                                    // Calculate distance (in metres) to the edge of the zone
                                                                    distToZoneEdge = Mathf.Max(distToZoneCentreX - (thisZone.width * clearingRadius * 0.5f),
                                                                                               distToZoneCentreZ - (thisZone.length * clearingRadius * 0.5f));
                                                                }

                                                                // Adjust blend factor to compensate for blend distance
                                                                if (lbGroupGrass.edgeBlendDist == 0f) { zoneBlendFactor = 1f; }
                                                                else { zoneBlendFactor = Mathf.Clamp01(distToZoneEdge / lbGroupGrass.edgeBlendDist); }

                                                                // Quadratic blend
                                                                zoneBlendFactor *= zoneBlendFactor;

                                                                // Apply blend factor - basically minimum of NOT zone blend factors
                                                                if (zoneBlendFactor < notZoneBlendFactor) { notZoneBlendFactor = zoneBlendFactor; }
                                                            }
                                                        }
                                                    }

                                                    // Calculate total zone blend factor by combining contriubutions of OR and NOT zones
                                                    if (includedOrZone && includedNotZone)
                                                    {
                                                        // Use minimum value
                                                        if (orZoneBlendFactor > notZoneBlendFactor) { totalZoneBlendFactor = notZoneBlendFactor; }
                                                        else { totalZoneBlendFactor = orZoneBlendFactor; }
                                                    }
                                                    // Use OR value
                                                    else if (includedOrZone) { totalZoneBlendFactor = orZoneBlendFactor; }
                                                    // Use NOT value
                                                    else if (includedNotZone) { totalZoneBlendFactor = notZoneBlendFactor; }
                                                    // Use one
                                                    else { totalZoneBlendFactor = 1f; }

                                                    // If cell satisfies zone rules, multiply clearing blend factor by calculated zone blend factor
                                                    // If a zone type wasn't used it will have default value of true
                                                    if (cellSatisfiesOrZoneRules && cellSatisfiesNotZoneRules) { gVars.grassPopulationBlendFactor *= totalZoneBlendFactor; }
                                                    // If cell does not satisfy zone rules, set clearing blend factor to zero
                                                    else { gVars.grassPopulationBlendFactor = 0f; }

                                                    #endregion
                                                }

                                                // Only calculate anything if we have to do blending
                                                if (gVars.grassPopulationBlendFactor > 0f)
                                                {
                                                    // Calculate noise if necessary
                                                    if (lbGroupGrass.useNoise)
                                                    {
                                                        // Calculate noise value from 5-octave ridged noise at the given point
                                                        // This is done in landscape-space (not world space), as it does not need to join up with other
                                                        // landscapes placed side-by-side (clearings can't do that)
                                                        gVars.grassNoiseValue = Mathf.Abs((LBNoise.PerlinFractalNoise(((float)gVars.grassArrayCellXCoord / (float)gVars.grassArrayCellsListWidth) * gVars.landscapeWidth / lbGroupGrass.noiseTileSize,
                                                            ((float)gVars.grassArrayCellZCoord / (float)gVars.grassArrayCellsListWidth) * gVars.landscapeLength / lbGroupGrass.noiseTileSize, lbGroupGrass.noiseOctaves) / (1f - LBNoise.IntPow(0.5f, lbGroupGrass.noiseOctaves))) - 0.5f) * 4f;
                                                        // Then if the noise value is less than (1 - grass cutoff value) set the grass population blend factor to 0
                                                        if (gVars.grassNoiseValue < 1f - lbGroupGrass.grassPlacementCutoff) { gVars.grassPopulationBlendFactor = 0f; }
                                                        // Uncomment line below to get grass blending from noise
                                                        //else { gVars.grassPopulationBlendFactor *= noiseValue; }
                                                    }

                                                    // Calculate the cell index in the grass array
                                                    gVars.thisGrassArrayCellIndex = (gVars.grassArrayCellZCoord * gVars.grassArrayCellsListWidth) + gVars.grassArrayCellXCoord;
                                                    gVars.grassAdditionArrayIndexShift = gVars.totalGrassArrayCells * gVars.terrainGrassArrayIndexList[gVars.grsIdx];

                                                    // Add the calculated blended grass amount to the array
                                                    // The blend factor is multiplied by a random value between minDensity and maxDensity (inclusive)
                                                    gVars.grassAdditionArray[gVars.thisGrassArrayCellIndex + gVars.grassAdditionArrayIndexShift] += (byte)(gVars.grassPopulationBlendFactor * UnityEngine.Random.Range(lbGroupGrass.minDensity, lbGroupGrass.maxDensity + 1));
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }

                        #endregion
                    }
                }
                // Uniform Group relative to landscape position
                else
                {
                    groupPosition.x = 0f;
                    groupPosition.z = 0f;
                    groupPositionWS.x = groupPosition.x + gVars.landscapePosition.x;
                    groupPositionWS.y = gVars.landscapePosition.y;
                    groupPositionWS.z = groupPosition.z + gVars.landscapePosition.z;
                }

                #region LBRandom for prefab XZ rotation (per region)
                // Create an instance of LBRandom for the prefab XZ random rotation
                // and set the seed to the x-axis position of the group
                if (lbRandomPrefabXZRotation == null)
                {
                    lbRandomPrefabXZRotation = new LBRandom();
                }
                if (lbRandomPrefabXZRotation != null)
                {
                    // Set the seed for this region
                    lbRandomPrefabXZRotation.SetSeed((int)groupPositionWS.x);
                }
                else { Debug.LogWarning("ERROR: " + methodName + " could not create LBRandom instance for prefab XZ rotation. Please Report"); }
                #endregion

                #endregion

                #region Process each of the group members within the current Group region (clearing instance)
                numGroupMembers = lbGroup.groupMemberList == null ? 0 : lbGroup.groupMemberList.Count;

                for (int gm = 0; gm < numGroupMembers; gm++)
                {
                    lbGroupMember = lbGroup.groupMemberList[gm];

                    if (lbGroupMember == null || lbGroupMember.isDisabled) { continue; }

                    bool isObjectPathMemberType = lbGroupMember.lbMemberType == LBGroupMember.LBMemberType.ObjPath;

                    // If using the ObjPathDesigner (and this isn't a subgroup being placed inside another group), restict processing to the GroupMember of the single ObjPath
                    if (!isChildGroup && gVars.isObjPathDesignerEnabled && lbGroupMember.GUID != gVars.lbGroupParams.lbObjPathParm.lbGroupMemberOwner.GUID) { continue; }
                    // Do basic validation on ObjPaths
                    else if (isObjectPathMemberType && (lbGroupMember.lbObjPath == null || lbGroupMember.lbObjPath.pathPointList == null || lbGroupMember.lbObjPath.pathPointList.Count < 2)) { continue; }
                    // Check to see if we should process this prefab member
                    else if (!lbGroupMember.isPathOnly)
                    {
                        // Reset member-scoped variables
                        if (combineMeshes != null) { combineMeshes.Clear(); }
                        memberPrefabGameObject = null;
                        componentList.Clear();
                        lbGroupMemberSeriesOverride = null;

                        int targetNumberOfMembers = 0;

                        #region Initialise Member-scoped Placement

                        // Create a group member-scoped region placement array
                        regionMemberPlacementList.Clear();
                        regionMemberCellBucketList.Clear();

                        // Except Uniform Groups, override placement options for clearings, subgroups and prefabs placed in the centre.
                        if (isGroupTypeUniform)
                        {
                            regionMemberPlacementListSize = regionGroupPlacementListSize;
                            isPlacedInCentre = false;
                        }
                        else
                        {
                            if (lbGroupMember.isPlacedInCentre)
                            {
                                regionMemberPlacementListSize = 1;
                                isPlacedInCentre = true;
                            }
                            else
                            {
                                regionMemberPlacementListSize = clearingPlacementListWidth * clearingPlacementListWidth;
                                isPlacedInCentre = false;
                            }
                        }

                        regionMemberPlacementList.AddRange(new byte[regionMemberPlacementListSize]);

                        // Fill the rule list with all potential cells (start will a full list of cells)
                        for (int rgpmbrIdx = 0; rgpmbrIdx < regionMemberPlacementListSize; rgpmbrIdx++)
                        {
                            regionMemberCellBucketList.Add(rgpmbrIdx);
                        }

                        if (isGroupTypeUniform)
                        {
                            targetNumberOfMembers = Mathf.RoundToInt(gVars.perSqrKmFactor * lbGroupMember.maxPrefabSqrKm);
                        }
                        else
                        {
                            // Procedural, Manual Clearings or SubGroups
                            // Calculate the target number in a clearing. Note, radius of each clearing could be different.
                            // Use clearingRadius local variable
                            if (isPlacedInCentre) { targetNumberOfMembers = 1; }
                            else
                            {
                                // Clearing diameter = width = length
                                targetNumberOfMembers = Mathf.RoundToInt(((clearingRadius * clearingRadius * 4) / 1000000f) * lbGroupMember.maxPrefabSqrKm);

                                // Clamp to the max prefabs for this member in the current group instance.
                                if (targetNumberOfMembers > lbGroupMember.maxPrefabPerGroup) { targetNumberOfMembers = lbGroupMember.maxPrefabPerGroup; }

                                // We may want at least 1 item placed in each clearing.
                                if (targetNumberOfMembers == 0) { targetNumberOfMembers = 1; }
                            }
                        }

                        int numberOfPrefabsCreated = 0;

                        // 32bit integers wrap to -ve values (then back to +ve). Check that the number of iterations is
                        // within the bounds of a 32bit int. We loop though 256 times the number of target members OR
                        // until we reach the target OR 0.1 seconds have elapsed since a prefab was placed.
                        ulong maxMemberIterationsLong = (ulong)targetNumberOfMembers * (ulong)256;  // was 256
                        int maxMemberIterations = (maxMemberIterationsLong > (ulong)int.MaxValue) ? int.MaxValue : (int)maxMemberIterationsLong;

                        regionMemberCellBucketListSize = regionMemberCellBucketList.Count;

                        #endregion

                        #region Initialise Member Prefab

                        // Create a new GameObject for the prefabs
                        // Check for child (sub)group first to include ObjPath prefabs within the SubGroup.
                        if (isChildGroup)
                        {
                            // [DESIGNER] (parentGroupName.parentObjPathName.subGroupName.regionnumber)
                            memberPrefabGameObject = new GameObject((gVars.isObjPathDesignerEnabled ? "[DESIGNER] " : string.Empty) + "(" + (parentGroup != null ? parentGroup.groupName : lbGroup.groupName) + "." + (parentGroupMember != null && parentGroupMember.lbObjPath != null && !string.IsNullOrEmpty(parentGroupMember.lbObjPath.pathName) ? parentGroupMember.lbObjPath.pathName : "SubGroup") + "." + (string.IsNullOrEmpty(lbGroup.groupName) ? "SubGroup" : lbGroup.groupName) + "." + (regionIdx + 1) + ")");

                            if (memberPrefabGameObject != null)
                            {
                                // The GroupDesigner is offset on the Y-axis. It needs to match the BasePlane created in LBGroupDesigner.CreateBasePlane().
                                if (gVars.isGroupDesignerEnabled) { memberPrefabGameObject.transform.position = gVars.groupDesignerPos; }
                                else { memberPrefabGameObject.transform.position = gVars.landscapePosition; }

                                memberPrefabGameObject.transform.SetParent(gVars.lbGroupParams.landscape.transform);
                                lbPrefabItem = memberPrefabGameObject.AddComponent<LBPrefabItem>();
                                if (lbPrefabItem != null)
                                {
                                    lbPrefabItem.prefabItemType = gVars.isObjPathDesignerEnabled ? LBPrefabItem.PrefabItemType.ObjPathDesignerPrefab : LBPrefabItem.PrefabItemType.ObjPathPrefab;
                                    // Add the GUID of the object path GroupMember so that we can track them in the scene
                                    // It lets us enable/disable existing prefabs when using the Object Path Designer
                                    // If this Group is being spawned from a parent group, assign the member GUID from that parent instead
                                    // of using the current member GUID. This ensures that the Designers can disable and enable the correct gameobject
                                    // for subgroups.
                                    lbPrefabItem.groupMemberGUID = parentGroupMember != null ? parentGroupMember.GUID : lbGroupMember.GUID;
                                }
                            }
                        }
                        else if (lbGroupMember.lbMemberType == LBGroupMember.LBMemberType.ObjPath)
                        {
                            memberPrefabGameObject = new GameObject((gVars.isObjPathDesignerEnabled ? "[DESIGNER] " : string.Empty) + "(" + lbGroup.groupName + "." + (string.IsNullOrEmpty(lbGroupMember.lbObjPath.pathName) ? "objPath" : lbGroupMember.lbObjPath.pathName) + "." + (regionIdx + 1) + ")");

                            if (memberPrefabGameObject != null)
                            {
                                // The GroupDesigner is offset on the Y-axis. It needs to match the BasePlane created in LBGroupDesigner.CreateBasePlane().
                                if (gVars.isGroupDesignerEnabled) { memberPrefabGameObject.transform.position = gVars.groupDesignerPos; }
                                else { memberPrefabGameObject.transform.position = gVars.landscapePosition; }

                                memberPrefabGameObject.transform.SetParent(gVars.lbGroupParams.landscape.transform);
                                lbPrefabItem = memberPrefabGameObject.AddComponent<LBPrefabItem>();
                                if (lbPrefabItem != null)
                                {
                                    lbPrefabItem.prefabItemType = gVars.isObjPathDesignerEnabled ? LBPrefabItem.PrefabItemType.ObjPathDesignerPrefab : LBPrefabItem.PrefabItemType.ObjPathPrefab;
                                    // Add the GUID of the object path GroupMember so that we can track them in the scene
                                    // It lets us enable/disable existing prefabs when using the Object Path Designe
                                    lbPrefabItem.groupMemberGUID = lbGroupMember.GUID;
                                }
                            }
                        }
                        else if (lbGroupMember.prefab != null)
                        {
                            memberPrefabGameObject = new GameObject("(" + lbGroup.groupName + "." + lbGroupMember.prefab.name + ")");

                            if (memberPrefabGameObject != null)
                            {
                                memberPrefabGameObject.transform.position = gVars.landscapePosition;
                                memberPrefabGameObject.transform.SetParent(gVars.lbGroupParams.landscape.transform);
                                lbPrefabItem = memberPrefabGameObject.AddComponent<LBPrefabItem>();
                                if (lbPrefabItem != null) { lbPrefabItem.prefabItemType = LBPrefabItem.PrefabItemType.GroupMemberPrefab; }

                                if (lbGroupMember.isCombineMesh && combineMeshes == null) { combineMeshes = new List<CombineInstance>(); }
                            }
                        }

                        #endregion

                        if (lbGroupMember.isTerrainFlattened || isObjectPathMemberType)
                        {
                            flattenPosNList.Clear();
                            flattenRectList.Clear();
                            flattenBlendRateList.Clear();
                        }

                        #region Initialise Member zone filters

                        // Check if only filling edges of a zone
                        isZoneEdgeFillEnabled = (lbGroupMember.isZoneEdgeFillTop || lbGroupMember.isZoneEdgeFillBottom || lbGroupMember.isZoneEdgeFillLeft || lbGroupMember.isZoneEdgeFillRight);

                        // Lookup the first zone (if any) in the member zone filter list
                        // This is used with member rotation (face 2 centre zone).
                        LBGroupZone firstZone = null;
                        if (lbGroup.zoneList != null && lbGroupMember.zoneGUIDList != null && lbGroupMember.zoneGUIDList.Count > 0)
                        {
                            // Get the zone from the group using the provided GUID
                            firstZone = lbGroup.zoneList.Find(z => z.GUID == lbGroupMember.zoneGUIDList[0]);

                            if (firstZone != null)
                            {
                                // Get the normalised position of the zone within the landscape. The zone is within the group (clearing instance)
                                // Get the normalised position of the first group zone relative to the normalised position of the group
                                firstZonePositionN.x = (firstZone.centrePointX * clearingRadius / gVars.landscapeWidth);
                                firstZonePositionN.y = 0f;
                                firstZonePositionN.z = (firstZone.centrePointZ * clearingRadius / gVars.landscapeLength);
                                // Rotate the zone position to match the clearing rotation
                                firstZonePositionN = Quaternion.Euler(0f, clearingRotationY, 0f) * firstZonePositionN;
                                // Add the normalised group position to move it into normalised landscape space
                                firstZonePositionN += groupPositionNormalised;
                            }
                        }
                        #endregion

                        #region Initialise Member Noise

                        // Do for all members, even if not using noise. This makes other Random calls more predictable
                        lbGroupMember.noiseOffset = UnityEngine.Random.Range(0f, lbGroupMember.noiseTileSize);
                        #endregion

                        float progress = 0f;
                        float lastProgressUpdateTime = 0f;
                        float lastPlacementTime = Time.realtimeSinceStartup;

                        #region Loop Initialisation

                        bool finishedInstantiatingMembers = false;

                        // Normal member looping variables
                        int mItn = 0;
                        #endregion

                        #region ObjPath Initialisation - variables
                        // Object path member looping variables
                        int objPathPrefabIdx = -1;
                        int objPathPrefabIdxPrev = -1;  // Used with SelectionMethod Random Less Repeats and RandomUnique
                        int objPathPointIdx = 0;
                        LBObjPath lbObjPath = lbGroupMember.lbObjPath;
                        bool objPathStartMemberDefined = false;
                        bool objPathEndMemberDefined = false;
                        bool objPathStartGroupDefined = false;
                        bool objPathEndGroupDefined = false;
                        LBObjPrefab startObjPrefab = null;
                        LBObjPrefab endObjPrefab = null;
                        LBObjSubGroup startObjSubGroup = null;
                        LBObjSubGroup endObjSubGroup = null;
                        int numMainObjsInList = 0;  // can be Prefabs or SubGroups
                        int numObjPathPoints = 0;
                        bool isObjPathSeriesUseSubGroups = false;
                        bool isSelectionMethodAlternating = false;
                        bool isSelectionMethodRandom = false;
                        bool isSelectionMethodRandom2 = false; // Less Repeats
                        bool isSelectionMethodRandom3 = false; // RandomUnique - first random object
                        bool isLayoutMethodSpacing = false;
                        bool isLayoutMethodExactQty = false;
                        bool isLayoutMethodQtyPer100m = false;
                        float objPathMemberSpacingDistance = 0f;
                        bool objPathIsRandomisePerGroupRegion = false;
                        Vector3 objPathForwardsDirection = Vector3.zero;
                        Vector3 objPathRightDirection = Vector3.zero;
                        float distanceAlongObjPath = 0f;
                        float objPathPlacementCutoff = 1f;
                        float objPathSurfaceHeightOffset = 0f; // Used in Clearing Groups to offset from first point in path on y-axis for Surface Mesh (see also objPathSeriesHeightOffset)

                        // Object Path Series variables
                        int objPathSeriesIdx = -1;  // Must start at -1 so it gets incremented to 0 for first series
                        int numObjPathSeries = 0;
                        LBObjPathSeries lbObjPathSeries = null;
                        float objPathSeriesHeightOffset = 0f;   // Used in Clearing Groups to offset from first point in path on y-axis for Series Objects (see also objPathSurfaceHeightOffset)
                        #endregion

                        #region ObjPath Initialisation - including topography, grass, trees and ground texturing
                        // Will need to have validation somewhere in here as well
                        if (isObjectPathMemberType && lbObjPath != null)
                        {
                            // Force refresh of spline cache
                            lbObjPath.isSplinesCached2 = false;
                            lbObjPath.CacheSplinePoints2();

                            objPathPrefabPointList.Clear();
                            objPathPrefabForwardsList.Clear();
                            objPathPrefabRightList.Clear();
                            activeMainObjPrefabList.Clear();

                            if (lbObjPath.useWidth)
                            {
                                #region Reset Garbage Collection
                                System.GC.Collect();
                                #endregion

                                // NOTE: CacheSplinePoints2 will not be called a second time here as it was refreshed above.
                                lbObjPath.RefreshObjPathPositions(true, lbObjPath.useSurfaceMesh);
                                int numSplineCentrePoints = (lbObjPath.cachedCentreSplinePointList == null ? 0 : lbObjPath.cachedCentreSplinePointList.Count);

                                #region Get surround spline data once 

                                Vector3[] centreSplinePointArray = null;
                                Vector3[] leftSplinePointArray = null;
                                Vector3[] rightSplinePointArray = null;
                                Vector4 objPathBounds = Vector4.zero;

                                // Convert splines from Clearing Group-space to Worldspace
                                if (isGroupTypeProceduralClearing || isGroupTypeManualClearing || isChildGroup)
                                {
                                    centreSplinePointArray = new Vector3[lbObjPath.cachedCentreSplinePointsLength];
                                    leftSplinePointArray = new Vector3[lbObjPath.cachedCentreSplinePointsLength];
                                    rightSplinePointArray = new Vector3[lbObjPath.cachedCentreSplinePointsLength];

                                    // In LB 2.2.0 added landscapePosition to fix problem with texturing terrain and modifying terrain heights
                                    // for object paths in Clearing Groups when the landscape is not at 0,0,0. groupPositionWS is modified for the GroupDesigner
                                    lbObjPath.ToWorldSpace(lbObjPath.cachedCentreSplinePointList, centreSplinePointArray, groupPositionWS, clearingRotationY);
                                    lbObjPath.ToWorldSpace(lbObjPath.cachedSplinePointLeftSurroundList, leftSplinePointArray, groupPositionWS, clearingRotationY);
                                    lbObjPath.ToWorldSpace(lbObjPath.cachedSplinePointRightSurroundList, rightSplinePointArray, groupPositionWS, clearingRotationY);
                                    objPathBounds = LBPath.GetSplineBounds(leftSplinePointArray, rightSplinePointArray);
                                }
                                else
                                {
                                    centreSplinePointArray = lbObjPath.cachedCentreSplinePointList.ToArray();
                                    leftSplinePointArray = lbObjPath.cachedSplinePointLeftSurroundList.ToArray();
                                    rightSplinePointArray = lbObjPath.cachedSplinePointRightSurroundList.ToArray();
                                    objPathBounds = lbObjPath.GetSurroundBounds();
                                }

                                #endregion

                                #region Count Surround Spline Points
                                #if LB_COMPUTE
                                // Object Paths use a separate set of cached spline points that are outside the regular left and right cached spline points.
                                // Unlike a LBMapPath, the edge distance is outside the left/right path points (which is why we have a separate set of surround spline points)
                                int numSplineLeftPoints = (lbObjPath.cachedSplinePointLeftSurroundList == null ? 0 : lbObjPath.cachedSplinePointLeftSurroundList.Count);
                                int numSplineRightPoints = (lbObjPath.cachedSplinePointRightSurroundList == null ? 0 : lbObjPath.cachedSplinePointRightSurroundList.Count);
                                #endif
                                #endregion

                                #region Compute Flatten ObjPath and optionally add Surface and Base Meshes (not in GroupDesigner)

                                // Flatten ObjPath requires GPU Acceleration (Path)
                                // Where possible make variable more global to method to reduce memory fragmentation
                                if (gVars.isPathComputeEnabled && !gVars.isGroupDesignerEnabled && lbGroupMember.isTerrainFlattened)
                                {
#if LB_COMPUTE
                                    try
                                    {
                                        Vector4[] pkKeyFrames = null;

                                        gVars.shaderPath = (ComputeShader)Resources.Load(LBCSPath, typeof(ComputeShader));

                                        // Perform some validation
                                        if (gVars.shaderPath == null) { if (gVars.lbGroupParams.showErrors) { Debug.LogWarning("ERROR: " + methodName + " " + LBCSPath + ".shader not found. Please Report"); } }
                                        else if (numSplineCentrePoints < 2) { if (gVars.lbGroupParams.showErrors) { Debug.LogWarning("ERROR: " + methodName + " Object Path " + lbObjPath.pathName + " - must have at least 2 centre spline points"); } }
                                        else if (numSplineLeftPoints < 2) { if (gVars.lbGroupParams.showErrors) { Debug.LogWarning("ERROR: " + methodName + " Object Path " + lbObjPath.pathName + " - must have at least 2 left spline points"); } }
                                        else if (numSplineRightPoints < 2) { if (gVars.lbGroupParams.showErrors) { Debug.LogWarning("ERROR: " + methodName + " Object Path " + lbObjPath.pathName + " - must have at least 2 right spline points"); } }
                                        else if (numSplineLeftPoints != numSplineRightPoints) { if (gVars.lbGroupParams.showErrors) { Debug.LogWarning("ERROR: " + methodName + " Object Path " + lbObjPath.pathName + " - in this release the number of left and right spline points must be the same"); } }
                                        else if (numSplineCentrePoints != numSplineRightPoints) { if (gVars.lbGroupParams.showErrors) { Debug.LogWarning("ERROR: " + methodName + " Object Path " + lbObjPath.pathName + " - in this release the number of centre, left and right spline points must be the same"); } }
                                        else
                                        {
                                            // Get the index to the Methods in the compute shader
                                            int kObjPathTopoIdx = gVars.shaderPath.FindKernel(CSKObjPathTopo);
                                            int kObjPathSmoothIdx = gVars.shaderPath.FindKernel(CSKObjPathSmooth);
                                            int kObjPathCpyHeightsIdx = gVars.shaderPath.FindKernel(CSKObjPathCopyHeightsOutToIn);

                                            #region Allocate input and output height arrays
                                            // Create heightmap as a 1-dimensional array
                                            float[] heightMap1D = new float[gVars.landscapeHeightmapSize];
                                            int heightMap1DSize = (heightMap1D == null ? 0 : heightMap1D.Length);
                                            #endregion

                                            #region Create Buffers
                                            gVars.shaderPath.SetInt(CSnumSplineCentrePoints, numSplineCentrePoints);

                                            // Assume all spline have the same number of items (which is validated above)
                                            gVars.cbufSplinePointsCentre = new ComputeBuffer(numSplineCentrePoints, sizeof(float) * 3, ComputeBufferType.Default);
                                            gVars.cbufSplinePointsLeft = new ComputeBuffer(numSplineCentrePoints, sizeof(float) * 3, ComputeBufferType.Default);
                                            gVars.cbufSplinePointsRight = new ComputeBuffer(numSplineCentrePoints, sizeof(float) * 3, ComputeBufferType.Default);

                                            // Create the buffers to hold the heightmap in/out data
                                            gVars.cbufHeightsIn = new ComputeBuffer(gVars.landscapeHeightmapSize, sizeof(float), ComputeBufferType.Default);
                                            gVars.cbufHeightsOut = new ComputeBuffer(gVars.landscapeHeightmapSize, sizeof(float), ComputeBufferType.Default);
                                            #endregion

                                            // Ensure buffers were created
                                            if (gVars.cbufSplinePointsCentre != null && gVars.cbufSplinePointsLeft != null && gVars.cbufSplinePointsRight != null && gVars.cbufHeightsIn != null && gVars.cbufHeightsOut != null && heightMap1DSize == gVars.landscapeHeightmapSize)
                                            {
                                                // This could be a little slow and memory hungry to do for each Object Path...
                                                if (!GetLandscapeScopedHeightmap(gVars.lbGroupParams.landscape, heightMap1D, false, gVars.lbGroupParams.showErrors)) { if (gVars.lbGroupParams.showErrors) { Debug.LogWarning("ERROR " + methodName + " - could not populate landscape-scoped heightmap array for Object Path " + lbObjPath.pathName + " on GPU."); } }
                                                else
                                                {
                                                    #region Assign height buffers to ObjPathTopo method and copy in height data
                                                    gVars.shaderPath.SetBuffer(kObjPathTopoIdx, CSheightsIn, gVars.cbufHeightsIn);
                                                    gVars.shaderPath.SetBuffer(kObjPathTopoIdx, CSheightsOut, gVars.cbufHeightsOut);

                                                    // Copy height data into shader
                                                    gVars.cbufHeightsIn.SetData(heightMap1D);
                                                    #endregion

                                                    #region Assign spline buffers and copy spline data to shader
                                                    // Allocate buffers to the compute shader method
                                                    gVars.shaderPath.SetBuffer(kObjPathTopoIdx, CSsplinePointsCentre, gVars.cbufSplinePointsCentre);
                                                    gVars.shaderPath.SetBuffer(kObjPathTopoIdx, CSsplinePointsLeft, gVars.cbufSplinePointsLeft);
                                                    gVars.shaderPath.SetBuffer(kObjPathTopoIdx, CSsplinePointsRight, gVars.cbufSplinePointsRight);

                                                    // Copy the data to the shader
                                                    gVars.cbufSplinePointsCentre.SetData(centreSplinePointArray);
                                                    gVars.cbufSplinePointsLeft.SetData(leftSplinePointArray);
                                                    gVars.cbufSplinePointsRight.SetData(rightSplinePointArray);

                                                    gVars.shaderPath.SetVector(CSpathBounds, objPathBounds);
                                                    #endregion

                                                    int numKeyFrames = 0;

                                                    #region Surround Blend Curve
                                                    pkKeyFrames = LBCurve.GetComputeKeyFrames(lbObjPath.surroundBlendCurve);

                                                    numKeyFrames = (pkKeyFrames == null ? 0 : pkKeyFrames.Length);
                                                    if (numKeyFrames > 0)
                                                    {
                                                        gVars.cbufObjPathSurroundBlendCurve = new ComputeBuffer(numKeyFrames, sizeof(float) * 4, ComputeBufferType.Default);
                                                        if (gVars.cbufObjPathSurroundBlendCurve != null) { gVars.shaderPath.SetBuffer(kObjPathTopoIdx, CSpathBlendCurve, gVars.cbufObjPathSurroundBlendCurve); gVars.cbufObjPathSurroundBlendCurve.SetData(pkKeyFrames); }
                                                    }
                                                    else { Debug.LogWarning("ERROR " + methodName + " - could not send surround blend curve data to compute shader for Object Path " + lbObjPath.pathName + " on GPU."); }

                                                    gVars.shaderPath.SetInt(CSpathBlendCurveNumKeys, numKeyFrames);
                                                    #endregion

                                                    #region Profile Height Curve
                                                    pkKeyFrames = LBCurve.GetComputeKeyFrames(lbObjPath.profileHeightCurve);

                                                    numKeyFrames = (pkKeyFrames == null ? 0 : pkKeyFrames.Length);
                                                    if (numKeyFrames > 0)
                                                    {
                                                        gVars.cbufObjPathProfileHeightCurve = new ComputeBuffer(numKeyFrames, sizeof(float) * 4, ComputeBufferType.Default);
                                                        if (gVars.cbufObjPathProfileHeightCurve != null) { gVars.shaderPath.SetBuffer(kObjPathTopoIdx, CSpathHeightCurve, gVars.cbufObjPathProfileHeightCurve); gVars.cbufObjPathProfileHeightCurve.SetData(pkKeyFrames); }
                                                    }
                                                    else { Debug.LogWarning("ERROR " + methodName + " - could not send MapPath height curve data to compute shader for Object Path " + lbObjPath.pathName + " on GPU."); }

                                                    gVars.shaderPath.SetInt(CSpathHeightCurveNumKeys, numKeyFrames);
                                                    #endregion

                                                    #region Set landscape and topography variables in shader
                                                    gVars.shaderPath.SetInt(CSheightmapResolution, gVars.landscapeHeightmapResolution);
                                                    // Landscape variables
                                                    gVars.shaderPath.SetVector(CSlandscapePos, gVars.landscapePosition);
                                                    gVars.shaderPath.SetVector(CSlandscapeSize, gVars.lbGroupParams.landscape.size);
                                                    gVars.shaderPath.SetFloat(CSterrainHeight, gVars.terrainHeight);
                                                    #endregion

                                                    #region Set path variables in shader                                                               
                                                    // For an object path the Surround Distance should always be > 0. Unlike a LBMapPath, the
                                                    // surround distance is outside the left/right spline points.
                                                    // Override blend ends settings if it is a complete closed circuit.
                                                    bool blendEnds = (lbObjPath.blendStart || lbObjPath.blendEnd) && !lbObjPath.closedCircuit;
                                                    // Currently checkEdges is not used with ObjPath as we always want to blend with surrounding topography
                                                    gVars.shaderPath.SetBool(CScheckEdges, true);
                                                    gVars.shaderPath.SetBool(CSblendEnds, blendEnds);
                                                    gVars.shaderPath.SetBool(CSblendStart, lbObjPath.blendStart);
                                                    gVars.shaderPath.SetBool(CSblendEnd, lbObjPath.blendEnd);
                                                    gVars.shaderPath.SetBool(CSclosedCircuit, lbObjPath.closedCircuit);
                                                    gVars.shaderPath.SetInt(CSquadLookAhead, 1);
                                                    gVars.shaderPath.SetFloat(CSedgeBlendWidth, lbObjPath.edgeBlendWidth);
                                                    gVars.shaderPath.SetFloat(CSsqrblendEdgeWidth, lbObjPath.edgeBlendWidth * lbObjPath.edgeBlendWidth);
                                                    gVars.shaderPath.SetFloat(CSsurroundSmoothing, lbObjPath.surroundSmoothing);
                                                    gVars.shaderPath.SetFloat(CSheightScale, lbObjPath.addTerrainHeight);

                                                    // When an Object Path is flattened in a clearing, the path heights must be blended with the terrain heights
                                                    // because we didn't know the height of the terrain under that point in the Group Designer. The terrain height
                                                    // at any point along the path can be different in each instance (Region) of the clearing Group or SubGroup within the landscape.
                                                    // With a Uniform Group, we (should) know what the terrain heights are as there is only 1 path being created.
                                                    // Use a float rather than a bool to enable easy multiplication and avoid any additional branching in the shader.
                                                    gVars.shaderPath.SetFloat(CSblendTerrainHeight, isGroupTypeProceduralClearing || isGroupTypeManualClearing || isGroupTypeSubGroup ? 1f : 0f);
                                                    #endregion

                                                    #region Unused in ObjPathTopo - set to avoid issues
                                                    // Set terrain variables (unused)
                                                    gVars.shaderPath.SetFloat(CSterrainWidth, 1f);
                                                    gVars.shaderPath.SetFloat(CSterrainLength, 1f);
                                                    gVars.shaderPath.SetVector(CSterrainWorldPos, Vector3.zero);
                                                    // Variables used in PathCreateMap (unused)
                                                    gVars.shaderPath.SetInt(CSPathmapTexWidth, 0);
                                                    gVars.shaderPath.SetInt(CSPathmapTexHeight, 0);
                                                    gVars.shaderPath.SetBool(CSremoveCentre, false);
                                                    gVars.shaderPath.SetFloat(CSsqrborderLeftWidth, 0f);
                                                    gVars.shaderPath.SetFloat(CSsqrborderRightWidth, 0f);
                                                    gVars.shaderPath.SetFloat(CSmaxWidth, 0f);
                                                    // Layer variables (unused)
                                                    gVars.shaderPath.SetFloat(CSminHeight, 1f);
                                                    gVars.shaderPath.SetInt(CSpathTypeMode, 0);
                                                    gVars.shaderPath.SetFloat(CSpathInvertMultipler, 1f);
                                                    #endregion

                                                    #region Execute Shader - Topography Pass
                                                    // As the heightmap res is 2^n + 1 we need to add an additional threadGroup in both x and z directions.
                                                    // In our shader Z is up so x,z in Unity become x,y in shader.
                                                    // The additional thread groups will only process 1 pixel. Although this means we "waste" parallel processing
                                                    // on the GPU, it means we can process the rest of the heightmap in parallel.
                                                    int threadGroupX = (gVars.landscapeHeightmapResolution - 1) / gVars.cskPathNumThreads;
                                                    int threadGroupY = (gVars.landscapeHeightmapResolution - 1) / gVars.cskPathNumThreads;

                                                    // Execute shader
                                                    // The Z thread group is 1 because we are processing a 2D heightmap
                                                    gVars.shaderPath.Dispatch(kObjPathTopoIdx, threadGroupX + 1, threadGroupY + 1, 1);
                                                    #endregion

                                                    if (lbObjPath.surroundSmoothing > 0f)
                                                    {
                                                        #region Assign buffers to, and excute copy heights
                                                        // This is required in preparation for the next smoothing pass
                                                        gVars.shaderPath.SetBuffer(kObjPathCpyHeightsIdx, CSheightsIn, gVars.cbufHeightsIn);
                                                        gVars.shaderPath.SetBuffer(kObjPathCpyHeightsIdx, CSheightsOut, gVars.cbufHeightsOut);
                                                        threadGroupX = gVars.landscapeHeightmapSize / gVars.cskCopyNumThreads;
                                                        threadGroupY = 1;
                                                        gVars.shaderPath.Dispatch(kObjPathCpyHeightsIdx, threadGroupX + 1, threadGroupY, 1);
                                                        #endregion

                                                        #region Assign buffers to, and excute Smoothing pass
                                                        gVars.shaderPath.SetBuffer(kObjPathSmoothIdx, CSheightsIn, gVars.cbufHeightsIn);
                                                        gVars.shaderPath.SetBuffer(kObjPathSmoothIdx, CSheightsOut, gVars.cbufHeightsOut);
                                                        gVars.shaderPath.SetBuffer(kObjPathSmoothIdx, CSsplinePointsCentre, gVars.cbufSplinePointsCentre);
                                                        gVars.shaderPath.SetBuffer(kObjPathSmoothIdx, CSsplinePointsLeft, gVars.cbufSplinePointsLeft);
                                                        gVars.shaderPath.SetBuffer(kObjPathSmoothIdx, CSsplinePointsRight, gVars.cbufSplinePointsRight);

                                                        threadGroupX = (gVars.landscapeHeightmapResolution - 1) / gVars.cskPathNumThreads;
                                                        threadGroupY = (gVars.landscapeHeightmapResolution - 1) / gVars.cskPathNumThreads;
                                                        gVars.shaderPath.Dispatch(kObjPathSmoothIdx, threadGroupX + 1, threadGroupY + 1, 1);
                                                        #endregion
                                                    }

                                                    #region Get heights data back from shader and update terrains
                                                    gVars.cbufHeightsOut.GetData(heightMap1D);

                                                    // update terrain heightmaps
                                                    // After data is processed, copy back from array to terrain heightmaps and free memory
                                                    if (!CommitLandscapeScopedHeightmap(gVars.lbGroupParams.landscape, heightMap1D, false, gVars.lbGroupParams.showErrors))
                                                    {
                                                        if (gVars.lbGroupParams.showErrors) { Debug.LogWarning("ERROR " + methodName + " - could not copy landscape-scoped heightmap array back to terrains for Object Path " + lbObjPath.pathName + " on GPU."); }
                                                    }
                                                    #endregion

                                                    #region Create Surface and Meshes
                                                    if (lbObjPath.useSurfaceMesh)
                                                    {
                                                        #region Get Anchor Point Height for Surface Mesh
                                                        // The anchor point at the start of the path in landscape-space (doesn't include landscape.start.y)
                                                        float objPathAnchorHeightLS = 0f;
                                                        objPathSurfaceHeightOffset = 0f;
                                                        // This indicates that the mesh should follow the general trend of the terrain,
                                                        // based on the terrain height at each user-defined point, relative to the anchor point
                                                        // at the start of the path.
                                                        bool isMeshFollowTerrain = false;

                                                        // This is required when a surface mesh needs to follow the path heights (rather than snap to terrain)
                                                        if (!lbObjPath.meshEdgeSnapToTerrain && (isGroupTypeProceduralClearing || isGroupTypeManualClearing || isGroupTypeSubGroup))
                                                        {
                                                            isMeshFollowTerrain = true;
                                                            objPathAnchorHeightLS = LBLandscapeTerrain.GetHeight(gVars.lbGroupParams.landscape, heightMap1D, gVars.landscapeHeightmapResolution, new Vector2(centreSplinePointArray[0].x, centreSplinePointArray[0].z), true) * gVars.terrainHeight;
                                                            objPathSurfaceHeightOffset = objPathAnchorHeightLS + gVars.lbGroupParams.landscape.start.y;
                                                        }

                                                        #endregion Get Anchor Point Height for Surface Mesh

                                                        // NOTE: This code is repeated, with different params, below in 'Add Surface and Base Meshes in GroupDesigner or without TerrainFlatten'
                                                        // Here we don't need to fetch the heightmap of all terrains because we already have it.
                                                        if (lbObjPath.CreateMeshFromPath(gVars.lbGroupParams.landscape, heightMap1D, gVars.landscapeHeightmapResolution, isGroupTypeProceduralClearing || isGroupTypeManualClearing || isChildGroup, groupPositionWS, clearingRotationY, false, (regionIdx + 1), isGroupTypeUniform, isMeshFollowTerrain, objPathAnchorHeightLS, gVars.lbGroupParams.showErrors))
                                                        {                                                            

                                                            // Object path meshes are created in world space, not in landscape-space. The gameobject is at 0,0,0 rather than the landscape position
                                                            Vector3 meshOffset = new Vector3(0f, lbObjPath.meshYOffset + objPathSurfaceHeightOffset, 0f);

                                                            //Debug.Log("[DEBUG] CreateMeshFromPath with flatten [" + lbObjPath.pathName + "] - meshOffset: " + meshOffset + " at " + new Vector2(centreSplinePointArray[0].x, centreSplinePointArray[0].z));

                                                            // The parent gameobject must contain the word "Mesh" as it is used by RemoveExistingPrefabs()
                                                            Transform meshTransform = LBMeshOperations.AddMeshToScene(lbObjPath.lbMesh, meshOffset, lbObjPath.pathName + "." + (regionIdx + 1) + " Mesh", memberPrefabGameObject.transform, lbObjPath.surfaceMeshMaterial, true, true);
                                                            if (meshTransform != null)
                                                            {
                                                                if (lbObjPath.isCreateSurfaceMeshCollider) { meshTransform.gameObject.AddComponent(typeof(MeshCollider)); }

                                                                // TODO - Add water to Object Path
                                                                if (lbObjPath.meshIncludeWater)
                                                                {

                                                                }
                                                            }

                                                            if (lbObjPath.CreateBaseMesh(gVars.lbGroupParams.landscape, heightMap1D, gVars.landscapeHeightmapResolution, isGroupTypeProceduralClearing || isGroupTypeManualClearing || isChildGroup, groupPositionWS, clearingRotationY, false, (regionIdx+1), isGroupTypeUniform, isMeshFollowTerrain, objPathAnchorHeightLS, gVars.lbGroupParams.showErrors))
                                                            {
                                                                int numMeshes = lbObjPath.baseMeshList == null ? 0 : lbObjPath.baseMeshList.Count;

                                                                for (int mshIdx = 0; mshIdx < numMeshes; mshIdx++)
                                                                {
                                                                    // The parent gameobject must contain the word "Mesh" as it is used by RemoveExistingPrefabs()
                                                                    meshTransform = LBMeshOperations.AddMeshToScene(lbObjPath.baseMeshList[mshIdx], meshOffset, lbObjPath.pathName + "." + (regionIdx + 1) + " BaseMesh" + mshIdx, memberPrefabGameObject.transform, lbObjPath.baseMeshMaterial, true, true);
                                                                    if (meshTransform != null)
                                                                    {
                                                                        if (lbObjPath.isCreateBaseMeshCollider) { meshTransform.gameObject.AddComponent(typeof(MeshCollider)); }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }

                                                    #endregion
                                                }
                                            }
                                        }
                                    }
                                    catch (System.Exception ex)
                                    {
                                        Debug.LogWarning("ERROR " + methodName + " - could not process Object Path " + lbObjPath.pathName + " on GPU. " + ex.Message);
                                    }
                                    #region Cleanup ObjPath Flatten resources
                                    finally
                                    {
                                        if (gVars.cbufHeightsIn != null) { gVars.cbufHeightsIn.Release(); gVars.cbufHeightsIn = null; }
                                        if (gVars.cbufHeightsOut != null) { gVars.cbufHeightsOut.Release(); gVars.cbufHeightsOut = null; }
                                        if (gVars.cbufSplinePointsCentre != null) { gVars.cbufSplinePointsCentre.Release(); gVars.cbufSplinePointsCentre = null; }
                                        if (gVars.cbufSplinePointsLeft != null) { gVars.cbufSplinePointsLeft.Release(); gVars.cbufSplinePointsLeft = null; }
                                        if (gVars.cbufSplinePointsRight != null) { gVars.cbufSplinePointsRight.Release(); gVars.cbufSplinePointsRight = null; }
                                        if (gVars.cbufObjPathSurroundBlendCurve != null) { gVars.cbufObjPathSurroundBlendCurve.Release(); gVars.cbufObjPathSurroundBlendCurve = null; }
                                        if (gVars.cbufObjPathProfileHeightCurve != null) { gVars.cbufObjPathProfileHeightCurve.Release(); gVars.cbufObjPathProfileHeightCurve = null; }
                                        if (gVars.shaderPath != null) { gVars.shaderPath = null; }
                                    }
                                    #endregion

#endif
                                }
                                #endregion

                                #region Add Surface and Base Meshes in GroupDesigner or without TerrainFlatten
                                if (lbObjPath.useSurfaceMesh && numSplineCentrePoints > 1 && (gVars.isGroupDesignerEnabled || !lbGroupMember.isTerrainFlattened))
                                {
                                    // NOTE: This code is repeated, with different params. Here and above in 'Compute Flatten ObjPath and optionally add Surface and Base Meshes'.
                                    // Here we need to also get the landscape-scoped heightmap because unlike above, we don't already have the current heightmap.
                                    float[] heightMap1D = null;

                                    // The anchor point at the start of the path in landscape-space (doesn't include landscape.start.y)
                                    float objPathAnchorHeightLS = 0f;
                                    objPathSurfaceHeightOffset = 0f;
                                    // This indicates that the mesh should follow the general trend of the terrain,
                                    // based on the terrain height at each user-defined point, relative to the anchor point
                                    // at the start of the path.
                                    bool isMeshFollowTerrain = false;

                                    if (!gVars.isGroupDesignerEnabled)
                                    {
                                        heightMap1D = new float[gVars.landscapeHeightmapSize];

                                        if (!GetLandscapeScopedHeightmap(gVars.lbGroupParams.landscape, heightMap1D, false, gVars.lbGroupParams.showErrors)) { if (gVars.lbGroupParams.showErrors) { Debug.LogWarning("ERROR " + methodName + " - could not populate landscape-scoped heightmap array for Object Path " + lbObjPath.pathName + " on GPU."); } }

                                        #region Get Anchor Point Height for Surface Mesh
                                        // This is required when a surface mesh needs to follow the path heights (rather than snap to terrain) in a clearing or subgroup.
                                        // NOTE: Uniform groups already have the correct heights for path points
                                        if (!lbObjPath.meshEdgeSnapToTerrain && (isGroupTypeProceduralClearing || isGroupTypeManualClearing || isGroupTypeSubGroup))
                                        {
                                            isMeshFollowTerrain = true;
                                            objPathAnchorHeightLS = LBLandscapeTerrain.GetHeight(gVars.lbGroupParams.landscape, heightMap1D, gVars.landscapeHeightmapResolution, new Vector2(centreSplinePointArray[0].x, centreSplinePointArray[0].z), true) * gVars.terrainHeight;
                                            objPathSurfaceHeightOffset = objPathAnchorHeightLS + gVars.lbGroupParams.landscape.start.y;
                                        }

                                        #endregion Get Anchor Point Height for Surface Mesh
                                    }

                                    // In LB 2.2.0 use groupPositionWS - which gets adjusted for both GroupDesigner and other.
                                    if (lbObjPath.CreateMeshFromPath(gVars.lbGroupParams.landscape, heightMap1D, gVars.landscapeHeightmapResolution, isGroupTypeProceduralClearing || isGroupTypeManualClearing || isChildGroup, groupPositionWS, clearingRotationY, gVars.isGroupDesignerEnabled, (regionIdx+1), isGroupTypeUniform, isMeshFollowTerrain, objPathAnchorHeightLS, gVars.lbGroupParams.showErrors))
                                    {
                                        // Object path meshes are created in world space, not in landscape-space. The gameobject is at 0,0,0 rather than the landscape position
                                        Vector3 meshOffset = new Vector3(0f, lbObjPath.meshYOffset + gVars.lbGroupParams.designerOffsetY + objPathSurfaceHeightOffset, 0f);

                                        // Make sure things like river surface meshes appear in the group designer above the group designer base plane.                                        
                                        if (gVars.isGroupDesignerEnabled && meshOffset.y < gVars.lbGroupParams.designerOffsetY) { meshOffset.y = gVars.lbGroupParams.designerOffsetY + 0.001f; }

                                        // The parent gameobject must contain the word "Mesh" as it is used by RemoveExistingPrefabs()
                                        Transform meshTransform = LBMeshOperations.AddMeshToScene(lbObjPath.lbMesh, meshOffset, lbObjPath.pathName + "." + (regionIdx + 1) + " Mesh", memberPrefabGameObject.transform, lbObjPath.surfaceMeshMaterial, true, true);
                                        if (meshTransform != null)
                                        {
                                            if (lbObjPath.isCreateSurfaceMeshCollider) { meshTransform.gameObject.AddComponent(typeof(MeshCollider)); }
                                            // TODO - Add water to Object Path
                                        }

                                        if (lbObjPath.CreateBaseMesh(gVars.lbGroupParams.landscape, heightMap1D, gVars.landscapeHeightmapResolution, isGroupTypeProceduralClearing || isGroupTypeManualClearing || isChildGroup, groupPositionWS, clearingRotationY, gVars.isGroupDesignerEnabled, (regionIdx+1), isGroupTypeUniform, isMeshFollowTerrain, objPathAnchorHeightLS, gVars.lbGroupParams.showErrors))
                                        {
                                            int numMeshes = lbObjPath.baseMeshList == null ? 0 : lbObjPath.baseMeshList.Count;

                                            //Debug.Log("[DEBUG] CreateBaseMesh for " + lbGroup.groupName + " region: " + regionIdx + " numMeshes: " + numMeshes);

                                            for (int mshIdx = 0; mshIdx < numMeshes; mshIdx++)
                                            {
                                                // The parent gameobject must contain the word "Mesh" as it is used by RemoveExistingPrefabs()
                                                meshTransform = LBMeshOperations.AddMeshToScene(lbObjPath.baseMeshList[mshIdx], meshOffset, lbObjPath.pathName + "." + (regionIdx + 1) + " BaseMesh" + mshIdx, memberPrefabGameObject.transform, lbObjPath.baseMeshMaterial, true, true);
                                                if (meshTransform != null)
                                                {
                                                    //Debug.Log("[DEBUG] CreateBaseMesh for " + lbGroup.groupName + " region: " + regionIdx + " numMeshes: " + numMeshes + " verts " + lbObjPath.baseMeshList[mshIdx].verts.Count);
                                                    if (lbObjPath.isCreateBaseMeshCollider) { meshTransform.gameObject.AddComponent(typeof(MeshCollider)); }
                                                }
                                            }
                                        }
                                    }
                                }
                                #endregion

                                #region Vegetation Studio Pro add biome and/or remove grass
                                #if VEGETATION_STUDIO_PRO
                                if (gVars.lbGroupParams.landscape.useVegetationSystem && !gVars.isGroupDesignerEnabled && (lbObjPath.isRemoveExistingGrass || lbObjPath.useBiomes) && memberPrefabGameObject != null && numSplineCentrePoints > 1)
                                {
                                    if (memberPrefabGameObject != null)
                                    {
                                        if (lbObjPath.useBiomes)
                                        {
                                            // Create a Biome Mask Area of the object path
                                            lbBiome = lbObjPath.lbBiomeList == null ? null : lbObjPath.lbBiomeList[0];
                                            if (lbBiome != null)
                                            {
                                                string maskName = "[BIOMEMASK] " + lbGroup.groupName + memberPrefabGameObject.name + "." + (regionIdx + 1);

                                                biomeMaskArea = LBIntegration.VegetationStudioProCreateBiomeMaskArea(gVars.vsPro, maskName, memberPrefabGameObject.transform, lbBiome);

                                                if (biomeMaskArea != null)
                                                {
                                                    biomeMaskArea.ClearNodes();
                                                    AwesomeTechnologies.VegetationSystem.Biomes.Node areaNode;

                                                    // The parent already has the correct position, so reset the local position so that
                                                    // position is inherited from parent.
                                                    biomeMaskArea.transform.localPosition = Vector3.zero;

                                                    // Groups need to be converted from group-space to worldspace points
                                                    if (isGroupTypeProceduralClearing || isGroupTypeManualClearing || isChildGroup)
                                                    {
                                                        Vector3[] leftSplinePointArrayVegArea = new Vector3[lbObjPath.cachedCentreSplinePointsLength];
                                                        Vector3[] rightSplinePointArrayVegArea = new Vector3[lbObjPath.cachedCentreSplinePointsLength];

                                                        // This is returning the landscape-space points because groupPosition is in landscape-space rather than world-space.
                                                        // With VSP 1.2.1 this works. It might be because the VegetationMaskArea is at the same offset as the parent
                                                        // landscape gameobject.
                                                        lbObjPath.ToWorldSpace(lbObjPath.cachedSplinePointLeftEdgeList, leftSplinePointArrayVegArea, groupPosition, clearingRotationY);
                                                        lbObjPath.ToWorldSpace(lbObjPath.cachedSplinePointRightEdgeList, rightSplinePointArrayVegArea, groupPosition, clearingRotationY);

                                                        // Add all the left spline points of the ObjPath as new nodes
                                                        for (int sptIdx = 0; sptIdx < lbObjPath.cachedCentreSplinePointsLength; sptIdx++)
                                                        {
                                                            areaNode = new AwesomeTechnologies.VegetationSystem.Biomes.Node();
                                                            areaNode.Position = leftSplinePointArrayVegArea[sptIdx];
                                                            biomeMaskArea.Nodes.Add(areaNode);
                                                        }

                                                        // Add all the right spline points from the end back to the start
                                                        for (int sptIdx = lbObjPath.cachedCentreSplinePointsLength - 1; sptIdx >= 0; sptIdx--)
                                                        {
                                                            areaNode = new AwesomeTechnologies.VegetationSystem.Biomes.Node();
                                                            areaNode.Position = rightSplinePointArrayVegArea[sptIdx];
                                                            biomeMaskArea.Nodes.Add(areaNode);
                                                        }
                                                    }
                                                    else
                                                    {
                                                        // Object Paths in Uniform Groups. The gameobject for the Uniform Group, which is the parent
                                                        // of the Vegetation Studio Pro Biome Area, has a zero-offset from the landscape
                                                        // parent gameobject.

                                                        // Add all the left spline points of the ObjPath as new nodes
                                                        for (int sptIdx = 0; sptIdx < numSplineCentrePoints; sptIdx++)
                                                        {
                                                            areaNode = new AwesomeTechnologies.VegetationSystem.Biomes.Node();
                                                            areaNode.Position = lbObjPath.cachedSplinePointLeftEdgeList[sptIdx] - groupPositionWS;
                                                            biomeMaskArea.Nodes.Add(areaNode);
                                                        }

                                                        // Add all the right spline points from the end back to the start
                                                        for (int sptIdx = numSplineCentrePoints - 1; sptIdx >= 0; sptIdx--)
                                                        {
                                                            areaNode = new AwesomeTechnologies.VegetationSystem.Biomes.Node();
                                                            areaNode.Position = lbObjPath.cachedSplinePointRightEdgeList[sptIdx] - groupPositionWS;
                                                            biomeMaskArea.Nodes.Add(areaNode);
                                                        }
                                                    }
                                                    biomeMaskArea.UpdateBiomeMask();
                                                }
                                            }
                                        }
                                        if (lbObjPath.isRemoveExistingGrass)
                                        {
                                            vegetationMaskArea = memberPrefabGameObject.AddComponent<AwesomeTechnologies.VegetationMaskArea>();
                                            if (vegetationMaskArea != null && vegetationMaskArea.Nodes != null)
                                            {
                                                // Update settings for this Vegetation Mask Area
                                                vegetationMaskArea.RemoveTrees = false;
                                                vegetationMaskArea.RemoveLargeObjects = false;
                                                vegetationMaskArea.RemoveObjects = false;
                                                vegetationMaskArea.RemovePlants = false;
                                                vegetationMaskArea.RemoveGrass = true;
                                                vegetationMaskArea.MaskName = memberPrefabGameObject.name;
                                                vegetationMaskArea.ShowHandles = false;

                                                // By default there are 4 nodes
                                                vegetationMaskArea.ClearNodes();

                                                AwesomeTechnologies.Node vspNode = new AwesomeTechnologies.Node();

                                                // Groups need to be converted from group-space to worldspace points
                                                if (isGroupTypeProceduralClearing || isGroupTypeManualClearing || isChildGroup)
                                                {
                                                    Vector3[] leftSplinePointArrayVegArea = new Vector3[lbObjPath.cachedCentreSplinePointsLength];
                                                    Vector3[] rightSplinePointArrayVegArea = new Vector3[lbObjPath.cachedCentreSplinePointsLength];

                                                    // This is returning the landscape-space points because groupPosition is in landscape-space rather than world-space.
                                                    // With VSP 1.2.1 this works. It might be because the VegetationMaskArea is at the same offset as the parent
                                                    // landscape gameobject.
                                                    lbObjPath.ToWorldSpace(lbObjPath.cachedSplinePointLeftEdgeList, leftSplinePointArrayVegArea, groupPosition, clearingRotationY);
                                                    lbObjPath.ToWorldSpace(lbObjPath.cachedSplinePointRightEdgeList, rightSplinePointArrayVegArea, groupPosition, clearingRotationY);

                                                    // Add all the left spline points of the ObjPath as new nodes
                                                    for (int sptIdx = 0; sptIdx < lbObjPath.cachedCentreSplinePointsLength; sptIdx++)
                                                    {
                                                        vspNode = new AwesomeTechnologies.Node();
                                                        vspNode.Position = leftSplinePointArrayVegArea[sptIdx];
                                                        vegetationMaskArea.Nodes.Add(vspNode);
                                                    }

                                                    // Add all the right spline points from the end back to the start
                                                    for (int sptIdx = lbObjPath.cachedCentreSplinePointsLength - 1; sptIdx >= 0; sptIdx--)
                                                    {
                                                        vspNode = new AwesomeTechnologies.Node();
                                                        vspNode.Position = rightSplinePointArrayVegArea[sptIdx];
                                                        vegetationMaskArea.Nodes.Add(vspNode);
                                                    }
                                                }
                                                else
                                                {
                                                    // Object Paths in Uniform Groups. The gameobject for the Uniform Group, which has the
                                                    // Vegetation Studio Pro Mask Area component added, has a zero-offset from the landscape
                                                    // parent gameobject.

                                                    // Add all the left spline points of the ObjPath as new nodes
                                                    for (int sptIdx = 0; sptIdx < numSplineCentrePoints; sptIdx++)
                                                    {
                                                        vspNode = new AwesomeTechnologies.Node();
                                                        vspNode.Position = lbObjPath.cachedSplinePointLeftEdgeList[sptIdx] - groupPositionWS;
                                                        vegetationMaskArea.Nodes.Add(vspNode);
                                                    }

                                                    // Add all the right spline points from the end back to the start
                                                    for (int sptIdx = numSplineCentrePoints - 1; sptIdx >= 0; sptIdx--)
                                                    {
                                                        vspNode = new AwesomeTechnologies.Node();
                                                        vspNode.Position = lbObjPath.cachedSplinePointRightEdgeList[sptIdx] - groupPositionWS;
                                                        vegetationMaskArea.Nodes.Add(vspNode);
                                                    }
                                                }

                                                vegetationMaskArea.UpdateVegetationMask();
                                            }
                                        }
                                    }
                                }

                                #endif
                                #endregion

                                #region Compute ObjPath Texture Terrain
                                #if LB_COMPUTE
                                if (gVars.isPathComputeEnabled && !gVars.isGroupDesignerEnabled && (!string.IsNullOrEmpty(lbObjPath.coreTextureGUID) || !string.IsNullOrEmpty(lbObjPath.surroundTextureGUID)))
                                {
                                    #region Reset Garbage Collection
                                    System.GC.Collect();
                                    #endregion

                                    #region Get Noise Offset for ground textures
                                    if (lbRandomObjPathCoreTexNoiseOffset == null) { lbRandomObjPathCoreTexNoiseOffset = new LBRandom(); }
                                    if (lbRandomObjPathSurrTexNoiseOffset == null) { lbRandomObjPathSurrTexNoiseOffset = new LBRandom(); }
                                    // The random range is seeded with an arbitary number at moment. This could be changed if required.
                                    if (lbRandomObjPathCoreTexNoiseOffset != null) { lbRandomObjPathCoreTexNoiseOffset.SetSeed((int)groupPosition.x); }
                                    if (lbRandomObjPathSurrTexNoiseOffset != null) { lbRandomObjPathSurrTexNoiseOffset.SetSeed((int)groupPosition.z); }
                                    #endregion

                                    try
                                    {
                                        // Load shader
                                        gVars.shaderPath = (ComputeShader)Resources.Load(LBCSPathTex, typeof(ComputeShader));

                                        // Perform some validation
                                        if (gVars.shaderPath == null) { if (gVars.lbGroupParams.showErrors) { Debug.LogWarning("ERROR: " + methodName + " " + LBCSPathTex + ".shader not found. Please Report"); } }
                                        else if (numSplineCentrePoints < 2) { if (gVars.lbGroupParams.showErrors) { Debug.LogWarning("ERROR: " + methodName + " - Texturing - Object Path " + lbObjPath.pathName + " - must have at least 2 centre spline points"); } }
                                        else if (numSplineLeftPoints < 2) { if (gVars.lbGroupParams.showErrors) { Debug.LogWarning("ERROR: " + methodName + " - Texturing - Object Path " + lbObjPath.pathName + " - must have at least 2 left spline points"); } }
                                        else if (numSplineRightPoints < 2) { if (gVars.lbGroupParams.showErrors) { Debug.LogWarning("ERROR: " + methodName + " - Texturing - Object Path " + lbObjPath.pathName + " - must have at least 2 right spline points"); } }
                                        else if (numSplineLeftPoints != numSplineRightPoints) { if (gVars.lbGroupParams.showErrors) { Debug.LogWarning("ERROR: " + methodName + " - Texturing - Object Path " + lbObjPath.pathName + " - in this release the number of left and right spline points must be the same"); } }
                                        else if (numSplineCentrePoints != numSplineRightPoints) { if (gVars.lbGroupParams.showErrors) { Debug.LogWarning("ERROR: " + methodName + " - Texturing - Object Path " + lbObjPath.pathName + " - in this release the number of centre, left and right spline points must be the same"); } }
                                        else
                                        {
                                            #region Init Compute Shader
                                            bool shaderInitialised = false;
                                            // Must match LB_PATH_TEX_NUM_THREADS/LB_PATH_TEX_NUM_THREADS_4K in LBCSPathTex.compute
                                            // OSX Metal seems to have a limit of 256. Not sure if this is hardware dependent.
                                            int cskObjPathTexNumThreads = gVars.terrainAlphamapResolution >= 4096 ? 512 : 256;

                                            // Get the index to the Methods in the compute shader
                                            int kObjPathTexIdx = gVars.shaderPath.FindKernel(gVars.terrainAlphamapResolution >= 4096 ? CSKObjPathTex4K : CSKObjPathTex);

                                            #region Create Buffers
                                            gVars.shaderPath.SetInt(CSnumSplineCentrePoints, numSplineCentrePoints);

                                            // Assume all spline have the same number of items (which is validated above)
                                            gVars.cbufSplinePointsCentre = new ComputeBuffer(numSplineCentrePoints, sizeof(float) * 3, ComputeBufferType.Default);
                                            gVars.cbufSplinePointsLeft = new ComputeBuffer(numSplineCentrePoints, sizeof(float) * 3, ComputeBufferType.Default);
                                            gVars.cbufSplinePointsRight = new ComputeBuffer(numSplineCentrePoints, sizeof(float) * 3, ComputeBufferType.Default);

                                            // To be consistent with how textures are processed in PopulateLandscapeWithGroups(), process
                                            // 1 terrain at a time. 
                                            // Size of a single splatmap layer for a single terrain
                                            int splatMap1DSize = gVars.terrainAlphamapResolution * gVars.terrainAlphamapResolution;

                                            // Create 1D array to store splatMaps = (alphares ^ 2) * numtextures
                                            int splatMaps1DSizeTarget = splatMap1DSize * gVars.totalTextureAdditionArrays;
                                            float[] splatMaps1D = new float[splatMaps1DSizeTarget];

                                            int splatMaps1DSize = (splatMaps1D == null ? 0 : splatMaps1D.Length);

                                            if (splatMaps1DSize == splatMaps1DSizeTarget)
                                            {
                                                // Create the flat splatmap buffer to hold all splats for 1 terrain
                                                gVars.cbufSplatMaps = new ComputeBuffer(splatMaps1DSizeTarget, sizeof(float), ComputeBufferType.Default);
                                            }

                                            // SplatAdditions contains the changes that have been applied already to the splatmaps in other groups or group members
                                            // The Object Path will be making more changes to this array. This is a landscape-scoped array.
                                            int[] textureAdditionArrayInt = new int[gVars.textureAdditionArraySize];
                                            if (textureAdditionArrayInt.Length == gVars.textureAdditionArraySize)
                                            {
                                                gVars.cbufSplatAdditions = new ComputeBuffer(gVars.textureAdditionArraySize, sizeof(int), ComputeBufferType.Default);
                                            }

                                            #endregion

                                            if (gVars.cbufSplinePointsCentre != null && gVars.cbufSplinePointsLeft != null && gVars.cbufSplinePointsRight != null && gVars.cbufSplatMaps != null && gVars.cbufSplatAdditions != null)
                                            {
                                                #region Assign spline buffers and copy spline data to shader
                                                // Allocate buffers to the compute shader method
                                                gVars.shaderPath.SetBuffer(kObjPathTexIdx, CSsplinePointsCentre, gVars.cbufSplinePointsCentre);
                                                gVars.shaderPath.SetBuffer(kObjPathTexIdx, CSsplinePointsLeft, gVars.cbufSplinePointsLeft);
                                                gVars.shaderPath.SetBuffer(kObjPathTexIdx, CSsplinePointsRight, gVars.cbufSplinePointsRight);

                                                // Copy the data to the shader
                                                gVars.cbufSplinePointsCentre.SetData(centreSplinePointArray);
                                                gVars.cbufSplinePointsLeft.SetData(leftSplinePointArray);
                                                gVars.cbufSplinePointsRight.SetData(rightSplinePointArray);

                                                gVars.shaderPath.SetVector(CSpathBounds, objPathBounds);
                                                #endregion

                                                #region Allocate additional buffers to methods and copy data
                                                // Set the splatmaps buffer to be used by the ObjPathTex method in the shader
                                                gVars.shaderPath.SetBuffer(kObjPathTexIdx, CSsplatMaps, gVars.cbufSplatMaps);

                                                // Copy the Additions byte array into the int array (compute shaders don't support byte buffers)           
                                                for (int aaIdx = 0; aaIdx < gVars.textureAdditionArraySize; aaIdx++) { textureAdditionArrayInt[aaIdx] = (int)gVars.textureAdditionArray[aaIdx]; }

                                                // Copy the data to the compute shader
                                                gVars.shaderPath.SetBuffer(kObjPathTexIdx, CSsplatAdditions, gVars.cbufSplatAdditions);
                                                gVars.cbufSplatAdditions.SetData(textureAdditionArrayInt);
                                                #endregion

                                                #region Set landscape and topography variables in shader
                                                gVars.shaderPath.SetInt(CSheightmapResolution, gVars.landscapeHeightmapResolution);
                                                // Landscape variables
                                                gVars.shaderPath.SetVector(CSlandscapePos, gVars.landscapePosition);
                                                gVars.shaderPath.SetVector(CSlandscapeSize, gVars.lbGroupParams.landscape.size);
                                                #endregion

                                                #region Set Shader Variables

                                                // Set compute shader variables which are same for all terrains
                                                gVars.shaderPath.SetInt(CSnumTerrainsWide, gVars.numTerrainsWide);
                                                gVars.shaderPath.SetInt(CSnumSplatTextures, gVars.totalTextureAdditionArrays);
                                                gVars.shaderPath.SetInt(CSalphaMapWidth, gVars.terrainAlphamapResolution);
                                                gVars.shaderPath.SetInt(CSalphaMapLength, gVars.terrainAlphamapResolution);

                                                // Textures will be passed to the shader as an index starting at 1 (rather than being 0-based)
                                                // A value of 0 will denote an undefined Texture. So Texture 1 in the Texturing tab will be 1,
                                                // Texture 2 will be 2 etc. This is how they look in the Object Path Core Texture dropdown list
                                                // in the LB Editor.

                                                // Find the core texture on the Texturing tab
                                                int textureIdx = gVars.terrainTextureList.FindIndex(ojpTx => ojpTx.GUID == lbObjPath.coreTextureGUID);
                                                if (textureIdx >= 0)
                                                {
                                                    // Is this Texture from the Texturing tab, actually in the terrain as a splatprototype?
                                                    if (gVars.terrainTextureArrayIndexList[textureIdx] < 0) { textureIdx = 0; }
                                                    else { textureIdx = gVars.terrainTextureArrayIndexList[textureIdx] + 1; }
                                                }
                                                else { textureIdx = 0; }
                                                gVars.shaderPath.SetInt(CSObjPathCoreTexIdx, textureIdx);

                                                // Find the surround texture on the Texturing tab
                                                textureIdx = gVars.terrainTextureList.FindIndex(ojpTx => ojpTx.GUID == lbObjPath.surroundTextureGUID);
                                                if (textureIdx >= 0)
                                                {
                                                    // Is this Texture from the Texturing tab, actually in the terrain as a splatprototype?
                                                    if (gVars.terrainTextureArrayIndexList[textureIdx] < 0) { textureIdx = 0; }
                                                    else { textureIdx = gVars.terrainTextureArrayIndexList[textureIdx] + 1; }
                                                }
                                                else { textureIdx = 0; }
                                                gVars.shaderPath.SetInt(CSObjPathSurroundTexIdx, textureIdx);

                                                // If noise is enabled, get the noise offset
                                                if (lbObjPath.coreTextureNoiseTileSize > 0f)
                                                {
                                                    objPathCoreTexNoiseOffset = lbRandomObjPathCoreTexNoiseOffset.Range(0f, lbObjPath.coreTextureNoiseTileSize + 0.001f);
                                                }
                                                else { objPathCoreTexNoiseOffset = 0f; }
                                                if (lbObjPath.surroundTextureNoiseTileSize > 0f)
                                                {
                                                    objPathSurrTexNoiseOffset = lbRandomObjPathCoreTexNoiseOffset.Range(0f, lbObjPath.surroundTextureNoiseTileSize + 0.001f);
                                                }
                                                else { objPathSurrTexNoiseOffset = 0f; }

                                                // x: texture strength
                                                // y: noise indicator (0=on, 1=off). If noise is not used, it will always return >= 1.0 in shader and be clamped to 1.0
                                                // z: noise tile size. When 0, set to arbitory value to avoid div0 in compute shader
                                                // w: noise offset
                                                gVars.shaderPath.SetVector
                                                (CSObjPathCoreTexParms,
                                                 new Vector4(
                                                 lbObjPath.coreTextureStrength,
                                                 lbObjPath.coreTextureNoiseTileSize > 0f ? 0f : 1f,
                                                 lbObjPath.coreTextureNoiseTileSize > 0f ? lbObjPath.coreTextureNoiseTileSize : 100f,
                                                 objPathCoreTexNoiseOffset
                                                ));

                                                gVars.shaderPath.SetVector
                                                (CSObjPathSurrTexParms,
                                                 new Vector4(
                                                 lbObjPath.surroundTextureStrength,
                                                 lbObjPath.surroundTextureNoiseTileSize > 0f ? 0f : 1f,
                                                 lbObjPath.surroundTextureNoiseTileSize > 0f ? lbObjPath.surroundTextureNoiseTileSize : 100f,
                                                 objPathSurrTexNoiseOffset
                                                ));

                                                gVars.shaderPath.SetFloat(CSedgeBlendWidth, lbObjPath.edgeBlendWidth);
                                                gVars.shaderPath.SetBool(CSblendStart, lbObjPath.blendStart);
                                                gVars.shaderPath.SetBool(CSblendEnd, lbObjPath.blendEnd);

                                                //Debug.Log("[DEBUG] " + methodName + " Object Path " + lbObjPath.pathName + " on GPU. surround texture " + textureIdx);

                                                gVars.shaderPath.SetFloat(CSterrainWidth, gVars.terrainWidth);
                                                gVars.shaderPath.SetFloat(CSterrainLength, gVars.terrainLength);
                                                gVars.shaderPath.SetFloat(CSterrainHeight, gVars.terrainHeight);

                                                // Path variables
                                                gVars.shaderPath.SetBool(CSclosedCircuit, lbObjPath.closedCircuit);
                                                gVars.shaderPath.SetInt(CSquadLookAhead, 1);
                                                #endregion

                                                shaderInitialised = true;
                                            }

                                            #endregion Init Compute Shader

                                            #region Process Terrains
                                            if (shaderInitialised)
                                            {
                                                for (int terrainIdx = 0; terrainIdx < gVars.numTerrains; terrainIdx++)
                                                {
                                                    Terrain tTerrain = gVars.landscapeTerrains[terrainIdx];
                                                    if (tTerrain == null) { if (gVars.lbGroupParams.showErrors) { Debug.LogWarning("ERROR " + methodName + " - texture Object Path - terrain " + terrainIdx.ToString() + " is invalid or could not be found. Please Report."); } break; }
                                                    else
                                                    {
                                                        TerrainData tTerrainData = tTerrain.terrainData;
                                                        if (tTerrainData == null) { if (gVars.lbGroupParams.showErrors) { Debug.LogWarning("ERROR " + methodName + " - texture Object Path - some terrain data is invalid or could not be found. Please Report."); } break; }
                                                        else
                                                        {
                                                            #region Get Splatmaps and send to compute shader

                                                            // Retrieve the texture arrays from the terrain data
                                                            float[,,] terrainTextureArray = tTerrainData.GetAlphamaps(0, 0, gVars.terrainAlphamapResolution, gVars.terrainAlphamapResolution);

                                                            // Convert from 3D to 1D array
                                                            // Copy 3D alphamap array to shader 1D array
                                                            for (int smTexIdx = 0; smTexIdx < gVars.totalTextureAdditionArrays; smTexIdx++)
                                                            {
                                                                for (int z = 0; z < gVars.terrainAlphamapResolution; z++)
                                                                {
                                                                    for (int x = 0; x < gVars.terrainAlphamapResolution; x++)
                                                                    {
                                                                        splatMaps1D[(splatMap1DSize * smTexIdx) + (gVars.terrainAlphamapResolution * z) + x] = terrainTextureArray[z, x, smTexIdx];
                                                                    }
                                                                }
                                                            }

                                                            // Copy 1D splatmaps array to shader
                                                            gVars.cbufSplatMaps.SetData(splatMaps1D);
                                                            #endregion

                                                            #region Per-Terrain Compute Shader variables
                                                            gVars.shaderPath.SetInt(CSterrainIdx, terrainIdx);
                                                            gVars.shaderPath.SetVector(CSterrainWorldPos, tTerrain.transform.position);
                                                            #endregion

                                                            //Debug.Log("[DEBUG] " + methodName + " Object Path " + lbObjPath.pathName + " on GPU. terain " + terrainIdx + " " + tTerrain.transform.name + " terrainWorldPos: " + tTerrain.transform.position);

                                                            #region Execute the compute shader

                                                            int threadGroupX = Mathf.CeilToInt(splatMap1DSize / cskObjPathTexNumThreads);
                                                            gVars.shaderPath.Dispatch(kObjPathTexIdx, threadGroupX, 1, 1);

                                                            #endregion

                                                            //Debug.Log("[DEBUG] " + methodName + " Object Path " + lbObjPath.pathName + " on GPU. terain " + terrainIdx);
                                                        }
                                                    }
                                                }

                                                if (gVars.numTerrains > 0)
                                                {
                                                    // Retrieve the splat additions
                                                    gVars.cbufSplatAdditions.GetData(textureAdditionArrayInt);

                                                    // Copy the Additions int array into the byte array (compute shaders don't support byte buffers)           
                                                    for (int aaIdx = 0; aaIdx < gVars.textureAdditionArraySize; aaIdx++) { gVars.textureAdditionArray[aaIdx] = (byte)textureAdditionArrayInt[aaIdx]; }

                                                    //Debug.Log("[DEBUG] " + methodName + " Object Path " + lbObjPath.pathName + " on GPU. Retrieved Data");
                                                }
                                            }

                                            #endregion
                                        }

                                    }
                                    catch (System.Exception ex)
                                    {
                                        Debug.LogWarning("ERROR " + methodName + " - could not Texture terrains along Object Path " + lbObjPath.pathName + " on GPU. " + ex.Message);
                                    }
                                    #region Cleanup ObjPath Texturing resources
                                    finally
                                    {
                                        if (gVars.cbufSplatMaps != null) { gVars.cbufSplatMaps.Release(); gVars.cbufSplatMaps = null; }
                                        if (gVars.cbufSplatAdditions != null) { gVars.cbufSplatAdditions.Release(); gVars.cbufSplatAdditions = null; }
                                        if (gVars.cbufSplinePointsCentre != null) { gVars.cbufSplinePointsCentre.Release(); gVars.cbufSplinePointsCentre = null; }
                                        if (gVars.cbufSplinePointsLeft != null) { gVars.cbufSplinePointsLeft.Release(); gVars.cbufSplinePointsLeft = null; }
                                        if (gVars.cbufSplinePointsRight != null) { gVars.cbufSplinePointsRight.Release(); gVars.cbufSplinePointsRight = null; }
                                        if (gVars.shaderPath != null) { gVars.shaderPath = null; }
                                    }
                                    #endregion
                                }
                                #endif
                                #endregion

                                #region Compute ObjPath remove trees
#if LB_COMPUTE

                                if (gVars.isPathComputeEnabled && !gVars.isGroupDesignerEnabled && lbObjPath.isRemoveExistingTrees)
                                {
                                    #region Reset Garbage Collection
                                    System.GC.Collect();
                                    #endregion

                                    try
                                    {
                                        // Load compute object path tree shader
                                        gVars.shaderPath = (ComputeShader)Resources.Load(LBCSPathTree, typeof(ComputeShader));

                                        // Perform some validation
                                        if (gVars.shaderPath == null) { if (gVars.lbGroupParams.showErrors) { Debug.LogWarning("ERROR: " + methodName + " " + LBCSPathTree + ".shader not found. Please Report"); } }
                                        else if (numSplineCentrePoints < 2) { if (gVars.lbGroupParams.showErrors) { Debug.LogWarning("ERROR: " + methodName + " - Trees - Object Path " + lbObjPath.pathName + " - must have at least 2 centre spline points"); } }
                                        else if (numSplineLeftPoints < 2) { if (gVars.lbGroupParams.showErrors) { Debug.LogWarning("ERROR: " + methodName + " - Trees - Object Path " + lbObjPath.pathName + " - must have at least 2 left spline points"); } }
                                        else if (numSplineRightPoints < 2) { if (gVars.lbGroupParams.showErrors) { Debug.LogWarning("ERROR: " + methodName + " - TexturTreesing - Object Path " + lbObjPath.pathName + " - must have at least 2 right spline points"); } }
                                        else if (numSplineLeftPoints != numSplineRightPoints) { if (gVars.lbGroupParams.showErrors) { Debug.LogWarning("ERROR: " + methodName + " - Trees - Object Path " + lbObjPath.pathName + " - in this release the number of left and right spline points must be the same"); } }
                                        else if (numSplineCentrePoints != numSplineRightPoints) { if (gVars.lbGroupParams.showErrors) { Debug.LogWarning("ERROR: " + methodName + " - Trees - Object Path " + lbObjPath.pathName + " - in this release the number of centre, left and right spline points must be the same"); } }
                                        else
                                        {
                                            #region Initialise Compute Shader
                                            bool shaderInitialised = false;
                                            // Must match LB_PATH_NUM_THREADS in LBCSPathTree.compute
                                            // OSX Metal seems to have a limit of 256. Not sure if this is hardware dependent.
                                            int cskObjPathTreeNumThreads = 256;

                                            // Get the index to the Methods in the compute shader
                                            int kObjPathRemoveTreesIdx = gVars.shaderPath.FindKernel(CSKObjPathRemoveTrees);

                                            #region Create Buffers
                                            // Assume all spline have the same number of items (which is validated above)
                                            gVars.cbufSplinePointsCentre = new ComputeBuffer(numSplineCentrePoints, sizeof(float) * 3, ComputeBufferType.Default);
                                            gVars.cbufSplinePointsLeft = new ComputeBuffer(numSplineCentrePoints, sizeof(float) * 3, ComputeBufferType.Default);
                                            gVars.cbufSplinePointsRight = new ComputeBuffer(numSplineCentrePoints, sizeof(float) * 3, ComputeBufferType.Default);

                                            int sizeLBCSObjectProximity = System.Runtime.InteropServices.Marshal.SizeOf(new LBCSObjectProximity());

                                            #endregion

                                            if (gVars.cbufSplinePointsCentre != null && gVars.cbufSplinePointsLeft != null && gVars.cbufSplinePointsRight != null)
                                            {
                                                #region Assign spline buffers and copy spline data to shader
                                                gVars.shaderPath.SetInt(CSnumSplineCentrePoints, numSplineCentrePoints);

                                                //Debug.Log("[DEBUG] (compute) remove trees from path " + lbObjPath.pathName + " numSplineCentrePoints: " + numSplineCentrePoints);

                                                // Allocate buffers to the compute shader method
                                                gVars.shaderPath.SetBuffer(kObjPathRemoveTreesIdx, CSsplinePointsCentre, gVars.cbufSplinePointsCentre);
                                                gVars.shaderPath.SetBuffer(kObjPathRemoveTreesIdx, CSsplinePointsLeft, gVars.cbufSplinePointsLeft);
                                                gVars.shaderPath.SetBuffer(kObjPathRemoveTreesIdx, CSsplinePointsRight, gVars.cbufSplinePointsRight);

                                                // Copy the data to the shader
                                                gVars.cbufSplinePointsCentre.SetData(centreSplinePointArray);
                                                // These are the (outer) surround spline points
                                                gVars.cbufSplinePointsLeft.SetData(leftSplinePointArray);
                                                gVars.cbufSplinePointsRight.SetData(rightSplinePointArray);

                                                gVars.shaderPath.SetVector(CSpathBounds, objPathBounds);
                                                #endregion

                                                #region Set landscape and topography variables in shader
                                                gVars.shaderPath.SetInt(CSheightmapResolution, gVars.landscapeHeightmapResolution);
                                                // Landscape variables
                                                gVars.shaderPath.SetVector(CSlandscapePos, gVars.landscapePosition);
                                                gVars.shaderPath.SetVector(CSlandscapeSize, gVars.lbGroupParams.landscape.size);
                                                #endregion

                                                #region Set Shader Variables

                                                // Path variables
                                                gVars.shaderPath.SetBool(CSclosedCircuit, lbObjPath.closedCircuit);
                                                gVars.shaderPath.SetInt(CSquadLookAhead, 1);
                                                gVars.shaderPath.SetFloat(CSedgeBlendWidth, lbObjPath.edgeBlendWidth);
                                                gVars.shaderPath.SetFloat(CSObjPathtreeDistFromEdge, lbObjPath.treeDistFromEdge);

                                                #endregion

                                                shaderInitialised = true;
                                            }

                                            #endregion Initialise Compute Shader

                                            #region Process Trees
                                            if (shaderInitialised)
                                            {
                                                List<LBObjectProximity> computeTreeProximityList = null;

                                                // Tree proximities details are stored in each "Cell" for faster proximity checking within Groups.
                                                // We need to process all cells to determine which trees are on the Object Path.
                                                // It "could" be faster to eliminate cells before calling the shader but this would need to be 
                                                // done on the CPU.
                                                for (int pxTreeCellIdx = 0; pxTreeCellIdx < gVars.totalProximityTreeCells; pxTreeCellIdx++)
                                                {
                                                    // Get the list of (tree) object proximities within this cell
                                                    computeTreeProximityList = gVars.treeProximitiesList[pxTreeCellIdx];
                                                    int numTreeObjProxities = computeTreeProximityList == null ? 0 : computeTreeProximityList.Count;

                                                    // Avoid attempting to create 0-sized ComputeBuffers
                                                    if (numTreeObjProxities > 0)
                                                    {
                                                        // Create a compute shader buffer to hold the object proximities for this cell
                                                        gVars.cbufLBObjectProximities = new ComputeBuffer(numTreeObjProxities, sizeLBCSObjectProximity, ComputeBufferType.Default);

                                                        gVars.cbufObjPathRemoveTreeIndexes = new ComputeBuffer(numTreeObjProxities, sizeof(int), ComputeBufferType.Default);

                                                        if (gVars.cbufLBObjectProximities != null && gVars.cbufObjPathRemoveTreeIndexes != null)
                                                        {
                                                            // Create an array of object proximities 
                                                            LBCSObjectProximity[] lbCSObjectProximities = new LBCSObjectProximity[numTreeObjProxities];

                                                            // Create an array to receive the output from the compute shader
                                                            int[] objPathRemoveTreeIndexesInt = new int[numTreeObjProxities];

                                                            #region Create and allocate tree proximity data buffers to method and copy data

                                                            // Populate the object proximities array with the list of class member properties
                                                            LBObjectProximity lbObjectProximity = null;
                                                            for (int pxIdx = 0; pxIdx < numTreeObjProxities; pxIdx++)
                                                            {
                                                                LBCSObjectProximity lbcsObjectProximity = lbCSObjectProximities[pxIdx];
                                                                lbObjectProximity = computeTreeProximityList[pxIdx];

                                                                lbcsObjectProximity.position = lbObjectProximity.position;
                                                                lbcsObjectProximity.proximity = lbObjectProximity.proximity;
                                                                lbcsObjectProximity.terrainIndex = (uint)lbObjectProximity.terrainIndex;
                                                                lbcsObjectProximity.objectIndex = (uint)lbObjectProximity.objectIndex;

                                                                lbCSObjectProximities[pxIdx] = lbcsObjectProximity;

                                                            }

                                                            // Assign the buffers to the ObjPathRemoveTrees() method in the compute shader
                                                            gVars.shaderPath.SetBuffer(kObjPathRemoveTreesIdx, CStreeObjProximities, gVars.cbufLBObjectProximities);
                                                            gVars.shaderPath.SetBuffer(kObjPathRemoveTreesIdx, CSObjPathRemoveTreeIndexes, gVars.cbufObjPathRemoveTreeIndexes);
                                                            gVars.shaderPath.SetInt(CSnumTreeObjProxities, numTreeObjProxities);

                                                            // Copy the data to the compute shader
                                                            gVars.cbufLBObjectProximities.SetData(lbCSObjectProximities);

                                                            #endregion

                                                            // We need to round up the number of passes in the shader. Although this means we "waste" parallel processing
                                                            // on the GPU, it means we can process the rest of the trees in parallel.
                                                            int threadGroupX = (numTreeObjProxities - 1) / cskObjPathTreeNumThreads;

                                                            // Execute shader
                                                            // The Z thread group is 1 because we are processing a 2D heightmap
                                                            gVars.shaderPath.Dispatch(kObjPathRemoveTreesIdx, threadGroupX + 1, 1, 1);

                                                            gVars.cbufObjPathRemoveTreeIndexes.GetData(objPathRemoveTreeIndexesInt);

                                                            //int tempTreesToBeRemoved = 0;

                                                            // record which trees to remove
                                                            for (int pxIdx = 0; pxIdx < numTreeObjProxities; pxIdx++)
                                                            {
                                                                // Should this tree be removed?
                                                                if (objPathRemoveTreeIndexesInt[pxIdx] == 1)
                                                                {
                                                                    lbObjectProximity = computeTreeProximityList[pxIdx];

                                                                    /// TODO - Should check if tree proximity it is already in list before adding

                                                                    gVars.treesToRemoveList.Add(lbObjectProximity);
                                                                    //tempTreesToBeRemoved++;
                                                                }
                                                            }

                                                            // Free the resources for the buffers
                                                            gVars.cbufLBObjectProximities.Release();
                                                            gVars.cbufLBObjectProximities = null;

                                                            gVars.cbufObjPathRemoveTreeIndexes.Release();
                                                            gVars.cbufObjPathRemoveTreeIndexes = null;

                                                            //Debug.Log("[DEBUG] (compute) remove trees from path " + lbObjPath.pathName + " cell: " + pxTreeCellIdx + " numTreeObjProxities: " + numTreeObjProxities + " remove: " + tempTreesToBeRemoved);
                                                        }
                                                    }
                                                }
                                            }
                                            #endregion
                                        }
                                    }
                                    catch (System.Exception ex)
                                    {
                                        Debug.LogWarning("ERROR " + methodName + " - could not remove trees along Object Path " + lbObjPath.pathName + " on GPU. " + ex.Message);
                                    }
                                    #region Cleanup ObjPath Tree resources
                                    finally
                                    {
                                        if (gVars.cbufSplinePointsCentre != null) { gVars.cbufSplinePointsCentre.Release(); gVars.cbufSplinePointsCentre = null; }
                                        if (gVars.cbufSplinePointsLeft != null) { gVars.cbufSplinePointsLeft.Release(); gVars.cbufSplinePointsLeft = null; }
                                        if (gVars.cbufSplinePointsRight != null) { gVars.cbufSplinePointsRight.Release(); gVars.cbufSplinePointsRight = null; }
                                        if (gVars.cbufLBObjectProximities != null) { gVars.cbufLBObjectProximities.Release(); gVars.cbufLBObjectProximities = null; }
                                        if (gVars.cbufObjPathRemoveTreeIndexes != null) { gVars.cbufObjPathRemoveTreeIndexes.Release(); gVars.cbufObjPathRemoveTreeIndexes = null; }
                                        if (gVars.shaderPath != null) { gVars.shaderPath = null; }
                                    }
                                    #endregion
                                }

#endif
                                #endregion Compute ObjPath remove trees

                                #region ObjPath Series
                                // Do we need to look up a master Series List from another Group Member of type Object Path?
                                // The Series must be in an Object Path in the same Group.
                                if (lbObjPath.isSeriesListOverride)
                                {
                                    numObjPathSeries = 0;

                                    // Look up the series list in the override GroupMember Object Path
                                    if (!string.IsNullOrEmpty(lbObjPath.seriesListGroupMemberGUID))
                                    {
                                        // Find the matching LBGroupMember (if any). It must be an Object Path
                                        int gmbrLookupIdx = lbGroup.groupMemberList.FindIndex(gmbr => gmbr.GUID == lbObjPath.seriesListGroupMemberGUID && !string.IsNullOrEmpty(gmbr.GUID) && gmbr.lbMemberType == LBGroupMember.LBMemberType.ObjPath);
                                        if (gmbrLookupIdx >= 0)
                                        {
                                            lbGroupMemberSeriesOverride = lbGroup.groupMemberList[gmbrLookupIdx];
                                            if (lbGroupMemberSeriesOverride != null && lbGroupMemberSeriesOverride.lbObjPath != null)
                                            {
                                                numObjPathSeries = lbGroupMemberSeriesOverride.lbObjPath.lbObjPathSeriesList == null ? 0 : lbGroupMemberSeriesOverride.lbObjPath.lbObjPathSeriesList.Count;
                                            }
                                        }
                                    }
                                }
                                else
                                {
                                    numObjPathSeries = lbObjPath.lbObjPathSeriesList == null ? 0 : lbObjPath.lbObjPathSeriesList.Count;
                                }

                                #endregion
                            }

                            #region Initialise Default Series
                            // NOTE: Default Series don't support SubGroups
                            isObjPathSeriesUseSubGroups = false;

                            // Avoid having to look up the enumeration multiple times
                            isSelectionMethodAlternating = lbObjPath.selectionMethod == LBObjPath.SelectionMethod.Alternating;
                            isSelectionMethodRandom = lbObjPath.selectionMethod == LBObjPath.SelectionMethod.Random;
                            isSelectionMethodRandom2 = lbObjPath.selectionMethod == LBObjPath.SelectionMethod.RandomLessRepeats;
                            isSelectionMethodRandom3 = lbObjPath.selectionMethod == LBObjPath.SelectionMethod.RandomUnique;
                            isLayoutMethodSpacing = lbObjPath.layoutMethod == LBObjPath.LayoutMethod.Spacing;
                            isLayoutMethodExactQty = lbObjPath.layoutMethod == LBObjPath.LayoutMethod.ExactQty;

                            // Get a list of Main Obj Prefabs which match an active GroupMember with a prefab
                            activeMainObjPrefabList = lbGroup.GetActiveMainObjPrefabList(lbGroupMember);
                            numMainObjsInList = activeMainObjPrefabList == null ? 0 : activeMainObjPrefabList.Count;

                            if (isLayoutMethodExactQty)
                            {
                                // Avoid div by 0, Min 2 objects on path. Use maxMainPrefabs - 1 to allow for the first point at 0 distance.
                                objPathMemberSpacingDistance = lbObjPath.maxMainPrefabs < 2 ? lbObjPath.splineLength : lbObjPath.splineLength / ((float)lbObjPath.maxMainPrefabs - 1f);
                            }
                            else if (isLayoutMethodSpacing)
                            {
                                objPathMemberSpacingDistance = lbObjPath.spacingDistance;
                            }
                            else // QtyPer100m
                            {
                                if (lbObjPath.splineLength < 100f && lbObjPath.maxMainPrefabs < 2) { objPathMemberSpacingDistance = 100f; }
                                else
                                {
                                    // For QtyPer100m, we need to use maxMainPrefabs - 1 to allow for the first point at 0 distance.
                                    objPathMemberSpacingDistance = lbObjPath.splineLength / ((lbObjPath.splineLength / 100f) * ((float)lbObjPath.maxMainPrefabs - 1f));
                                }
                            }

                            // Get a list of the positions where the prefabs will be placed along the central path
                            objPathPrefabPointList = lbObjPath.GetPositionList(objPathMemberSpacingDistance, lbObjPath.isLastObjSnappedToEnd, gVars.lbGroupParams.showErrors);

                            numObjPathPoints = (objPathPrefabPointList == null ? 0 : objPathPrefabPointList.Count);

                            // if there are no points to place prefabs or subgroups, ignore this Obj Path and continue with the next Group Member (if any)
                            if (numObjPathPoints < 1 && numObjPathSeries == 0) { continue; }

                            // Check if the start/end members for this path are defined
                            startObjPrefab = lbObjPath.startObjPrefab;
                            endObjPrefab = lbObjPath.endObjPrefab;

                            objPathStartMemberDefined = lbGroup.GetMemberByGUID(startObjPrefab.groupMemberGUID, true) != null;
                            objPathEndMemberDefined = lbGroup.GetMemberByGUID(endObjPrefab.groupMemberGUID, true) != null;

                            objPathIsRandomisePerGroupRegion = lbObjPath.isRandomisePerGroupRegion;

                            // Setup sparse path population
                            objPathPlacementCutoff = lbGroupMember.noisePlacementCutoff;

                            lbRandomObjPathSparse = new LBRandom();
                            // Set a seed value
                            if (lbRandomObjPathSparse != null && numObjPathPoints > 0)
                            {
                                // Use the x-axis value of the first point in the ObjPath as the random generator seed.
                                // Check if a different seed should be used for each group region or instance placed in the landscape
                                lbRandomObjPathSparse.SetSeed(Mathf.RoundToInt(objPathPrefabPointList[0].x + (objPathIsRandomisePerGroupRegion ? groupPosition.x : 0f)));
                            }

                            // Setup and seed Random when the SelectionMethod is Random, RandomLessRepeats or RandomUnique
                            if ((isSelectionMethodRandom || isSelectionMethodRandom2 || isSelectionMethodRandom3) && numObjPathPoints > 0)
                            {
                                lbRandomObjPathSelection = new LBRandom();
                                if (lbRandomObjPathSelection != null)
                                {
                                    // Use the z-axis value of the first point in the ObjPath as the random generator seed.
                                    // Check if a different seed should be used for each group region or instance placed in the landscape
                                    lbRandomObjPathSelection.SetSeed(Mathf.RoundToInt(objPathPrefabPointList[0].z + (objPathIsRandomisePerGroupRegion ? groupPosition.z : 0f)));
                                }
                            }

                            #endregion

                            // NOTE: ObjPath Series list settings are updated at the end of the Instantiating Members loop
                            // after the Default Series is processed
                        }

                        #endregion

                        #region Initialise combine instances 2D list for Default Series object path members
                        int objPathCbmIdx = 0;
                        if (isObjectPathMemberType)
                        {
                            objPathCombineMeshesList.Clear();
                            numActiveMainObjPrefabList = activeMainObjPrefabList.Count;
                            for (objPathCbmIdx = 0; objPathCbmIdx < numActiveMainObjPrefabList; objPathCbmIdx++)
                            {
                                objPathCombineMeshesList.Add(new List<CombineInstance>());
                            }
                        }
                        #endregion

                        #region Instantiating Members loop

                        while (!finishedInstantiatingMembers)
                        {
                            #region Decide On Member or SubGroup To Place

                            if (isObjectPathMemberType)
                            {
                                // Decide which group member or SubGroup to place based on object path rules
                                lbGroupMemberToPlace = null;
                                subGroupToPlace = null;

                                if (objPathPointIdx == 0 && objPathStartMemberDefined)
                                {
                                    // Use the start prefab for the first point if one is defined
                                    lbGroupMemberToPlace = lbGroup.GetMemberByGUID(startObjPrefab.groupMemberGUID, true);
                                    // Mark this prefab as one not to be combined using combine meshes functionality
                                    objPathCbmIdx = -1;
                                }
                                else if (objPathPointIdx == 0 && objPathStartGroupDefined)
                                {
                                    subGroupToPlace = LBGroup.GetGroupByGUID(gVars.activeGroupList, startObjSubGroup.subGroupGUID, true);
                                    // Combine meshes functionality is not used with SubGroup placement
                                    objPathCbmIdx = -1;
                                }
                                else if (objPathPointIdx == numObjPathPoints - 1 && objPathEndMemberDefined)
                                {
                                    // Use the end prefab for the last point if one is defined
                                    lbGroupMemberToPlace = lbGroup.GetMemberByGUID(endObjPrefab.groupMemberGUID, true);
                                    // Mark this prefab as one not to be combined using combine meshes functionality
                                    objPathCbmIdx = -1;
                                }
                                else if (objPathPointIdx == numObjPathPoints - 1 && objPathEndGroupDefined)
                                {
                                    subGroupToPlace = LBGroup.GetGroupByGUID(gVars.activeGroupList, endObjSubGroup.subGroupGUID, true);
                                    // Combine meshes functionality is not used with SubGroup placement
                                    objPathCbmIdx = -1;
                                }
                                else
                                {
                                    if (isSelectionMethodAlternating)
                                    {
                                        // If using alternating selection method, loop through the available prefabs or subgroups
                                        objPathPrefabIdx++;
                                        if (objPathPrefabIdx > numMainObjsInList - 1) { objPathPrefabIdx = 0; }
                                    }
                                    else if (isSelectionMethodRandom)
                                    {
                                        // If using random selection method, choose an available prefab or subgroup at random
                                        // Turning Randomise Per Group ON will also potentially affect other group members and groups
                                        // as it changes the sequence of Random numbers used by those other items.
                                        objPathPrefabIdx = objPathIsRandomisePerGroupRegion ? lbRandomObjPathSelection.Range(0, numMainObjsInList - 1) : UnityEngine.Random.Range(0, numMainObjsInList);
                                    }
                                    // Check for repeats
                                    else if (isSelectionMethodRandom2)
                                    {
                                        // If using random selection method, choose an available prefab at random
                                        objPathPrefabIdx = lbRandomObjPathSelection.Range(0, numMainObjsInList - 1);

                                        // Try again
                                        if (objPathPrefabIdx == objPathPrefabIdxPrev)
                                        {
                                            objPathPrefabIdx = lbRandomObjPathSelection.Range(0, numMainObjsInList - 1);

                                            // If it is still the same, try again if 5 or more in the list
                                            if (objPathPrefabIdx == objPathPrefabIdxPrev && numMainObjsInList > 4)
                                            {
                                                objPathPrefabIdx = lbRandomObjPathSelection.Range(0, numMainObjsInList - 1);

                                                if (objPathPrefabIdx == objPathPrefabIdxPrev)
                                                {
                                                    objPathPrefabIdx = lbRandomObjPathSelection.Range(0, numMainObjsInList - 1);
                                                }
                                            }
                                        }

                                        objPathPrefabIdxPrev = objPathPrefabIdx;
                                    }
                                    // If RandomUnique and the first random object hasn't been found yet, find it.
                                    // objPathPrefabIdx is reset at the start of each Group Member cycle AND
                                    // at the start of each Series cycle.
                                    else if (isSelectionMethodRandom3 && objPathPrefabIdx < 0)
                                    {
                                        // Get a random object from the list
                                        objPathPrefabIdx = lbRandomObjPathSelection.Range(0, numMainObjsInList - 1);
                                    }

                                    // Find the LBGroupMember to place at this point on the object path
                                    // If this is a default series and there are no start/end or main members lbGroupMemberToPlace will remain null (by design)
                                    if (objPathPrefabIdx >= 0 && objPathPrefabIdx < numMainObjsInList)
                                    {
                                        if (isObjPathSeriesUseSubGroups)
                                        {
                                            // Find the LBGroup we want to instantiate by calling ProcessGroup(..) again
                                            subGroupToPlace = LBGroup.GetGroupByGUID(gVars.activeGroupList, activeMainObjSubGroupList[objPathPrefabIdx].subGroupGUID, true);
                                        }
                                        else
                                        {
                                            // Find the LBGroupMember we want to instantiate
                                            lbGroupMemberToPlace = lbGroup.GetMemberByGUID(activeMainObjPrefabList[objPathPrefabIdx].groupMemberGUID, true);
                                        }
                                    }

                                    // Remember the index for combining meshes with Prefabs (does not apply to SubGroups)
                                    objPathCbmIdx = isObjPathSeriesUseSubGroups ? -1 : objPathPrefabIdx;
                                }

                                /// TODO - BUG HERE ObjPathSeries distanceAlongObjPath will be incorrect when not on centre spline 

                                // If isLastObjSnappedToEnd, the last position's distance is always the length of the spline
                                if ((objPathPointIdx == numObjPathPoints - 1) && lbObjPath.isLastObjSnappedToEnd) { distanceAlongObjPath = lbObjPath.splineLength; }
                                else { distanceAlongObjPath = objPathPointIdx * objPathMemberSpacingDistance; }
                            }
                            else
                            {
                                // Always place the same group member if this is a normal group member
                                lbGroupMemberToPlace = lbGroupMember;
                            }

                            #endregion

                            isMemberPlacementPositionOk = false;
                            createPrefab = false;
                            isSubGroupPlacementOk = false;
                            createSubGroup = false;

                            #region Generic Member Placement rules

                            // Are they any potential cells left that we could instantiate a member into?
                            if (regionMemberCellBucketListSize < 1) { break; }
                            else if (isObjectPathMemberType)
                            {
                                if (objPathPointIdx < numObjPathPoints)
                                {
                                    // Get path position
                                    cellPos = objPathPrefabPointList[objPathPointIdx];

                                    // If this path is in a clearing, convert from clearing-space into worldspace (shouldn't this be landscape-space??)
                                    if ((isGroupTypeManualClearing || isGroupTypeProceduralClearing) && !gVars.isObjPathDesignerEnabled)
                                    {
                                        cellPos = Quaternion.Euler(0f, clearingRotationY, 0f) * cellPos;
                                        cellPos += groupPosition;
                                    }
                                    else if (isGroupTypeSubGroup)
                                    {
                                        // TODO - SubGroup path rotation - what if subgroup is rotated with the rotated clearing (parent) group??
                                        cellPos = Quaternion.Euler(0f, clearingRotationY, 0f) * cellPos;
                                        cellPos += groupPosition;
                                    }
                                    else if (isGroupTypeUniform)
                                    {
                                        // Uniform Object Path data is store in Worldspace. Convert it to Landscape-space.
                                        cellPos.x -= gVars.landscapePosition.x;
                                        cellPos.y -= gVars.landscapePosition.y;
                                        cellPos.z -= gVars.landscapePosition.z;
                                    }

                                    // If in the GroupDesigner, reset the height of the path object to be that of the GroupDesigner BasePlane
                                    if (gVars.isGroupDesignerEnabled)
                                    {
                                        if (lbGroupMemberToPlace != null && lbGroupMemberToPlace.usePathHeight)
                                        {
                                            cellPos.y += gVars.lbGroupParams.designerOffsetY;
                                        }
                                        else
                                        {
                                            cellPos.y = gVars.lbGroupParams.designerOffsetY;
                                        }

                                    }
                                    else if (isGroupTypeUniform && lbGroupMemberToPlace != null && lbGroupMemberToPlace.usePathHeight)
                                    {
                                        // Only get the slope
                                        GetLandscapeInterpolatedSlopeData(gVars.terrainDataArray, gVars.terrainRectsArray, new Vector2(cellPos.x, cellPos.z), ref thisTerrainPointSteepness);
                                    }
                                    else
                                    {
                                        // Get terrain height at this point
                                        GetLandscapeInterpolatedData(gVars.terrainDataArray, gVars.terrainRectsArray, new Vector2(cellPos.x, cellPos.z), ref thisTerrainPointHeight, ref thisTerrainPointSteepness);

                                        if (lbGroupMemberToPlace != null && lbGroupMemberToPlace.usePathHeight)
                                        {
                                            // Set the anchor point height for the Object Path in a clearing group to the terrain height at the first point
                                            if (objPathPointIdx == 0) { objPathSeriesHeightOffset = thisTerrainPointHeight; }

                                            cellPos.y += objPathSeriesHeightOffset;

                                            // Non-uniform group with usePathHeight. Do a simple add delta from
                                            // object path anchor point height - like for Surface Meshes.
                                            // In future should get distance and height between previous and next
                                            // user-defined path points, then lerp the height for this point on spline.
                                            if (lbGroupMemberToPlace.useTerrainTrend) { cellPos.y += thisTerrainPointHeight - objPathSeriesHeightOffset; }
                                        }
                                        else
                                        {
                                            // Set cell pos y to terrain height
                                            cellPos.y = thisTerrainPointHeight;
                                        }
                                    }

                                    // Convert into normalised position
                                    cellPosN.x = cellPos.x / gVars.landscapeWidth;
                                    cellPosN.y = cellPos.y / gVars.terrainHeight;
                                    cellPosN.z = cellPos.z / gVars.landscapeLength;

                                    #region Check the member rules for Object Path Members

                                    // Could potentially - find the cell and check that first

                                    // Basic height and slope terrain rules don't apply to the GroupDesigner because it doesn't use the terrains
                                    if (!gVars.isGroupDesignerEnabled)
                                    {
                                        // Are we trying to instantiate a whole (Sub)Group at this location along an object path?
                                        if (subGroupToPlace != null)
                                        {
                                            // Evaluate the group-scoped rules for the heightmap
                                            // Determine if this point in the terrain complies with the Group-scoped rule of the SubGroup
                                            isRuleMatched = cellPosN.y >= subGroupToPlace.minHeight && cellPosN.y <= subGroupToPlace.maxHeight &&
                                                            thisTerrainPointSteepness >= subGroupToPlace.minInclination && thisTerrainPointSteepness <= subGroupToPlace.maxInclination;

                                            isSubGroupPlacementOk = isRuleMatched;
                                        }
                                        else if (lbGroupMemberToPlace == null) { isRuleMatched = false; }
                                        else if (lbGroupMemberToPlace.isGroupOverride)
                                        {
                                            // Determine if this point in the terrain complies with the GroupMember rule
                                            isRuleMatched = cellPosN.y >= lbGroupMemberToPlace.minHeight && cellPosN.y <= lbGroupMemberToPlace.maxHeight &&
                                                            thisTerrainPointSteepness >= lbGroupMemberToPlace.minInclination && thisTerrainPointSteepness <= lbGroupMemberToPlace.maxInclination;
                                        }
                                        // Optimisation when Group placement is working
                                        //else if (regionMemberPlacementListSize == regionGroupPlacementListSize)
                                        //{
                                        //    // ASSUMES region group placement size is the same as member placement size
                                        //    // Look up the answer in the region Group Placement list
                                        //    isRuleMatched = regionGroupPlacementList[ruleStatusIdx];
                                        //}
                                        else
                                        {
                                            // Evaluate the group-scoped rules for the heightmap
                                            // Determine if this point in the terrain complies with the Group-scoped rule
                                            isRuleMatched = cellPosN.y >= lbGroup.minHeight && cellPosN.y <= lbGroup.maxHeight &&
                                                            thisTerrainPointSteepness >= lbGroup.minInclination && thisTerrainPointSteepness <= lbGroup.maxInclination;
                                        }

                                        // Update for both prefabs and subgroup placement.
                                        // SubGroups are clarified by the isSubGroupPlacementOk variable. 
                                        isMemberPlacementPositionOk = isRuleMatched;
                                    }
                                    // Basic placement rules are always ok in the GroupDesigner when there is a SubGroup to place
                                    else if (subGroupToPlace != null) { isSubGroupPlacementOk = true; isMemberPlacementPositionOk = true; }
                                    // Basic placement rules are always ok in the GroupDesigner when there is a prefab to place
                                    else { isMemberPlacementPositionOk = lbGroupMemberToPlace != null; }

                                    #endregion
                                }
                                else { isMemberPlacementPositionOk = false; }
                            }
                            else if (isPlacedInCentre)
                            {
                                isMemberPlacementPositionOk = true;

                                #region PlaceInCentre (GroupDesigner)
                                if (gVars.isGroupDesignerEnabled)
                                {
                                    // In the GroupDesigner, currently this block of code only runs for SubGroups within a Clearing Group.
                                    // PlaceInCentre for non-SubGroups runs in GroupDesiger.RefreshObjects() and GroupDesigner.UpdateGroupMember()
                                    cellPosN = groupPosNList[regionIdx];

                                    if (lbGroupMemberToPlace.minOffsetX != 0f || lbGroupMemberToPlace.minOffsetZ != 0f)
                                    {
                                        // Modify position by normalised provided offset (modified by group instance rotation)
                                        prefabOffset.x = lbGroupMemberToPlace.minOffsetX / parentGroup.maxClearingRadius;
                                        // The y-axis component get added later during the "Get Member Prefab Position / Rotation" phase
                                        prefabOffset.y = 0f;
                                        prefabOffset.z = lbGroupMemberToPlace.minOffsetZ / parentGroup.maxClearingRadius;
                                        cellPosN += Quaternion.Euler(0f, clearingRotationY, 0f) * prefabOffset;

                                        // Check to see if the offset pushes it outside the designer
                                        // The range in GroupDesigner can be -1.0 to 1.0 as it is offset from the centre
                                        isMemberPlacementPositionOk = !(cellPosN.x < -1f || cellPosN.x > 1f || cellPosN.z < -1f || cellPosN.z > 1f);
                                    }

                                    // Convert into clearing space offset in metres from the centre of the parent group
                                    cellPos.x = cellPosN.x * parentGroup.maxClearingRadius;
                                    cellPos.y = (cellPosN.y * gVars.terrainHeight) + gVars.lbGroupParams.designerOffsetY;
                                    cellPos.z = cellPosN.z * parentGroup.maxClearingRadius;

                                    // Get the position of the prefab relative to the centre of the subgroup (used later)
                                    posRelativeToGroup.x = cellPos.x - groupPosition.x;
                                    posRelativeToGroup.z = cellPos.z - groupPosition.z;
                                }
                                #endregion

                                #region PlaceInCentre (Not GroupDesigner)
                                else
                                {
                                    // Get the centre of this clearing
                                    cellPosN = groupPosNList[regionIdx];

                                    if (lbGroupMemberToPlace.minOffsetX != 0f || lbGroupMemberToPlace.minOffsetZ != 0f)
                                    {
                                        // Modify position by provided offset (modified by group instance rotation)
                                        prefabOffset.x = lbGroupMemberToPlace.minOffsetX / gVars.landscapeWidth;
                                        // The y-axis component get added later during the "Get Member Prefab Position / Rotation" phase
                                        prefabOffset.y = 0f;
                                        prefabOffset.z = lbGroupMemberToPlace.minOffsetZ / gVars.landscapeLength;
                                        cellPosN += Quaternion.Euler(0f, clearingRotationY, 0f) * prefabOffset;

                                        // Check to see if the offset pushes it outside the landscape
                                        isMemberPlacementPositionOk = !(cellPosN.x < 0f || cellPosN.x > 1f || cellPosN.z < 0f || cellPosN.z > 1f);

                                        // If there are one or more stencil filters, objects placed in the exact centre
                                        // will have already been checked at the group-level. However, objects offset from
                                        // the centre, may still be affected by the filters.
                                        if (!gVars.isGroupDesignerEnabled && gVars.isStencilLayerFiltersToApply[activeGpIdx])
                                        {
                                            gVars.stencilLayerPosN.x = cellPosN.x;
                                            gVars.stencilLayerPosN.y = cellPosN.z;
                                            if (LBFilter.IsPointFilteredByStencils(lbGroup.filterList, gVars.stencilLayerPosN)) { isMemberPlacementPositionOk = false; }
                                        }
                                    }

                                    if (isMemberPlacementPositionOk)
                                    {
                                        // Convert into landscape position in metres (does not include any landscape start offset)
                                        cellPos.x = cellPosN.x * gVars.landscapeWidth;
                                        cellPos.y = cellPosN.y * gVars.terrainHeight;
                                        cellPos.z = cellPosN.z * gVars.landscapeLength;

                                        if (lbGroupMemberToPlace.minOffsetX != 0f || lbGroupMemberToPlace.minOffsetZ != 0f)
                                        {
                                            // Get terrain height at this point - this is already done in the group pos code, 
                                            // but has to be done again if the offset is not zero
                                            GetLandscapeInterpolatedData(gVars.terrainDataArray, gVars.terrainRectsArray, new Vector2(cellPos.x, cellPos.z), ref thisTerrainPointHeight, ref thisTerrainPointSteepness);

                                            cellPos.y = thisTerrainPointHeight;
                                            cellPosN.y = cellPos.y / gVars.terrainHeight;
                                        }

                                        // Currently placed-in-centre objects do not take into account zones,
                                        // but they do check to see whether they are actually inside the clearing itself

                                        // Get the position of the prefab relative to the centre of the clearing
                                        posRelativeToGroup.x = cellPos.x - groupPosition.x;
                                        posRelativeToGroup.z = cellPos.z - groupPosition.z;

                                        // Only place the object if it is within the clearing radius
                                        isMemberPlacementPositionOk = (posRelativeToGroup.x * posRelativeToGroup.x) +
                                                                      (posRelativeToGroup.z * posRelativeToGroup.z) <
                                                                      clearingRadius * clearingRadius;
                                    }
                                }
                                #endregion

                                #region Check the member rules for PlaceInCentre clearing or subgroup members

                                if (isMemberPlacementPositionOk)
                                {
                                    // Could potentially - find the cell and check that first
                                    if (gVars.isGroupDesignerEnabled)
                                    {
                                        // We can ignore terrain height and slope rules in the GroupDesigner
                                        isRuleMatched = true;
                                    }
                                    else if (lbGroupMemberToPlace.isGroupOverride)
                                    {
                                        // Determine if this point in the terrain complies with the Group-scoped rule
                                        isRuleMatched = cellPosN.y >= lbGroupMemberToPlace.minHeight && cellPosN.y <= lbGroupMemberToPlace.maxHeight &&
                                                        thisTerrainPointSteepness >= lbGroupMemberToPlace.minInclination && thisTerrainPointSteepness <= lbGroupMemberToPlace.maxInclination;
                                    }
                                    // Optimisation when Group placement is working
                                    //else if (regionMemberPlacementListSize == regionGroupPlacementListSize)
                                    //{
                                    //    // ASSUMES region group placement size is the same as member placement size
                                    //    // Look up the answer in the region Group Placement list
                                    //    isRuleMatched = regionGroupPlacementList[ruleStatusIdx];
                                    //}
                                    else
                                    {
                                        // Evaluate the group-scoped rules for the heightmap
                                        // Determine if this point in the terrain complies with the Group-scoped rule
                                        isRuleMatched = cellPosN.y >= lbGroup.minHeight && cellPosN.y <= lbGroup.maxHeight &&
                                                        thisTerrainPointSteepness >= lbGroup.minInclination && thisTerrainPointSteepness <= lbGroup.maxInclination;
                                    }

                                    isMemberPlacementPositionOk = isRuleMatched;
                                }

                                #endregion
                            }
                            // Not ObjPath Member, and not PlaceInCentre. SubGroup of another Group in the GroupDesigner
                            else if (gVars.isGroupDesignerEnabled && isGroupTypeSubGroup && isChildGroup)
                            {
                                // In the GroupDesigner, currently this block of code only runs for SubGroups within a Clearing Group.
                                // Prefabs without PlaceInCentre for non-SubGroups runs in GroupDesiger.RefreshObjects() and GroupDesigner.UpdateGroupMember()
                                cellPosN = groupPosNList[regionIdx];

                                // Get a random position in the GroupDesigner subgroup
                                subGroupPos2D = LBGroupMember.GetRandomOffset(lbGroupMember, clearingRadius, 100);
                                //cellPos.y = gVars.lbGroupParams.designerOffsetY;

                                // Modify position by normalised provided offset (modified by group instance rotation)
                                prefabOffset.x = subGroupPos2D.x / parentGroup.maxClearingRadius;
                                // The y-axis component get added later during the "Get Member Prefab Position / Rotation" phase
                                prefabOffset.y = 0f;
                                prefabOffset.z = subGroupPos2D.y / parentGroup.maxClearingRadius;
                                cellPosN += Quaternion.Euler(0f, clearingRotationY, 0f) * prefabOffset;

                                // Check to see if the offset pushes it outside the designer
                                // The range in GroupDesigner can be -1.0 to 1.0 as it is offset from the centre
                                isMemberPlacementPositionOk = !(cellPosN.x < -1f || cellPosN.x > 1f || cellPosN.z < -1f || cellPosN.z > 1f);

                                //Debug.Log("Parent: " + parentGroup.groupName + " child " + lbGroup.groupName + " prefab: " + lbGroupMember.prefabName + " subGroupPos2D: " + subGroupPos2D + " cellPosN: " + cellPosN + " isOK ? " + isMemberPlacementPositionOk);

                                if (isMemberPlacementPositionOk)
                                {
                                    // Convert into clearing space offset in metres from the centre of the parent group
                                    cellPos.x = cellPosN.x * parentGroup.maxClearingRadius;
                                    cellPos.y = (cellPosN.y * gVars.terrainHeight) + gVars.lbGroupParams.designerOffsetY;
                                    cellPos.z = cellPosN.z * parentGroup.maxClearingRadius;

                                    // Get the position of the prefab relative to the centre of the subgroup
                                    posRelativeToGroup.x = cellPos.x - groupPosition.x;
                                    posRelativeToGroup.z = cellPos.z - groupPosition.z;

                                    // Only place the object if it is within the subgroup radius
                                    isMemberPlacementPositionOk = (posRelativeToGroup.x * posRelativeToGroup.x) +
                                                                  (posRelativeToGroup.z * posRelativeToGroup.z) <
                                                                  clearingRadius * clearingRadius;
                                }

                                //if (isChildGroup) { Debug.Log("[DEBUG] C subgroup prefabName: " + lbGroupMember.prefabName + " posRelativeToGroup: " + posRelativeToGroup + " cellPos: " + cellPos + " groupPosition: " + groupPosition); }
                            }
                            // Not ObjPath Member, and not PlaceInCentre.
                            else if (isGroupTypeProceduralClearing || isGroupTypeManualClearing || isGroupTypeSubGroup || isGroupTypeUniform)
                            {
                                // Clearing, SubGroup or Uniform member position

                                // Find a random cell in the list of potential cells
                                cellIdx = UnityEngine.Random.Range(0, regionMemberCellBucketListSize);
                                ruleStatusIdx = regionMemberCellBucketList[cellIdx];

                                // Get the current status of this cell
                                cellStatus = regionMemberPlacementList[ruleStatusIdx];

                                // Has cell already been checked and failed rule test?
                                if (cellStatus == cellStatusRuleFailed) { continue; }
                                // Has the cell been checked?
                                else
                                {
                                    #region Check the member rules (terrain height and slope)

                                    // Convert rule into a position on the terrain
                                    if (isGroupTypeUniform)
                                    {
                                        zHeightmap = ((int)(ruleStatusIdx / (gVars.landscapeHeightmapResolution - 1)));
                                        xHeightmap = (ruleStatusIdx % (gVars.landscapeHeightmapResolution - 1));
                                    }
                                    else
                                    {
                                        zHeightmap = ((int)(ruleStatusIdx / clearingPlacementListWidth)) + clearingMinZIndex;
                                        xHeightmap = (ruleStatusIdx % clearingPlacementListWidth) + clearingMinXIndex;
                                    }

                                    // Get the normalised position (bottom-left) for this heightmap cell in the terrain
                                    landscapePosN.x = xHeightmap / (gVars.landscapeHeightmapResolutionF - 1f);
                                    landscapePosN.z = zHeightmap / (gVars.landscapeHeightmapResolutionF - 1f);

                                    // Assume not tested (if already passed, no need to do another else)
                                    if (cellStatus != cellStatusRulePassed)
                                    {
                                        // Find that coordinate's height and steepness
                                        GetLandscapeInterpolatedData(gVars.terrainDataArray, gVars.terrainRectsArray, new Vector2(landscapePosN.x * gVars.landscapeWidth, landscapePosN.z * gVars.landscapeLength), ref thisTerrainPointHeight, ref thisTerrainPointSteepness);
                                        landscapePosN.y = thisTerrainPointHeight / gVars.terrainHeight;

                                        if (lbGroupMemberToPlace.isGroupOverride)
                                        {
                                            // Determine if this point in the terrain complies with the Group-scoped rule
                                            isRuleMatched = landscapePosN.y >= lbGroupMemberToPlace.minHeight && landscapePosN.y <= lbGroupMemberToPlace.maxHeight &&
                                                            thisTerrainPointSteepness >= lbGroupMemberToPlace.minInclination && thisTerrainPointSteepness <= lbGroupMemberToPlace.maxInclination;
                                        }
                                        // Optimisation when Group placement is working
                                        //else if (regionMemberPlacementListSize == regionGroupPlacementListSize)
                                        //{
                                        //    // ASSUMES region group placement size is the same as member placement size
                                        //    // Look up the answer in the region Group Placement list
                                        //    isRuleMatched = regionGroupPlacementList[ruleStatusIdx];
                                        //}
                                        else
                                        {
                                            // Evaluate the group-scoped rules for the heightmap
                                            // Determine if this point in the terrain complies with the Group-scoped rule
                                            isRuleMatched = landscapePosN.y >= lbGroup.minHeight && landscapePosN.y <= lbGroup.maxHeight &&
                                                            thisTerrainPointSteepness >= lbGroup.minInclination && thisTerrainPointSteepness <= lbGroup.maxInclination;
                                        }

                                        cellStatus = isRuleMatched ? cellStatusRulePassed : cellStatusRuleFailed;
                                        //cellStatus = cellStatusRulePassed;
                                        regionMemberPlacementList[ruleStatusIdx] = cellStatus;

                                        // If failed placement rules, remove cell from potential list and go to next iteration
                                        if (cellStatus == cellStatusRuleFailed)
                                        {
                                            regionMemberCellBucketList.RemoveAt(cellIdx);
                                            regionMemberCellBucketListSize--;
                                            continue;
                                        }
                                    }

                                    #endregion
                                }

                                landscapePos.x = landscapePosN.x * gVars.landscapeWidth;
                                landscapePos.z = landscapePosN.z * gVars.landscapeLength;
                                landscapePos.y = 0f; // unused

                                // Find the location within the cell (cells are the size of the heightmap pixels)
                                cellPos.x = UnityEngine.Random.Range(landscapePos.x, landscapePos.x + gVars.terrainHeightmapCellSize.x);
                                cellPos.z = UnityEngine.Random.Range(landscapePos.z, landscapePos.z + gVars.terrainHeightmapCellSize.z);

                                if (isGroupTypeUniform)
                                {
                                    // Basic member placement position looks okay
                                    isMemberPlacementPositionOk = true;
                                }
                                else // Clearings or SubGroups
                                {
                                    // Get the position of the prefab relative to the centre of the clearing
                                    posRelativeToGroup.x = cellPos.x - groupPosition.x;
                                    posRelativeToGroup.z = cellPos.z - groupPosition.z;

                                    // Only place the object if it is within the clearing radius
                                    isMemberPlacementPositionOk = (posRelativeToGroup.x * posRelativeToGroup.x) +
                                                                  (posRelativeToGroup.z * posRelativeToGroup.z) <
                                                                  clearingRadius * clearingRadius;
                                }

                                if (isMemberPlacementPositionOk)
                                {
                                    cellPosN.x = cellPos.x / gVars.landscapeWidth;
                                    cellPosN.z = cellPos.z / gVars.landscapeLength;

                                    // Check the Stencil filters for objects not placed in centre
                                    if (gVars.isStencilLayerFiltersToApply[activeGpIdx])
                                    {
                                        gVars.stencilLayerPosN.x = cellPosN.x;
                                        gVars.stencilLayerPosN.y = cellPosN.z;
                                        if (LBFilter.IsPointFilteredByStencils(lbGroup.filterList, gVars.stencilLayerPosN)) { continue; }
                                    }

                                    GetLandscapeInterpolatedData(gVars.terrainDataArray, gVars.terrainRectsArray, new Vector2(cellPos.x, cellPos.z), ref thisTerrainPointHeight);
                                    cellPos.y = thisTerrainPointHeight;
                                    cellPosN.y = cellPos.y / gVars.terrainHeight;
                                }
                            }
                            else // FUTURE TYPES etc
                            {
                                isMemberPlacementPositionOk = false;
                            }
                            #endregion

                            #region Check Member Zones

                            // Applies to Clearing Groups and SubGroups (ObjPath prefab members and not PlaceInCentre)
                            if (isMemberPlacementPositionOk && (isGroupTypeProceduralClearing || isGroupTypeManualClearing || isGroupTypeSubGroup) && ((isObjectPathMemberType && !isSubGroupPlacementOk) || (!isObjectPathMemberType && !isPlacedInCentre)))
                            {
                                // Zones
                                // Check that the placement position is within any defined zones for this member
                                if (lbGroupMemberToPlace.zoneGUIDList != null && lbGroupMemberToPlace.zoneGUIDList.Count > 0)
                                {
                                    // We don't have the prefab position relative to the centre of the clearing for ObjPath members
                                    if (isObjectPathMemberType)
                                    {
                                        // Get the position of the prefab relative to the centre of the clearing
                                        posRelativeToGroup.x = cellPos.x - groupPosition.x;
                                        posRelativeToGroup.z = cellPos.z - groupPosition.z;
                                    }

                                    // Get the group-space placement position
                                    posRelativeToGroup = Quaternion.Euler(0f, -clearingRotationY, 0f) * posRelativeToGroup;

                                    // Loop through the zones
                                    for (zoneListIndex = 0; zoneListIndex < lbGroupMemberToPlace.zoneGUIDList.Count; zoneListIndex++)
                                    {
                                        // Get the zone from the group using the provided GUID
                                        thisZone = lbGroup.zoneList.Find(z => z.GUID == lbGroupMemberToPlace.zoneGUIDList[zoneListIndex]);
                                        // Comparer depends on zone type
                                        if (thisZone.zoneType == LBGroupZone.LBGroupZoneType.circle)
                                        {
                                            // Circle - check distance to centre
                                            // Compare the distance from the centre of the zone to the placement position
                                            // with the radius of the zone
                                            // Both distances are squared distances for performance
                                            positionInsideZone = ((posRelativeToGroup.x - (thisZone.centrePointX * clearingRadius)) * (posRelativeToGroup.x - (thisZone.centrePointX * clearingRadius)))
                                                + ((posRelativeToGroup.z - (thisZone.centrePointZ * clearingRadius)) * (posRelativeToGroup.z - (thisZone.centrePointZ * clearingRadius))) <
                                                thisZone.width * clearingRadius * thisZone.width * clearingRadius;

                                            // Check the prefab is within the correct distance of the zone edge
                                            if (positionInsideZone && isZoneEdgeFillEnabled)
                                            {
                                                positionInsideZone = ((posRelativeToGroup.x - (thisZone.centrePointX * clearingRadius)) * (posRelativeToGroup.x - (thisZone.centrePointX * clearingRadius)))
                                                    + ((posRelativeToGroup.z - (thisZone.centrePointZ * clearingRadius)) * (posRelativeToGroup.z - (thisZone.centrePointZ * clearingRadius))) >
                                                    ((thisZone.width * clearingRadius - lbGroupMemberToPlace.zoneEdgeFillDistance) * (thisZone.width * clearingRadius - lbGroupMemberToPlace.zoneEdgeFillDistance));
                                            }
                                        }
                                        else
                                        {
                                            // Rectangle - check min and max coordinates
                                            // Currently assumes that the rectangles cannot be rotated in group space
                                            // Check that the position is between min and max coordinate limits
                                            positionInsideZone = (posRelativeToGroup.x > (thisZone.centrePointX - (thisZone.width * 0.5f)) * clearingRadius) &&
                                                                 (posRelativeToGroup.x < (thisZone.centrePointX + (thisZone.width * 0.5f)) * clearingRadius) &&
                                                                 (posRelativeToGroup.z > (thisZone.centrePointZ - (thisZone.length * 0.5f)) * clearingRadius) &&
                                                                 (posRelativeToGroup.z < (thisZone.centrePointZ + (thisZone.length * 0.5f)) * clearingRadius);

                                            // If any of Zone Edge Fill sides are enabled, check prefabs are within those edge distances.
                                            if (positionInsideZone && isZoneEdgeFillEnabled)
                                            {
                                                positionInsideZone = (lbGroupMemberToPlace.isZoneEdgeFillLeft ? (posRelativeToGroup.x < ((thisZone.centrePointX - (thisZone.width / 2f)) * clearingRadius) + lbGroupMemberToPlace.zoneEdgeFillDistance) : false) ||
                                                                     (lbGroupMemberToPlace.isZoneEdgeFillRight ? (posRelativeToGroup.x > ((thisZone.centrePointX + (thisZone.width / 2f)) * clearingRadius) - lbGroupMemberToPlace.zoneEdgeFillDistance) : false) ||
                                                                     (lbGroupMemberToPlace.isZoneEdgeFillBottom ? (posRelativeToGroup.z < ((thisZone.centrePointZ - (thisZone.length / 2f)) * clearingRadius) + lbGroupMemberToPlace.zoneEdgeFillDistance) : false) ||
                                                                     (lbGroupMemberToPlace.isZoneEdgeFillTop ? (posRelativeToGroup.z > ((thisZone.centrePointZ + (thisZone.length / 2f)) * clearingRadius) - lbGroupMemberToPlace.zoneEdgeFillDistance) : false);
                                            }
                                        }

                                        if (thisZone.zoneMode == LBGroupZone.ZoneMode.OR)
                                        {
                                            // OR
                                            if (zoneListIndex == 0) { isMemberPlacementPositionOk = positionInsideZone; }
                                            else { isMemberPlacementPositionOk = isMemberPlacementPositionOk || positionInsideZone; }
                                        }
                                        else
                                        {
                                            // NOT
                                            if (zoneListIndex == 0) { isMemberPlacementPositionOk = !positionInsideZone; }
                                            else if (positionInsideZone) { isMemberPlacementPositionOk = false; break; }
                                        }
                                    }
                                }
                            }

                            #endregion

                            #region Get Member Prefab Position / Rotation
                            // Need to get position prefab will potentially be placed before checking the proximity filters
                            // which store other object positions in world space

                            // So far, so good if this is a prefab or a subgroup to place
                            if (isMemberPlacementPositionOk && (isSubGroupPlacementOk || (lbGroupMemberToPlace != null && lbGroupMemberToPlace.prefab != null)))
                            {
                                // Prefab scaling - do this first as it is also used for model offset
                                if (isSubGroupPlacementOk) { prefabScale = Vector3.one; }
                                else if (lbGroupMemberToPlace.isGroupOverride) { prefabScale = Vector3.one * UnityEngine.Random.Range(lbGroupMemberToPlace.minScale, lbGroupMemberToPlace.maxScale); }
                                else { prefabScale = Vector3.one * UnityEngine.Random.Range(lbGroup.minScale, lbGroup.maxScale); }

                                #region Prefab Offset
                                if (isSubGroupPlacementOk) { prefabOffset = Vector3.zero; }
                                else
                                {
                                    // Add model offset - this will later be transformed into local space
                                    prefabOffset = Vector3.Scale(new Vector3(lbGroupMemberToPlace.modelOffsetX, lbGroupMemberToPlace.modelOffsetY, lbGroupMemberToPlace.modelOffsetZ), prefabScale);

                                    // If y-axis placement is being randomised (like for raising and lowering a rock in the terrain), modify the Y-axis prefab offset.
                                    if (lbGroupMemberToPlace.randomiseOffsetY && lbGroupMemberToPlace.minOffsetY < lbGroupMemberToPlace.maxOffsetY)
                                    {
                                        prefabOffset.y += UnityEngine.Random.Range(lbGroupMemberToPlace.minOffsetY, lbGroupMemberToPlace.maxOffsetY);
                                    }
                                    // Otherwise just add a constant offset
                                    else { prefabOffset.y += lbGroupMemberToPlace.minOffsetY; }
                                }
                                #endregion

                                #region Rotation
                                // NOTE: When modifying Rotation code, LBGroupDesigner.GetMemberRotation(..) will also need to be updated.
                                // Calculate the Y rotation of the prefab first
                                // Random rotation vs. fixed rotation
                                if (isSubGroupPlacementOk) { prefabRotationY = 0f; }
                                else if (lbGroupMemberToPlace.randomiseRotationY) { prefabRotationY = UnityEngine.Random.Range(lbGroupMemberToPlace.startRotationY, lbGroupMemberToPlace.endRotationY); }
                                else { prefabRotationY = lbGroupMemberToPlace.startRotationY; }

                                // If it is an object path member and the member to place is in path space, or it is a subgroup being placed along an object path,
                                // rotate so that it is relative to path orientation
                                if (isObjectPathMemberType && (isSubGroupPlacementOk || lbGroupMemberToPlace.lbObjectOrientation == LBObjPath.LBObjectOrientation.PathSpace))
                                {
                                    if (objPathSeriesIdx >= 0)
                                    {
                                        // Use Series cached forwards
                                        objPathForwardsDirection = objPathPrefabForwardsList[objPathPointIdx];
                                        objPathRightDirection = objPathPrefabRightList[objPathPointIdx];
                                    }
                                    // Cater for scenario where object spacing would not evenly reach end.
                                    // isLastObjSnappedToEnd is enabled but distanceAlongObjPath < splineLength - 0.1, so doesn't reverse Forwards as expected.
                                    // Check this scenario so falls through to second ForwardsDirection calc.
                                    else if (distanceAlongObjPath < lbObjPath.splineLength - 0.1f && (!lbObjPath.isLastObjSnappedToEnd || objPathPointIdx < numObjPathPoints - 1))
                                    {
                                        // This only works for Default Series
                                        objPathForwardsDirection = lbObjPath.GetPathPosition(distanceAlongObjPath + 0.1f, 1) - objPathPrefabPointList[objPathPointIdx];
                                        // TODO: Tilt calculations
                                        objPathRightDirection = Vector3.Cross(Vector3.up, objPathForwardsDirection);
                                    }
                                    else
                                    {
                                        // Near or at the end of the path, so treat as special case.
                                        // This only works for Default Series
                                        objPathForwardsDirection = lbObjPath.GetForwardsAtEnd();
                                        // TODO: Tilt calculations
                                        objPathRightDirection = Vector3.Cross(Vector3.up, objPathForwardsDirection);
                                    }

                                    // If in a clearing, rotate so that it is relative to clearing rotation
                                    if (isGroupTypeProceduralClearing || isGroupTypeManualClearing)
                                    {
                                        objPathForwardsDirection = Quaternion.Euler(0f, clearingRotationY, 0f) * objPathForwardsDirection;
                                        objPathRightDirection = Quaternion.Euler(0f, clearingRotationY, 0f) * objPathRightDirection;
                                    }
                                    else if (isGroupTypeSubGroup)
                                    {
                                        // Rotation of subgroups along path...
                                        objPathForwardsDirection = Quaternion.Euler(0f, clearingRotationY, 0f) * objPathForwardsDirection;
                                        objPathRightDirection = Quaternion.Euler(0f, clearingRotationY, 0f) * objPathRightDirection;
                                    }

                                    prefabRotationY += Quaternion.LookRotation(objPathForwardsDirection, Vector3.up).eulerAngles.y;
                                }
                                // Clearing or SubGroup prefabs can be placed in world space, group space or face 2 centre space
                                else if (isGroupTypeProceduralClearing || isGroupTypeManualClearing || isGroupTypeSubGroup)
                                {
                                    // If in group space, rotate so that it is relative to clearing rotation
                                    if (lbGroupMemberToPlace.rotationType == LBGroupMember.LBRotationType.GroupSpace)
                                    {
                                        prefabRotationY += clearingRotationY;
                                    }
                                    // If in face 2 centre space, rotate to face centre of clearing
                                    else if (lbGroupMemberToPlace.rotationType == LBGroupMember.LBRotationType.Face2GroupCentre)
                                    {
                                        prefabRotationY += Quaternion.LookRotation(groupPositionNormalised - cellPosN, Vector3.up).eulerAngles.y;
                                    }
                                    // If in face 2 zone centre space, rotate to face the centre of the FIRST zone in the member zone filters list (if any)
                                    else if (lbGroupMemberToPlace.rotationType == LBGroupMember.LBRotationType.Face2ZoneCentre && firstZone != null)
                                    {
                                        if (firstZone.zoneType == LBGroupZone.LBGroupZoneType.circle)
                                        {
                                            // Add a rotation to face the normalised position of the first zone in the group
                                            prefabRotationY += Quaternion.LookRotation(firstZonePositionN - cellPosN, Vector3.up).eulerAngles.y;
                                        }
                                        else // rectangular zone
                                        {
                                            // Get the normalised position of the member within the clearing
                                            posRelativeToGroupN.x = posRelativeToGroup.x / clearingRadius;
                                            posRelativeToGroupN.y = 0f;
                                            posRelativeToGroupN.z = posRelativeToGroup.z / clearingRadius;

                                            // Declare zone equation variables
                                            float zoneZEq1 = 0f, zoneZEq2 = 0f;
                                            // Calculate normalised (0-1) coordinates for position in the rectangle
                                            float zoneMemberXPos = ((posRelativeToGroupN.x - firstZone.centrePointX) / firstZone.width) + 0.5f;
                                            float zoneMemberZPos = ((posRelativeToGroupN.z - firstZone.centrePointZ) / firstZone.length) + 0.5f;
                                            // Calculate the gradient of the dividing lines
                                            float zonePosGradient = firstZone.width / firstZone.length;

                                            if (firstZone.width >= firstZone.length)
                                            {
                                                // Calculate the height of each dividing line equation given the x-coordinate
                                                // of the zone member
                                                zoneZEq1 = Mathf.Clamp(zoneMemberXPos * zonePosGradient, 0f, 0.5f) +
                                                    Mathf.Clamp(((zoneMemberXPos - 1f) * zonePosGradient) + 0.5f, 0, 0.5f);
                                                zoneZEq2 = Mathf.Clamp(0.5f - (zoneMemberXPos * zonePosGradient), 0f, 0.5f) +
                                                    Mathf.Clamp((1f - zoneMemberXPos) * zonePosGradient, 0, 0.5f);
                                            }
                                            else
                                            {
                                                // Calculate the height of each dividing line equation given the x-coordinate
                                                // of the zone member
                                                zoneZEq1 = zoneMemberXPos * zonePosGradient;
                                                zoneZEq2 = 1f - (zoneMemberXPos * zonePosGradient);
                                                if (zoneMemberXPos > 0.5f) { zoneZEq1 += 1f - zonePosGradient; zoneZEq2 -= 1f - zonePosGradient; }
                                            }

                                            // Compare the z-coordinate of the zone member with the z-coordinates of the dividing
                                            // line equations to work out which side the zone member is on
                                            // Top
                                            if (zoneMemberZPos >= zoneZEq1 && zoneMemberZPos >= zoneZEq2) { prefabRotationY += 180f; }
                                            // Bottom
                                            else if (zoneMemberZPos < zoneZEq1 && zoneMemberZPos < zoneZEq2) { prefabRotationY += 0f; }
                                            // Left
                                            else if (zoneMemberZPos >= zoneZEq1 && zoneMemberZPos < zoneZEq2) { prefabRotationY += 90f; }
                                            // Right
                                            else { prefabRotationY += -90f; }
                                            // Adjust rotation to match clearing rotation
                                            prefabRotationY += clearingRotationY;
                                        }
                                    }
                                    // If in world space, don't modify rotation
                                }

                                // Prefab Rotation and Terrain alignment - adjust calculated Y rotation to align with terrain                                        
                                // Checking Terrain normal will be slightly slower, so deal with separately to non-aligned rotation
                                // OR
                                // Object Path member that should be aligned to the path slope (and has PathSpace orientation)
                                if (isSubGroupPlacementOk) { prefabRotation = Quaternion.Euler(0f, prefabRotationY, 0f); }
                                else if ((lbGroupMemberToPlace.isTerrainAligned && !gVars.isGroupDesignerEnabled) ||
                                    (isObjectPathMemberType && lbGroupMemberToPlace.usePathSlope && lbGroupMemberToPlace.lbObjectOrientation == LBObjPath.LBObjectOrientation.PathSpace))
                                {
                                    if (lbGroupMemberToPlace.isTerrainAligned && !gVars.isGroupDesignerEnabled)
                                    {
                                        // If terrain aligned, point normal comes from terrain
                                        GetLandscapeInterpolatedData(gVars.terrainDataArray, gVars.terrainRectsArray, new Vector2(cellPos.x, cellPos.z), ref thisTerrainPointNormal);
                                    }
                                    else
                                    {
                                        // ObjectPath only
                                        // If using path slope, terrain normal comes from path right and forwards direction
                                        thisTerrainPointNormal = Vector3.Cross(objPathForwardsDirection, objPathRightDirection);
                                    }

                                    // Create a unit vector facing in the rotated direction in the world XZ plane
                                    unitVector = Quaternion.Euler(0f, prefabRotationY, 0f) * Vector3.forward;
                                    // Project the vector into the plane of the terrain normal
                                    // Nx.Ux + Ny.Uy + Nz.Uz = 0. Uy is the only unknown
                                    // NOTE: It is not a unit vector anymore
                                    unitVector.y = ((thisTerrainPointNormal.x * unitVector.x) + (thisTerrainPointNormal.z * unitVector.z)) / -thisTerrainPointNormal.y;

                                    if (isObjectPathMemberType && lbGroupMemberToPlace.isLockTilt)
                                    {
                                        // Set the rotation to face the calculated vector and to have an adjusted terrain normal
                                        // as the upwards direction of the rotation
                                        // The adjusted terrain normal is the terrain normal projected into the global y / local z plane
                                        // To do this we do a cross product of the global up and forwards directions, to give a local/global right direction
                                        // Then we remove the component of the terrain normal that faces in this direction
                                        prefabRotation.SetLookRotation(unitVector, thisTerrainPointNormal - Vector3.Project(thisTerrainPointNormal, Vector3.Cross(Vector3.up, unitVector)));
                                    }
                                    else
                                    {
                                        // Set the rotation to face the calculated vector and to have the terrain normal
                                        // as the upwards direction of the rotation
                                        prefabRotation.SetLookRotation(unitVector, thisTerrainPointNormal);
                                    }

                                    // Rotate in local space to achieve an XZ offset rotation
                                    if (lbGroupMemberToPlace.randomiseRotationXZ && lbRandomPrefabXZRotation != null)
                                    {
                                        // LBRandom.Range is minFloat inclusive to maxFloat exclusive, so add a small amount to end rotation.
                                        prefabRotation *= Quaternion.Euler(lbRandomPrefabXZRotation.Range(lbGroupMemberToPlace.rotationX, lbGroupMemberToPlace.endRotationX + 0.01f), 0f, lbRandomPrefabXZRotation.Range(lbGroupMemberToPlace.rotationZ, lbGroupMemberToPlace.endRotationZ + 0.01f));
                                    }
                                    else { prefabRotation *= Quaternion.Euler(lbGroupMemberToPlace.rotationX, 0f, lbGroupMemberToPlace.rotationZ); }
                                }
                                // Otherwise just construct quaternion from Y rotation (with or without XZ randomisation)
                                else if (lbGroupMemberToPlace.randomiseRotationXZ && lbRandomPrefabXZRotation != null)
                                {
                                    // LBRandom.Range is minFloat inclusive to maxFloat exclusive, so add a small amount to end rotation.
                                    prefabRotation = Quaternion.Euler(lbRandomPrefabXZRotation.Range(lbGroupMemberToPlace.rotationX, lbGroupMemberToPlace.endRotationX + 0.01f), prefabRotationY, lbRandomPrefabXZRotation.Range(lbGroupMemberToPlace.rotationZ, lbGroupMemberToPlace.endRotationZ + 0.01f));
                                }
                                else
                                {
                                    prefabRotation = Quaternion.Euler(lbGroupMemberToPlace.rotationX, prefabRotationY, lbGroupMemberToPlace.rotationZ);
                                }

                                // If it is an object path member and the member to place is in path space, as a final step rotate it around the
                                // axis of the path's forward direction by the specified amount
                                if (isObjectPathMemberType && !isSubGroupPlacementOk && lbGroupMemberToPlace.lbObjectOrientation == LBObjPath.LBObjectOrientation.PathSpace)
                                {
                                    /// TODO - BUG HERE ObjPathSeries distanceAlongObjPath will be incorrect when not using DefaultSeries
                                    /// However, we do have the forwards direction cached in objPathForwardsDirection, whcih comes from objPathPrefabForwardsList[objPathPointIdx]

                                    int furthestPointIdx = lbObjPath.cachedPathPointDistanceList.FindIndex(a => a >= distanceAlongObjPath);
                                    if (furthestPointIdx == 0) { furthestPointIdx = 1; }
                                    // If we've gone past the end of the path, select the last point (cachedPathPointsLength is the num of path positions = num path points)
                                    else if (furthestPointIdx < 0) { furthestPointIdx = lbObjPath.cachedPathPointsLength - 1; }

                                    prefabRotation = Quaternion.AngleAxis(-Mathf.Lerp(lbObjPath.pathPointList[furthestPointIdx - 1].rotationZ, lbObjPath.pathPointList[furthestPointIdx].rotationZ,
                                        Mathf.InverseLerp(lbObjPath.cachedPathPointDistances[furthestPointIdx - 1], lbObjPath.cachedPathPointDistances[furthestPointIdx], distanceAlongObjPath)), objPathForwardsDirection) * prefabRotation;
                                }
                                #endregion

                                // Transform prefab offset into local space using the calculated rotation
                                prefabOffset = prefabRotation * prefabOffset;

                                // If this member prefab will flatten the terrain, raise or lower the Y offset of the prefab position.
                                if (!isSubGroupPlacementOk && lbGroupMemberToPlace.isTerrainFlattened && !gVars.isGroupDesignerEnabled)
                                {
                                    // cellPosN is the normalised (0-1.0f) prefab position within the landscape
                                    // Do cellPos first, then cellPosN which results in one less multiplication
                                    cellPos.y += lbGroupMemberToPlace.flattenHeightOffset;
                                    cellPos.y = cellPos.y < 0 ? 0 : (cellPos.y > gVars.terrainHeight ? gVars.terrainHeight : cellPos.y);
                                    cellPosN.y = cellPos.y / gVars.terrainHeight;
                                }

                                // Set the prefab position - note that this is different from the one used for meshes in the Meshes Tab when usePrefab is false
                                if (isObjectPathMemberType && gVars.isGroupDesignerEnabled)
                                {
                                    prefabPosition = cellPos + prefabOffset;
                                }
                                else if (isChildGroup && gVars.isGroupDesignerEnabled)
                                {
                                    //prefabPosition = cellPos + groupPosition + prefabOffset;
                                    prefabPosition = cellPos + prefabOffset;
                                }
                                else
                                {
                                    prefabPosition = cellPos + gVars.landscapePosition + prefabOffset;
                                }

                                // Set the position used for proximity
                                // Currently is in landscape-space and DOES NOT take into account model offset
                                //proximityObjectPos = cellPos + prefabOffset;
                                proximityObjectPos = cellPos;

                                // Ensure the prefab is placed within the landscape (ignore when GroupDesigner is enabled and this is a clearing group or subgroup)
                                isMemberPlacementPositionOk = (!isGroupTypeUniform && gVars.isGroupDesignerEnabled) || (prefabPosition.x >= gVars.landscapeBounds.xMin && prefabPosition.x <= gVars.landscapeBounds.xMax && prefabPosition.z >= gVars.landscapeBounds.yMin && prefabPosition.z <= gVars.landscapeBounds.yMax);

                                createPrefab = isMemberPlacementPositionOk && lbGroupMemberToPlace != null;
                                createSubGroup = isMemberPlacementPositionOk && isSubGroupPlacementOk;
                            }

                            #endregion

                            #region Noise
                            if (createPrefab)
                            {
                                if (isObjectPathMemberType)
                                {
                                    // Sparse path population (use the ObjPath GroupMember or Series placement cutoff rather than the member to be placed)
                                    if (lbRandomObjPathSparse != null)
                                    {
                                        // Always check cutoff for consistency
                                        if (lbRandomObjPathSparse.Range(0.01f, 1f) < 1f - objPathPlacementCutoff)
                                        {
                                            // If this prefab will not be populated, check that it is not at one of the ends which needs a particular prefab.
                                            if (!((objPathPointIdx == 0 && objPathStartMemberDefined) || ((objPathPointIdx == numObjPathPoints - 1) && objPathEndMemberDefined)))
                                            {
                                                createMesh = false; isMemberPlacementPositionOk = false;
                                            }
                                        }
                                    }
                                }
                                else if (lbGroupMemberToPlace.useNoise)
                                {
                                    // Get a perlin noise value for this point in the landscape
                                    float meshNoiseTileSize = lbGroupMemberToPlace.noiseTileSize;
                                    coords.x = prefabPosition.x + lbGroupMemberToPlace.noiseOffset;
                                    coords.y = prefabPosition.z + lbGroupMemberToPlace.noiseOffset;
                                    float noiseValue = Mathf.Abs(LBNoise.PerlinFractalNoise(coords.x / meshNoiseTileSize, coords.y / meshNoiseTileSize, 5) - 0.5f) * 4f;
                                    // If the noise value is less than (1 - prefab cutoff value) don't create the prefab
                                    if (noiseValue < 1f - lbGroupMemberToPlace.noisePlacementCutoff) { createMesh = false; isMemberPlacementPositionOk = false; }
                                }
                            }
                            // Sparse path population for SubGroups along a path (use Series placement cutoff)
                            else if (createSubGroup && isObjectPathMemberType && lbRandomObjPathSparse != null)
                            {
                                // Always check cutoff for consistency
                                if (lbRandomObjPathSparse.Range(0.01f, 1f) < 1f - objPathPlacementCutoff)
                                {
                                    // If this subgroup will not be populated, check that it is not at one of the ends which needs a particular subgroup.
                                    if (!((objPathPointIdx == 0 && objPathStartGroupDefined) || ((objPathPointIdx == numObjPathPoints - 1) && objPathEndGroupDefined)))
                                    {
                                        createSubGroup = false; isSubGroupPlacementOk = false; isMemberPlacementPositionOk = false;
                                    }
                                }
                            }

                            #endregion

                            #region Member Proximity

                            if (isMemberPlacementPositionOk && createPrefab) // #SMS 2.1.1 beta 1h - always find cell, then check proximity
                            {
                                #region Find which cell we are in

                                // *******************************************
                                // NOTE: In GroupDesigner, cellPosN.x / z can be -ve values as x,z 0,0 is in the centre of the GroupDesigner's base plane.
                                // NEED ATTENTION HERE...
                                // ********************************************
                                if (gVars.isGroupDesignerEnabled)
                                {
                                    // DAVID - Check if we need to offset -ve values to right rather than just take absolute value...
                                    // Values are normalised based on radius not diameter of the GroupDesigner
                                    gVars.proximityMemberCellXCoord = (int)((cellPosN.x < 0f ? -cellPosN.x : cellPosN.x) * gVars.proximityMemberCellsListWidth);
                                    gVars.proximityMemberCellZCoord = (int)((cellPosN.z < 0f ? -cellPosN.z : cellPosN.z) * gVars.proximityMemberCellsListWidth);
                                }
                                else
                                {
                                    gVars.proximityMemberCellXCoord = (int)(cellPosN.x * gVars.proximityMemberCellsListWidth);
                                    gVars.proximityMemberCellZCoord = (int)(cellPosN.z * gVars.proximityMemberCellsListWidth);
                                }

                                if (gVars.proximityMemberCellXCoord >= gVars.proximityMemberCellsListWidth) { gVars.proximityMemberCellXCoord = gVars.proximityMemberCellsListWidth - 1; }
                                if (gVars.proximityMemberCellZCoord >= gVars.proximityMemberCellsListWidth) { gVars.proximityMemberCellZCoord = gVars.proximityMemberCellsListWidth - 1; }
                                gVars.thisObjectProximityCellIndex = gVars.proximityMemberCellXCoord + (gVars.proximityMemberCellZCoord * gVars.proximityMemberCellsListWidth);
                                if (gVars.thisObjectProximityCellIndex < 0) { gVars.thisObjectProximityCellIndex = 0; }
                                else if (gVars.thisObjectProximityCellIndex >= gVars.totalProximityMemberCells) { gVars.thisObjectProximityCellIndex = gVars.totalProximityMemberCells - 1; }
                                #endregion

                                if (!lbGroupMemberToPlace.isIgnoreProximityOfOthers) // #SMS 2.1.1 beta 1h - always find cell, then check proximity
                                {
                                    // Get a new list to store object proximities in
                                    gVars.thisObjectProximitiesList.Clear();
                                    // Add the object proximities from this cell
                                    gVars.thisObjectProximitiesList.AddRange(gVars.objectProximitiesList[gVars.thisObjectProximityCellIndex]);
                                    // Then add the object proximities from any surrounding cells
                                    if (gVars.proximityMemberCellXCoord > 0)
                                    {
                                        // Bottom left cell
                                        if (gVars.proximityMemberCellZCoord > 0) { gVars.thisObjectProximitiesList.AddRange(gVars.objectProximitiesList[gVars.thisObjectProximityCellIndex - gVars.proximityMemberCellsListWidth - 1]); }
                                        // Top left cell
                                        if (gVars.proximityMemberCellZCoord < gVars.proximityMemberCellsListWidth - 1) { gVars.thisObjectProximitiesList.AddRange(gVars.objectProximitiesList[gVars.thisObjectProximityCellIndex + gVars.proximityMemberCellsListWidth - 1]); }
                                        // Centre left cell

                                        gVars.thisObjectProximitiesList.AddRange(gVars.objectProximitiesList[gVars.thisObjectProximityCellIndex - 1]);
                                    }
                                    if (gVars.proximityMemberCellXCoord < gVars.proximityMemberCellsListWidth - 1)
                                    {
                                        // Bottom right cell
                                        if (gVars.proximityMemberCellZCoord > 0) { gVars.thisObjectProximitiesList.AddRange(gVars.objectProximitiesList[gVars.thisObjectProximityCellIndex - gVars.proximityMemberCellsListWidth + 1]); }
                                        // Top right cell
                                        if (gVars.proximityMemberCellZCoord < gVars.proximityMemberCellsListWidth - 1) { gVars.thisObjectProximitiesList.AddRange(gVars.objectProximitiesList[gVars.thisObjectProximityCellIndex + gVars.proximityMemberCellsListWidth + 1]); }
                                        // Centre right cell
                                        gVars.thisObjectProximitiesList.AddRange(gVars.objectProximitiesList[gVars.thisObjectProximityCellIndex + 1]);
                                    }
                                    // Bottom centre cell
                                    if (gVars.proximityMemberCellZCoord > 0) { gVars.thisObjectProximitiesList.AddRange(gVars.objectProximitiesList[gVars.thisObjectProximityCellIndex - gVars.proximityMemberCellsListWidth]); }
                                    // Top centre cell
                                    if (gVars.proximityMemberCellZCoord < gVars.proximityMemberCellsListWidth - 1) { gVars.thisObjectProximitiesList.AddRange(gVars.objectProximitiesList[gVars.thisObjectProximityCellIndex + gVars.proximityMemberCellsListWidth]); }

                                    // Then use this list to check if this mesh/prefab position is too close to another object
                                    isMemberPlacementPositionOk = !gVars.thisObjectProximitiesList.Exists(msh => (((proximityObjectPos.x - msh.position.x) * (proximityObjectPos.x - msh.position.x)) + ((proximityObjectPos.z - msh.position.z) * (proximityObjectPos.z - msh.position.z)))
                                            < (msh.proximity + lbGroupMemberToPlace.proximityExtent) * (msh.proximity + lbGroupMemberToPlace.proximityExtent));
                                }
                            }

                            #endregion

                            #region Tree Proximity

                            // 25% faster to not check tree proximity when minTreeProximity = 0
                            if (isMemberPlacementPositionOk && createPrefab && lbGroupMemberToPlace.minTreeProximity > 0f && !gVars.isGroupDesignerEnabled)
                            {
                                // Find which cell we are in
                                gVars.proximityTreeCellXCoord = (int)(cellPosN.x * gVars.proximityTreeCellsListWidth);
                                gVars.proximityTreeCellZCoord = (int)(cellPosN.z * gVars.proximityTreeCellsListWidth);
                                if (gVars.proximityTreeCellXCoord >= gVars.proximityTreeCellsListWidth) { gVars.proximityTreeCellXCoord = gVars.proximityTreeCellsListWidth - 1; }
                                if (gVars.proximityTreeCellZCoord >= gVars.proximityTreeCellsListWidth) { gVars.proximityTreeCellZCoord = gVars.proximityTreeCellsListWidth - 1; }
                                gVars.thisTreeProximityCellIndex = gVars.proximityTreeCellXCoord + (gVars.proximityTreeCellZCoord * gVars.proximityTreeCellsListWidth);
                                if (gVars.thisTreeProximityCellIndex < 0) { gVars.thisTreeProximityCellIndex = 0; }
                                else if (gVars.thisTreeProximityCellIndex >= gVars.totalProximityTreeCells) { gVars.thisTreeProximityCellIndex = gVars.totalProximityTreeCells - 1; }

                                // Get a new list to store object proximities in
                                gVars.thisTreeProximitiesList.Clear();
                                // Add the tree proximities from this cell
                                gVars.thisTreeProximitiesList.AddRange(gVars.treeProximitiesList[gVars.thisTreeProximityCellIndex]);
                                // Then add the tree proximities from any surrounding cells
                                if (gVars.proximityTreeCellXCoord > 0)
                                {
                                    // Bottom left cell
                                    if (gVars.proximityTreeCellZCoord > 0) { gVars.thisTreeProximitiesList.AddRange(gVars.treeProximitiesList[gVars.thisTreeProximityCellIndex - gVars.proximityTreeCellsListWidth - 1]); }
                                    // Top left cell
                                    if (gVars.proximityTreeCellZCoord < gVars.proximityTreeCellsListWidth - 1) { gVars.thisTreeProximitiesList.AddRange(gVars.treeProximitiesList[gVars.thisTreeProximityCellIndex + gVars.proximityTreeCellsListWidth - 1]); }
                                    // Centre left cell
                                    gVars.thisTreeProximitiesList.AddRange(gVars.treeProximitiesList[gVars.thisTreeProximityCellIndex - 1]);
                                }
                                if (gVars.proximityTreeCellXCoord < gVars.proximityTreeCellsListWidth - 1)
                                {
                                    // Bottom right cell
                                    if (gVars.proximityTreeCellZCoord > 0) { gVars.thisTreeProximitiesList.AddRange(gVars.treeProximitiesList[gVars.thisTreeProximityCellIndex - gVars.proximityTreeCellsListWidth + 1]); }
                                    // Top right cell
                                    if (gVars.proximityTreeCellZCoord < gVars.proximityTreeCellsListWidth - 1) { gVars.thisTreeProximitiesList.AddRange(gVars.treeProximitiesList[gVars.thisTreeProximityCellIndex + gVars.proximityTreeCellsListWidth + 1]); }
                                    // Centre right cell
                                    gVars.thisTreeProximitiesList.AddRange(gVars.treeProximitiesList[gVars.thisTreeProximityCellIndex + 1]);
                                }
                                // Bottom centre cell
                                if (gVars.proximityTreeCellZCoord > 0) { gVars.thisTreeProximitiesList.AddRange(gVars.treeProximitiesList[gVars.thisTreeProximityCellIndex - gVars.proximityTreeCellsListWidth]); }
                                // Top centre cell
                                if (gVars.proximityTreeCellZCoord < gVars.proximityTreeCellsListWidth - 1) { gVars.thisTreeProximitiesList.AddRange(gVars.treeProximitiesList[gVars.thisTreeProximityCellIndex + gVars.proximityTreeCellsListWidth]); }

                                if (lbGroupMemberToPlace.isRemoveTree)
                                {
                                    // Remove trees within certain distance of an object
                                    // Find all trees that are too close and add them to the list of trees to remove
                                    gVars.thisTreesToRemoveList = gVars.thisTreeProximitiesList.FindAll(msh => (((proximityObjectPos.x - msh.position.x) * (proximityObjectPos.x - msh.position.x)) + ((proximityObjectPos.z - msh.position.z) * (proximityObjectPos.z - msh.position.z)))
                                            < lbGroupMemberToPlace.minTreeProximity * lbGroupMemberToPlace.minTreeProximity);
                                    if (gVars.thisTreesToRemoveList.Count > 0)
                                    {
                                        // Then add them to a list of trees to be removed...
                                        gVars.treesToRemoveList.AddRange(gVars.thisTreesToRemoveList);
                                        // ... then remove them from the tree proximity list
                                        // Is there a quicker way to do this, given that we already have the list of objects?
                                        gVars.thisTreeProximitiesList.RemoveAll(msh => (((proximityObjectPos.x - msh.position.x) * (proximityObjectPos.x - msh.position.x)) + ((proximityObjectPos.z - msh.position.z) * (proximityObjectPos.z - msh.position.z)))
                                            < lbGroupMemberToPlace.minTreeProximity * lbGroupMemberToPlace.minTreeProximity);
                                    }
                                }
                                else
                                {
                                    // Use this code if we want to just not place objects within certain distance of a tree
                                    // Use this list to check if this prefab position is too close to a tree
                                    isMemberPlacementPositionOk = !gVars.thisTreeProximitiesList.Exists(msh => (((proximityObjectPos.x - msh.position.x) * (proximityObjectPos.x - msh.position.x)) + ((proximityObjectPos.z - msh.position.z) * (proximityObjectPos.z - msh.position.z)))
                                            < lbGroupMemberToPlace.minTreeProximity * lbGroupMemberToPlace.minTreeProximity);
                                }
                            }

                            #endregion

                            #region Flatten Under Member Prefab

                            // Will need to find terrain to flatten
                            if (isMemberPlacementPositionOk && createPrefab && lbGroupMemberToPlace.isTerrainFlattened && !gVars.isGroupDesignerEnabled)
                            {
                                flattenPosNList.Add(cellPosN);

                                // Get the rectangle that defines the circular area that will be flattened
                                // NOTE: Adding the rect directly to the Add(..) isn't any faster.
                                Rect flattenRect = Rect.MinMaxRect(prefabPosition.x - lbGroupMemberToPlace.flattenDistance, prefabPosition.z - lbGroupMemberToPlace.flattenDistance, prefabPosition.x + lbGroupMemberToPlace.flattenDistance, prefabPosition.z + lbGroupMemberToPlace.flattenDistance);
                                flattenRectList.Add(flattenRect);

                                flattenBlendRateList.Add(lbGroupMemberToPlace.flattenBlendRate);
                            }

                            #endregion

                            #region Remove Grass Under Member Prefab

                            if (isMemberPlacementPositionOk && createPrefab && lbGroupMemberToPlace.minGrassProximity > 0f && !gVars.isGroupDesignerEnabled)
                            {
                                // Get the min, max and centre coordinates of the area which grass will be removed from
                                gVars.grassAreaNoBlendRadius = lbGroupMemberToPlace.minGrassProximity / (float)gVars.grassArrayCellSize;
                                gVars.grassAreaRadius = (int)(gVars.grassAreaNoBlendRadius * (1f + lbGroupMemberToPlace.removeGrassBlendDist));
                                if (gVars.grassAreaNoBlendRadius > gVars.grassAreaRadius) { gVars.grassAreaNoBlendRadius = gVars.grassAreaRadius; }
                                gVars.grassAreaCentreXIndex = (int)(cellPosN.x * gVars.grassArrayCellsListWidth);
                                gVars.grassAreaCentreZIndex = (int)(cellPosN.z * gVars.grassArrayCellsListWidth);
                                gVars.grassAreaMinXIndex = gVars.grassAreaCentreXIndex - gVars.grassAreaRadius;
                                gVars.grassAreaMaxXIndex = gVars.grassAreaCentreXIndex + gVars.grassAreaRadius;
                                gVars.grassAreaMinZIndex = gVars.grassAreaCentreZIndex - gVars.grassAreaRadius;
                                gVars.grassAreaMaxZIndex = gVars.grassAreaCentreZIndex + gVars.grassAreaRadius;

                                // Clamp area to within the bounds of the landscape
                                if (gVars.grassAreaMinXIndex < 0) { gVars.grassAreaMinXIndex = 0; }
                                if (gVars.grassAreaMaxXIndex > gVars.grassArrayCellsListWidth - 1) { gVars.grassAreaMaxXIndex = gVars.grassArrayCellsListWidth - 1; }
                                if (gVars.grassAreaMinZIndex < 0) { gVars.grassAreaMinZIndex = 0; }
                                if (gVars.grassAreaMaxZIndex > gVars.grassArrayCellsListWidth - 1) { gVars.grassAreaMaxZIndex = gVars.grassArrayCellsListWidth - 1; }

                                // Loop through the area cells
                                for (gVars.grassArrayCellXCoord = gVars.grassAreaMinXIndex; gVars.grassArrayCellXCoord <= gVars.grassAreaMaxXIndex; gVars.grassArrayCellXCoord++)
                                {
                                    for (gVars.grassArrayCellZCoord = gVars.grassAreaMinZIndex; gVars.grassArrayCellZCoord <= gVars.grassAreaMaxZIndex; gVars.grassArrayCellZCoord++)
                                    {
                                        // Get the distance to the centre of the removal area
                                        gVars.grassRemovalDist = (new Vector2(gVars.grassArrayCellXCoord - gVars.grassAreaCentreXIndex, gVars.grassArrayCellZCoord - gVars.grassAreaCentreZIndex)).magnitude / gVars.grassAreaRadius;
                                        // The middle area (measured radially) has no blending
                                        if (gVars.grassRemovalDist < 1f) { gVars.grassRemovalBlendFactor = 0f; }
                                        // The rest of the area blends out towards the edge
                                        else if (lbGroupMemberToPlace.removeGrassBlendDist == 0f) { gVars.grassRemovalBlendFactor = 1f; }
                                        else { gVars.grassRemovalBlendFactor = Mathf.Clamp01((gVars.grassRemovalDist - 1f) * (1f / lbGroupMemberToPlace.removeGrassBlendDist)); }
                                        // Only calculate anything if we have to do blending
                                        if (gVars.grassRemovalBlendFactor < 1f)
                                        {
                                            // Calculate the cell index in the grass removal array
                                            gVars.thisGrassArrayCellIndex = (gVars.grassArrayCellZCoord * gVars.grassArrayCellsListWidth) + gVars.grassArrayCellXCoord;
                                            // Set the new value to the minimum of:
                                            // a) the current grass strength value, and
                                            // b) the calculated grass strength value
                                            if (gVars.grassRemovalBlendFactor * 255f < gVars.finalGrassRemovalArray[gVars.thisGrassArrayCellIndex])
                                            {
                                                gVars.finalGrassRemovalArray[gVars.thisGrassArrayCellIndex] = (byte)(gVars.grassRemovalBlendFactor * 255f);
                                            }
                                        }
                                    }
                                }
                            }

                            #endregion

                            GameObject newPrefabInstance = null;

                            #region Instantiate Members (Group Type: Uniform, Clearings or SubGroup)
                            // A member of a uniform group will be uniformly distributed across the landscape (based on the rules)
                            // It is not dependant on the placement of the group as only members have position in the terrain
                            if (isMemberPlacementPositionOk && createPrefab && (isGroupTypeUniform || isGroupTypeProceduralClearing || isGroupTypeManualClearing || isGroupTypeSubGroup))
                            {
                                #region Uniform Member Prefab or Clearing prefab

#if UNITY_EDITOR
                                if (lbGroupMemberToPlace.isKeepPrefabConnection) { newPrefabInstance = (GameObject)UnityEditor.PrefabUtility.InstantiatePrefab(lbGroupMemberToPlace.prefab); }
                                else { newPrefabInstance = (GameObject)UnityEngine.Object.Instantiate(lbGroupMemberToPlace.prefab, prefabPosition, prefabRotation); }
#else
                                newPrefabInstance = (GameObject)UnityEngine.Object.Instantiate(lbGroupMemberToPlace.prefab, prefabPosition, prefabRotation);
#endif

                                if (newPrefabInstance != null)
                                {
                                    gVars.lbGroupParams.landscape.numberOfGroupPrefabs++;
                                    numberOfPrefabsCreated++;

#if UNITY_EDITOR
                                    if (lbGroupMemberToPlace.isKeepPrefabConnection)
                                    {
                                        newPrefabInstance.transform.SetPositionAndRotation(prefabPosition, prefabRotation);
                                    }
#endif
                                    newPrefabInstance.transform.SetParent(memberPrefabGameObject.transform);
                                    newPrefabInstance.transform.localScale = prefabScale;

#if UNITY_EDITOR && LB_EDITOR

                                    if ((isObjectPathMemberType || isChildGroup) && gVars.isGroupDesignerEnabled)
                                    {
                                        // Add a component to keep track of meta data about this prefab in the Group Designer
                                        LBGroupDesignerItem lbGroupDesignerItem = newPrefabInstance.AddComponent<LBGroupDesignerItem>();
                                        if (lbGroupDesignerItem == null) { if (gVars.lbGroupParams.showErrors) { Debug.LogWarning("ERROR: " + methodName + " - could not add LBGroupDesignerItem to " + lbGroup.groupName + " " + lbGroupMemberToPlace.prefabName + ". Please Report"); } }
                                        else
                                        {
                                            lbGroupDesignerItem.GroupMemberGUID = lbGroupMemberToPlace.GUID;
                                            lbGroupDesignerItem.lbGroupMember = lbGroupMemberToPlace;
                                            lbGroupDesignerItem.isObjPathMember = isObjectPathMemberType;
                                            lbGroupDesignerItem.objPathGroupMemberGUID = lbGroupMember.GUID;
                                            if (isChildGroup) { lbGroupDesignerItem.SubGroupGUID = lbGroup.GUID; }
                                            // This is a prefab, not a SubGroup (although it could be a prefab WITHIN a subgroup)
                                            lbGroupDesignerItem.isSubGroup = false;
                                            lbGroupDesignerItem.FindGroupDesigner();
                                        }
                                    }
#endif

                                }

                                #endregion
                            }
                            #endregion

                            #region Instantiate SubGroups along a Path
                            else if (isSubGroupPlacementOk && createSubGroup)
                            {
                                // When useSubGroups is enabled on an LBObjPathSeries, Groups of type SubGroup, can be created along the path.
                                // This requires this method (ProcessGroup), to call itself to create the SubGroups (with all its members) in the landscape or the GroupDesigner.
                                int subGroupIdx = gVars.activeGroupList.FindIndex(grp => grp.GUID == subGroupToPlace.GUID && !string.IsNullOrEmpty(grp.GUID));

                                //Debug.Log("[DEBUG] ObjPath - placing " + subGroupToPlace.groupName + " at " + prefabPosition + " with rotation: " + prefabRotation.eulerAngles + " subGroupIdx: " + subGroupIdx);

                                // Groups placed along the path could be different so process them one at a time
                                if (subGroupToPlace.positionList == null) { subGroupToPlace.positionList = new List<Vector3>(1); }
                                else { subGroupToPlace.positionList.Clear(); }

                                if (subGroupToPlace.subGroupRotationList == null) { subGroupToPlace.subGroupRotationList = new List<Vector3>(1); }
                                else { subGroupToPlace.subGroupRotationList.Clear(); }

                                // The prefabPosition here is in Landscape-space rather than Worldspace
                                subGroupToPlace.positionList.Add(gVars.isGroupDesignerEnabled ? prefabPosition : prefabPosition - gVars.landscapePosition);
                                // Remember the base rotation of the subgroup before any random rotation of the actual subgroup is applied.
                                subGroupToPlace.subGroupRotationList.Add(prefabRotation.eulerAngles);

                                // Instantiate the child (sub)group. Pass in this activeGpIdx as the parent Group,
                                // and gm as the index of the group member in the lbGroup.groupmemberList.
                                ProcessGroup(subGroupIdx, activeGpIdx, gm, true, gVars);

                                numberOfPrefabsCreated++;
                            }

                            #endregion

                            #region isCombineMesh

                            // Should the prefab meshes be combined? A new mesh is created for each mesh filter within the prefab
                            // See LBLandscapeMeshController.BuildCombinedMeshes(List<LBGroup> lbGroupList)
                            if (newPrefabInstance != null && lbGroupMemberToPlace.isCombineMesh && !gVars.isGroupDesignerEnabled)
                            {
                                if (!isObjectPathMemberType || (isObjectPathMemberType && objPathCbmIdx != -1))
                                {
                                    // Create a new Combine Instance
                                    CombineInstance newCombineInstance = new CombineInstance();
                                    // Create the "transform" from the calculated values above (no need to set the mesh here)
                                    newCombineInstance.transform = Matrix4x4.TRS(prefabPosition - gVars.landscapePosition, prefabRotation, prefabScale);
                                    if (isObjectPathMemberType)
                                    {
                                        // Add the Combine Instance into the relevant list
                                        objPathCombineMeshesList[objPathCbmIdx].Add(newCombineInstance);
                                    }
                                    else
                                    {
                                        // Add the Combine Instance into the list
                                        combineMeshes.Add(newCombineInstance);
                                    }

                                    // Remove the mesh renderers from the prefab typeMeshRenderer
                                    Component[] prefabMeshRenderers = newPrefabInstance.GetComponentsInChildren(typeMeshRenderer, true);
                                    if (prefabMeshRenderers != null)
                                    {
                                        // Loop backwards through the mesh renderers and remove them from the instantiated prefab
                                        for (mRIdx = prefabMeshRenderers.Length - 1; mRIdx >= 0; mRIdx--)
                                        {
                                            GameObject.DestroyImmediate(prefabMeshRenderers[mRIdx]);
                                        }
                                    }

                                    // Remove the mesh filters from the prefab
                                    Component[] prefabMeshFilters = newPrefabInstance.GetComponentsInChildren(typeMeshFilter, true);
                                    if (prefabMeshFilters != null)
                                    {
                                        // Loop backwards through the mesh filters and remove them from the instantiated prefab
                                        for (mFIdx = prefabMeshFilters.Length - 1; mFIdx >= 0; mFIdx--)
                                        {
                                            GameObject.DestroyImmediate(prefabMeshFilters[mFIdx]);
                                        }
                                    }

                                    // Optionally remove any Animator components from the prefab
                                    if (lbGroupMemberToPlace.isRemoveAnimator)
                                    {
                                        Component[] prefabAnimators = newPrefabInstance.GetComponentsInChildren(typeAnimator, true);
                                        if (prefabAnimators != null)
                                        {
                                            // Loop backwards through the Animators and remove them from the instantiated prefab
                                            for (mAIdx = prefabAnimators.Length - 1; mAIdx >= 0; mAIdx--)
                                            {
                                                GameObject.DestroyImmediate(prefabAnimators[mAIdx]);
                                            }
                                        }
                                    }
                                }
                            }

                            #endregion

                            #region Collider
                            if (newPrefabInstance != null && lbGroupMemberToPlace.isCreateCollider && !gVars.isGroupDesignerEnabled)
                            {
                                // If combining all the prefab meshes, we need to remove any existing colliders
                                // They will be added to the combined meshes in LBLandscapeMeshController.BuildCombineMeshes()
                                if (lbGroupMemberToPlace.isCombineMesh)
                                {
                                    // Remove the colliders from the prefab
                                    Component[] prefabColliders = newPrefabInstance.GetComponentsInChildren(typeof(Collider), true);
                                    if (prefabColliders != null)
                                    {
                                        // Loop backwards through the colliders and remove them from the instantiated prefab
                                        for (pColIdx = prefabColliders.Length - 1; pColIdx >= 0; pColIdx--)
                                        {
                                            GameObject.DestroyImmediate(prefabColliders[pColIdx]);
                                        }
                                    }
                                }
                                else
                                {
                                    // Get all the mesh filters for this prefab
                                    MeshFilter[] mFilters = newPrefabInstance.GetComponentsInChildren<MeshFilter>();
                                    if (mFilters != null)
                                    {
                                        // Loop through all the mesh filters for this prefab
                                        // Adding mesh colliders to all the meshes in the prefab is pretty inefficient...
                                        for (mFIdx = 0; mFIdx < mFilters.Length; mFIdx++)
                                        {
                                            // Add a collider
                                            mFilters[mFIdx].gameObject.AddComponent(typeof(MeshCollider));
                                        }
                                    }
                                }
                            }
                            #endregion

                            #region Remove Empty Gameobjects for CombineMesh
                            if (newPrefabInstance != null && lbGroupMemberToPlace.isCombineMesh && lbGroupMemberToPlace.isRemoveEmptyGameObjects && !gVars.isGroupDesignerEnabled)
                            {
                                // Whether to remove empty gameobjects when combining Meshes. This can reduce the number of
                                // GameObjects in the scene if the prefabs don't contain additional scripts or components.
                                // Check this last because if isCreateCollider was on, then the existing colliders may have
                                // been last items to remove.
                                if (componentList == null) { componentList = new List<Component>(); }
                                else { componentList.Clear(); }

                                newPrefabInstance.GetComponentsInChildren(componentList);

                                // If there are no components that aren't a Transform or a LODGroup, delete the instantiated prefab from the scene
                                // This is very fast if some do exist as it looks for only the first it that is not a Transform or LODGroup
                                if (!componentList.Exists(c => c.GetType() != typeof(Transform) && c.GetType() != typeof(LODGroup))) { GameObject.DestroyImmediate(newPrefabInstance); }
                            }
                            #endregion

                            #region Store Member Proximity Data In List

                            // Add proximity data for prefab, unless it is to be ignored by other prefabs being placed in scene
                            if (isMemberPlacementPositionOk && createPrefab && !lbGroupMemberToPlace.isProximityIgnoredByOthers)
                            {
                                // If this member placement is OK, we have already calculated the correct cell for proximity
                                gVars.objectProximitiesList[gVars.thisObjectProximityCellIndex].Add(new LBObjectProximity(proximityObjectPos, lbGroupMemberToPlace.proximityExtent));

                                // If in the GroupDesigner, pass the proximity data back to the GroupDesigner
                                if (gVars.isGroupDesignerEnabled && gVars.lbGroupParams.objectProximitiesList != null)
                                {
                                    gVars.lbGroupParams.objectProximitiesList.Add(new LBObjectProximity(proximityObjectPos, lbGroupMemberToPlace.proximityExtent));
                                }
                            }

                            #endregion

                            #region Progress

                            // Only update progress bar every fixed amount of time
                            if (gVars.lbGroupParams.showProgress && Time.realtimeSinceStartup > lastProgressUpdateTime + 0.25f)
                            {
                                // Call back to update the progress bar
                                progress = (float)numberOfPrefabsCreated / (float)targetNumberOfMembers;
                                lastProgressUpdateTime = Time.realtimeSinceStartup;
                                gVars.lbGroupParams.showProgressDelegate("Populating Landscape With Groups", lbGroup.groupName + " region " + (regionIdx + 1) + " of " + numRegions + " member " + (gm + 1) + ": " + numberOfPrefabsCreated + " of " + targetNumberOfMembers, progress);
                            }

                            // If a give number of iterations happen without a prefab being placed, give up
                            if (isMemberPlacementPositionOk) { lastPlacementTime = Time.realtimeSinceStartup; }
                            else if (Time.realtimeSinceStartup > lastPlacementTime + 0.1f && !isObjectPathMemberType)
                            {
                                // Check for !isObjectPathMemberType.
                                // For an ObjectPath, if the Default Series has no valid prefabs then this will always be true,
                                // and the next Series (if there is one) will never be reached in the Looping Code below.
                                // So, we need to ensure that ObjectPaths always have a finite number of points to process.

                                //Debug.Log("Stopped early at iteration " + mItn.ToString());
                                break;
                            }

                            #endregion

                            #region Looping Code including ObjPathSeries

                            // Emulates the behaviour of a for loop

                            if (isObjectPathMemberType)
                            {
                                objPathPointIdx++;

                                // Combine Instance and select next Series (if applicable)
                                if (objPathPointIdx >= numObjPathPoints)
                                {
                                    #region Combine Instances Default Series or previous Series
                                    // Loop through the various main members in this object path
                                    numObjPathCombineMeshesList = objPathCombineMeshesList == null ? 0 : objPathCombineMeshesList.Count;
                                    for (objPathCbmIdx = 0; objPathCbmIdx < numObjPathCombineMeshesList; objPathCbmIdx++)
                                    {
                                        // Send the list of Combine Instances to the terrain mesh controller
                                        if (lbGroup.GetMemberByGUID(activeMainObjPrefabList[objPathCbmIdx].groupMemberGUID, true).isCombineMesh && !gVars.isGroupDesignerEnabled)
                                        {
                                            gVars.terrainMeshController.AddCombineInstanceArray(objPathCombineMeshesList[objPathCbmIdx].ToArray(), activeMainObjPrefabList[objPathCbmIdx].groupMemberGUID);
                                        }
                                    }
                                    #endregion

                                    // This is first run when the Default Series has been completed
                                    objPathSeriesIdx++;

                                    //Debug.Log("[DEBUG] numObjPathSeries: " + numObjPathSeries + " objPathSeriesIdx:" + objPathSeriesIdx);

                                    // If there are no Series in the list, objPathSeriesIdx (0) will equal numObjPathSeries (0)
                                    if (objPathSeriesIdx < numObjPathSeries)
                                    {
                                        numObjPathPoints = 0;
                                        objPathPointIdx = 0;
                                        // Reset so that a new prefab can be selected at the start of a Series when RandomUnique is selected
                                        objPathPrefabIdx = -1;

                                        if (lbObjPath.isSeriesListOverride)
                                        {
                                            // Look up the series list in the override GroupMember Object Path
                                            // The override group member was discovered during ObjPath initialisation
                                            lbObjPathSeries = null;
                                            if (lbGroupMemberSeriesOverride != null && numObjPathSeries > 0)
                                            {
                                                lbObjPathSeries = lbGroupMemberSeriesOverride.lbObjPath.lbObjPathSeriesList[objPathSeriesIdx];
                                            }
                                        }
                                        else
                                        {
                                            lbObjPathSeries = lbObjPath.lbObjPathSeriesList[objPathSeriesIdx];
                                        }

                                        if (lbObjPathSeries != null)
                                        {
                                            isObjPathSeriesUseSubGroups = lbObjPathSeries.useSubGroups;
                                            // Avoid having to look up the enumeration multiple times
                                            isSelectionMethodAlternating = lbObjPathSeries.selectionMethod == LBObjPath.SelectionMethod.Alternating;
                                            isSelectionMethodRandom = lbObjPathSeries.selectionMethod == LBObjPath.SelectionMethod.Random;
                                            isSelectionMethodRandom2 = lbObjPathSeries.selectionMethod == LBObjPath.SelectionMethod.RandomLessRepeats;
                                            isSelectionMethodRandom3 = lbObjPathSeries.selectionMethod == LBObjPath.SelectionMethod.RandomUnique;
                                            isLayoutMethodSpacing = lbObjPathSeries.layoutMethod == LBObjPath.LayoutMethod.Spacing;
                                            isLayoutMethodQtyPer100m = lbObjPathSeries.layoutMethod == LBObjPath.LayoutMethod.QtyPer100m;

                                            if (activeMainObjPrefabList != null) { activeMainObjPrefabList.Clear(); }
                                            if (activeMainObjSubGroupList != null) { activeMainObjSubGroupList.Clear(); }

                                            if (isObjPathSeriesUseSubGroups)
                                            {
                                                // Get a list of Main Obj SubGroups which match an active Group of type SubGroup
                                                lbGroup.GetActiveMainObjSubGroupList(lbObjPathSeries, gVars.activeGroupList, activeMainObjSubGroupList);
                                                numMainObjsInList = activeMainObjSubGroupList == null ? 0 : activeMainObjSubGroupList.Count;
                                            }
                                            else
                                            {
                                                // Get a list of Main Obj Prefabs which match an active GroupMember with a prefab
                                                lbGroup.GetActiveMainObjPrefabList(lbObjPathSeries, activeMainObjPrefabList);
                                                numMainObjsInList = activeMainObjPrefabList == null ? 0 : activeMainObjPrefabList.Count;
                                            }

                                            if (isLayoutMethodSpacing)
                                            {
                                                objPathMemberSpacingDistance = lbObjPathSeries.spacingDistance;
                                            }
                                            else if (isLayoutMethodQtyPer100m)
                                            {
                                                // For QtyPer100m, we need to use maxMainPrefabs - 1 to allow for the first point at 0 distance.
                                                objPathMemberSpacingDistance = lbObjPathSeries.maxMainPrefabs < 2 ? 100f : 100f / ((float)lbObjPathSeries.maxMainPrefabs - 1f);
                                            }
                                            else
                                            {
                                                // We currently don't support Exact Quantity for Series because we don't known the exact length of the spline initially
                                                objPathMemberSpacingDistance = 100000;
                                            }

                                            // Get a list of the positions where the prefabs will be placed along a spline
                                            objPathPrefabPointList.Clear();
                                            objPathPrefabForwardsList.Clear();
                                            objPathPrefabRightList.Clear();
                                            objPathPrefabDistancesList.Clear();
                                            lbObjPath.GetObjPathPositionList(objPathPrefabPointList, objPathPrefabForwardsList, objPathPrefabRightList, objPathPrefabDistancesList, lbObjPathSeries, objPathMemberSpacingDistance, gVars.lbGroupParams.showErrors);

                                            numObjPathPoints = objPathPrefabPointList == null ? 0 : objPathPrefabPointList.Count;

                                            if (isObjPathSeriesUseSubGroups)
                                            {
                                                // Check if the start/end SubGroups for this path are defined
                                                startObjSubGroup = lbObjPathSeries.startObjSubGroup;
                                                endObjSubGroup = lbObjPathSeries.endObjSubGroup;
                                                objPathStartGroupDefined = LBGroup.GetGroupByGUID(gVars.activeGroupList, startObjSubGroup.subGroupGUID, true) != null;
                                                objPathEndGroupDefined = LBGroup.GetGroupByGUID(gVars.activeGroupList, endObjSubGroup.subGroupGUID, true) != null;

                                                // When SubGroups are used, GroupMembers are not
                                                startObjPrefab = null;
                                                endObjPrefab = null;
                                                objPathStartMemberDefined = false;
                                                objPathEndMemberDefined = false;
                                            }
                                            else
                                            {
                                                // Check if the start/end members for this path are defined
                                                startObjPrefab = lbObjPathSeries.startObjPrefab;
                                                endObjPrefab = lbObjPathSeries.endObjPrefab;

                                                objPathStartMemberDefined = lbGroup.GetMemberByGUID(startObjPrefab.groupMemberGUID, true) != null;
                                                objPathEndMemberDefined = lbGroup.GetMemberByGUID(endObjPrefab.groupMemberGUID, true) != null;

                                                // When GroupMembers are used, SubGroups are not
                                                startObjSubGroup = null;
                                                endObjSubGroup = null;
                                                objPathStartGroupDefined = false;
                                                objPathEndGroupDefined = false;
                                            }

                                            objPathIsRandomisePerGroupRegion = lbObjPathSeries.isRandomisePerGroupRegion;

                                            // Set up sparse path population variables
                                            objPathPlacementCutoff = lbObjPathSeries.sparcePlacementCutoff;
                                            // Set a seed value
                                            if (lbRandomObjPathSparse != null)
                                            {
                                                // Use the x-axis value of the first point in the ObjPath as the random generator seed.
                                                // If no prefab points to place, set seed to some arbitary number (e.g. numberOfPrefabsCreated)
                                                // Check if a different seed should be used for each group region or instance placed in the landscape
                                                lbRandomObjPathSparse.SetSeed(numObjPathPoints > 0 ? Mathf.RoundToInt(objPathPrefabPointList[0].x + (objPathIsRandomisePerGroupRegion ? groupPosition.x : 0f)) : numberOfPrefabsCreated);
                                            }

                                            // Setup and seed Random when the SelectionMethod is Random, RandomLessRepeats or RandomUnique
                                            if ((isSelectionMethodRandom || isSelectionMethodRandom2 || isSelectionMethodRandom3) && numObjPathPoints > 0)
                                            {
                                                if (lbRandomObjPathSelection == null) { lbRandomObjPathSelection = new LBRandom(); }
                                                if (lbRandomObjPathSelection != null)
                                                {
                                                    // Use the z-axis value of the first point in the ObjPath as the random generator seed.
                                                    // Check if a different seed should be used for each group region or instance placed in the landscape
                                                    lbRandomObjPathSelection.SetSeed(Mathf.RoundToInt(objPathPrefabPointList[0].z + (objPathIsRandomisePerGroupRegion ? groupPosition.z : 0f)));
                                                }
                                            }

                                            #region Initialise combine instances 2D list for Series object path members
                                            objPathCbmIdx = 0;

                                            objPathCombineMeshesList.Clear();
                                            // SubGroups will handle their own combine meshes when ProcessGroup(..) is called for that group
                                            numActiveMainObjPrefabList = isObjPathSeriesUseSubGroups ? 0 : activeMainObjPrefabList.Count;
                                            for (objPathCbmIdx = 0; objPathCbmIdx < numActiveMainObjPrefabList; objPathCbmIdx++)
                                            {
                                                objPathCombineMeshesList.Add(new List<CombineInstance>());
                                            }

                                            #endregion
                                        }

                                        //Debug.Log("[DEBUG] objPathSeriesIdx " + (objPathSeriesIdx + 1) + " of " + numObjPathSeries);
                                    }
                                    else { finishedInstantiatingMembers = true; }
                                }
                            }
                            else
                            {
                                mItn++;
                                if (mItn >= maxMemberIterations || numberOfPrefabsCreated >= targetNumberOfMembers)
                                {
                                    finishedInstantiatingMembers = true;
                                }
                            }

                            #endregion
                        }

                        if (lbRandomObjPathSparse != null) { lbRandomObjPathSparse = null; }
                        if (lbRandomObjPathSelection != null) { lbRandomObjPathSelection = null; }

                        #endregion

                        #region Combine Instances

                        // NOTE: Combine Instances for ObjPath Members are processed at end of Loop Code
                        if (!isObjectPathMemberType)
                        {
                            // Send the list of Combine Instances to the terrain mesh controller
                            if (lbGroupMember.isCombineMesh && lbGroupMember.prefab != null && combineMeshes != null && !gVars.isGroupDesignerEnabled)
                            {
                                //Debug.Log("INFO: " + methodName + " - adding combined instance array for " + lbGroup.groupName + " member " + (gm + 1) + " combineMeshes: " + combineMeshes.Count);
                                gVars.terrainMeshController.AddCombineInstanceArray(combineMeshes.ToArray(), lbGroupMember.GUID);

                                // Remove the potentially empty parent gameobject where the prefabs were instantiated
                                if (memberPrefabGameObject != null && lbGroupMember.isRemoveEmptyGameObjects)
                                {
                                    // GetComponentsInChild will also return the LBPrefabItem attached to the parent gameobject
                                    Component[] components = memberPrefabGameObject.GetComponentsInChildren(typeof(Component));
                                    if (components != null)
                                    {
                                        // Check that there aren't some prefabs with other scripts or components attached to them.
                                        // If only the LBPrefabItem attached to the GameObject (Transform), then remove it from the scene
                                        if (components.Length == 2)
                                        {
                                            lbPrefabItem = memberPrefabGameObject.GetComponent(typeof(LBPrefabItem)) as LBPrefabItem;
                                            if (lbPrefabItem != null) { GameObject.DestroyImmediate(lbPrefabItem); }
                                            GameObject.DestroyImmediate(memberPrefabGameObject);
                                        }
                                        components = null;
                                    }
                                }
                            }
                        }

                        #endregion

                        #region Member Flatten Terrains

                        if (flattenPosNList != null && flattenPosNList.Count > 0 && !gVars.isObjPathDesignerEnabled && !gVars.isGroupDesignerEnabled)
                        {
                            FlattenModifier(gVars.lbGroupParams.landscape, flattenPosNList, flattenRectList, flattenBlendRateList,
                                            gVars.lbGroupParams.showProgressDelegate, (lbGroup.groupName + " member " + (gm + 1)), gVars.lbGroupParams.showErrors);

                            // Clear the list so they don't get used for next member processed.
                            flattenPosNList.Clear();
                            flattenRectList.Clear();
                            flattenBlendRateList.Clear();
                        }

                        #endregion

                        #region Cleanup ChildGroup (SubGroup) temporary list
                        // A SubGroup may be created from multiple parent Groups and/or Group Object Paths.
                        if (isChildGroup)
                        {
                            if (lbGroup.positionList != null) { lbGroup.positionList.Clear(); }
                            if (lbGroup.subGroupRotationList != null) { lbGroup.subGroupRotationList.Clear(); }
                        }
                        #endregion

                        //Debug.Log("INFO: " + lbGroup.groupName + " member " + (gm + 1) + " prefabs created:" + numberOfPrefabsCreated);

                    }  // End of non-disabled group member
                }  // End of group members list for-loop
                #endregion

            } // End of region for-loop
        }

        #endregion

        #region Static Smoothing Methods

        /// <summary>
        /// Smooth a terrain based on the layer smoothing.
        /// This needs to be a post-topography layer process so as to avoid any terrain edge issues. This is because smoothing can
        /// alter pixels in a neighbouring terrain to the one currently being processed.
        /// </summary>
        /// <param name="landscape"></param>
        /// <param name="tData"></param>
        /// <param name="terrainWorldPosition"></param>
        /// <param name="layersList"></param>
        /// <returns></returns>
        public static TerrainData SmoothHeightmapFromLayers(LBLandscape landscape, TerrainData tData, Vector3 terrainWorldPosition, List<LBLayer> layersList)
        {
            float tStart = Time.realtimeSinceStartup;

            // Validate input
            if (landscape == null) { Debug.LogWarning("LBLandscapeTerrain.SmoothHeightmapFromLayers - landscape cannot be null"); }
            else if (tData == null) { Debug.LogWarning("LBLandscapeTerrain.SmoothHeightmapFromLayers - terrain data cannot be null"); }
            else if (layersList == null) { Debug.LogWarning("LBLandscapeTerrain.SmoothHeightmapFromLayers - layersList cannot be null"); }
            else
            {
                // Initialise variables
                int layerTypeInt = -1;

                Rect terrainRect = Rect.MinMaxRect(terrainWorldPosition.x, terrainWorldPosition.z, terrainWorldPosition.x + tData.size.x, terrainWorldPosition.z + tData.size.z);
                Rect smoothingRect;
                LBMap smoothlbMap;

                foreach (LBLayer lbLayer in layersList)
                {
                    if (lbLayer != null)
                    {
                        // Ignore disabled layers
                        if (lbLayer.isDisabled) { continue; }

                        layerTypeInt = lbLayer.LayerTypeInt;

                        // Process Image layers (ignore layers with no heightmap image)
                        if (layerTypeInt > 3 && layerTypeInt < 8 && lbLayer.detailSmoothRate >= 0.001f && lbLayer.heightmapImage != null)
                        {
                            if (lbLayer.restrictArea) { smoothingRect = lbLayer.areaRect; }
                            else { smoothingRect = terrainRect; }

                            // Optionally, restrict smoothing to the area of the image only for Image subtractive and additive layers
                            if ((layerTypeInt == 5 || layerTypeInt == 6) && lbLayer.isSmoothLayerOnly)
                            {
                                // Colour tolerance is an arbitary value as we're not using it with SmoothingAlgorithm.LayerBlendMap
                                smoothlbMap = new LBMap(lbLayer.heightmapImage, Color.white, 0);
                                smoothlbMap.inverse = false;
                                smoothlbMap.useAdvancedTolerance = false;

                                tData = SmoothHeight(landscape, tData, terrainWorldPosition, smoothingRect, lbLayer.detailSmoothRate,
                                                     LBLandscapeTerrain.SmoothingAlgorithm.LayerBlendMap, false, 1, smoothlbMap, null, lbLayer);
                            }
                            else
                            {
                                tData = SmoothHeight(landscape, tData, terrainWorldPosition, smoothingRect, lbLayer.detailSmoothRate,
                                                    LBLandscapeTerrain.SmoothingAlgorithm.UnweightedSlidingAverage, false, 1, null, null, lbLayer);
                            }
                        }

                        // Process the filters
                        if (lbLayer.filters != null)
                        {
                            foreach (LBLayerFilter lbLayerFilter in lbLayer.filters)
                            {
                                // Smooth the area of the map - depending on the edge width of the LBMapPath, it may not smooth all the way to the edge
                                if (lbLayerFilter.type == LBLayerFilter.LayerFilterType.Map && lbLayerFilter.map != null && lbLayerFilter.smoothRate > 0.01f)
                                {
                                    // SMS v1.4.0 Beta 9b - mapColour is required for Stencil layer maps (and EasyRoads3D map textures)
                                    smoothlbMap = new LBMap(lbLayerFilter.map, lbLayerFilter.mapColour, 20);
                                    smoothlbMap.inverse = lbLayerFilter.mapInverse;
                                    smoothlbMap.useAdvancedTolerance = false;

                                    tData = SmoothHeight(landscape, tData, terrainWorldPosition, terrainRect, lbLayerFilter.smoothRate,
                                                         LBLandscapeTerrain.SmoothingAlgorithm.LayerFilterMap, false, 2, smoothlbMap, null, lbLayer);
                                }
                            }
                        }

                        // Check if any MapPath Add, Set or Flatten layers need smoothing
                        if (layerTypeInt == 20)
                        {
                            //if (lbLayer.lbPath != null && lbLayer.layerTypeMode == LBLayer.LayerTypeMode.Flatten && lbLayer.detailSmoothRate >= 0.001f)
                            if (lbLayer.lbPath != null && lbLayer.detailSmoothRate >= 0.001f)
                            {
                                tData = SmoothHeight(landscape, tData, terrainWorldPosition, terrainRect, lbLayer.detailSmoothRate,
                                                         LBLandscapeTerrain.SmoothingAlgorithm.LayerFilterMap, false, 1, null, lbLayer.lbPath, lbLayer);
                            }
                        }
                    }
                }
            }

            if (landscape != null)
            {
                if (landscape.showTiming) { Debug.Log("Time taken to smooth heightmap: " + (Time.realtimeSinceStartup - tStart).ToString("0.000") + "s"); }
            }

            return tData;
        }

        /// <summary>
        /// Smooth an area of a terrain. Can optionally make multiple passes over the area.
        /// IMPORTANT: AFTER smoothing an area or landcape you must apply
        /// heightmap LOB mods to terrains affected by this change by calling
        /// LBLandscapeTerrain.ApplyDelayedHeightmapLOD(landscapeTerrains);
        /// when smoothing an lbPath.
        /// </summary>
        /// <param name="landscape"></param>
        /// <param name="tData"></param>
        /// <param name="worldPosition"></param>
        /// <param name="selectionRect"></param>
        /// <param name="smoothRate"></param>
        /// <param name="smoothingAlgorithm"></param>
        /// <param name="blendEdge"></param>
        /// <param name="numberOfPasses"></param>
        /// <param name="lbMap"></param>
        /// <param name="lbPath"></param>
        /// <param name="lbLayer"></param>
        /// <returns></returns>
        public static TerrainData SmoothHeight(LBLandscape landscape, TerrainData tData, Vector3 worldPosition, Rect selectionRect, float smoothRate,
                                               SmoothingAlgorithm smoothingAlgorithm, bool blendEdge, int numberOfPasses = 1, LBMap lbMap = null, LBPath lbPath = null, LBLayer lbLayer = null)
        {
            if (tData != null)
            {
                #region Variables
                float terrainWidth = tData.size.x;
                float smoothedHeight = 0f;
                bool smoothThisPoint = false;

                // Variables declared outside the loop for speed.
                Vector2 pointOutsideTerrain = Vector2.zero;
                float heightOutsideTerrain = 0f;
                float terrainPixelWidth = 0f;
                int xNeighbour = 0, yNeighbour = 0;

                // Look up enumerations outside loops
                bool isLayerBlendMap = (smoothingAlgorithm == SmoothingAlgorithm.LayerBlendMap);
                bool isLayerFilterMap = (smoothingAlgorithm == SmoothingAlgorithm.LayerFilterMap);
                bool isUnweightedSlidingAverage = (smoothingAlgorithm == SmoothingAlgorithm.UnweightedSlidingAverage);

                // Typically the smoothing with (m) should be an odd number.
                int smoothwidth = 5;

                // Define the domain
                int smoothWidthMin = 3;
                int smoothWidthMax = 9;

                if (isLayerFilterMap) { smoothWidthMax = 27; }
                else if (isLayerBlendMap) { smoothWidthMax = 13; }

                // Determine the smoothing width based on the smoothRate (0-1). This formula shouldn't be simplified because we always
                // want to end with an odd number.
                smoothwidth = (2 * Mathf.RoundToInt(((((float)smoothWidthMax - (float)smoothWidthMin) / 2f) * smoothRate)) + smoothWidthMin);

                // Matrix variables
                int smX = 0, smY = 0;
                int smoothMiddle = (smoothwidth - 1) / 2;
                int smoothPixels = smoothwidth * smoothwidth;
                int smoothMatrixPixels = 0; // The actual number of pixels in the matrix to average
                float[,] smoothMatrix = new float[smoothwidth, smoothwidth];
                int pixelOffsetX = 0, pixelOffsetY = 0;
                float smoothMatrixAverage = 0f;
                float smoothMatrixSum = 0f;

                string smoothEdgeName = string.Empty;

                float blendFactor = 0f;
                float blendRate = 0.98f;
                float distToCenter = 0f;

                // Smoothing Map variables
                LBMapPoint mapPoint;
                // Normalised positions in terrain
                float xPosN = 0f, yPosN = 0f;
                bool useMap = (lbMap != null);
                float mapBlendAmount = 0f;

                // MapPath variables
                bool isValidLBPath = false;
                Vector3[] splinePointsCentre = null;
                Vector3[] splinePointsLeft = null;
                Vector3[] splinePointsRight = null;
                Vector3 hmapWorldPos = Vector3.zero;
                int closestPoint = 0, secondclosestPoint = 0;
                int numSplinePoints = 0;
                Vector3 quadP1 = Vector3.zero, quadP2 = Vector3.zero, quadP3 = Vector3.zero, quadP4 = Vector3.zero;
                bool isMatch = false;
                float sqrDistLeft = 0f, sqrDistRight = 0f, sqrPixelDistFromEdge = 0f;
                float sqrblendEdgeWidth = 0f;
                float pathBlendAmount = 0f;
                //float distFromEdge = 0f;
                int prevIdx = 0, nextIdx = 0;
                int quadLookAheadInt = 1;
                float minHeightN = 0f, maxHeightN = 1f; // Used for MapPath Topography Layer edge blending
                bool isSmoothToEdge = true;             // When smoothing LBLayer.LayerTypeMode.Flatten, we don't want to smooth all the way to the outer edge of the path.
                AnimationCurve smoothCurve = null;

                // Get the normalised (0-1) bounds of this terrain within the landscape (used for Map)
                Vector3 landscapePosition = landscape.transform.position;
                float startX = ((worldPosition.x - landscapePosition.x) / landscape.size.x);
                float endX = startX + (tData.size.x / landscape.size.x);
                float startZ = ((worldPosition.z - landscapePosition.z) / landscape.size.y);
                float endZ = startZ + (tData.size.z / landscape.size.y);

                Rect terrainRect = Rect.MinMaxRect(worldPosition.x, worldPosition.z, worldPosition.x + terrainWidth, worldPosition.z + terrainWidth);

                // Expand top and right boarders slightly to overcome issue with Rect.Contains()
                Rect selectionRectExpanded = new Rect(selectionRect.xMin, selectionRect.yMin, selectionRect.width + 0.05f, selectionRect.height + 0.05f);

                bool processTerrain = false;
                if (useMap) { processTerrain = (lbMap.map != null); }
                else { processTerrain = selectionRectExpanded.Overlaps(terrainRect); }
                #endregion

                // Only do anything if this terrain is part of the highlighted area
                if (processTerrain)
                {
                    heightmapResolution = tData.heightmapResolution;
                    terrainPixelWidth = tData.heightmapScale.x;

                    float[,] heightMap = tData.GetHeights(0, 0, heightmapResolution, heightmapResolution);

                    // We need to determine if a MapPath was created in the Compute Shader
                    // This is true when both Topography and Path acceleration is enabled
                    #if !(UNITY_STANDALONE_OSX || UNITY_STANDALONE_WIN || UNITY_XBOXONE || UNITY_WSA_10_0)
                    bool isTopographyComputeEnabled = false;
                    bool isPathComputeEnabled = false;
                    #else
                    bool isTopographyComputeEnabled = (landscape == null ? false : landscape.useGPUTopography);
                    bool isPathComputeEnabled = (landscape == null ? false : landscape.useGPUPath);
                    #endif

                    #region If smoothing a path, get the data we need
                    if (!useMap && lbPath != null)
                    {
                        // Assume the Path and Spline points and distances have already been cached
                        // If MapPath Topography Layer was created using compute shader, use a different cache
                        if (isTopographyComputeEnabled && isPathComputeEnabled)
                        {
                            splinePointsCentre = lbPath.cachedCentreSplinePointList.ToArray();
                            splinePointsLeft = lbPath.GetSplinePathEdgePoints2(LBPath.PositionType.Left, true, true);
                            splinePointsRight = lbPath.GetSplinePathEdgePoints2(LBPath.PositionType.Right, true, true);
                        }
                        else
                        {
                            splinePointsCentre = lbPath.cachedCentreSplinePoints;
                            splinePointsLeft = lbPath.GetSplinePathEdgePoints(LBPath.PositionType.Left, true);
                            splinePointsRight = lbPath.GetSplinePathEdgePoints(LBPath.PositionType.Right, true);
                        }

                        // Validate the path
                        if (splinePointsCentre != null && splinePointsLeft != null && splinePointsRight != null)
                        {
                            isValidLBPath = (splinePointsCentre.Length > 1 && splinePointsLeft.Length > 1 && splinePointsRight.Length > 1 && splinePointsLeft.Length == splinePointsRight.Length && splinePointsCentre.Length == splinePointsRight.Length);

                            numSplinePoints = splinePointsCentre.Length;
                            hmapWorldPos.y = 0f;

                            // Blend a bit more than the edge width
                            sqrblendEdgeWidth = (lbPath.edgeBlendWidth * 1.5f) * (lbPath.edgeBlendWidth * 1.5f);

                            // The min/max normalised (smoothed) height values
                            minHeightN = 0f;
                            maxHeightN = 1f;

                            if (lbLayer != null)
                            {
                                // If too much smoothing is applied in Set topography LBMapPath layers, the terrain
                                // values may be greater than the original heightmap and may protrude above, say, the top
                                // of a river bank - which will look ugly.
                                if (lbLayer.layerTypeMode == LBLayer.LayerTypeMode.Set)
                                {
                                    minHeightN = lbLayer.minHeight;
                                    maxHeightN = lbLayer.heightScale;
                                }

                                // When smoothing LBLayer.LayerTypeMode.Flatten, we don't want to smooth all the way to the outer edge of the path.
                                // This can help when smoothing a road or pathway on the side of a cliff.
                                isSmoothToEdge = !(lbLayer.layerTypeMode == LBLayer.LayerTypeMode.Flatten);
                            }

                            smoothCurve = LBCurve.SetCurveFromPreset(LBCurve.CurvePreset.PowerOfFour);

                            if (isSmoothToEdge)
                            {
                                sqrblendEdgeWidth = lbPath.edgeBlendWidth * lbPath.edgeBlendWidth;
                            }
                            else
                            {
                                // Blend a bit more than the edge width when LBLayer.LayerTypeMode.Flatten
                                sqrblendEdgeWidth = (lbPath.edgeBlendWidth * 1.5f) * (lbPath.edgeBlendWidth * 1.5f);
                            }
                        }
                    }
                    #endregion

                    for (int pass = 0; pass < numberOfPasses; pass++)
                    {
                        // Loop through heightmap points
                        for (int x = 0; x < heightmapResolution; x++)
                        {
                            for (int y = 0; y < heightmapResolution; y++)
                            {
                                smoothThisPoint = false;

                                // Find the world-space coordinates of this terrain position
                                xPos = (tData.heightmapScale.x * y) + worldPosition.x;
                                yPos = (tData.heightmapScale.z * x) + worldPosition.z;
                                coords = new Vector2(xPos, yPos);

                                #region Restict by LBMap
                                // If there is a LBMap defined in the parameters, restrict smoothing to the map pixels
                                if (lbMap != null)
                                {
                                    // If there is no texture
                                    if (lbMap.map == null) { smoothThisPoint = false; }
                                    else
                                    {
                                        // Get "terrain position" of this heightmap point - values between 0 and 1
                                        xPosN = (float)x / (float)(heightmapResolution - 1);
                                        yPosN = (float)y / (float)(heightmapResolution - 1);

                                        // Convert the normalised terrain coordinates into a point on the Map texture
                                        mapPoint = lbMap.GetMapPositionFromTerrainPosition(xPosN, yPosN, startX, endX, startZ, endZ);

                                        // Compare the terrain position with the colour on the Map texture (PNG image)
                                        if (isLayerBlendMap)
                                        {
                                            // In the future we could blend smoothing using this value
                                            mapBlendAmount = lbMap.map.GetPixel(mapPoint.x, mapPoint.y).grayscale;

                                            // Is the map pixel non-black and are the coordinates within the highlighted area?
                                            smoothThisPoint = (mapBlendAmount > 0f) && (xPos >= selectionRect.xMin && xPos <= selectionRect.xMax && yPos >= selectionRect.yMin && yPos <= selectionRect.yMax);
                                        }
                                        else
                                        {
                                            // Check if the pixel in the map is the same as the mapColour within the Tolerance factor
                                            // If inverse is enabled, the opposite will be returned
                                            smoothThisPoint = lbMap.IsMapPixelMatchToMapColour(mapPoint.x, mapPoint.y, false, true);
                                        }
                                    }
                                }
                                #endregion

                                #region Smooth LBPath Blending
                                else if (lbPath != null)
                                {
                                    if (isValidLBPath)
                                    {
                                        pathBlendAmount = 0f;

                                        // Is this World Position in the path?
                                        // Get world position of heightmap point (calculate base x,y only once)
                                        // This will be used for Map Path which are actual world positions
                                        hmapWorldPos.x = (tData.heightmapScale.x * y) + worldPosition.x;
                                        hmapWorldPos.z = (tData.heightmapScale.z * x) + worldPosition.z;

                                        // Find the closest central spline point
                                        closestPoint = LBMap.FindClosestPoint(splinePointsCentre, hmapWorldPos);

                                        // Find the closest of its consecutive points
                                        secondclosestPoint = LBMap.FindClosestConsecutivePoint(splinePointsCentre, hmapWorldPos, closestPoint);

                                        int firstPtIdx = (closestPoint < secondclosestPoint ? closestPoint : secondclosestPoint);
                                        int secondPtIdx = (closestPoint < secondclosestPoint ? secondclosestPoint : closestPoint);

                                        quadP1.x = splinePointsLeft[firstPtIdx].x;
                                        quadP1.z = splinePointsLeft[firstPtIdx].z;
                                        quadP2.x = splinePointsLeft[secondPtIdx].x;
                                        quadP2.z = splinePointsLeft[secondPtIdx].z;
                                        quadP3.x = splinePointsRight[firstPtIdx].x;
                                        quadP3.z = splinePointsRight[firstPtIdx].z;
                                        quadP4.x = splinePointsRight[secondPtIdx].x;
                                        quadP4.z = splinePointsRight[secondPtIdx].z;

                                        // Set all the Y positions to 0
                                        quadP1.y = 0f; quadP2.y = 0f; quadP3.y = 0f; quadP4.y = 0f;

                                        isMatch = LBMap.IsInQuad(quadP1, quadP2, quadP3, quadP4, hmapWorldPos);

                                        // Check the previous quads to get all edge fragments from the outside of corners and the inside of the last curve
                                        for (prevIdx = 0; !isMatch && firstPtIdx > prevIdx && prevIdx < quadLookAheadInt; prevIdx++)
                                        {
                                            quadP1.x = splinePointsLeft[firstPtIdx - prevIdx - 1].x;
                                            quadP1.z = splinePointsLeft[firstPtIdx - prevIdx - 1].z;
                                            quadP2.x = splinePointsLeft[firstPtIdx - prevIdx].x;
                                            quadP2.z = splinePointsLeft[firstPtIdx - prevIdx].z;
                                            quadP3.x = splinePointsRight[firstPtIdx - prevIdx - 1].x;
                                            quadP3.z = splinePointsRight[firstPtIdx - prevIdx - 1].z;
                                            quadP4.x = splinePointsRight[firstPtIdx - prevIdx].x;
                                            quadP4.z = splinePointsRight[firstPtIdx - prevIdx].z;

                                            isMatch = LBMap.IsInQuad(quadP1, quadP2, quadP3, quadP4, hmapWorldPos);
                                        }

                                        // Check the next quads to get all edge fragments from the inside of corners and the outside of the last curve
                                        for (nextIdx = 0; !isMatch && secondPtIdx + nextIdx + 1 < numSplinePoints && nextIdx < quadLookAheadInt; nextIdx++)
                                        {
                                            quadP1.x = splinePointsLeft[secondPtIdx + nextIdx].x;
                                            quadP1.z = splinePointsLeft[secondPtIdx + nextIdx].z;
                                            quadP2.x = splinePointsLeft[secondPtIdx + nextIdx + 1].x;
                                            quadP2.z = splinePointsLeft[secondPtIdx + nextIdx + 1].z;
                                            quadP3.x = splinePointsRight[secondPtIdx + nextIdx].x;
                                            quadP3.z = splinePointsRight[secondPtIdx + nextIdx].z;
                                            quadP4.x = splinePointsRight[secondPtIdx + nextIdx + 1].x;
                                            quadP4.z = splinePointsRight[secondPtIdx + nextIdx + 1].z;

                                            isMatch = LBMap.IsInQuad(quadP1, quadP2, quadP3, quadP4, hmapWorldPos);
                                        }

                                        if (isMatch)
                                        {
                                            if (lbPath.edgeBlendWidth > 0f)
                                            {
                                                // How far away from the edge is this point?
                                                sqrDistLeft = LBMap.PlanarSquareDistance(hmapWorldPos, quadP1);
                                                sqrDistRight = LBMap.PlanarSquareDistance(hmapWorldPos, quadP3);

                                                // Left side
                                                if (sqrDistLeft < sqrDistRight)
                                                {
                                                    // What is the distance from this point to the left edge?
                                                    sqrPixelDistFromEdge = Mathf.Abs(LBMap.SquareDistanceToSide(quadP1, quadP2, hmapWorldPos));
                                                }
                                                // Right side
                                                else
                                                {
                                                    // What is the distance from this point to the right edge?
                                                    sqrPixelDistFromEdge = Mathf.Abs(LBMap.SquareDistanceToSide(quadP3, quadP4, hmapWorldPos));
                                                }

                                                // This point is within the path edge "zone" (ignore close to the edge if isSmoothToEdge = false)
                                                if ((isSmoothToEdge || sqrPixelDistFromEdge > tData.heightmapScale.x) && sqrPixelDistFromEdge <= sqrblendEdgeWidth)
                                                {
                                                    pathBlendAmount = sqrPixelDistFromEdge / sqrblendEdgeWidth;
                                                    smoothThisPoint = isMatch;
                                                }
                                            }
                                        }
                                    }
                                }
                                #endregion

                                else
                                {
                                    // Are the coordinates within the highlighted area?
                                    smoothThisPoint = (xPos >= selectionRect.xMin && xPos <= selectionRect.xMax && yPos >= selectionRect.yMin && yPos <= selectionRect.yMax);
                                }

                                // Do something if the coordinates are within the highlighted area
                                if (smoothThisPoint)
                                {
                                    if (isUnweightedSlidingAverage || isLayerFilterMap || isLayerBlendMap)
                                    {
                                        // Reset values for this matrix
                                        smoothMatrixAverage = 0f;
                                        smoothMatrixSum = 0f;
                                        smoothMatrixPixels = smoothPixels;

                                        pointOutsideTerrain = Vector2.zero;

                                        // Get the average of the points around this one
                                        for (smX = 0; smX < smoothwidth; smX++)
                                        {
                                            for (smY = 0; smY < smoothwidth; smY++)
                                            {
                                                // The pixels many not be in the current terrain
                                                pixelOffsetX = x + (smX - smoothMiddle);
                                                pixelOffsetY = y + (smY - smoothMiddle);

                                                // Is this pixel outside the current terrain?
                                                if (pixelOffsetX < 0 || pixelOffsetX > heightmapResolution - 1 ||
                                                    pixelOffsetY < 0 || pixelOffsetY > heightmapResolution - 1)
                                                {
                                                    pointOutsideTerrain.x = xPos + ((smX - smoothMiddle) * terrainPixelWidth);
                                                    pointOutsideTerrain.y = yPos + ((smY - smoothMiddle) * terrainPixelWidth);

                                                    // Get the point height in the neighbouring terrain (if there is one)
                                                    heightOutsideTerrain = GetHeight(landscape, pointOutsideTerrain);

                                                    // If the point exists in the landscape add it to the matrix
                                                    if (heightOutsideTerrain > 0f)
                                                    {
                                                        smoothMatrix[smX, smY] = heightOutsideTerrain;
                                                        smoothMatrixSum += smoothMatrix[smX, smY];
                                                    }
                                                    else
                                                    {
                                                        // The point is outside the landscape so ignore it
                                                        smoothMatrix[smX, smY] = 0f;
                                                        smoothMatrixPixels--;
                                                    }
                                                }
                                                else
                                                {
                                                    smoothMatrix[smX, smY] = heightMap[pixelOffsetX, pixelOffsetY];
                                                    smoothMatrixSum += smoothMatrix[smX, smY];
                                                }
                                            }
                                        }

                                        if (smoothMatrixPixels > 0)
                                        {
                                            // This is the unweighted average of the smoothwidth matrix
                                            smoothMatrixAverage = smoothMatrixSum / (float)smoothMatrixPixels;

                                            smoothedHeight = smoothMatrixAverage;

                                            // Match up the edge of the neighbouring terrain
                                            if (x == 0 || x == heightmapResolution - 1 || y == 0 || y == heightmapResolution - 1)
                                            {
                                                // Are we on the right edge of the terrain
                                                // Same as  (xPos - worldPosition.x == terrainWidth)
                                                if (y == heightmapResolution - 1)
                                                {
                                                    // The pixel in the terrain to the right must have the same world position but xPos = 0
                                                    xNeighbour = x;
                                                    yNeighbour = 0;

                                                    // These values get overwritten when the left edge of the neighbouring terrain is smoothed
                                                    SetHeight(landscape, coords, yNeighbour, xNeighbour, smoothMatrixAverage, false);
                                                }
                                                // On the left edge of the terrain
                                                // Same as (xPos - worldPosition.x == 0f)
                                                else if (y == 0)
                                                {
                                                    // The pixel in the terrain to the left needs adjusting
                                                    xNeighbour = x;
                                                    yNeighbour = heightmapResolution - 1;
                                                    SetHeight(landscape, coords, xNeighbour, yNeighbour, smoothMatrixAverage, false);
                                                    // The terrain to the left's edge has been overwritten by SetHeight, so make sure
                                                    // it gets smoothed
                                                    smoothEdgeName += "LEFT ";
                                                }

                                                // On the top of the terrain
                                                // Same as (yPos - worldPosition.z == terrainWidth)
                                                if (x == heightmapResolution - 1)
                                                {
                                                    // The pixel in the terrain to the bottom needs adjusting
                                                    xNeighbour = 0;
                                                    yNeighbour = y;
                                                    SetHeight(landscape, coords, xNeighbour, yNeighbour, smoothMatrixAverage, false);
                                                }
                                                // On the bottom of the terrain
                                                // Same as (yPos - worldPosition.z == 0f)
                                                else if (x == 0)
                                                {
                                                    xNeighbour = heightmapResolution - 1;
                                                    yNeighbour = y;
                                                    SetHeight(landscape, coords, xNeighbour, yNeighbour, smoothMatrixAverage, false);
                                                    smoothEdgeName += "BOTTOM ";
                                                }
                                            }
                                        }
                                        else { smoothedHeight = heightMap[x, y]; }
                                    }
                                    else
                                    {
                                        // Just get the current height
                                        smoothedHeight = heightMap[x, y];
                                    }

                                    // NOTE: There may be an issue if we now change the height on a terrain boundary if we have just
                                    // updated the neighbour adjacent heightmap point above...

                                    if (blendEdge)
                                    {
                                        // Blend out anything more than halfway between the centre and the outside of the higlighted area
                                        distToCenter = Vector2.Distance(coords, selectionRect.center);
                                        blendFactor = (Mathf.Clamp(distToCenter / (selectionRect.width * 0.5f), 0.5f, 1f) - 0.5f) * 2f;
                                        // Adjust blend distance between halfway to centre and outer edge
                                        blendFactor = Mathf.Clamp01(blendFactor / blendRate);

                                        // Calculate the heightmap based on the smooth height variable
                                        heightMap[x, y] = (heightMap[x, y] * blendFactor) + (smoothedHeight * (1f - blendFactor));
                                    }
                                    else if (isValidLBPath && pathBlendAmount > 0f)
                                    {
                                        if (isSmoothToEdge) // LBLayer.LayerTypeMode.Add or Set
                                        {
                                            pathBlendAmount = smoothCurve.Evaluate(pathBlendAmount);

                                            // WARNING: Mathf.Lerp() may be a little slow
                                            // clamping the smoothedHeight to the normalised values provided.
                                            heightMap[x, y] = Mathf.Lerp(heightMap[x, y], Mathf.Clamp(smoothedHeight, minHeightN, maxHeightN), pathBlendAmount);
                                        }
                                        else // LBLayer.LayerTypeMode.Flatten
                                        {
                                            // Smooth more near the edge of the path
                                            heightMap[x, y] = (heightMap[x, y] * pathBlendAmount) + (smoothedHeight * (1f - pathBlendAmount));
                                        }
                                    }
                                    else { heightMap[x, y] = smoothedHeight; }
                                }
                            }
                        }
                    }

                    // Update the heightmap
                    tData.SetHeightsDelayLOD(0, 0, heightMap);

                    if (!blendEdge)
                    {
                        if (smoothEdgeName.Contains("LEFT"))
                        {
                            SmoothTerrainEdge(landscape, tData, terrainWidth, "LEFT", worldPosition, selectionRect, smoothRate, SmoothingAlgorithm.UnweightedSlidingAverage, false, 1);
                        }
                        if (smoothEdgeName.Contains("BOTTOM"))
                        {
                            SmoothTerrainEdge(landscape, tData, terrainWidth, "BOTTOM", worldPosition, selectionRect, smoothRate, SmoothingAlgorithm.UnweightedSlidingAverage, false, 1);
                        }
                    }
                }
            }

            return tData;
        }

        /// <summary>
        /// Make sure the edge heights of all terrains match those of the neighbouring terrain in the same landscape.
        /// </summary>
        /// <param name="landscape"></param>
        /// <param name="landscapeTerrains"></param>
        public static void FixTerrainEdges(LBLandscape landscape, Terrain[] landscapeTerrains, float smoothRate = 1f)
        {
            if (landscape != null && landscapeTerrains != null)
            {
                for (int t = 0; t < landscapeTerrains.Length; t++)
                {
                    TerrainData tData = landscapeTerrains[t].terrainData;
                    Vector3 worldPosition = landscapeTerrains[t].transform.position;

                    Rect terrainRect = Rect.MinMaxRect(worldPosition.x, worldPosition.z, worldPosition.x + tData.size.x, worldPosition.z + tData.size.z);
                    // Only fix the corners
                    SmoothTerrainEdge(landscape, tData, tData.size.x, "LEFT", worldPosition, terrainRect, smoothRate, SmoothingAlgorithm.UnweightedSlidingAverage, true, 1);
                    SmoothTerrainEdge(landscape, tData, tData.size.x, "BOTTOM", worldPosition, terrainRect, smoothRate, SmoothingAlgorithm.UnweightedSlidingAverage, true, 1);
                    //landscapeTerrains[t].ApplyDelayedHeightmapModification();
                    // Have potentially modified heights in adjoining terrains, so update LOD to get set correct pixel heights
                    ApplyDelayedHeightmapLOD(landscapeTerrains);
                }
            }
        }

        /// <summary>
        /// Smooth the edge of a neighbouring terrain in the same landscape
        /// Currently only supports terrains on the LEFT or BOTTOM edges
        /// of the terrain.
        /// </summary>
        /// <param name="landscape"></param>
        /// <param name="t1Data"></param>
        /// <param name="t1TerrainWidth"></param>
        /// <param name="edgeName"></param>
        /// <param name="worldPosition"></param>
        /// <param name="selectionRect"></param>
        /// <param name="smoothRate"></param>
        /// <param name="smoothingAlgorithm"></param>
        /// <param name="numberOfPasses"></param>
        public static void SmoothTerrainEdge(LBLandscape landscape, TerrainData t1Data, float t1TerrainWidth, string edgeName, Vector3 worldPosition, Rect selectionRect, float smoothRate,
                                              SmoothingAlgorithm smoothingAlgorithm, bool fixCornersOnly, int numberOfPasses)
        {
            Vector3 landscapeWorldPosition = Vector3.zero;
            int heightmapResolution = 0;
            TerrainData t2Data = null;

            int t1Z = 0, t1X = 0, t2X = 0, t2Z = 0;
            float t1EdgeHeight = 0f;
            float t1Height = 0f, t2Height = 0f;
            int edgeWidth = 0, baseEdgeWidth = 0;

            float[,] t1HeightMap, t2HeightMap;

            if (landscape != null && t1Data != null)
            {
                landscapeWorldPosition = landscape.transform.position;
                heightmapResolution = t1Data.heightmapResolution;

                // Adjust the edge blend width based on the terrain heightmap resolution and the smoothrate
                baseEdgeWidth = (heightmapResolution - 1) / 32;

                edgeWidth = Mathf.RoundToInt(Mathf.Clamp((float)baseEdgeWidth * smoothRate, 3f, (float)baseEdgeWidth));

                for (int pass = 0; pass < numberOfPasses; pass++)
                {
                    // Is there a terrain to the left of this terrain?
                    if (worldPosition.x > landscapeWorldPosition.x && edgeName.Contains("LEFT"))
                    {
                        t2Data = GetTerrainData(landscape, worldPosition, heightmapResolution - 1, 0, false);
                        if (t2Data != null)
                        {
                            // Only fetching and update the edges to improve performance
                            // Get heightmaps from both terrains
                            t1HeightMap = t1Data.GetHeights(0, 0, edgeWidth, heightmapResolution);
                            t2HeightMap = t2Data.GetHeights(heightmapResolution - edgeWidth, 0, edgeWidth, heightmapResolution);

                            if (fixCornersOnly)
                            {
                                //Debug.Log("fixCornersOnly left worldPosition: " + worldPosition.ToString());

                                for (t1Z = heightmapResolution - edgeWidth - 1; t1Z < heightmapResolution; t1Z++)
                                {
                                    t2HeightMap[t1Z, edgeWidth - 1] = t1HeightMap[t1Z, 0];
                                }
                            }
                            else
                            {
                                //Debug.Log("SMOOTH left");
                                // Z axis in worldspace (without any Transform rotation)
                                for (t1Z = 0; t1Z < heightmapResolution; t1Z++)
                                {
                                    for (t1X = 0; t1X < edgeWidth; t1X++)
                                    {
                                        // Get the local terrain height at this point
                                        t1Height = t1HeightMap[t1Z, t1X];

                                        // Get the local terrain height at the edge for this t1Z value
                                        if (t1X == 0) { t1EdgeHeight = t1Height; }

                                        // Get the heightmap coordinates in the adjorning terrain
                                        t2X = edgeWidth - 1 - t1X;
                                        t2Z = t1Z;

                                        if (t1Z > heightmapResolution - edgeWidth && t1X == 0)
                                        {
                                            t2HeightMap[t2Z, t2X] = t1EdgeHeight;
                                        }
                                        else
                                        {
                                            // Get the height from the adjoining terrain
                                            t2Height = t2HeightMap[t2Z, t2X];

                                            // TODO - SmoothTerrainEdge improve edge blending
                                            t2HeightMap[t2Z, t2X] = Mathf.Lerp(t1EdgeHeight, t2Height, (float)t1X / (float)edgeWidth);
                                        }
                                    }
                                }
                            }
                            // Only update the left terrain that has been changed
                            t2Data.SetHeightsDelayLOD(heightmapResolution - edgeWidth, 0, t2HeightMap);

                            //if (fixCornersOnly) { t1Data.SetHeightsDelayLOD(0, 0, t1HeightMap); }
                        }
                    }

                    // Is there a terrain at the bottom of this terrain?
                    if (worldPosition.z > landscapeWorldPosition.z && edgeName.Contains("BOTTOM"))
                    {
                        t2Data = GetTerrainData(landscape, worldPosition, 0, heightmapResolution - 1, false);
                        if (t2Data != null)
                        {
                            // Only fetching and update the edges to improve performance
                            // Get heightmaps from both terrains
                            t1HeightMap = t1Data.GetHeights(0, 0, heightmapResolution, edgeWidth);
                            t2HeightMap = t2Data.GetHeights(0, heightmapResolution - edgeWidth, heightmapResolution, edgeWidth);

                            if (fixCornersOnly)
                            {
                                //Debug.Log("fixCornersOnly bottom worldPosition: " + worldPosition.ToString());

                                for (t1X = heightmapResolution - edgeWidth - 1; t1X < heightmapResolution; t1X++)
                                {
                                    t2HeightMap[edgeWidth - 1, t1X] = t1HeightMap[0, t1X];
                                }
                            }
                            else
                            {
                                //Debug.Log("SMOOTH bottom");
                                // Z axis in worldspace (without any Transform rotation)
                                for (t1X = 0; t1X < heightmapResolution; t1X++)
                                {
                                    for (t1Z = 0; t1Z < edgeWidth; t1Z++)
                                    {
                                        // Get the local terrain height at this point
                                        t1Height = t1HeightMap[t1Z, t1X];

                                        // Get the local terrain height at the edge for this t1X value
                                        if (t1Z == 0) { t1EdgeHeight = t1Height; }

                                        // Get the heightmap coordinates in the adjorning terrain
                                        t2X = t1X;
                                        t2Z = edgeWidth - 1 - t1Z;

                                        // Get the height from the adjoining terrain
                                        t2Height = t2HeightMap[t2Z, t2X];

                                        // TODO - SmoothTerrainEdge improve edge blending
                                        t2HeightMap[t2Z, t2X] = Mathf.Lerp(t1EdgeHeight, t2Height, (float)t1Z / (float)edgeWidth);
                                    }
                                }
                            }
                            // Only update the bottom terrain that has been changed
                            t2Data.SetHeightsDelayLOD(0, heightmapResolution - edgeWidth, t2HeightMap);
                        }
                    }
                }
            }
        }

        #endregion

        #region Static Worldspace Methods

        /// <summary>
        /// Get the Landscape world bounds in world space on the x-axis and z-axis
        /// </summary>
        /// <param name="terrainSize"></param>
        /// <param name="landscapeTerrains"></param>
        /// <returns></returns>
        public static Rect GetLandscapeWorldBounds(Terrain[] landscapeTerrains)
        {
            Rect WorldBounds = new Rect();
            Rect terrainBounds = new Rect();
            Vector3 worldPosition = Vector3.zero;
            Vector3 terrainSize = Vector3.zero;

            for (int t = 0; t < landscapeTerrains.Length; t++)
            {
                worldPosition = landscapeTerrains[t].transform.position;
                terrainSize = landscapeTerrains[t].terrainData.size;

                terrainBounds = Rect.MinMaxRect(worldPosition.x, worldPosition.z, worldPosition.x + terrainSize.x, worldPosition.z + terrainSize.z);

                if (t == 0)
                {
                    WorldBounds = terrainBounds;
                }
                else
                {
                    if (terrainBounds.xMin < WorldBounds.xMin) { WorldBounds.xMin = terrainBounds.xMin; }
                    if (terrainBounds.xMax > WorldBounds.xMax) { WorldBounds.xMax = terrainBounds.xMax; }

                    if (terrainBounds.yMin < WorldBounds.yMin) { WorldBounds.yMin = terrainBounds.yMin; }
                    if (terrainBounds.yMax > WorldBounds.yMax) { WorldBounds.yMax = terrainBounds.yMax; }
                }
            }

            return WorldBounds;
        }

        #endregion

        #region Static Stitching Methods

        /// <summary>
        /// Looks for adjoining terrains and stitches them together
        /// StitchEdgeDistance is the edge distance in metres that will be blended on each landscape
        /// StitchLandscapeWeight is the weight given to each landscape during blending of heights
        ///                       range is 0 to 1 with 0-0.5 favouring the first landscape (default 0)
        /// </summary>
        /// <param name="landscape1"></param>
        /// <param name="landscape2"></param>
        /// <param name="StitchEdgeDistance"></param>
        /// <param name="StitchLandscapeWeight"></param>
        /// <returns></returns>
        public static bool StitchLandscapes(LBLandscape landscape1, LBLandscape landscape2, int StitchEdgeDistance, float StitchLandscapeWeight, bool SetNeighbours = false)
        {
            // First added in v1.2.0
            bool isSuccessful = false;

            // Declare viables
            Terrain[] landscape1Terrains = null;
            Terrain[] landscape2Terrains = null;
            Terrain l1Terrain = null;
            Rect landscape1WorldBounds = new Rect();
            Rect landscape2WorldBounds = new Rect();
            Rect checkAdjoinRect = new Rect();
            Rect checkNeighbourRect = new Rect();
            Vector3 l1TerrainWorldPosition = Vector3.zero;
            Rect l1TerrainBounds = new Rect();
            Vector3 l1TerrainSize = Vector3.zero;
            bool terrainStitchingErrors = false;

            //float stitchStartTime = Time.realtimeSinceStartup;

            // Perform some validation
            if (landscape1 == null || landscape2 == null)
            {
                Debug.LogError("StitchLandscapes - no landscapes to stitch");
            }
            else if (landscape1.gameObject == null)
            {
                Debug.LogError("StitchLandscapes - landscape1 does not have a parent gameobject");
            }
            else if (landscape2.gameObject == null)
            {
                Debug.LogError("StitchLandscapes - landscape2 does not have a parent gameobject");
            }
            else
            {
                landscape1Terrains = landscape1.GetComponentsInChildren<Terrain>();
                landscape2Terrains = landscape2.GetComponentsInChildren<Terrain>();
                if (landscape1Terrains == null)
                {
                    Debug.LogError("StitchLandscapes - no terrains are children of the " + landscape1.gameObject.name + " gameobject");
                }
                else if (landscape1Terrains.Length == 0)
                {
                    Debug.LogError("StitchLandscapes - no terrains are children of the " + landscape1.gameObject.name + " gameobject");
                }
                if (landscape2Terrains == null)
                {
                    Debug.LogError("StitchLandscapes - no terrains are children of the " + landscape2.gameObject.name + " gameobject");
                }
                else if (landscape2Terrains.Length == 0)
                {
                    Debug.LogError("StitchLandscapes - no terrains are children of the " + landscape2.gameObject.name + " gameobject");
                }
                else
                {
                    // Get the bounds in world space (on x-z plane) for both landscapes
                    landscape1WorldBounds = LBLandscapeTerrain.GetLandscapeWorldBounds(landscape1Terrains);
                    landscape2WorldBounds = LBLandscapeTerrain.GetLandscapeWorldBounds(landscape2Terrains);

                    // Rect to determine if there are adjoining borders on the x-z plane
                    checkAdjoinRect.xMin = landscape1WorldBounds.xMin - 1f;
                    checkAdjoinRect.xMax = landscape1WorldBounds.xMax + 1f;
                    checkAdjoinRect.yMin = landscape1WorldBounds.yMin - 1f;
                    checkAdjoinRect.yMax = landscape1WorldBounds.yMax + 1f;

                    if (!checkAdjoinRect.Overlaps(landscape2WorldBounds))
                    {
                        Debug.LogError("StitchLandscapes - the landscapes do not adjoin each other. " + landscape1.name + " " + landscape1WorldBounds.ToString() + " " + landscape2.name + " " + landscape2WorldBounds.ToString());
                    }
                    else if (landscape1WorldBounds.Overlaps(landscape2WorldBounds))
                    {
                        Debug.LogError("StitchLandscapes - the landscapes overlap each other. " + landscape1.name + " " + landscape1WorldBounds.ToString() + " " + landscape2.name + " " + landscape2WorldBounds.ToString());
                    }
                    else if (landscape1.transform.rotation != landscape2.transform.rotation)
                    {
                        Debug.LogError("StitchLandscapes - the landscapes do not have the same rotation in world space.");
                    }
                    else
                    {
                        // Loop throught the first landscape
                        for (int l1t = 0; l1t < landscape1Terrains.Length; l1t++)
                        {
                            l1Terrain = landscape1Terrains[l1t];

                            l1TerrainWorldPosition = l1Terrain.transform.position;
                            l1TerrainSize = l1Terrain.terrainData.size;
                            l1TerrainBounds = Rect.MinMaxRect(l1TerrainWorldPosition.x, l1TerrainWorldPosition.z, l1TerrainWorldPosition.x + l1TerrainSize.x, l1TerrainWorldPosition.z + l1TerrainSize.z);

                            // Only consider terrains that are one of the edges of the first landscape
                            if (l1TerrainBounds.xMin == landscape1WorldBounds.xMin || l1TerrainBounds.xMax == landscape1WorldBounds.xMax ||
                                l1TerrainBounds.yMin == landscape1WorldBounds.yMin || l1TerrainBounds.yMax == landscape1WorldBounds.yMax)
                            {
                                // Is this the top edge of the terrain?
                                if (l1TerrainBounds.yMax == landscape1WorldBounds.yMax)
                                {
                                    // could join on the top edge
                                    checkNeighbourRect = new Rect(l1TerrainBounds.xMin, l1TerrainBounds.yMax, l1TerrainBounds.width, 2f);
                                    if (landscape2WorldBounds.Overlaps(checkNeighbourRect))
                                    {
                                        // Stitch this terrain to the second landscape. Exit out if something goes wrong
                                        if (!StitchTerrainEdge(landscape1, landscape2, l1Terrain, "TOP", l1TerrainBounds,
                                            landscape2Terrains, StitchEdgeDistance, StitchLandscapeWeight, SetNeighbours)) { terrainStitchingErrors = true; break; }
                                    }
                                }

                                // Is this the right edge terrain?
                                if (l1TerrainBounds.xMax == landscape1WorldBounds.xMax)
                                {
                                    // could join on the right edge
                                    checkNeighbourRect = new Rect(l1TerrainBounds.xMax, l1TerrainBounds.yMin, 2f, l1TerrainBounds.height);
                                    if (landscape2WorldBounds.Overlaps(checkNeighbourRect))
                                    {
                                        // Stitch this terrain to the second landscape. Exit out if something goes wrong
                                        if (!StitchTerrainEdge(landscape1, landscape2, l1Terrain, "RIGHT", l1TerrainBounds,
                                            landscape2Terrains, StitchEdgeDistance, StitchLandscapeWeight, SetNeighbours)) { terrainStitchingErrors = true; break; }
                                    }
                                }

                                // Is this terrain on the left edge of the landscape?
                                if (l1TerrainBounds.xMin == landscape1WorldBounds.xMin)
                                {
                                    // could join on the left edge
                                    checkNeighbourRect = new Rect(l1TerrainBounds.xMin - 1f, l1TerrainBounds.yMin, 2f, l1TerrainBounds.height);
                                    if (landscape2WorldBounds.Overlaps(checkNeighbourRect))
                                    {
                                        // Stitch this terrain to the second landscape. Exit out if something goes wrong
                                        if (!StitchTerrainEdge(landscape1, landscape2, l1Terrain, "LEFT", l1TerrainBounds,
                                            landscape2Terrains, StitchEdgeDistance, StitchLandscapeWeight, SetNeighbours)) { terrainStitchingErrors = true; break; }
                                    }
                                }

                                if (l1TerrainBounds.yMin == landscape1WorldBounds.yMin)
                                {
                                    // could join on the bottom edge
                                    checkNeighbourRect = new Rect(l1TerrainBounds.xMin, l1TerrainBounds.yMin - 1f, l1TerrainBounds.width, 2f);
                                    if (landscape2WorldBounds.Overlaps(checkNeighbourRect))
                                    {
                                        // Stitch this terrain to the second landscape. Exit out if something goes wrong
                                        if (!StitchTerrainEdge(landscape1, landscape2, l1Terrain, "BOTTOM", l1TerrainBounds,
                                            landscape2Terrains, StitchEdgeDistance, StitchLandscapeWeight, SetNeighbours)) { terrainStitchingErrors = true; break; }
                                    }
                                }
                            }
                        }

                        isSuccessful = !terrainStitchingErrors;

                        if (isSuccessful)
                        {
                            ApplyDelayedHeightmapLOD(landscape1Terrains);
                            ApplyDelayedHeightmapLOD(landscape2Terrains);
                        }
                    }
                }
            }

            //Debug.Log("stitch duration: " + (Time.realtimeSinceStartup - stitchStartTime).ToString() + " secs");

            return isSuccessful;
        }

        /// <summary>
        /// Stitch a terrain to the Landscape along it's top, right, left or bottom edge
        /// The adjoining Landscape may have multiple (equal sized) terrains
        /// </summary>
        /// <param name="landscape1"></param>
        /// <param name="landscape2"></param>
        /// <param name="terrain1"></param>
        /// <param name="terrain1Edge"></param>
        /// <param name="terrain1Bounds"></param>
        /// <param name="stitchToTerrains"></param>
        /// <param name="StitchEdgeDistanceInMetres"></param>
        /// <param name="StitchLandscapeWeight"></param>
        /// <returns></returns>
        public static bool StitchTerrainEdge(LBLandscape landscape1, LBLandscape landscape2, Terrain terrain1, string terrain1Edge, Rect terrain1Bounds,
                                             Terrain[] stitchToTerrains, int StitchEdgeDistanceInMetres, float StitchLandscapeWeight, bool SetNeighbours)
        {
            // Define local variables
            bool isSuccessful = false;
            string[] edgeTypes = { "TOP", "RIGHT", "LEFT", "BOTTOM" };
            int t1Z = 0, t1X = 0;
            int t1EdgeOffset = 0;
            int t1HeightmapResolution = 0, t2HeightmapResolution = 0;
            int lastT2 = -1, t2Match = -2;  // These values must be -ve and different
            float terrainDistanceSquare = Mathf.Infinity, tdistancesq = 0f;
            float[,] t1HeightMap, t2HeightMap = new float[1, 1];
            float t1Height = 0f;
            float t1EdgeHeight = 0f;
            float t1t2WorldPosHeightOffset = 0f;
            Vector3 t1HeightmapScale = Vector3.zero;
            Vector3 t1WorldPos = Vector3.zero, t2WorldPos = Vector3.zero;
            Vector3 t1WorldEdgePos = Vector3.zero, t2WorldEdgePos = Vector3.zero;
            Vector3 l2TerrainWorldPosition = Vector3.zero;
            Vector3 l2TerrainSize = Vector3.zero;
            Rect l2TerrainBounds = new Rect();
            Rect l2TerrainBoundsExpand = new Rect();  // The Unity Rect.Contains() method excludes the top and right boundaries. This corrects that issue.
            float boundsExpansion = 0.005f;

            int edgeWidth = 0;   // This is the edge width in heightmap points (not world space metres)

            terrain1Edge = terrain1Edge.ToUpper();

            // Validate the parameters
            if (terrain1 == null)
            {
                Debug.LogError("StitchTerrainEdge - the terrain is null");
            }
            else if (!edgeTypes.Contains(terrain1Edge))
            {
                Debug.LogError("StitchTerrainEdge - " + terrain1Edge + " is not a defined edge type");
            }
            else if (stitchToTerrains == null)
            {
                Debug.LogError("StitchTerrainEdge - stitchToTerrains is null");
            }
            else if (stitchToTerrains.Length == 0)
            {
                Debug.LogError("StitchTerrainEdge - stitchToTerrains does not contain any terrain");
            }
            else if (StitchEdgeDistanceInMetres < 1)
            {
                Debug.LogError("StitchTerrainEdge - StitchEdgeDistance cannot be less than 1 metre");
            }
            // Check for a edge size greater than the size of the terrain
            else if (StitchEdgeDistanceInMetres > Mathf.RoundToInt(terrain1.terrainData.size.x) ||
                     StitchEdgeDistanceInMetres > Mathf.RoundToInt(terrain1.terrainData.size.z))
            {
                Debug.LogError("StitchTerrainEdge - StitchEdgeDistance cannot be greater than " + Mathf.Min(terrain1.terrainData.size.x, terrain1.terrainData.size.z).ToString());
            }
            else
            {
                // Height Resolution includes extra space for some metadata.
                // Resolutions are 513, 1025, 2049 etc
                t1HeightmapResolution = terrain1.terrainData.heightmapResolution;
                t1HeightmapScale = terrain1.terrainData.heightmapScale;

                // Convert the StitchEdgeDistanceInMetres into heightmap distance - this is an approximation
                edgeWidth = Mathf.RoundToInt((float)StitchEdgeDistanceInMetres / t1HeightmapScale.x);

                t1HeightMap = terrain1.terrainData.GetHeights(0, 0, t1HeightmapResolution, t1HeightmapResolution);

                // Stitching will happen from the edge and continue away from the edge
                if (terrain1Edge == "LEFT" || terrain1Edge == "RIGHT")
                {
                    // Loop through heightmap points in the Terrain1            

                    // Z axis in worldspace (without any Transform rotation)
                    for (t1Z = 0; t1Z < t1HeightmapResolution; t1Z++)
                    {
                        // This applies to the second landscape being on the left of Terrain1
                        if (terrain1Edge == "LEFT")
                        {
                            for (t1X = 0; t1X < edgeWidth; t1X++)
                            {
                                // Get the local terrain height at this point
                                t1Height = t1HeightMap[t1Z, t1X];

                                // Get the world-space position of terrain1 position
                                t1WorldPos.x = (t1HeightmapScale.x * t1X) + terrain1Bounds.xMin;
                                t1WorldPos.z = (t1HeightmapScale.z * t1Z) + terrain1Bounds.yMin;
                                t1WorldPos.y = (t1HeightmapScale.y * t1Height) + terrain1.transform.position.y;

                                // Get the terrain heights and positions
                                if (t1X == 0)
                                {
                                    // Get the local terrain height at the edge for this t1Y value
                                    // It will get modified in StitchAdjustHeights() so can't reference in t1HeightMap again,
                                    // because the updated value may be different
                                    t1EdgeHeight = t1Height;

                                    // Get the world-space position of terrain1 edge position
                                    t1WorldEdgePos.x = terrain1Bounds.xMin;
                                    t1WorldEdgePos.z = t1WorldPos.z;
                                    t1WorldEdgePos.y = (t1HeightmapScale.y * t1EdgeHeight) + terrain1.transform.position.y;

                                    // Get the corresponding edge point in world space in the adjoining landscape
                                    t2WorldEdgePos = new Vector3(terrain1Bounds.xMin, 0f, t1WorldPos.z);
                                }

                                // How far away from the edge of the terrain is this point?
                                t1EdgeOffset = t1X;

                                // Get the corresponding point in world space in the adjoining landscape
                                t2WorldPos = new Vector3(terrain1Bounds.xMin - ((float)t1EdgeOffset * t1HeightmapScale.z), 0f, t1WorldPos.z);

                                // Update variables that will be used when searching through the adjoining landscape
                                coords.x = t2WorldPos.x;
                                coords.y = t2WorldPos.z;
                                t2Match = -2; // Initialise to a -ve value not the same as intialised lastT2
                                terrainDistanceSquare = Mathf.Infinity;
                                tdistancesq = 0f;

                                // Find which terrain in the adjoining landscape shares this common edge
                                for (int t2 = 0; t2 < stitchToTerrains.Length; t2++)
                                {
                                    l2TerrainWorldPosition = stitchToTerrains[t2].transform.position;
                                    l2TerrainSize = stitchToTerrains[t2].terrainData.size;
                                    l2TerrainBounds = Rect.MinMaxRect(l2TerrainWorldPosition.x, l2TerrainWorldPosition.z, l2TerrainWorldPosition.x + l2TerrainSize.x, l2TerrainWorldPosition.z + l2TerrainSize.z);

                                    // Expand top and right boarders slightly to overcome issue with Rect.Contains()
                                    l2TerrainBoundsExpand = new Rect(l2TerrainBounds.xMin, l2TerrainBounds.yMin, l2TerrainBounds.width + boundsExpansion, l2TerrainBounds.height + boundsExpansion);

                                    // Is this on the bottom or top edge of a terrain?
                                    if ((t1Z == 0 || t1Z == t1HeightmapResolution - 1) && (l2TerrainBoundsExpand.Contains(coords)))
                                    {
                                        // Compare distances between terrain1 and potential adjoining terrain
                                        // If there are two "matches" then this helps to determine which one is correct
                                        tdistancesq = DistanceBetweenTerrainOriginsSquared(ref terrain1Bounds, l2TerrainBounds);
                                        if (tdistancesq < terrainDistanceSquare)
                                        {
                                            terrainDistanceSquare = tdistancesq;
                                            t2Match = t2;
                                        }
                                    }
                                    // Is this point in this adjoining terrain?
                                    else if (l2TerrainBoundsExpand.Contains(coords))
                                    {
                                        t2Match = t2;
                                        break;
                                    }
                                }

                                if (t2Match >= 0)
                                {
                                    // To be more efficient, could get and update just the edge of the heightmap as updates are
                                    // relatively slow and consume most of the processing time of the stitching tool
                                    if (t2Match != lastT2)
                                    {
                                        // Do we need to update the terrain data?
                                        if (lastT2 >= 0 && t2HeightMap != null)
                                        {
                                            // Update the last used terrain heightmap in the adjoining landscape
                                            stitchToTerrains[lastT2].terrainData.SetHeightsDelayLOD(0, 0, t2HeightMap);
                                            t2HeightMap = null;
                                        }

                                        // Get the heightmap for the current terrain being updated in the adjoining landscape
                                        t2HeightMap = stitchToTerrains[t2Match].terrainData.GetHeights(0, 0, stitchToTerrains[t2Match].terrainData.heightmapResolution, stitchToTerrains[t2Match].terrainData.heightmapResolution);

                                        // Ensure LOD matches between adjoining terrains
                                        if (SetNeighbours) { UpdateNeighbours(landscape1, landscape2, terrain1, stitchToTerrains[t2Match], terrain1Edge); }

                                        lastT2 = t2Match;
                                    }

                                    // Get the height offset in Worldspace between the two terrains
                                    t1t2WorldPosHeightOffset = terrain1.transform.position.y - stitchToTerrains[t2Match].transform.position.y;

                                    // If this is an edge, we may need to update some variables
                                    if ((t1Z == 0 || t1Z == t1HeightmapResolution - 1))
                                    {
                                        t2HeightmapResolution = stitchToTerrains[t2Match].terrainData.heightmapResolution;
                                        l2TerrainWorldPosition = stitchToTerrains[t2Match].transform.position;
                                        l2TerrainSize = stitchToTerrains[t2Match].terrainData.size;
                                        l2TerrainBounds = Rect.MinMaxRect(l2TerrainWorldPosition.x, l2TerrainWorldPosition.z, l2TerrainWorldPosition.x + l2TerrainSize.x, l2TerrainWorldPosition.z + l2TerrainSize.z);
                                    }

                                    StitchAdjustHeights(stitchToTerrains[t2Match].terrainData, t1Z, t1X, t1EdgeHeight, t1EdgeOffset, t1HeightmapScale, t1HeightMap, t2HeightMap, t1Height,
                                                            t1t2WorldPosHeightOffset, t2WorldPos, t2WorldEdgePos, edgeWidth, l2TerrainWorldPosition, l2TerrainSize, t2HeightmapResolution, StitchLandscapeWeight);
                                }
                            }
                        }
                        // This applies to the second landscape being on the right of Terrain1
                        else
                        {
                            // x-axis in world space
                            for (t1X = t1HeightmapResolution - 1; t1X > t1HeightmapResolution - edgeWidth; t1X--)
                            {
                                // Get the local terrain height
                                t1Height = t1HeightMap[t1Z, t1X];

                                // Find the world-space coordinates of terrain1 position
                                t1WorldPos.x = (t1HeightmapScale.x * t1X) + terrain1Bounds.xMin;
                                t1WorldPos.z = (t1HeightmapScale.z * t1Z) + terrain1Bounds.yMin;
                                t1WorldPos.y = (t1HeightmapScale.y * t1Height) + terrain1.transform.position.y;

                                // Get the terrain heights and positions
                                if (t1X == t1HeightmapResolution - 1)
                                {
                                    // Get the local terrain height at the edge for this t1Y value
                                    // It will get modified in StitchAdjustHeights() so can't reference in t1HeightMap again,
                                    // because the updated value may be different
                                    t1EdgeHeight = t1Height;

                                    // Get the world-space position of terrain1 edge position
                                    t1WorldEdgePos.x = terrain1Bounds.xMax;
                                    t1WorldEdgePos.z = t1WorldPos.z;
                                    t1WorldEdgePos.y = (t1HeightmapScale.y * t1EdgeHeight) + terrain1.transform.position.y;

                                    // Get the corresponding edge point in world space in the adjoining landscape
                                    t2WorldEdgePos = new Vector3(terrain1Bounds.xMax, 0f, t1WorldPos.z);
                                }

                                // How far away from the edge of the terrain is this point?
                                t1EdgeOffset = t1HeightmapResolution - 1 - t1X;

                                // Get the corresponding point in world space in the adjoining landscape
                                t2WorldPos = new Vector3(terrain1Bounds.xMax + ((float)t1EdgeOffset * t1HeightmapScale.z), 0f, t1WorldPos.z);

                                // Update variables that will be used when searching through the adjoining landscape
                                coords.x = t2WorldPos.x;
                                coords.y = t2WorldPos.z;
                                t2Match = -2; // Initialise to a -ve value not the same as intialised lastT2
                                terrainDistanceSquare = Mathf.Infinity;
                                tdistancesq = 0f;

                                // Find which terrain in the adjoining landscape shares this common edge
                                for (int t2 = 0; t2 < stitchToTerrains.Length; t2++)
                                {
                                    l2TerrainWorldPosition = stitchToTerrains[t2].transform.position;
                                    l2TerrainSize = stitchToTerrains[t2].terrainData.size;
                                    l2TerrainBounds = Rect.MinMaxRect(l2TerrainWorldPosition.x, l2TerrainWorldPosition.z, l2TerrainWorldPosition.x + l2TerrainSize.x, l2TerrainWorldPosition.z + l2TerrainSize.z);

                                    // Expand top and right boarders slightly to overcome issue with Rect.Contains()
                                    l2TerrainBoundsExpand = new Rect(l2TerrainBounds.xMin, l2TerrainBounds.yMin, l2TerrainBounds.width + boundsExpansion, l2TerrainBounds.height + boundsExpansion);

                                    // Is this on the bottom or top edge of a terrain?
                                    if ((t1Z == 0 || t1Z == t1HeightmapResolution - 1) && (l2TerrainBoundsExpand.Contains(coords)))
                                    {
                                        // Compare distances between terrain1 and potential adjoining terrain
                                        // If there are two "matches" then this helps to determine which one is correct
                                        tdistancesq = DistanceBetweenTerrainOriginsSquared(ref terrain1Bounds, l2TerrainBounds);
                                        if (tdistancesq < terrainDistanceSquare)
                                        {
                                            terrainDistanceSquare = tdistancesq;
                                            t2Match = t2;
                                        }
                                    }
                                    // Is this point in this adjoining terrain?
                                    else if (l2TerrainBoundsExpand.Contains(coords))
                                    {
                                        t2Match = t2;
                                        break;
                                    }
                                }

                                if (t2Match >= 0)
                                {
                                    // To be more efficient, could get and update just the edge of the heightmap as updates are
                                    // relatively slow and consume most of the processing time of the stitching tool
                                    if (t2Match != lastT2)
                                    {
                                        // Do we need to update the terrain data?
                                        if (lastT2 >= 0 && t2HeightMap != null)
                                        {
                                            // Update the last used terrain heightmap in the adjoining landscape
                                            stitchToTerrains[lastT2].terrainData.SetHeightsDelayLOD(0, 0, t2HeightMap);
                                            t2HeightMap = null;
                                        }

                                        // Get the heightmap for the current terrain being updated in the adjoining landscape
                                        t2HeightMap = stitchToTerrains[t2Match].terrainData.GetHeights(0, 0, stitchToTerrains[t2Match].terrainData.heightmapResolution, stitchToTerrains[t2Match].terrainData.heightmapResolution);

                                        // Ensure LOD matches between adjoining terrains
                                        if (SetNeighbours) { UpdateNeighbours(landscape1, landscape2, terrain1, stitchToTerrains[t2Match], terrain1Edge); }

                                        lastT2 = t2Match;
                                    }

                                    // Get the height offset in Worldspace between the two terrains
                                    t1t2WorldPosHeightOffset = terrain1.transform.position.y - stitchToTerrains[t2Match].transform.position.y;

                                    // If this is an edge, we may need to update some variables
                                    if ((t1Z == 0 || t1Z == t1HeightmapResolution - 1))
                                    {
                                        t2HeightmapResolution = stitchToTerrains[t2Match].terrainData.heightmapResolution;
                                        l2TerrainWorldPosition = stitchToTerrains[t2Match].transform.position;
                                        l2TerrainSize = stitchToTerrains[t2Match].terrainData.size;
                                        l2TerrainBounds = Rect.MinMaxRect(l2TerrainWorldPosition.x, l2TerrainWorldPosition.z, l2TerrainWorldPosition.x + l2TerrainSize.x, l2TerrainWorldPosition.z + l2TerrainSize.z);
                                    }

                                    StitchAdjustHeights(stitchToTerrains[t2Match].terrainData, t1Z, t1X, t1EdgeHeight, t1EdgeOffset, t1HeightmapScale, t1HeightMap, t2HeightMap, t1Height,
                                                            t1t2WorldPosHeightOffset, t2WorldPos, t2WorldEdgePos, edgeWidth, l2TerrainWorldPosition, l2TerrainSize, t2HeightmapResolution, StitchLandscapeWeight);
                                }
                            }
                        }
                    }

                    // Check to see if we updated the last used heightmap from the adjoining landscape
                    if (lastT2 >= 0 && t2HeightMap != null)
                    {
                        // Update the last used terrain heightmap in the adjoining landscape
                        stitchToTerrains[lastT2].terrainData.SetHeightsDelayLOD(0, 0, t2HeightMap);
                        t2HeightMap = null;
                    }

                    // Update the heightmap in the first landscape
                    terrain1.terrainData.SetHeights(0, 0, t1HeightMap);
                    isSuccessful = true;
                }
                // TOP OR BOTTOM
                else
                {
                    // Loop through heightmap points in the Terrain1

                    // X direction in worldspace (without any Transform rotation)
                    for (t1X = 0; t1X < t1HeightmapResolution; t1X++)
                    {
                        // This applies to the second landscape being on the top of Terrain1
                        if (terrain1Edge == "BOTTOM")
                        {
                            // loop through z-axis (same direction as worldspace z-axis)
                            for (t1Z = 0; t1Z < edgeWidth; t1Z++)
                            {
                                // Get the local terrain height
                                t1Height = t1HeightMap[t1Z, t1X];

                                // Find the world-space coordinates of terrain1 position
                                t1WorldPos.x = (t1HeightmapScale.x * t1X) + terrain1Bounds.xMin;
                                t1WorldPos.z = (t1HeightmapScale.z * t1Z) + terrain1Bounds.yMin;
                                t1WorldPos.y = (t1HeightmapScale.y * t1Height) + terrain1.transform.position.y;

                                // Get the terrain heights and positions
                                if (t1Z == 0)
                                {
                                    // Get the local terrain height at the edge for this t1Y value
                                    // It will get modified in StitchAdjustHeights() so can't reference in t1HeightMap again,
                                    // because the updated value may be different
                                    t1EdgeHeight = t1Height;

                                    // Get the world-space position of terrain1 edge position
                                    t1WorldEdgePos.x = t1WorldPos.x;
                                    t1WorldEdgePos.z = terrain1Bounds.yMin;
                                    t1WorldEdgePos.y = (t1HeightmapScale.y * t1EdgeHeight) + terrain1.transform.position.y;

                                    // Get the corresponding edge point in world space in the adjoining landscape
                                    t2WorldEdgePos = new Vector3(t1WorldPos.x, 0f, terrain1Bounds.yMin);
                                }

                                // How far away from the edge of the terrain is this point?
                                t1EdgeOffset = t1Z;

                                // Get the corresponding point in world space in the adjoining landscape
                                t2WorldPos = new Vector3(t1WorldPos.x, 0f, terrain1Bounds.yMin - ((float)t1EdgeOffset * t1HeightmapScale.x));

                                // Update variables that will be used when searching through the adjoining landscape
                                coords.x = t2WorldPos.x;
                                coords.y = t2WorldPos.z;
                                t2Match = -2; // Initialise to a -ve value not the same as intialised lastT2
                                terrainDistanceSquare = Mathf.Infinity;
                                tdistancesq = 0f;

                                // Find which terrain in the adjoining landscape shares this common edge
                                for (int t2 = 0; t2 < stitchToTerrains.Length; t2++)
                                {
                                    l2TerrainWorldPosition = stitchToTerrains[t2].transform.position;
                                    l2TerrainSize = stitchToTerrains[t2].terrainData.size;
                                    l2TerrainBounds = Rect.MinMaxRect(l2TerrainWorldPosition.x, l2TerrainWorldPosition.z, l2TerrainWorldPosition.x + l2TerrainSize.x, l2TerrainWorldPosition.z + l2TerrainSize.z);

                                    // Expand top and right boarders slightly to overcome issue with Rect.Contains()
                                    l2TerrainBoundsExpand = new Rect(l2TerrainBounds.xMin, l2TerrainBounds.yMin, l2TerrainBounds.width + boundsExpansion, l2TerrainBounds.height + boundsExpansion);

                                    // Is this on the bottom or top edge of a terrain?
                                    if ((t1X == 0 || t1X == t1HeightmapResolution - 1) && (l2TerrainBoundsExpand.Contains(coords)))
                                    {
                                        // Compare distances between terrain1 and potential adjoining terrain
                                        // If there are two "matches" then this helps to determine which one is correct
                                        tdistancesq = DistanceBetweenTerrainOriginsSquared(ref terrain1Bounds, l2TerrainBounds);
                                        if (tdistancesq < terrainDistanceSquare)
                                        {
                                            terrainDistanceSquare = tdistancesq;
                                            t2Match = t2;
                                        }
                                    }
                                    // Is this point in this adjoining terrain?
                                    else if (l2TerrainBoundsExpand.Contains(coords))
                                    {
                                        t2Match = t2;
                                        break;
                                    }
                                }

                                if (t2Match >= 0)
                                {
                                    // To be more efficient, could get and update just the edge of the heightmap as updates are
                                    // relatively slow and consume most of the processing time of the stitching tool
                                    if (t2Match != lastT2)
                                    {
                                        // Do we need to update the terrain data?
                                        if (lastT2 >= 0 && t2HeightMap != null)
                                        {
                                            // Update the last used terrain heightmap in the adjoining landscape
                                            stitchToTerrains[lastT2].terrainData.SetHeightsDelayLOD(0, 0, t2HeightMap);
                                            t2HeightMap = null;
                                        }

                                        // Get the heightmap for the current terrain being updated in the adjoining landscape
                                        t2HeightMap = stitchToTerrains[t2Match].terrainData.GetHeights(0, 0, stitchToTerrains[t2Match].terrainData.heightmapResolution, stitchToTerrains[t2Match].terrainData.heightmapResolution);

                                        // Ensure LOD matches between adjoining terrains
                                        if (SetNeighbours) { UpdateNeighbours(landscape1, landscape2, terrain1, stitchToTerrains[t2Match], terrain1Edge); }

                                        lastT2 = t2Match;
                                    }

                                    // Get the height offset in Worldspace between the two terrains
                                    t1t2WorldPosHeightOffset = terrain1.transform.position.y - stitchToTerrains[t2Match].transform.position.y;

                                    // If this is an edge, we may need to update some variables
                                    if ((t1X == 0 || t1X == t1HeightmapResolution - 1))
                                    {
                                        t2HeightmapResolution = stitchToTerrains[t2Match].terrainData.heightmapResolution;
                                        l2TerrainWorldPosition = stitchToTerrains[t2Match].transform.position;
                                        l2TerrainSize = stitchToTerrains[t2Match].terrainData.size;
                                        l2TerrainBounds = Rect.MinMaxRect(l2TerrainWorldPosition.x, l2TerrainWorldPosition.z, l2TerrainWorldPosition.x + l2TerrainSize.x, l2TerrainWorldPosition.z + l2TerrainSize.z);
                                    }

                                    StitchAdjustHeights(stitchToTerrains[t2Match].terrainData, t1Z, t1X, t1EdgeHeight, t1EdgeOffset, t1HeightmapScale, t1HeightMap, t2HeightMap, t1Height,
                                                            t1t2WorldPosHeightOffset, t2WorldPos, t2WorldEdgePos, edgeWidth, l2TerrainWorldPosition, l2TerrainSize, t2HeightmapResolution, StitchLandscapeWeight);
                                }
                            }
                        }
                        // TOP - This applies to the second landscape being on the bottom of Terrain1
                        else
                        {
                            // Loop through z-axis in terrain data (which is also the z-axis in world space)
                            for (t1Z = t1HeightmapResolution - 1; t1Z > t1HeightmapResolution - edgeWidth; t1Z--)
                            {
                                // Get the local terrain height
                                t1Height = t1HeightMap[t1Z, t1X];

                                // Find the world-space coordinates of terrain1 position
                                t1WorldPos.x = (t1HeightmapScale.x * t1X) + terrain1Bounds.xMin;
                                t1WorldPos.z = (t1HeightmapScale.z * t1Z) + terrain1Bounds.yMin;
                                t1WorldPos.y = (t1HeightmapScale.y * t1Height) + terrain1.transform.position.y;

                                // Get the terrain heights and positions
                                if (t1Z == t1HeightmapResolution - 1)
                                {
                                    // Get the local terrain height at the edge for this t1Y value
                                    // It will get modified in StitchAdjustHeights() so can't reference in t1HeightMap again,
                                    // because the updated value may be different
                                    t1EdgeHeight = t1Height;

                                    // Get the world-space position of terrain1 edge position
                                    t1WorldEdgePos.x = t1WorldPos.x;
                                    t1WorldEdgePos.z = terrain1Bounds.yMax;
                                    t1WorldEdgePos.y = (t1HeightmapScale.y * t1EdgeHeight) + terrain1.transform.position.y;

                                    // Get the corresponding edge point in world space in the adjoining landscape
                                    t2WorldEdgePos = new Vector3(t1WorldPos.x, 0f, terrain1Bounds.yMax);
                                }

                                // How far away from the edge of the terrain is this point?
                                t1EdgeOffset = t1HeightmapResolution - 1 - t1Z;

                                // Get the corresponding point in world space in the adjoining landscape
                                t2WorldPos = new Vector3(t1WorldPos.x, 0f, terrain1Bounds.yMax + ((float)t1EdgeOffset * t1HeightmapScale.x));

                                // Update variables that will be used when searching through the adjoining landscape
                                coords.x = t2WorldPos.x;
                                coords.y = t2WorldPos.z;
                                t2Match = -2; // Initialise to a -ve value not the same as intialised lastT2
                                terrainDistanceSquare = Mathf.Infinity;
                                tdistancesq = 0f;

                                // Find which terrain in the adjoining landscape shares this common edge
                                for (int t2 = 0; t2 < stitchToTerrains.Length; t2++)
                                {
                                    l2TerrainWorldPosition = stitchToTerrains[t2].transform.position;
                                    l2TerrainSize = stitchToTerrains[t2].terrainData.size;
                                    l2TerrainBounds = Rect.MinMaxRect(l2TerrainWorldPosition.x, l2TerrainWorldPosition.z, l2TerrainWorldPosition.x + l2TerrainSize.x, l2TerrainWorldPosition.z + l2TerrainSize.z);

                                    // Expand top and right boarders slightly to overcome issue with Rect.Contains()
                                    l2TerrainBoundsExpand = new Rect(l2TerrainBounds.xMin, l2TerrainBounds.yMin, l2TerrainBounds.width + boundsExpansion, l2TerrainBounds.height + boundsExpansion);

                                    // Is this on the bottom or top edge of a terrain?
                                    if ((t1X == 0 || t1X == t1HeightmapResolution - 1) && (l2TerrainBoundsExpand.Contains(coords)))
                                    {
                                        // Compare distances between terrain1 and potential adjoining terrain
                                        // If there are two "matches" then this helps to determine which one is correct
                                        tdistancesq = DistanceBetweenTerrainOriginsSquared(ref terrain1Bounds, l2TerrainBounds);
                                        if (tdistancesq < terrainDistanceSquare)
                                        {
                                            terrainDistanceSquare = tdistancesq;
                                            t2Match = t2;
                                        }
                                    }
                                    // Is this point in this adjoining terrain?
                                    else if (l2TerrainBoundsExpand.Contains(coords))
                                    {
                                        t2Match = t2;
                                        break;
                                    }
                                }

                                if (t2Match >= 0)
                                {
                                    // To be more efficient, could get and update just the edge of the heightmap as updates are
                                    // relatively slow and consume most of the processing time of the stitching tool
                                    if (t2Match != lastT2)
                                    {
                                        // Do we need to update the terrain data?
                                        if (lastT2 >= 0 && t2HeightMap != null)
                                        {
                                            // Update the last used terrain heightmap in the adjoining landscape
                                            stitchToTerrains[lastT2].terrainData.SetHeightsDelayLOD(0, 0, t2HeightMap);
                                            t2HeightMap = null;
                                        }

                                        // Get the heightmap for the current terrain being updated in the adjoining landscape
                                        t2HeightMap = stitchToTerrains[t2Match].terrainData.GetHeights(0, 0, stitchToTerrains[t2Match].terrainData.heightmapResolution, stitchToTerrains[t2Match].terrainData.heightmapResolution);

                                        // Ensure LOD matches between adjoining terrains
                                        if (SetNeighbours) { UpdateNeighbours(landscape1, landscape2, terrain1, stitchToTerrains[t2Match], terrain1Edge); }

                                        lastT2 = t2Match;
                                    }

                                    // Get the height offset in Worldspace between the two terrains
                                    t1t2WorldPosHeightOffset = terrain1.transform.position.y - stitchToTerrains[t2Match].transform.position.y;

                                    // If this is an edge, we may need to update some variables
                                    if ((t1X == 0 || t1X == t1HeightmapResolution - 1))
                                    {
                                        t2HeightmapResolution = stitchToTerrains[t2Match].terrainData.heightmapResolution;
                                        l2TerrainWorldPosition = stitchToTerrains[t2Match].transform.position;
                                        l2TerrainSize = stitchToTerrains[t2Match].terrainData.size;
                                        l2TerrainBounds = Rect.MinMaxRect(l2TerrainWorldPosition.x, l2TerrainWorldPosition.z, l2TerrainWorldPosition.x + l2TerrainSize.x, l2TerrainWorldPosition.z + l2TerrainSize.z);
                                    }

                                    StitchAdjustHeights(stitchToTerrains[t2Match].terrainData, t1Z, t1X, t1EdgeHeight, t1EdgeOffset, t1HeightmapScale, t1HeightMap, t2HeightMap, t1Height,
                                                            t1t2WorldPosHeightOffset, t2WorldPos, t2WorldEdgePos, edgeWidth, l2TerrainWorldPosition, l2TerrainSize, t2HeightmapResolution, StitchLandscapeWeight);
                                }
                            }
                        }
                    }

                    // Check to see if we updated the last used heightmap from the adjoining landscape
                    if (lastT2 >= 0 && t2HeightMap != null)
                    {
                        // Update the last used terrain heightmap in the adjoining landscape
                        stitchToTerrains[lastT2].terrainData.SetHeightsDelayLOD(0, 0, t2HeightMap);
                        t2HeightMap = null;
                    }

                    // Update the heightmap in the first landscape
                    terrain1.terrainData.SetHeights(0, 0, t1HeightMap);
                    isSuccessful = true;
                }
            }

            return isSuccessful;
        }

        private static float DistanceBetweenTerrainOriginsSquared(ref Rect terrain1Bounds, Rect l2TerrainBounds)
        {
            return ((terrain1Bounds.xMin - l2TerrainBounds.xMin) * (terrain1Bounds.xMin - l2TerrainBounds.xMin)) + ((terrain1Bounds.yMin - l2TerrainBounds.yMin) * (terrain1Bounds.yMin - l2TerrainBounds.yMin));
        }

        /// <summary>
        /// SetNeighbors in adjoining terrains in adjoining landscapes
        /// </summary>
        /// <param name="landscape1"></param>
        /// <param name="landscape2"></param>
        /// <param name="l1Terrain"></param>
        /// <param name="l2Terrain"></param>
        private static void UpdateNeighbours(LBLandscape landscape1, LBLandscape landscape2, Terrain l1Terrain, Terrain l2Terrain, string l1TerrainEdge)
        {
            if (landscape1 != null && landscape2 != null && l1Terrain != null && l2Terrain != null)
            {
                Terrain leftTerrain = null;
                Terrain rightTerrain = null;
                Terrain topTerrain = null;
                Terrain bottomTerrain = null;

                // Get current neighbours for the first terrain in first landscape
                switch (l1TerrainEdge.ToUpper())
                {
                    case "LEFT":
                        leftTerrain = l2Terrain;
                        rightTerrain = landscape1.GetTerrainNeighbour(l1Terrain, "RIGHT");
                        topTerrain = landscape1.GetTerrainNeighbour(l1Terrain, "TOP");
                        bottomTerrain = landscape1.GetTerrainNeighbour(l1Terrain, "BOTTOM");
                        break;
                    case "RIGHT":
                        leftTerrain = landscape1.GetTerrainNeighbour(l1Terrain, "LEFT");
                        rightTerrain = l2Terrain;
                        topTerrain = landscape1.GetTerrainNeighbour(l1Terrain, "TOP");
                        bottomTerrain = landscape1.GetTerrainNeighbour(l1Terrain, "BOTTOM");
                        break;
                    case "TOP":
                        leftTerrain = landscape1.GetTerrainNeighbour(l1Terrain, "LEFT");
                        rightTerrain = landscape1.GetTerrainNeighbour(l1Terrain, "RIGHT");
                        topTerrain = l2Terrain;
                        bottomTerrain = landscape1.GetTerrainNeighbour(l1Terrain, "BOTTOM");
                        break;
                    case "BOTTOM":
                        leftTerrain = landscape1.GetTerrainNeighbour(l1Terrain, "LEFT");
                        rightTerrain = landscape1.GetTerrainNeighbour(l1Terrain, "RIGHT");
                        topTerrain = landscape1.GetTerrainNeighbour(l1Terrain, "TOP");
                        bottomTerrain = l2Terrain;
                        break;
                }

                // Set neighbours for the first landscape
                l1Terrain.SetNeighbors(leftTerrain, topTerrain, rightTerrain, bottomTerrain);

                // Get current neighbours for the terrain in adjoining landscape
                // If l1Terrain is joining on the left of l2Terrain, then the reverse is now
                // true for l2Terrain (i.e. it will join on the right)
                switch (l1TerrainEdge.ToUpper())
                {
                    case "LEFT":
                        leftTerrain = landscape2.GetTerrainNeighbour(l2Terrain, "LEFT");
                        rightTerrain = null; // l1Terrain;
                        topTerrain = landscape2.GetTerrainNeighbour(l2Terrain, "TOP");
                        bottomTerrain = landscape2.GetTerrainNeighbour(l2Terrain, "BOTTOM");
                        break;
                    case "RIGHT":
                        leftTerrain = null; // l1Terrain;
                        rightTerrain = landscape2.GetTerrainNeighbour(l2Terrain, "RIGHT");
                        topTerrain = landscape2.GetTerrainNeighbour(l2Terrain, "TOP");
                        bottomTerrain = landscape2.GetTerrainNeighbour(l2Terrain, "BOTTOM");
                        break;
                    case "TOP":
                        leftTerrain = landscape2.GetTerrainNeighbour(l2Terrain, "LEFT");
                        rightTerrain = landscape2.GetTerrainNeighbour(l2Terrain, "RIGHT");
                        topTerrain = landscape2.GetTerrainNeighbour(l2Terrain, "TOP");
                        bottomTerrain = null; // l1Terrain;
                        break;
                    case "BOTTOM":
                        leftTerrain = landscape2.GetTerrainNeighbour(l2Terrain, "LEFT");
                        rightTerrain = landscape2.GetTerrainNeighbour(l2Terrain, "RIGHT");
                        topTerrain = null; // l1Terrain;
                        bottomTerrain = landscape2.GetTerrainNeighbour(l2Terrain, "BOTTOM");
                        break;
                }

                // Set neighbours for the adjoining terrain in landscape2
                l2Terrain.SetNeighbors(leftTerrain, topTerrain, rightTerrain, bottomTerrain);
            }
        }

        private static void StitchAdjustHeights(TerrainData h1tdata, int t1Z, int t1X, float t1EdgeHeight, int t1EdgeOffset, Vector3 t1HeightmapScale,
                                                float[,] t1HeightMap, float[,] t2HeightMap, float t1Height, float t1t2WorldPosHeightOffset, Vector3 t2WorldPos,
                                                Vector3 t2WorldEdgePos, int edgeWidth, Vector3 l2TerrainWorldPosition, Vector3 l2TerrainSize,
                                                int t2HeightmapResolution, float StitchLandscapeWeight)
        {
            float t2Height = 0f, t2EdgeHeight = 0f, t1t2EdgeHeight = 0f, t1BlendedHeight = 0f, t2BlendedHeight = 0f;
            float t2EdgePosZ = 0f, t2EdgePosX = 0f, t2PosX = 0f, t2PosZ = 0f;
            float t1t2WorldPosHeightOffsetNormalised = 0f;
            int t2Z = 0, t2X = 0;

            // Get the normalised (0-1) position of this point in the adjorning landscape's terrain
            t2PosX = (t2WorldPos.x - l2TerrainWorldPosition.x) / l2TerrainSize.x;
            t2PosZ = (t2WorldPos.z - l2TerrainWorldPosition.z) / l2TerrainSize.z;

            // Get the normalised (0-1) position of the edge point in the adjorning landscape's terrain
            t2EdgePosX = (t2WorldEdgePos.x - l2TerrainWorldPosition.x) / l2TerrainSize.x;
            t2EdgePosZ = (t2WorldEdgePos.z - l2TerrainWorldPosition.z) / l2TerrainSize.z;

            // Get the heightmap coordinates in the adjorning landscape's terrain
            t2X = Mathf.RoundToInt(t2PosX * (t2HeightmapResolution - 1));
            t2Z = Mathf.RoundToInt(t2PosZ * (t2HeightmapResolution - 1));

            // Get the height from the adjoining landscape's terrain
            t2Height = h1tdata.GetInterpolatedHeight(t2PosX, t2PosZ) / l2TerrainSize.y;

            // Get the height from the edge of the adjoining landscape's terrain
            // This will return zero if it isn't in the same terrain...
            t2EdgeHeight = h1tdata.GetInterpolatedHeight(t2EdgePosX, t2EdgePosZ) / l2TerrainSize.y;

            // Adjust the heights for the difference in worldspace on the y-axis
            t1t2WorldPosHeightOffsetNormalised = t1t2WorldPosHeightOffset / t1HeightmapScale.y;
            t2Height = Mathf.Clamp01(t2Height - t1t2WorldPosHeightOffsetNormalised);
            t2EdgeHeight = Mathf.Clamp01(t2EdgeHeight - t1t2WorldPosHeightOffsetNormalised);

            // This is the combined edge height from both terrains based on the weighting provided
            t1t2EdgeHeight = Mathf.Lerp(t1EdgeHeight, t2EdgeHeight, StitchLandscapeWeight);

            // Perform any blending here...
            float blendFactor = (float)t1EdgeOffset / (float)edgeWidth;
            blendFactor = blendFactor * (blendFactor - 2f) + 1f;
            t1BlendedHeight = Mathf.Lerp(t1Height, t1t2EdgeHeight, blendFactor);
            t2BlendedHeight = Mathf.Lerp(t2Height, t1t2EdgeHeight, blendFactor);

            // Adjust the height in terrain1
            t1HeightMap[t1Z, t1X] = t1BlendedHeight;

            // Adjust the height of the terrain in the adjoining landscape
            // To set the height of the adjoining landscape, add back on any height difference between the two landscapes
            t2HeightMap[t2Z, t2X] = Mathf.Clamp01(t2BlendedHeight + t1t2WorldPosHeightOffsetNormalised);
        }

        #endregion

        #region Static Height Methods

        /// <summary>
        /// Get the Height of any terrain within a landscape at a point in worldspace
        /// By default returns the height as a normalised value
        /// </summary>
        /// <param name="landscape"></param>
        /// <param name="point"></param>
        /// <param name="normalise"></param>
        /// <returns></returns>
        public static float GetHeight(LBLandscape landscape, Vector2 point, bool normalise = true)
        {
            float pointHeight = 0f;
            Terrain[] landscapeTerrains;
            TerrainData tData;
            Vector3 worldPosition;
            float terrainWidth = 0f;
            float terrainHeight = 0f;

            Rect terrainRect;

            if (landscape != null)
            {
                GameObject landscapeGameObject = landscape.gameObject;

                if (landscapeGameObject != null)
                {
                    // Get the terrains attached to the landscape
                    landscapeTerrains = landscapeGameObject.GetComponentsInChildren<Terrain>();

                    if (landscapeTerrains != null)
                    {
                        // Loop through all the terrains in the landscape until we find the one that contains the point required
                        for (int index = 0; index < landscapeTerrains.Length; index++)
                        {
                            tData = landscapeTerrains[index].terrainData;
                            worldPosition = landscapeTerrains[index].transform.position;

                            // Terrain width (x) and length (z) are always the same in LB
                            terrainWidth = tData.size.x;

                            terrainHeight = tData.size.y;

                            // Get the rectange boundary of the terrain - expanded to work with Rect.Contains()
                            terrainRect = Rect.MinMaxRect(worldPosition.x, worldPosition.z, worldPosition.x + terrainWidth + 0.005f, worldPosition.z + terrainWidth + 0.005f);

                            // Is the point within this terrain?
                            if (terrainRect.Contains(point))
                            {
                                // Convert point into a normalised position on the terrain
                                float normXPos = Mathf.InverseLerp(worldPosition.x, worldPosition.x + terrainWidth, point.x);
                                float normYPos = Mathf.InverseLerp(worldPosition.z, worldPosition.z + terrainWidth, point.y);

                                //Debug.Log("terrainRect:" + terrainRect.xMin + "," + terrainRect.yMin + " - " + terrainRect.xMax + "," + terrainRect.yMax + " " + normXPos + "," + normYPos);

                                // Get the height at that point on the terrain (0-1)
                                if (normalise) { pointHeight = tData.GetInterpolatedHeight(normXPos, normYPos) / terrainHeight; }
                                else { pointHeight = tData.GetInterpolatedHeight(normXPos, normYPos); }

                                break;
                            }
                        }
                    }
                    else { Debug.LogError("LBLandscapeTerrain.GetHeight - no terrains attached to selected landscape"); }
                }
                else { Debug.LogError("LBLandscapeTerrain.GetHeight - landscape parent gameobject is null"); }
            }
            else { Debug.LogError("LBLandscapeTerrain.GetHeight - landscape script object is null"); }

            return pointHeight;
        }

        /// <summary>
        /// Get the Height of the terrain within a landscape at a point in worldspace.
        /// By default returns the height as a normalised value (fastest).
        /// Takes a 1D whole-landscape heightmap array.
        /// PREREQUISITES: landscape.SetLandscapeTerrains(false)
        /// </summary>
        /// <param name="landscape"></param>
        /// <param name="heightMap1D"></param>
        /// <param name="heightmapResolution"></param>
        /// <param name="point"></param>
        /// <param name="normalise"></param>
        /// <returns></returns>
        public static float GetHeight(LBLandscape landscape, float[] heightMap1D, int heightmapResolution, Vector2 point, bool normalise = true)
        {
            float pointHeight = 0f;

            // Do basic validation
            if (landscape != null && heightMap1D != null && heightMap1D.Length > 0)
            {
                // Convert point into a normalised position in the landscape
                float posXN = Mathf.InverseLerp(landscape.start.x, landscape.start.x + landscape.size.x, point.x);
                float posZN = Mathf.InverseLerp(landscape.start.z, landscape.start.z + landscape.size.y, point.y);

                // Get xy heightmap position from heights normalised position.
                int posX = Mathf.RoundToInt(posXN * (float)(heightmapResolution - 1));
                int posZ = Mathf.RoundToInt(posZN * (float)(heightmapResolution - 1));

                // Get min/max x,y points
                int minPosX = Mathf.FloorToInt(posXN * (float)(heightmapResolution - 1));
                int minPosZ = Mathf.FloorToInt(posZN * (float)(heightmapResolution - 1));

                // Check if we're on an edge
                if (minPosX == (heightmapResolution - 1)) { --minPosX; }
                if (minPosZ == (heightmapResolution - 1)) { --minPosZ; }

                int maxPosX = minPosX + 1;
                int maxPosZ = minPosZ + 1;

                // Get surrounding heights
                float h1 = heightMap1D[(minPosZ * heightmapResolution) + posX];
                float h2 = heightMap1D[(maxPosZ * heightmapResolution) + posX];
                float h3 = heightMap1D[(posZ * heightmapResolution) + minPosX];
                float h4 = heightMap1D[(posZ * heightmapResolution) + maxPosX];

                // Just avg 4 surrounding points (which is closest to Unity's GetInterpolatedHeight)
                // NOTE: Including diagonals doesn't improve it (slower and more jaggard)
                pointHeight = (h1 + h2 + h3 + h4) / 4f;

                if (!normalise) { pointHeight *= landscape.GetLandscapeTerrainHeight(); }
            }

            return pointHeight;
        }

        /// <summary>
        /// Set the height in the landspace of a point in worldspace
        /// Ensure the correct terrain is updated by checking the X,Y heightmap position
        /// IMPORTANT: You need to call Terrain.ApplyDelayedHeightmapModification() when
        /// all the points have been updated.
        /// </summary>
        /// <param name="landscape"></param>
        /// <param name="point"></param>
        /// <param name="heightmapX"></param>
        /// <param name="heightmapY"></param>
        /// <param name="height"></param>
        public static void SetHeight(LBLandscape landscape, Vector2 point, int heightmapX, int heightmapY, float height, bool showErrors = false)
        {
            Terrain[] landscapeTerrains;
            TerrainData tData;
            Vector3 worldPosition;
            int heightmapResolution = 0;
            float terrainWidth = 0f;
            float pointHeight = 0f;

            // Create a single pixel heightmap
            float[,] heightMap = new float[1, 1];
            heightMap[0, 0] = height;

            Rect terrainRect;

            if (landscape != null && height >= 0f && height <= 1f)
            {
                if (landscape != null)
                {
                    GameObject landscapeGameObject = landscape.gameObject;

                    if (landscapeGameObject != null)
                    {
                        // Get the terrains attached to the landscape
                        landscapeTerrains = landscapeGameObject.GetComponentsInChildren<Terrain>();

                        if (landscapeTerrains != null)
                        {
                            // Loop through all the terrains in the landscape until we find the one that contains the point required
                            for (int index = 0; index < landscapeTerrains.Length; index++)
                            {
                                tData = landscapeTerrains[index].terrainData;
                                worldPosition = landscapeTerrains[index].transform.position;

                                // Terrain width (x) and length (z) are always the same in LB
                                terrainWidth = tData.size.x;
                                heightmapResolution = tData.heightmapResolution;

                                // Get the rectange boundary of the terrain
                                terrainRect = Rect.MinMaxRect(worldPosition.x, worldPosition.z, worldPosition.x + terrainWidth, worldPosition.z + terrainWidth);

                                // Is the point within this terrain?
                                if (point.x >= terrainRect.xMin && point.x <= terrainRect.xMax && point.y >= terrainRect.yMin && point.y <= terrainRect.yMax)
                                //if (terrainRect.Contains(point))
                                {
                                    // Convert point into a normalised position on the terrain
                                    float normXPos = Mathf.InverseLerp(worldPosition.x, worldPosition.x + terrainWidth, point.x);
                                    float normYPos = Mathf.InverseLerp(worldPosition.z, worldPosition.z + terrainWidth, point.y);

                                    int x = Mathf.RoundToInt(normXPos * (heightmapResolution - 1));
                                    int y = Mathf.RoundToInt(normYPos * (heightmapResolution - 1));

                                    if (x == heightmapX && y == heightmapY)
                                    {
                                        if (showErrors)
                                        {
                                            // Set the height at that point on the terrain (0-1)
                                            pointHeight = tData.GetInterpolatedHeight(normXPos, normYPos);
                                            Debug.Log("SetHeight: " + landscapeTerrains[index].name + " x,y:" + x.ToString() + "," + y.ToString() + " h:" + pointHeight.ToString() + " new h:" + (height * 2000f).ToString());
                                        }

                                        // Update the height at the single point
                                        // Us SetHeightDelayLOB() rather than SetHeight() as it is MUCH faster
                                        // Once all the updates have happened will need to call
                                        // Terrain.ApplyDelayedHeightmapModification()
                                        tData.SetHeightsDelayLOD(x, y, heightMap);
                                    }
                                }
                            }
                        }
                        else if (showErrors) { Debug.LogError("LBLandscapeTerrain.SetHeight - no terrains attached to selected landscape"); }
                    }
                    else if (showErrors) { Debug.LogError("LBLandscapeTerrain.SetHeight - landscape parent gameobject is null"); }
                }
                else if (showErrors) { Debug.LogError("LBLandscapeTerrain.SetHeight - landscape script object is null"); }

            }
        }

        public static Vector2 GetTerrainHeightRange(TerrainData tData, bool isNormalised)
        {
            Vector2 heightRange = new Vector2(float.PositiveInfinity, float.NegativeInfinity);

            if (tData != null)
            {
                heightmapResolution = tData.heightmapResolution;
                float terrainHeight = tData.size.y;
                height = 0f;

                float[,] heightMap = tData.GetHeights(0, 0, heightmapResolution, heightmapResolution);

                // Loop through heightmap points (certainly not fast...)
                for (int x = 0; x < heightmapResolution; x++)
                {
                    for (int y = 0; y < heightmapResolution; y++)
                    {
                        // Get the current pixel height (0-1)
                        height = heightMap[y, x];

                        // If we want the value in metres rather than between 0 and 1
                        // multiple by the size of the terrain in the y-axis.
                        if (!isNormalised)
                        {
                            height *= terrainHeight;
                        }

                        heightRange.x = Mathf.Min(heightRange.x, height);
                        heightRange.y = Mathf.Max(heightRange.y, height);
                    }
                }

                //Debug.Log("heightrange: " + heightRange.ToString());

                height = 0f;
            }

            return heightRange;
        }

        #endregion

        #region Static Slope Methods

        /// <summary>
        /// Get the Slope of any terrain within a landscape at a point in worldspace
        /// </summary>
        /// <param name="landscape"></param>
        /// <param name="point"></param>
        /// <returns></returns>
        public static float GetSlope(LBLandscape landscape, Vector2 point)
        {
            float pointSlope = 0f;
            Terrain[] landscapeTerrains;
            TerrainData tData;
            Vector3 worldPosition;
            float terrainWidth = 0f;
            float terrainHeight = 0f;

            Rect terrainRect;

            if (landscape != null)
            {
                GameObject landscapeGameObject = landscape.gameObject;

                if (landscapeGameObject != null)
                {
                    // Get the terrains attached to the landscape
                    landscapeTerrains = landscapeGameObject.GetComponentsInChildren<Terrain>();

                    if (landscapeTerrains != null)
                    {
                        // Loop through all the terrains in the landscape until we find the one that contains the point required
                        for (int index = 0; index < landscapeTerrains.Length; index++)
                        {
                            tData = landscapeTerrains[index].terrainData;
                            worldPosition = landscapeTerrains[index].transform.position;

                            // Terrain width (x) and length (z) are always the same in LB
                            terrainWidth = tData.size.x;
                            terrainHeight = tData.size.y;

                            // Get the rectange boundary of the terrain - expanded to work with Rect.Contains()
                            terrainRect = Rect.MinMaxRect(worldPosition.x, worldPosition.z, worldPosition.x + terrainWidth + 0.005f, worldPosition.z + terrainWidth + 0.005f);

                            // Is the point within this terrain?
                            if (terrainRect.Contains(point))
                            {
                                // Convert point into a normalised position on the terrain
                                float normXPos = Mathf.InverseLerp(worldPosition.x, worldPosition.x + terrainWidth, point.x);
                                float normYPos = Mathf.InverseLerp(worldPosition.z, worldPosition.z + terrainHeight, point.y);

                                // Get the height at that point on the terrain (0-1)
                                pointSlope = tData.GetSteepness(normXPos, normYPos);
                            }
                        }
                    }
                    else { Debug.LogError("LBLandscapeTerrain.GetSlope - no terrains attached to selected landscape"); }
                }
                else { Debug.LogError("LBLandscapeTerrain.GetSlope - landscape parent gameobject is null"); }
            }
            else { Debug.LogError("LBLandscapeTerrain.GetSlope - landscape script object is null"); }

            return pointSlope;
        }

        /// <summary>
        /// Create and populate a RenderTexture containing the slope data for a terrain
        /// Store normals in Red channel as 0.0 - 1.0 values which represent 0.0-90.0 degrees.
        /// WARNING: THERE IS A BUG IN THIS CODE... See below.
        /// </summary>
        /// <param name="landscape"></param>
        /// <param name="tData"></param>
        /// <param name="texWidth"></param>
        /// <param name="texLength"></param>
        /// <param name="texName"></param>
        /// <returns></returns>
        public static RenderTexture GetSlopeTexture(LBLandscape landscape, TerrainData tData, int texWidth, int texLength, string texName)
        {
            RenderTexture normalsTex = null;
            float slope = 0f;
            Vector2 posN = Vector2.zero;
            float texWidthLess1 = (float)(texWidth - 1);
            float texLengthLess1 = (float)(texLength - 1);

            if (landscape != null && tData != null)
            {
                Vector3 terrainSize = tData.size;

                if (terrainSize.x > 0f && terrainSize.y > 0f && terrainSize.z > 0)
                {
                    normalsTex = new RenderTexture(texWidth, texLength, 24, RenderTextureFormat.ARGB32, RenderTextureReadWrite.Linear);

                    if (normalsTex)
                    {
                        normalsTex.useMipMap = false;
                        normalsTex.autoGenerateMips = false;
                        normalsTex.hideFlags = HideFlags.DontSave;
                        normalsTex.enableRandomWrite = false;
                        normalsTex.name = texName;
                        normalsTex.Create();

                        if (!normalsTex.IsCreated()) { LBTextureOperations.DestroyRenderTexture(ref normalsTex); }
                        else
                        {
                            Texture2D tex2D = new Texture2D(texWidth, texLength, TextureFormat.ARGB32, false, true);

                            if (tex2D != null)
                            {
                                Color[] colours = tex2D.GetPixels();

                                // Populate render texture with terrain slope data
                                for (int x = 0; x < texWidth; x++)
                                {
                                    for (int y = 0; y < texWidth; y++)
                                    {
                                        posN.x = (float)x / texWidthLess1;
                                        posN.y = (float)y / texLengthLess1;

                                        // Steepness is 0-90 degrees
                                        slope = tData.GetSteepness(posN.x, posN.y);

                                        colours[y * texWidth + x].r = Mathf.Clamp01(slope / 90f);

                                        //Debug.Log("Pos: " + "x,y: " + x + "," + y + " PosN: " + posN + " slope: " + slope);
                                    }
                                }

                                tex2D.SetPixels(colours);
                                tex2D.Apply();

                                // ERROR HERE - ReadPixels does the reverse of what I expected
                                // Actually it reads from the active RenderTexture and writes to the Texture2D...
                                // Copy Texture2D into the RenderTexture
                                // Remember the current active texture
                                RenderTexture currentRT = RenderTexture.active;
                                RenderTexture.active = normalsTex;
                                tex2D.ReadPixels(new Rect(0, 0, texWidth, texLength), 0, 0);
                                tex2D.Apply();
                                // Restore the current texture
                                RenderTexture.active = currentRT;

                                // Safely dispose of the Texture2D after use to avoid
                                // memory leaks
                                LBTextureOperations.DestroyTexture2D(ref tex2D);
                            }
                            else
                            {
                                // If the Texture2D creation failed, also clean up the RenderTexture
                                LBTextureOperations.DestroyRenderTexture(ref normalsTex);
                            }
                        }
                    }
                }
            }

            return normalsTex;
        }

        /// <summary>
        /// Create and populate a Texture2D containing the slope data for a terrain
        /// Store normals in Red channel as 0.0 - 1.0 values which represent 0.0-90.0 degrees.
        /// NOTE: Call LBTextureOperations.DestroyTexture2D(ref tex2D) after use to safely
        /// dispose of the new texture.
        /// </summary>
        /// <param name="landscape"></param>
        /// <param name="tData"></param>
        /// <param name="terrainData"></param>
        /// <param name="terrainRects"></param>
        /// <param name="texWidth"></param>
        /// <param name="texLength"></param>
        /// <param name="texName"></param>
        /// <returns></returns>
        public static Texture2D GetSlopeTexture2D(LBLandscape landscape, Vector3 landscapePosition, TerrainData tData, Vector3 terrainPosition, int texWidth, int texLength, string texName)
        {
            Texture2D normalsTex = null;
            float slope = 0f;
            Vector2 posN = Vector2.zero;
            Vector2 landscapePosN2D = Vector2.zero;
            Vector2 landscapePos2DM = Vector2.zero; // position in landscape, in metres, from bottom-left corner
            Vector2 worldPos2D = Vector2.zero; // true worldspace position
            float texWidthLess1 = (float)(texWidth - 1);
            float texLengthLess1 = (float)(texLength - 1);

            if (landscape != null && tData != null)
            {
                Vector3 terrainSize = tData.size;
                float landscapeWidth = landscape.size.x;
                float landscapeLength = landscape.size.y;

                landscape.SetLandscapeTerrains(true);
                Terrain[] landscapeTerrains = landscape.landscapeTerrains;
                int numTerrains = (landscapeTerrains == null ? 0 : landscapeTerrains.Length);
                landscapeWidth = landscape.size.x;
                landscapeLength = landscape.size.y;

                bool useLandscapeSlope = false;
                TerrainData[] terrainDataArray = null;
                Rect[] terrainRectsArray = new Rect[0];

                if (numTerrains > 1)
                {
                    useLandscapeSlope = true;
                    // Create arrays for terrain data and terrain rects
                    terrainDataArray = new TerrainData[numTerrains];
                    terrainRectsArray = new Rect[numTerrains];
                    for (int i = 0; i < numTerrains; i++)
                    {
                        terrainDataArray[i] = landscapeTerrains[i].terrainData;
                        if (terrainDataArray[i] == null) { useLandscapeSlope = false; break; }
                        Vector3 landscapePositionVector = landscapeTerrains[i].transform.position - landscapePosition;
                        terrainRectsArray[i] = Rect.MinMaxRect(landscapePositionVector.x, landscapePositionVector.z, landscapePositionVector.x + landscapeTerrains[i].terrainData.size.x,
                            landscapePositionVector.z + landscapeTerrains[i].terrainData.size.z);

                        //Debug.Log("terrainRectsArray " + i + " " + terrainRectsArray[i].xMin + "," + terrainRectsArray[i].yMin + " - " + terrainRectsArray[i].xMax + "," + terrainRectsArray[i].yMax);
                    }
                }            

                if (terrainSize.x > 0f && terrainSize.y > 0f && terrainSize.z > 0)
                {
                    normalsTex = new Texture2D(texWidth, texLength, TextureFormat.ARGB32, false, true);

                    if (normalsTex != null)
                    {
                        Color[] colours = normalsTex.GetPixels();

                        // Populate render texture with terrain slope data
                        for (int x = 0; x < texWidth; x++)
                        {
                            for (int y = 0; y < texWidth; y++)
                            {
                                posN.x = (float)x / texWidthLess1;
                                posN.y = (float)y / texLengthLess1;
                                
                                // Always get the slope from the same terrain along the edges so that they match correctly
                                if (useLandscapeSlope && (x == 0 || x == texWidthLess1 || y == 0 || y == texLengthLess1))
                                {
                                    // Get the worldspace position
                                    worldPos2D.x = (posN.x * terrainSize.x) + terrainPosition.x;
                                    worldPos2D.y = (posN.y * terrainSize.z) + terrainPosition.z;

                                    // Get normalised position in landscape
                                    landscapePosN2D = landscape.NormalisePointFromWorldPos2DFast(worldPos2D);
                                    if (landscapePosN2D.x < 0) { landscapePosN2D.x = 0f; }
                                    else if (landscapePosN2D.x > 1f) { landscapePosN2D.x = 1f; }
                                    if (landscapePosN2D.y < 0) { landscapePosN2D.y = 0f; }
                                    else if (landscapePosN2D.y > 1f) { landscapePosN2D.y = 1f; }

                                    landscapePos2DM.x = landscapePosN2D.x * landscapeWidth;
                                    landscapePos2DM.y = landscapePosN2D.y * landscapeLength;

                                    GetLandscapeInterpolatedSlopeData(terrainDataArray, terrainRectsArray, landscapePos2DM, ref slope);
                                }
                                else
                                {
                                    // Steepness is 0-90 degrees
                                    slope = tData.GetSteepness(posN.x, posN.y);
                                }

                                colours[y * texWidth + x].r = Mathf.Clamp01(slope / 90f);
                            }
                        }

                        normalsTex.SetPixels(colours);
                        normalsTex.Apply();
                    }
                }
            }

            return normalsTex;
        }

        #endregion

        #region Static Compute Shader Methods

        #if LB_COMPUTE
        /// <summary>
        /// Configure a dummy list of Text2DArrays for Stencil Layers
        /// Set the texture size to 1x1
        /// </summary>
        /// <param name="stencilLayerTex2DArrayList"></param>
        public static void ConfigDummyStencilLayerTex2DArrayList(List<Texture2DArray> stencilLayerTex2DArrayList, ComputeShader computeShader, int methodIdx)
        {
            if (stencilLayerTex2DArrayList != null && computeShader != null)
            {
                for (int i = 0; i < 7; i++)
                {
                    stencilLayerTex2DArrayList.Add(new Texture2DArray(1, 1, 1, TextureFormat.ARGB32, false, true));
                    stencilLayerTex2DArrayList[i].hideFlags = HideFlags.DontSave;
                }

                int numSLayerTex2DArrays = (stencilLayerTex2DArrayList == null ? 0 : stencilLayerTex2DArrayList.Count);

                // Assign the Texture2DArrays to the compute shader
                if (numSLayerTex2DArrays > 0) { computeShader.SetTexture(methodIdx, CSstencilLayer128Tex2DArray, stencilLayerTex2DArrayList[0]); }
                if (numSLayerTex2DArrays > 1) { computeShader.SetTexture(methodIdx, CSstencilLayer256Tex2DArray, stencilLayerTex2DArrayList[1]); }
                if (numSLayerTex2DArrays > 2) { computeShader.SetTexture(methodIdx, CSstencilLayer512Tex2DArray, stencilLayerTex2DArrayList[2]); }
                if (numSLayerTex2DArrays > 3) { computeShader.SetTexture(methodIdx, CSstencilLayer1024Tex2DArray, stencilLayerTex2DArrayList[3]); }
                if (numSLayerTex2DArrays > 4) { computeShader.SetTexture(methodIdx, CSstencilLayer2048Tex2DArray, stencilLayerTex2DArrayList[4]); }
                if (numSLayerTex2DArrays > 5) { computeShader.SetTexture(methodIdx, CSstencilLayer4096Tex2DArray, stencilLayerTex2DArrayList[5]); }
                if (numSLayerTex2DArrays > 6) { computeShader.SetTexture(methodIdx, CSstencilLayer8192Tex2DArray, stencilLayerTex2DArrayList[6]); }
            }
        }
        
        /// <summary>
        /// Copy and assign a list of Stencil Layer Texture2DArrays to a compute shader method
        /// </summary>
        /// <param name="stencilLayerTex2DArrayList"></param>
        /// <param name="computeShader"></param>
        /// <param name="methodIdx"></param>
        public static void CopyStencilLayerTex2DArrayListToShader(List<Texture2DArray> stencilLayerTex2DArrayList, ComputeShader computeShader, int methodIdx)
        {
            if (stencilLayerTex2DArrayList != null && computeShader != null)
            {
                int numSLayerTex2DArrays = (stencilLayerTex2DArrayList == null ? 0 : stencilLayerTex2DArrayList.Count);

                // Assign the Texture2DArrays to the compute shader
                if (numSLayerTex2DArrays > 0) { computeShader.SetTexture(methodIdx, CSstencilLayer128Tex2DArray, stencilLayerTex2DArrayList[0]); }
                if (numSLayerTex2DArrays > 1) { computeShader.SetTexture(methodIdx, CSstencilLayer256Tex2DArray, stencilLayerTex2DArrayList[1]); }
                if (numSLayerTex2DArrays > 2) { computeShader.SetTexture(methodIdx, CSstencilLayer512Tex2DArray, stencilLayerTex2DArrayList[2]); }
                if (numSLayerTex2DArrays > 3) { computeShader.SetTexture(methodIdx, CSstencilLayer1024Tex2DArray, stencilLayerTex2DArrayList[3]); }
                if (numSLayerTex2DArrays > 4) { computeShader.SetTexture(methodIdx, CSstencilLayer2048Tex2DArray, stencilLayerTex2DArrayList[4]); }
                if (numSLayerTex2DArrays > 5) { computeShader.SetTexture(methodIdx, CSstencilLayer4096Tex2DArray, stencilLayerTex2DArrayList[5]); }
                if (numSLayerTex2DArrays > 6) { computeShader.SetTexture(methodIdx, CSstencilLayer8192Tex2DArray, stencilLayerTex2DArrayList[6]); }
            }
        }

        #endif

        #endregion

        #region Static Formulae Methods

        /// <summary>
        /// Normalise the value "x" to return values between 0 and 1
        /// given the potential range between "a" and "b"
        /// If "b" less than or equal to "a" this funtion will always return 0
        /// </summary>
        /// <param name="x"></param>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns></returns>
        public static float Normalise(float x, float a, float b)
        {
            if (b <= a) { return 0f; }
            else { return ((x - a) * (1f / (b - a))); }
        }

        /// <summary>
        /// Normalise the value "x" to return values between 0 and 1
        /// given the potential range between "a" and "b"
        /// If "b" less than or equal to "a" this funtion will always return 0
        /// </summary>
        /// <param name="x"></param>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns></returns>
        public static float Normalise(ushort x, ushort a, ushort b)
        {
            if (b <= a) { return 0f; }
            else { return ((x - a) * (1f / (b - a))); }
        }

        /// <summary>
        /// Given a supplied non-null empty list of vector3s, populate it with a list of polygon points
        /// of a regular polygon on the inside of circle. Each segment will be approx 1 metre unless
        /// circle is very small or large.
        /// </summary>
        /// <param name="polygonList"></param>
        /// <param name="circleCentre"></param>
        /// <param name="circleRadius"></param>
        /// <param name="addClosingPoint"></param>
        public static void CircleToPolygon(List<Vector3> polygonList, Vector3 circleCentre, float circleRadius, bool addClosingPoint)
        {
            // Minimum number of possible segments of polygon is 3. However, here in LB we'll set min to 6.            
            if (polygonList == null) { return; }
            else
            {
                polygonList.Clear();

                float circum = 2f * (float)System.Math.PI * circleRadius;

                // Each segment should be approx 1 metre in length
                int numSegmts = (int)circum;

                if (numSegmts < 6) { numSegmts = 6; }
                else if (numSegmts > 1000) { numSegmts = 1000; }
                // Check for odd numbers. First point should have no z offset.
                else if (numSegmts % 2 == 1) { numSegmts += 1; }

                //Debug.Log("[DEBUG] r:" + circleRadius + " circum: " + circum + " segments: " + numSegmts);

                float exteriorAngleRad = (360f / numSegmts) * (float)System.Math.PI / 180f;

                Vector3 p0 = (Vector3.right * circleRadius) + circleCentre;
                Vector3 pN = p0;
                polygonList.Add(p0);

                for (int sgIdx = 1; sgIdx < numSegmts; sgIdx++)
                {
                    pN.x = (circleRadius * (float)System.Math.Cos((float)sgIdx * exteriorAngleRad)) + circleCentre.x;
                    pN.z = (circleRadius * (float)System.Math.Sin((float)sgIdx * exteriorAngleRad)) + circleCentre.z;
                    polygonList.Add(pN);
                }
                if (addClosingPoint) { polygonList.Add(p0); }
            }
        }

        #endregion
    }
}