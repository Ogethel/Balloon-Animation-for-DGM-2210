using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using UnityEditor;
using System;
using UnityEditor.SceneManagement;
using System.IO;
using Object = UnityEngine.Object;
//using System.Linq;

// Landscape Builder. Copyright (c) 2016-2019 SCSM Pty Ltd. All rights reserved.
namespace LandscapeBuilder
{
    public class LandscapeBuilderWindow : EditorWindow
    {
        public static string LBVersion { get { return LBEditorCommon.LBVersion; } }
        private string LBBetaVersion { get { return LBEditorCommon.LBBetaVersion; } }

        #region Enums

        private enum WindZonePreset
        {
            Default,
            Calm,
            Windy,
            Gusty,
            Stormy,
            Cyclonic
        }

        private enum NoiseGeneratorType
        {
            LayerBased = 0,
            ValueBased = 10
        }

        private enum NoisePreset
        {
            Default = 0,
            GentleValleys = 1,
            MountainsAndValleys = 2,
            Desert = 3,
            TieredCanyon = 4,
            ManyTieredCanyon = 5,
            MountainRange = 6,
            ComplexMountainRange = 7,
            WorldMountainRange = 8,
            MountainousHighlands = 9,
            MountainousLowlands = 10,
            MountainPeaks = 11,
            FlatCoast = 12,
            CliffedCoast = 13,
            Islands = 14,
            MountainousLagoons = 15,
            Forest = 16,
            RollingHills = 17
        }

        private enum MaskMode
        {
            None = 0,
            DistanceToCentre = 1,
            Noise = 2
        }

        private enum FakeErosionType
        {
            None = 0,
            StreamErosion = 1,
            RainErosion = 2,
            CombinedErosion = 3
        }

        private enum ErosionPreset
        {
            Default = 0
        }

        private enum ModifierType
        {
            Landform = 0,
            Flatten = 1,
            Noise = 2,
            Smooth = 3,
            Topography = 4,
            Image = 5
        }

        private enum ModifierMode
        {
            Add = 0,
            Subtract = 1,
            Multiply = 2,
            Set = 3
        }

        private enum TerrainSettingsType
        {
            Default = 0,
            Quality1 = 10,
            Performance1 = 20,
            Performance2 = 21
        }

        // Temporary for v1.5 testing
        private enum LayerTypeRestricted
        {
            PerlinBase = 0,
            PerlinAdditive = 1,
            PerlinSubtractive = 2,
            PerlinDetail = 3,
            ImageBase = 4,
            ImageAdditive = 5,
            ImageSubtractive = 6,
            ImageDetail = 7,
            MapPath = 20,
            UnityTerrains = 50
        }

        // Will be converted to/from a bool
        private enum CurvatureType
        {
            Concave = 0,
            Convex = 1
        }

        #endregion

        #region Option Arrays

        // Height Map Resolutions
        private int[] possibleHMRs = { 65, 129, 257, 513, 1025, 2049, 4097 };
        private string[] possibleHMRStrings = { "65", "129", "257", "513", "1025", "2049", "4097" };

        // Base Texture Resolutions
        private int[] possibleBTRs = { 64, 128, 256, 512, 1024, 2048, 4096 };
        private string[] possibleBTRStrings = { "64", "128", "256", "512", "1024", "2048", "4096" };

        // Alpha Map Resolutions
        #if UNITY_2019_3_OR_NEWER
        private int[] possibleAMRs = { 64, 128, 256, 512, 1024, 2048, 4096 };
        private GUIContent[] AMRGUIContent = { new GUIContent("64"), new GUIContent("128"), new GUIContent("256"), new GUIContent("512"), new GUIContent("1024"), new GUIContent("2048"), new GUIContent("4096") };
        #else
        private int[] possibleAMRs = { 64, 128, 256, 512, 1024, 2048 };
        private GUIContent[] AMRGUIContent = { new GUIContent("64"), new GUIContent("128"), new GUIContent("256"), new GUIContent("512"), new GUIContent("1024"), new GUIContent("2048") };
        #endif

        // Detail (Grass) Resolution
        private int[] possibleDTRs = { 128, 256, 512, 1024 };
        private static readonly GUIContent[] DTRGUIContent = { new GUIContent("128"), new GUIContent("256"), new GUIContent("512"), new GUIContent("1024") };

        private int[] possibleRotationAngles = { -270, -180, -90, 90, 180, 270 };
        private string[] possibleRotationAngleStrings = { "-270", "-180", "-90", "90", "180", "270" };

        #endregion

        #region Variables
        // Editor window variables
        private int selectedTabInt = 0;
        //private int lastselectedTabInt = 0;
        private Vector2 scrollPosition = Vector2.zero;
        private bool mouseClickEvent = false;
        private GUIStyle helpBoxRichText = null;
        private GUIStyle labelFieldRichText = null;
        private GUIStyle labelFieldRichTextCentred = null;
        private GUIStyle labelFieldHeaderBox = null;
        private GUIStyle labelsmallFieldRichText = null;
        private GUIStyle versionBox = null;
        private GUIStyle headerBox = null;
        private GUIStyle buttonCompact = null;
        private GUIStyle buttonCompact8 = null;
        private GUIStyle buttonCompactNoOffset = null;
        private static GUIStyle toggleCompactButtonStyleNormal = null;  // Small Toggle button. e.g. P(ath) in GroupMember
        private static GUIStyle toggleCompactButtonStyleToggled = null;
        private static GUIStyle toggleTinyButtonStyleNormal = null;  // Small Toggle button. e.g. Zone in Group
        private static GUIStyle toggleTinyButtonStyleToggled = null;
        private static GUIStyle line1Style = null; // Used in ObjPathSeries
        private GUIStyle foldoutStyleNoLabel = null;
        private GUIStyle displayTerrainNameLabel = null;
        private GUIStyle searchTextFieldStyle = null;
        private GUIStyle searchCancelButtonStyle = null;
        private float defaultSearchTextFieldWidth = 150f;
        private string txtColourName = "black";
        private bool allowRepaint = true;
        private bool hasRetrievedSavedData = false;
        private bool isSceneSaveRequired = false;
        private bool isSceneDirtyRequired = false;
        private bool isJustEnabled = true;
        private bool isDefaultResourcesValid = true;    // Helps to determine if LB is still in default Assets/ folder
        private List<string> tagList = new List<string>();
        private float defaultEditorLabelWidth = 150f;
        private float defaultEditorFieldWidth = 0f;
        private Texture2D lbTitleTex = null;
        private Texture2D lbTopoHeaderTex = null;
        private Texture2D lbTreeHeaderTex = null;
        private Texture2D lbGrassHeaderTex = null;
        private Texture2D lbTexturingHeaderTex = null;
        private Texture2D lbGroupsHeaderTex = null;

        // Used in HierachyWindowChanged for Scene change detection
        private string currentScene;
        private string activeScene;

        // Temporary variables
        private int x;
        private int y;
        private float xF;
        private float yF;
        private int index;
        private int index2;
        private int temp;
        private int arrayInt;
        private int arrayInt2;
        private Terrain[] landscapeTerrains;
        private Color testColour;
        private bool prevToggleValue;
        private string labelText, labelText2;
        private int displayDialogComplexInt = 0;

        // Landscape variables
        private string lbHelpPDF = "";
        private bool showTerrainSettings = false;
        private bool showLandscapeStats = false;
        private bool showSceneSettings = false;
        private bool showScenePaths = false;
        private bool showLandscapeTemplate = false;
        private bool showStencils = false;
        private string landscapeName = "Landscape 01";
        [SerializeField] private GameObject landscapeGameObjectSelection;
        private LBLandscape landscapeSelection;
        private GameObject landscapeGameObject;
        private bool landscapeHasSwitched = true;   // Has a different landscape been selected?
        private LBLandscape landscape;
        private Vector2 landscapeSize = Vector2.one * 4000f;
        private Vector3 startPosition = Vector3.zero;
        private Vector2 landscapeMinMaxHeight = Vector2.zero;
        private int heightmapResolution = 513;
        private float terrainWidth = 2000f;
        private float terrainLength = 2000f;
        private float terrainHeight = 2000f;
        private Vector3 terrainSize3D = Vector3.one * 2000f;
        private float pixelError = 1f;
        private float baseMapDistance = 1500f;
        private int baseTextureResolution = 512;
        private int alphaMapResolution = 512;
        private int landscapeLayerIndex = 0; // Unity "Default" built in layer
        private int selectedLandscapeLayerIndex = 0; // Selected in editor but may not be yet applied to landscape
        private List<string> layerNameListRestricted = null;
        private float treeDistance = 10000f;
        private float treeBillboardDistance = 200f;
        private int detailResolution = 1024;
        private float detailDistance = 200f;
        private float detailDensity = 1f;
        private float treeFadeDistance = 5f;
        private bool showTerrainGrassWindSettings = false;
        private float grassWindSpeed = 0.5f;
        private float grassWindRippleSize = 0.5f;
        private float grassWindBending = 0.5f;
        private Color grassWindTint = Color.white;
        private LBLandscape.TerrainMaterialType terrainMaterialType = LBLandscape.TerrainMaterialType.BuiltInStandard;
        private Color terrainLegacySpecular = new Color(0.5f, 0.5f, 0.5f, 1f);
        private float terrainLegacyShininess = 0.1f;
        private bool useTerrainDrawInstanced = true; // new in U2018.3
        private bool useTerrainPerPixelNormals = false; // new in U2018.3 with LWRP 4.0.1+
        private bool useProjectForTerrainData = false;
        private string terrainDataFolder = string.Empty; // The folder in the project folder. Stored without the Assets/ prefix.
        private bool useTerrainAutoConnect = true; // new in U2018.3
        private int terrainGroupingID = 100; // new in U2018.3
        private Material terrainCustomMaterial;
        private bool heightPickerEnabled = false;
        private Vector3 heightPickerWorldPosition = Vector3.zero;
        private float heightPickerOutput = 0f;
        private float heightPickerSlopeOutput = 0f;
        private LBTerrainHighlight heightPickerHighlighter;
        private Camera editorCamera;
        private TerrainSettingsType terrainSettingsType = TerrainSettingsType.Default;
        private bool displayTerrainLabels = false;
        private int displayTerrainLabelIdx = 0;
        private Vector3 displayLabelNamePos = Vector3.zero;
        private Color displayLabelColor = new Color(1f, 1f, 1f, 1f);
        private bool isReparentRequired = false; // This is true if a single terrain directly attached to LB Landscape script

        // Landscape Water variables
        private Transform waterPrefab;
        private float waterHeight = 1000f;
        private LBWater.WaterResizingMode waterResizingMode = LBWater.WaterResizingMode.TransformScaling;
        private int waterScaleFactorIndex = 3;
        private bool waterIsPrimary = true;
        private bool waterKeepPrefabAspectRatio = false;
        private string waterLabel = string.Empty;
        private float currentWaterHeight = 0f;
        private LBWater lbWaterToRemove = null;
        private LBWater lbWaterToResize = null;
        private bool waterResizing = false;
        private Transform waterTransform = null;
        private Vector3 waterPosition = Vector3.zero;
        private LBTerrainHighlight waterHighlighter;
        private bool waterHighlighterEnabled = false;
        private float waterSecondarySize = 200f;
        private int waterMaxMeshThreshold = 5000;
        private Camera waterMainCamera = null;
        private List<LBWaterCaustics> waterCausticsList;
        private List<Transform> waterCausticsPrefabList;
        private bool waterEnabledStateChanged = false;
        // AQUAS specific water variables
        private bool isAQUASRiverInstalled = false;
        private bool waterIsRiver = false;
        private Material waterRiverMaterial = null;
        private Material waterMaterial = null;
        private string pathFlowMapPainter = string.Empty;
        // Calm Water specific water variables
        private bool isCalmWaterInstalled = false;

        // Landscape Lights variables
        private bool removeOtherDirectionalLights = true;
        private bool isLinearColourSpace = true;

        // Landscape Windzone variables
        private WindZonePreset windZonePreset = WindZonePreset.Default;

        // Landscape Template variables
        private string landscapeTemplateName = "Landscape Template";
        private bool createTemplatePackage = false;
        private bool addMapTexturesToTemplatePackage = false;
        private bool addLayerHeightmapTexturesToTemplatePackage = false;
        private bool addLBLightingToTemplate = true;
        private bool addPathsToTemplate = true;
        private bool addStencilsToTemplate = true;
        private bool addPathMeshMaterialsToTemplate = false;
        private LBTemplate lbTemplateToRestore = null;
        private bool importTerrainSettingsFromTemplate = true;
        private bool importTopographyFromTemplate = true;
        private bool importTexturesFromTemplate = true;
        private bool importGrassFromTemplate = true;
        private bool importTreesFromTemplate = true;
        private bool importGroupsFromTemplate = true;
        private bool importMeshesFromTemplate = true;
        private bool importLBLightingFromTemplate = false;
        private bool importPathsFromTemplate = false;
        private bool removeExistingPathsInLandscape = false;
        private bool importWaterFromTemplate = true;
        private bool importStencilsFromTemplate = false;
        private bool removeExistingStencilsInLandscape = false;
        private bool templateReplaceExistingCameraAnimators = false;
        private bool templateIgnoreStartPosition = false;
        private bool templateUpdateTerrainHeight = false;
        private bool templateApplyTopography = true;
        private bool templateApplyTextures = true;
        private bool templateApplyGrass = true;
        private bool templateApplyTrees = true;
        private bool templateApplyGroups = true;
        private bool templateApplyMeshes = false;
        private bool templateApplyPathMeshes = false;

        // Topography variables

        // v1.3.1 Beta 5b Topography Mask now stored in LBLandscape

        // Topography Mask Defaults
        private float GetDefaultMaskWarpAmount { get { return 0f; } }
        private float GetDefaultMaskNoiseTileSize { get { return 2000f; } }
        private float GetDefaultMaskNoiseOffsetX { get { return 0f; } }
        private float GetDefaultMaskNoiseOffsetY { get { return 0f; } }
        private AnimationCurve GetDefaultMaskDistanceToCentreMask { get { return AnimationCurve.EaseInOut(0f, 1f, 1f, 0f); } }
        private AnimationCurve GetDefaultMaskNoiseCurveModifier { get { return AnimationCurve.Linear(0f, 0.5f, 1f, 1f); } }
        private List<AnimationCurve> noiseCurveModifiers;
        private List<LBCurve.CurvePreset> noiseCurvePresets;
        private List<AnimationCurve> perOctaveNoiseCurveModifiers;
        private List<LBCurve.CurvePreset> perOctaveNoiseCurvePresets;
        private int keyInt = 0;
        private LBLayerFilter lbLayerFilter;
        private List<LBLayer> topographyLayers;
        private LBAreaHighlight areaHighlighter;
        private bool areaHighlighterEnabled = false;
        private bool areaHighlighterRequired = false;
        private LBVolumeHighlight volumeHighlighter = null;
        private bool volumeHighlighterEnabled = false;
        private bool volumeHighlighterRequired = false;
        private bool volumeHighligherJustEnabled = false;
        private LBLayer layerToRemove = null;
        private int insertLayerPos = -1;
        private LBLayer layerToMove = null;
        private int moveLayerPos = -1;

        private string rawDataSourceDisplayName = string.Empty;
        private ushort rawMinHeight = 0;
        private ushort rawMaxHeight = 0;

        private Texture2D heightmapImage;
        private bool imageReadWriteEnabled;
        //private int interpolationSmoothing = 0;
        private Texture2D blurredImage;

        private LBCurve.MapPathBlendCurvePreset newMapPathBlendCurvePreset;
        private LBCurve.MapPathHeightCurvePreset newMapPathHeightCurvePreset;
        private float mapPathMinHeight = 0f;
        private float mapPathMaxHeight = 2000f;

        // Layer Modifier variables
        private float layerModifierAddHeight = 0f;
        private float layerModifierYOffset = 0f;
        private float layerModifierVolumeYPos = 0f;
        private float layerModifierVolumeYScale = 0f;
        private Vector3 layerModifierMinPos = Vector3.zero;
        private Vector3 layerModifierMaxPos = Vector3.one;
        private string[] layerModifierNoneFoundArray = new string[] { "None Found" };
        private LBRaw.SourceFileType layerModifierSourceFileType = LBRaw.SourceFileType.RAW;
        float layerModifierPrevFloorOffsetY = 0f;
        float layerModifierPrevImageHeightScale = 0f;
        float layerModifierPrevAreaRectRotation = 0f;
        Rect layerModifierPrevAreaRect = new Rect();

        // Group variables
        private List<LBGroup> lbGroupList;
        private LBGroup groupToRemove = null;
        private int insertGroupPos = -1;
        private LBGroup groupToMove = null;
        private int moveGroupPos = -1;
        private int lbGroupMemberIdx = -1;
        private LBGroup lbGroup = null;
        private LBGroupMember lbGroupMember = null;
        private LBGroupMember groupMemberToRemove = null;
        private int insertGroupMemberPos = -1;
        private LBGroupMember groupMemberToMove = null;
        private LBGroupMember groupMemberInserted = null;
        private int moveGroupMemberPos = -1;
        private string groupMemberZoneToRemove = string.Empty;
        private int lastMouseOverGroupPos = -1;
        private int lastMouseOverGroupMemberPos = -1;
        private Color currentBgndColor = Color.white;
        private bool isGroupListExpanded = false;
        private bool isGroupDesignerEnabled = false;
        private bool isGroupDesignerInitialised = false;
        private LBGroupDesigner lbGroupDesigner = null;
        private LBGroup lbGroupShowLocations = null;
        private bool isShowGroupsInScene = false;
        private LBFilter groupLBFilter = null;
        private LBFilter groupLBFilterToRemove = null;
        private LBGroupZone lbGroupZone = null;
        private LBGroupZone lbGroupZoneToRemove = null;
        private int insertZonePos = -1;
        private LBGroupTexture lbGroupTexture = null;
        private LBGroupTexture lbGroupTextureToRemove = null;
        private string lbGroupTextureZoneToRemove = string.Empty;
        private LBGroupGrass lbGroupGrass = null;
        private LBGroupGrass lbGroupGrassToRemove = null;
        private string lbGroupGrassZoneToRemove = string.Empty;
        private Material manualClearingGroupMaterial = null;
        private LBGroup.LBGroupType prevGroupType = LBGroup.LBGroupType.Uniform;
        private Event grpCurrentEvt = null;
        private bool isGroupGUIDMissing = false;
        private bool isSubGroupNameListRefreshRequired = false;
        private float subGroupNameListLastRefreshed = 0f;
        // Group Member Object Path variables
        private LBObjPath lbObjPath = null;
        private bool isObjPathDesignerEnabled = false;
        private bool isObjPathDesignerInitialised = false;
        private LBObjPathDesigner lbObjPathDesigner = null;
        private int pathResolutionInt = 1;
        private int findZoomDistanceInt = 1;
        private int heightAboveTerrainInt = 1;
        private int pointDisplayScaleInt = 4;
        private int numPointsInList = 0;
        private bool isObjPathPointSelected = false;
        private int insertObjPathPointPos = -1;
        private int deleteObjPathPointPos = -1;
        private int findObjPathPointPos = -1;
        private LBPathPoint objPathPointToRemove = null;
        private LBPathPoint lbPathPoint = null;
        private int numMainPrefabsInList = 0;
        private LBObjPrefab objPrefabToRemove = null;
        private LBObjPrefab lbObjPrefab = null;
        private int deleteObjPrefabPos = -1;
        private int insertObjPathPrefabPos = -1;
        private List<string> groupMemberNameTypePrefabList;
        private List<string> groupMemberNameTypeObjPathList;
        private int groupMemberLookupIndex = -1;
        private int groupMemberLookupIndex2 = -1;
        private string groupMemberLookupName = string.Empty;
        private LBMapPath lbMapPathToImport = null;
        private int numObjPathSeriesInList = 0;
        private int deleteObjPathSeriesPos = -1;
        private int insertObjPathSeriesPos = -1;
        private int moveObjPathSeriesPos = -1;
        private LBObjPathSeries objPathSeriesToRemove = null;
        private LBObjPathSeries objPathSeriesToMove = null;
        private LBObjPathSeries objPathSeriesInserted = null;
        private LBObjPathSeries objPathSeries = null;
        private LBCurve.ObjPathHeightCurvePreset newObjPathProfileHeightCurvePreset;
        private int groupLookupIndex = -1;
        // The SubGroup GUID/Name lists are a pair and must remain in sync
        private List<string> subGroupGUIDList;
        private List<string> subGroupNameList;
        private int numMainSubGroupsInList = 0;
        private LBObjSubGroup objSubGroupToRemove = null;
        private LBObjSubGroup lbObjSubGroup = null;
        private int deleteObjSubGroupPos = -1;
        private int insertObjPathSubGroupPos = -1;

        // Group Copy and Paste Variables
        private LBGroupMember grpMbrCopy = null;
        private string grpMbrCopyGroupName = string.Empty;
        private LBGroup.LBGroupType grpMbrCopyGroupType = LBGroup.LBGroupType.Uniform;

        // Temporary erosion variables (TODO: DELETE after implementation in landscape script)
        private bool useHydraulicErosion = false;
        private int hydraulicErosionIterations = 10;
        private float hydraulicErosionStrength = 0.1f;
        private float hydraulicErosionRainfall = 10f;
        private float hydraulicErosionEvaporation = 0.5f;
        private float hydraulicErosionCarryingCapacity = 10f;

        private bool debugFinalPassWaterLevel = false;

        // Final pass variables

        private int finalPassSelectedTabInt = 0;
        private GUIContent[] finalPassTabTexts = { new GUIContent("Masks"), new GUIContent("Erosion"), new GUIContent("Smoothing") };

        // Modifier variables
        private LBTerrainHighlight terrainHighlighter = null;
        private bool terrainHighlighterEnabled = false;

        private bool isLandformCategoryDropdownRefreshRequired = true;
        private bool isLoadingModifierLandformLists = false;
        private bool isModifierLandformListsRefreshRequired = true;
        private bool isModifierCategoryLakeOrValley = false;
        private bool isModifierCategoryCustom = false;
        private int modifierLandformFileIndex = 0;
        private string previousLandformCategory = string.Empty;
        private int previousLandformFileIndex = -1;
        private bool hasLandformCategorySelectionChanged = false;
        private bool hasLandformFileTypeChanged = false;
        private List<string> modifierLandformHills = new List<string>();
        private List<string> modifierLandformLakes = new List<string>();
        private List<string> modifierLandformMesas = new List<string>();
        private List<string> modifierLandformMountains = new List<string>();
        private List<string> modifierLandformValleys = new List<string>();
        private List<string> modifierLandformCustom = new List<string>();

        private List<string> modifierLandformHillsRAW = new List<string>();
        private List<string> modifierLandformLakesRAW = new List<string>();
        private List<string> modifierLandformMesasRAW = new List<string>();
        private List<string> modifierLandformMountainsRAW = new List<string>();
        private List<string> modifierLandformValleysRAW = new List<string>();

        // Texturing variables
        private List<LBTerrainTexture> terrainTexturesList;
        private int selectedTexturingPreset = 0;
        private List<string> texturingPresetNames;
        private List<LBTerrainTexture> TerrainTexturesAvailableList;
        private string[] TerrainTexturesAvailableArray;
        private List<LBTerrainTexture> appliedTexturesList;
        private string[] appliedTexturesArray;
        private LBTextureFilter textureLBTextureFilter = null;
        private LBAreaHighlight textureFilterAreaHighlighter;
        private bool textureFilterAreaHighlighterEnabled = false;
        private LBTerrainTexture textureToRemove = null;
        private int insertTexturePos = -1;
        private bool isTextureListExpanded = false;
        private Event txtCurrentEvt = null;
        private int lastMouseOverTxtPos = -1;

        // Tree variables
        private List<LBTerrainTree> terrainTreesList;
        private int selectedTreePreset = 0;
        private List<string> treePresetNames;
        private int maxTreeAmount;
        private LBFilter treeLBFilter = null;
        private LBAreaHighlight treeAreaHighlighter;
        private bool treeAreaHighlighterEnabled = false;
        private LBTerrainTree treeToRemove = null;
        private int insertTreePos = -1;
        private bool isTreeImported = false;
        private bool isTreeListExpanded = false;

        // Grass variables
        private List<LBTerrainGrass> terrainGrassList;
        private int selectedGrassPreset = 0;
        private List<string> grassPresetNames;
        private LBFilter grassLBFilter = null;
        private LBAreaHighlight grassAreaHighlighter;
        private bool grassAreaHighlighterEnabled = false;
        private LBTerrainGrass grassToRemove = null;
        private int insertGrassPos = -1;
        // The list contains all pre-configured grasses
        private List<LBGrassConfig> grassConfigList;
        // Used to get the selected grass from LandscapeBuilderGrassSelector
        public LBGrassConfig lbGrassConfigSelected;
        public bool isGrassConfigSelected = false;
        // Used by GrassEditor to signal when a GrassConfigList has changed
        public bool isGrassConfigListDirty = false;
        private LBTerrainGrass lbTerrainGrassToConfigure;
        private bool isGrassImported = false;
        private bool isGrassListExpanded = false;
        private bool isGrassForGroupsOnly = false;
        // used for Group-level grass tab
        private List<LBTerrainGrass> appliedGrassList;
        private string[] appliedGrassArray;

        // HQ Photographic Integration variables
        private bool isHQPhotoPackVol1Installed = false;
        private bool isHQPhotoPackVol2Installed = false;
        private bool isRusticGrassInstalled = false;
        private string pathHQPhotoPackVol1 = string.Empty;
        private string pathHQPhotoPackVol2 = string.Empty;
        private string pathRusticGrass = string.Empty;

        // Mesh variables
        private List<LBLandscapeMesh> landscapeMeshList;
        private LBFilter meshLBFilter = null;
        private LBAreaHighlight meshAreaHighlighter;
        private bool meshAreaHighlighterEnabled = false;
        private LBLandscapeMesh meshToRemove = null;
        private LayerMask tempLayerMask;
        private LBLandscapeMesh meshToMove = null;
        private int moveMeshPos = -1;
        private int insertMeshPos = -1;
        private float maxClusterResolution = 1f;
        private bool isMeshPrefabListExpanded = false;

        // Export variables
        private bool saveTerrainDataFiles = true;
        private string terrainDataName = "LandscapeTerrainData";
        private string exportTerrainDataFolder = "LandscapeBuilder/TerrainData";
        private bool exportCreatePrefab = true;
        private string landscapePrefabName = "LandscapePrefab";
        private bool exportPackage = false;
        private string exportedPackageName = "LandscapePackage";
        private bool packageIncludeDependencies = true;
        private string exportPNGFileName = "LandscapeHeightmap";
        private string exportPNGFolderPath = "Assets/LandscapeBuilder/Images";
        private string exportPNGFilePath = string.Empty;
        private string exportPNGSubfolderName = string.Empty;
        private bool exportHeightmapNormalise = false;
        private bool exportMeshAddColliders = false;
        private bool exportMeshIncludeSplatmaps = false;
        private bool exportMeshIsStatic = false;
        private bool exportMeshIncludeOcclusionArea = false;  // Off by default, because it could create 200K temp files
        private bool exportMeshBakeOcclusion = false;
        private bool exportMeshUseMegaSplat = false;
        private bool exportMeshToProjectFolder = false;

        // Export EasyRoads3D Integration variables
        private string exportERFileName = "Road1";
        private int exportMapResolutionIndex = 2;   // 4096
        private float exportERLeftEdgeMinWidth = 0f;
        private float exportERLeftEdgeMaxWidth = 10f;
        private float exportERRightEdgeMinWidth = 0f;
        private float exportERRightEdgeMaxWidth = 10f;
        private bool exportERIncludeRoad = true;
        private bool exportERCombineRoads = false;
        private string exportERCombinedFileName = "CombinedRoads";
        private UnityEngine.Color exportERMapColour = UnityEngine.Color.blue;

        // Advanced variables
        private TextureImporter texImporter;
        private bool drawTreesAndFoliage = true;
        private bool autoSaveEnabled = true;
        private bool isNonSquareTerrainsEnabled = false;
        private bool isLegacyNoiseOffsetEnabled = false;

        // Stitch tool variables
        private LBLandscape stitchLandscape1 = null;
        private LBLandscape stitchLandscape2 = null;
        private int stitchEdgeDistance = 500;
        private float stitchLandscapeWeight = 0.5f;
        private bool stitchSetNeighbours = false;

        // MegaSplat variables
        private bool isMegaSplatInstalled = false;
        private string megaSplatVersion = string.Empty;
        private bool megaSplatAutoClosePainter = true;
        #if __MEGASPLAT__
        private Texture2DArray megaSplatT2Array2Copy = null;
        #endif

        // MicroSplat variables
        private bool isMicroSplatInstalled = false;

        // Vegetation Studio variables
        private bool isVegetationStudioInstalled = false;
        private bool isVegetationStudioProInstalled = false;
        #if VEGETATION_STUDIO
        private Camera cameraToRemove = null;
        #endif

        // Vegetation Studio Pro variables
        #if VEGETATION_STUDIO_PRO
        // cache this for Biomes in Groups
        AwesomeTechnologies.VegetationSystem.VegetationSystemPro vsPro = null;
        #endif

        // Render Pipeline variables
        private bool isURP = false;
        private bool isLWRP = false;
        private bool isHDRP = false;

        private bool disableAllTerrains = false;
        private bool sceneSaved;

        private GUIContent[] tabTexts = { new GUIContent(" Landscape"), new GUIContent(" Topography"), new GUIContent(" Groups"), new GUIContent(" Texturing"), new GUIContent(" Trees"), new GUIContent(" Grass"), new GUIContent(" Mesh/Prefab"), new GUIContent(" Export"), new GUIContent(" Advanced") };

        #endregion

        #region Public Delegates


        #endregion

        #region Static Readonly Strings
        // URL buttons
        private static readonly string btnTxtGetSupport = "Get Support";
        private static readonly string btnTxtBetaProgram = "Beta Program";
        private static readonly string btnTxtAssetPage = "Asset Page";
        private static readonly string urlGetSupport = "http://forum.unity3d.com/threads/387912";
        private static readonly string urlBetaProgram = "http://forum.unity3d.com/threads/401254";
        private static readonly string urlAssetPage = "http://u3d.as/oaN";
        private static readonly string urlDiscordChannel = "https://discord.gg/kv3tZ72";
        private static readonly string urlTutorials = "http://scsmmedia.com/lb.html#tutorials";

        #endregion

        #region Static GUIContent for Landscape
        private static readonly GUIContent btnHelpContent = new GUIContent("Help", "Requires Adobe Reader\nAvailable from\nadobe.com/reader");
        private static readonly GUIContent btnDiscordContent = new GUIContent("Discord", "Open LB Discord Channel in browser");

        private static readonly GUIContent smallResetButtonContent = new GUIContent("R", "Reset");
        private static readonly GUIContent scriptCurveContent = new GUIContent("S", "Script curve to Console window");
        private static readonly GUIContent scriptTerrainSettingsContent = new GUIContent("S", "Script Landscape Terrain Settings to Console window");

        // Landscape GUIContent
        private static readonly GUIContent landscapeNameContent = new GUIContent("Landscape Name", "The name of the landscape in the scene. Ensure that each name is unique in your project.");
        private static readonly GUIContent landscapeSizeContent = new GUIContent("Landscape Size", "The size of the generated landscape in metres");
        private static readonly GUIContent landscapeStartPositionContent = new GUIContent("Start position", "The start position of the generated landscape in metres");
        private static readonly GUIContent landscapeTerrainWidthContent = new GUIContent("Terrain Width", "The width in metres of each terrain on the x-axis in the generated landscape");
        private static readonly GUIContent landscapeTerrainLengthContent = new GUIContent("Terrain Length", "The length in metres of each terrain on the z-axis in the generated landscape");

        private static readonly GUIContent generateLandscapeContent = new GUIContent("Generate Landscape", "Create a new landscape within the scene");
        private static readonly GUIContent createNewLandscapeContent = new GUIContent("Create New Landscape", "Get the settings required to create a new landcape");
        private static readonly GUIContent zoomAllLandscapeContent = new GUIContent("Display", "Show the whole landscape in the Scene view");
        private static readonly GUIContent terrainLegacySpecularContent = new GUIContent("Specular Colour", "The specular colour of the terrains in this landscape");
        private static readonly GUIContent terrainLegacyShinninessContent = new GUIContent("Shininess", "The shininess value of the terrains in this landscape");
        private static readonly GUIContent terrainMaterialTypeContent = new GUIContent("Material Type", "The type of material to use for the terrains in this landscape");
        private static readonly GUIContent terrainSettingsPresetContent = new GUIContent("Terrain Settings Preset", "Can be used to update terrain settings with preset values");
        private static readonly GUIContent terrainCustomMatContent = new GUIContent("Material", "The material to use for the terrains in this landscape - should use a terrain shader");
        private static readonly GUIContent terrainMatMegaSplatContent = new GUIContent("Material", "The MegaSplat material to use for the terrains in this landscape");
        private static readonly GUIContent terrainMatMicroSplatContent = new GUIContent("Material", "The MicroSplat material to use for the terrains in this landscape");
        private static readonly GUIContent terrainUseRTPTesselationContent = new GUIContent("Tessellation", "Tessellation requires Texture Heightmaps. Turn on using Advanced Tab, then add in Texturing Tab.");
        private static readonly GUIContent terrainSettingsHeightContent = new GUIContent("Terrain Height", "The maximum height in metres of each terrain in the landscape");
        private static readonly GUIContent terrainSettingsPixelErrorContent = new GUIContent("Pixel Error", "The pixel error controls the detail level of distant terrain geometry - the lower the pixel error the higher the detail level, and at 0 detail level is reduced only for extremely distant terrain patches");
        private static readonly GUIContent terrainSettingsBaseMapDistanceContent = new GUIContent("Base Map Distance", "The maximum distance at which terrain textures will be displayed at full resolution");
        private static readonly GUIContent terrainSettingsAlphaMapResolutionContent = new GUIContent("Alpha Map Resolution", "Sometimes called the Control Texture resolution, it determines the splatmap resolution which contains the textures for the terrains. See Help for more details.");
        private static readonly GUIContent terrainSettingsTreeDistanceContent = new GUIContent("Tree Distance", "The maximum distance in metres from the camera that trees will be rendered");
        private static readonly GUIContent terrainSettingsTreeBillboardStartContent = new GUIContent("Tree Billboard Start", "The distance in metres from the camera at which trees will be rendered as 2D billboards");
        private static readonly GUIContent terrainSettingsDetailResolutionContent = new GUIContent("Grass (Detail) Resolution", "Determines the number of separate patches of detail (grass) within a terrain. Lower resolutions will provide more sparse grass and/or can be used with terrain sizes less than 1000x1000. (Default: 1024)");
        private static readonly GUIContent terrainSettingsDetailDistanceContent = new GUIContent("Grass (Detail) Distance", "The maximum distance in metres from the camera at which terrain details (grass) will be rendered");
        private static readonly GUIContent terrainSettingsDetailDensityContent = new GUIContent("Grass (Detail) Density", "The global density at which terrain details (grass) will be rendered (Default is 1). Lower values will affect how much grass can be applied on the Grass Tab");
        private static readonly GUIContent terrainSettingsTreeFadeDistanceContent = new GUIContent("Tree Fade Length", "Distance over which trees will transition between 3D objects and billboards");
        #if UNITY_2018_3_OR_NEWER
        private static readonly GUIContent terrainSettingsDrawInstancedContent = new GUIContent("Draw Instanced", "Terrain drawing will happen on the GPU. Requires Unity 2018.3 or newer.");
        private static readonly GUIContent terrainSettingsPerPixelNormalsContent = new GUIContent("Per Pixel Normals", "Terrain normals are per-pixel and are generated from the heightmap independently of the mesh LOD. When enabled, pixel error can be reduced to decrease terrain vertex count. Requires U2018.3+ and LWRP 4.0.1+ or U2019.3+ and URP 7.1.2+");
        private static readonly GUIContent terrainSettingsAutoConnectContent = new GUIContent("Auto Connect", "Used in U2018.3+ to set terrain neighbours. All terrains with the same GroupingID are automatically connected for LOD etc.");
        private static readonly GUIContent terrainSettingsGroupingIDContent = new GUIContent("Grouping ID", "Used in U2018.3+ when Auto Connect is enabled to set terrain neighbours. All terrains with the same GroupingID are automatically connected for LOD etc.");
        #endif
        private static readonly GUIContent terrainSettingsUseProjectForTDataContent = new GUIContent("Store TData in Project", "Store the terrain data files in the project folder rather than the scene (only recommended for large landscapes with 25+ terrains)");
        private static readonly GUIContent terrainSettingsGrassWindSpeedContent = new GUIContent("Speed", "The speed of the wind that affects the grass. Setting this to 0 won't disable wind for grass");
        private static readonly GUIContent terrainSettingsGrassRippleSizeContent = new GUIContent("Ripple Size", "The size of the grass ripples");
        private static readonly GUIContent terrainSettingsGrassWindBendingContent = new GUIContent("Grass Bending", "The degree to which the grass is bent by the wind. Setting this to 0 will disable wind for grass");
        private static readonly GUIContent terrainSettingsGrassWindTintContent = new GUIContent("Grass Tint", "The colour of the waving grass. Typically set to white so grass textured keep their original colour.");
        private static readonly GUIContent terrainSettingsUseVegetationSystemContent = new GUIContent("Use Vegetation System", "Automatically add Vegetation Studio scripts to terrains in the landscape. WARNING: The Landscape name must be unique in the whole project. Ensure Texturing, Grass, Trees, Groups tabs have been applied before enabling.");
        private static readonly GUIContent terrainSettingsUseVegetationSystemProContent = new GUIContent("Use Vegetation System", "Automatically add Vegetation Studio Pro scripts to terrains in the landscape. WARNING: The Landscape name must be unique in the whole project. Ensure Texturing, Grass, Trees, Groups tabs have been applied before enabling.");
        private static readonly GUIContent terrainSettingsUseVegetationSystemTexturesContent = new GUIContent("Apply Textures", "Apply the textures in the Landscape Builder Texturing tab with Vegetation Studio");
        private static readonly GUIContent terrainSettingsUseVegetationSystemTexturesAutoContent = new GUIContent("Auto Textures", "Enable LB textues for auto splat generation with Vegetation Studio (DEFAULT: OFF)");

        private static readonly GUIContent sceneWaterPrefabContent = new GUIContent("Water Prefab", "The prefab to use for water in the scene");
        private static readonly GUIContent scenePrimaryBodyOfWaterContent = new GUIContent("Primary Body of Water", "Is this the primary body of water in the scene? eg The ocean");
        private static readonly GUIContent sceneWaterLevelContent = new GUIContent("Water Level", "The height above 0 in metres to place the water in the scene");
        private static readonly GUIContent sceneKeepWaterAspectRatioContent = new GUIContent("Keep Aspect Ratio", "Keep the aspect ratio of the water prefab");
        private static readonly GUIContent sceneWaterResizingModeContent = new GUIContent("Water Resizing Mode", "How to resize the water to fit the landscape");
        private static readonly GUIContent sceneWaterMainCameraContent = new GUIContent("Main Camera", "The scene's main camera");
        private static readonly GUIContent sceneWaterPrimaryCausticPrefabContent = new GUIContent("Primary Caustic Prefab", "Creates the primary caustics that are projected below the surface");
        private static readonly GUIContent sceneWaterSecondaryCausticPrefabContent = new GUIContent("Second. Caustic Prefab", "Creates the secondary caustics that are projected below the surface");
        private static readonly GUIContent sceneWaterCausticPrefabContent = new GUIContent("Caustic Prefab", "Creates the caustics that are projected below the surface");
        private static readonly GUIContent sceneWaterCalmWaterMaterialContent = new GUIContent("Water Material", "Select a Calm Water material to apply to the body of water");
        private static readonly GUIContent sceneWaterSecondarySizeContent = new GUIContent("Water Size", "The size of the body of water to place in the scene. Use [ ] keys to increase or decrease size.");

        private static readonly GUIContent sceneUseLandscapeExtensionContent = new GUIContent("Enable Extension", "Extends the landscape towards the horizon using a flat low-poly mesh");
        private static readonly GUIContent sceneLandscapeExtensionHeightOffsetContent = new GUIContent("Height Offset", "The distance, in metres, to raise the extension mesh above 0 on the y-axis of the landscape.");

        private static readonly GUIContent addCameraAnimatorToSceneContent = new GUIContent("Camera Animation", "Creates a camera path and animator script as a child of the current landscape");
        private static readonly GUIContent addMapPathToLandscapeContent = new GUIContent("Map Path", "Creates a MapPath as a child of the current landscape");

        #endregion

        #region Static GUIContent for Templates
        private static GUIContent saveTemplateNameContent = new GUIContent("Template Name", "The name of the saved Landscape Template");
        private static GUIContent saveTemplateIncludeLBLightingContent = new GUIContent("Include LBLighting", "Includes LB Lighting configuration if it is present in the scene");
        private static GUIContent saveTemplateIncludePathsContent = new GUIContent("Include Paths", "Includes Camera or Map Paths if they are present in the scene. NOTE: Doesn't include Camera Animators. Object Path are automatically included with Groups.");
        private static GUIContent saveTemplateIncludePathMeshMatContent = new GUIContent("Include Path Mesh Mat", "Includes Map Path Mesh Materials if they are present in the scene.");
        private static GUIContent saveTemplateIncludeStencilContent = new GUIContent("Include Stencils", "Includes Stencils if they are present in the scene.");
        private static GUIContent saveTemplateExportPackageContent = new GUIContent("Export Package", "Whether a package containing the Template will be exported");
        private static GUIContent saveTemplateIncludeMapTexturesContent = new GUIContent("Include Map Textures", "Includes the Map Textures in the exported package. WARNING: These are the actual textures and will significantly increase the size of the package");
        private static GUIContent saveTemplateIncludeLayerHeightmapTexturesContent = new GUIContent("Include T. Layer Images", "Includes the Topography Layer Image Based Heightmap textures in the exported package. WARNING: These are the actual textures and will significantly increase the size of the package");
        private static GUIContent applyTemplateGotoFolderBtnContent = new GUIContent("F", "Find and highlight the default LB Template folder in the project hierarchy");
        private static GUIContent applyTemplateImportTerrainSettingsContent = new GUIContent("Import Terrain Settings", "Import and apply the terrain settings from the Template replace existing settings for this landscape (Default: Enabled)");
        private static GUIContent applyTemplateImportTopographyContent = new GUIContent("Import Topography", "Import the topography layers from the Template replace existing");
        private static GUIContent applyTemplateImportTexturesContent = new GUIContent("Import Textures", "Import the Textures from the Template and replace existing");
        private static GUIContent applyTemplateImportTreesContent = new GUIContent("Import Trees", "Import the Tree types from the Template and replace existing");
        private static GUIContent applyTemplateImportGrassContent = new GUIContent("Import Grass", "Import the Grass types from the Template and replace existing");
        private static GUIContent applyTemplateImportGroupsContent = new GUIContent("Import Groups", "Import the Groups from the Template and replace existing");
        private static GUIContent applyTemplateImportMeshesContent = new GUIContent("Import Mesh/Prefabs", "Import the Mesh/Prefabs from the Template and replace existing ones in the Mesh/Prefab tab.");
        private static GUIContent applyTemplateImportLBLightingContent = new GUIContent("Import LBLighting", "Import LB Lighting configuration if present in the Template. Overwrite any lighting in the scene.");
        private static GUIContent applyTemplateImportWaterContent = new GUIContent("Import Water", "Import Water (and apply) if present in the Template.");
        private static GUIContent applyTemplateImportPathsContent = new GUIContent("Import Paths", "Import Paths if present in the Template.");
        private static GUIContent applyTemplateRemoveOtherPathsContent = new GUIContent("Remove other Paths", "Remove Existing Paths in the landscape");
        private static GUIContent applyTemplateReplaceCamAnimatorsContent = new GUIContent("Replace Cam Animators", "Remove Existing Camera Animators in the landscape and hook up Camera Paths to default Camera Animators");
        private static GUIContent applyTemplateImportStencilsContent = new GUIContent("Import Stencils", "Import Stencils if present in the Template.");
        private static GUIContent applyTemplateRemoveOtherStencilsContent = new GUIContent("Remove other Stencils", "Remove Existing Stencils in the landscape");
        private static GUIContent applyTemplateIgnoreStartPositionContent = new GUIContent("Ignore Start Position", "Ignore the original template landscape start position and use current landscape position in world space");
        private static GUIContent applyTemplateUpdateTerrainHeightContent = new GUIContent("Update Terrain Height", "Set the height to the current landscape to match the template's terrain height");
        private static GUIContent applyTemplateMainCameraContent = new GUIContent("Main Camera", "The scene's main camera which is required for Templates that use AQUAS water or LBLighting");
        private static GUIContent applyTemplateApplyTopographyContent = new GUIContent("Apply Topography", "Build the landscape with the template topography layers");
        private static GUIContent applyTemplateApplyTexturesContent = new GUIContent("Apply Textures", "Apply the Textures from the template to the landscape");
        private static GUIContent applyTemplateApplyTreesContent = new GUIContent("Apply Trees", "Apply the Trees from the template to the landscape");
        private static GUIContent applyTemplateApplyGrassContent = new GUIContent("Apply Grass", "Apply the Grass from the template to the landscape");
        private static GUIContent applyTemplateApplyGroupsContent = new GUIContent("Apply Groups", "Apply the Groups from the template to the landscape");
        private static GUIContent applyTemplateApplyMeshContent = new GUIContent("Apply Mesh/Prefabs", "Apply the Mesh/Prefab tab settings from the template to the landscape");
        private static GUIContent applyTemplateApplyPathMeshesContent = new GUIContent("Apply Path Meshes", "Apply the Map Path Meshes from the template to the landscape only if Create Mesh was used in the source scene.");
        #endregion

        #region Static GUIContent for Topography Layers
        private static readonly GUIContent topoHeaderContent = new GUIContent("Used for the generation of heightmap data for each of the terrains in the landscape, this is " +
                                           " what defines the topography. For realworld use Image Modifier Layers or import (Geo)TIFF data.");
        private static readonly GUIContent layersDistanceToCentreMaskContent = new GUIContent("Mask Curve", "Curve that is used to specify the strength of the mask at varying distances from the centre of the landscape");
        private static readonly GUIContent layersMaskWarpAmountContent = new GUIContent("Warp Amount", "Factor the mask is warped by");
        private static readonly GUIContent layersMaskNoiseTileSizeContent = new GUIContent("Noise Tile Size", "Scaling of the noise on the x-z plane");
        private static readonly GUIContent layersMaskNoiseOffsetXContent = new GUIContent("Noise Offset X", "Offset of the noise on the x-axis");
        private static readonly GUIContent layersMaskNoiseOffsetZContent = new GUIContent("Noise Offset Z", "Offset of the noise on the z-axis");
        private static readonly GUIContent layersMaskNoiseCurveModifierContent = new GUIContent("Noise Curve Modifier", "Curve that is used to modify the output of the noise function");
        private static readonly GUIContent layersScriptContent = new GUIContent("S", "Script Layer to Console window");
        private static readonly GUIContent layersMoveLayerDownButtonContent = new GUIContent("V", "Move Layer down. If this is the last Layer, make it the first.");
        private static readonly GUIContent layersInsertLayerButtonContent = new GUIContent("I", "Insert new Layer above this Layer");
        private static readonly GUIContent layersTypeContent = new GUIContent("Layer Type", "The type of layer this is");
        private static readonly GUIContent layersNameContent = new GUIContent("Layer Name", "The user-defined descriptive name of the layer. Can be left blank if not required.");
        private static readonly GUIContent layersNoiseTileSizeContent = new GUIContent("Noise Tile Size", "Scaling of the noise on the x-z plane");
        private static readonly GUIContent layersNoiseOffsetXContent = new GUIContent("Noise Offset X", "Offset of the noise on the x-axis");
        private static readonly GUIContent layersNoiseOffsetZContent = new GUIContent("Noise Offset Z", "Offset of the noise on the z-axis");
        private static readonly GUIContent layersNoiseOctavesContent = new GUIContent("Noise Octaves", "Detail layers of the noise");
        private static readonly GUIContent layersNoiseDownscalingContent = new GUIContent("Downscaling", "How much the tile size of the noise is downscaled; the y-axis of the noise will be scale down proportionally. Increase this to get smaller scale details");
        private static readonly GUIContent layersNoiseLacunarityContent = new GUIContent("Noise Lacunarity", "Factor each octave of the noise is scaled down by on the x-z plane");
        private static readonly GUIContent layersNoiseGainContent = new GUIContent("Noise Gain", "Factor each octave of the noise is scaled by on the y-axis");
        private static readonly GUIContent layersNoiseWarpAmountContent = new GUIContent("Warp Amount", "Factor the noise is warped by");
        private static readonly GUIContent layersNoiseWarpOctavesContent = new GUIContent("Warp Octaves", "Detail of the noise warping");
        private static readonly GUIContent layersHeightScaleContent = new GUIContent("Height Scale", "Scaling of the noise on the y-axis");
        private static readonly GUIContent layersAdditiveAmountContent = new GUIContent("Additive Amount", "Approximately how much of this layer is added onto your landscape. If this layer does not appear to affect your topography, increase this value");
        private static readonly GUIContent layersRemoveBaseNoiseContent = new GUIContent("Remove Base Noise", "Whether the base noise will be removed when adding this layer on top of it");
        private static readonly GUIContent layersAddMinHeightContent = new GUIContent("Add Min Height", "Whether or not to add the minimum terrain height to the additive layer");
        private static readonly GUIContent layersAddHeightContent = new GUIContent("Add Height", "The amount of height (in metres) to add to the layer.");
        private static readonly GUIContent layersSubtractiveAmountContent = new GUIContent("Subtractive Amount", "Approximately how much of this layer is subtracted from your landscape. If this layer does not appear to affect your topography, increase this value");
        //private static GUIContent layersRemoveHeightContent = new GUIContent("Remove Height", "The amount of height (in metres) to subtract from the subtractive layer.");
        private static readonly GUIContent layersRestrictAreaContent = new GUIContent("Restrict Area", "Only apply this layer to a particular area or region of the landscape");
        private static readonly GUIContent layersAreaRectangleContent = new GUIContent("       Area Rectangle", "The area in the landscape that this layer will be applied to");
        private static readonly GUIContent layersAreaBlendRateContent = new GUIContent("Blend Rate", "The amount to blend the edges with the surrounding topography");
        private static readonly GUIContent layersOutputCurveModifiersContent = new GUIContent("<b>Output Curve Modifiers</b>", "Curve Modifiers that modify the overall output of this layer");
        private static readonly GUIContent layersPerOctaveCurveModifiersContent = new GUIContent("<b>Per Octave Curve Modifiers</b>", "Curve Modifiers that modify the output of each octave (or detail layer) of this layer");

        private static readonly GUIContent layersNormaliseInputContent = new GUIContent("Normalise Input", "The image grey scale values are adjusted to cover the whole range from black to white");
        private static readonly GUIContent layersImageRepairHolesContent = new GUIContent("Repair Holes", "Sometimes data is missing in source image files and it appears with 0 values. This will attempt to fix those data holes");
        private static readonly GUIContent layersThresholdRepairHolesContent = new GUIContent("Repair Threshold", "The higher the value, the more pixels with a grey scale value greater than 0 will be replaced.");
        private static readonly GUIContent layersImageHeightScaleContent = new GUIContent("Height Scale", "Scaling of the layer output on the y-axis");
        private static readonly GUIContent layersDetailSmoothRateContent = new GUIContent("Detail Smoothing", "The amount of detail-level smoothing to be applied after topography has been added");
        private static readonly GUIContent layersIsSmoothLayerOnlyContent = new GUIContent("Smooth Layer Only", "Only apply detail-level smoothing to this layer. Will ignore black areas of the heightmap image for this layer.");

        private static readonly GUIContent layersTypeModeContent = new GUIContent("Type Mode", "The Map Path layer type mode. SET is used to set the bottom and top heights of the path in the landscape. ADD is used when add (or removing) height from the current topography heights. FLATTEN is used to flatten the height perpendicular to the direction of the path.");
        private static readonly GUIContent layersMapPathBlendPresetContent = new GUIContent("Blend Preset", "The Blend Curve to use. 'Ease In Out' is the default and will rarely need to be changed.");
        private static readonly GUIContent layersBlendCurveContent = new GUIContent("Blend Curve", "This determines how the edges of the path blend in with the surrounding landscape topography. Although you can customise this curve the default should work in most circumstances.");
        private static readonly GUIContent layersMapPathHeightPresetContent = new GUIContent("Height Preset", "Select one of the presets to alter the Height Curve.");
        private static readonly GUIContent layersMapPathHeightCurveContent = new GUIContent("Height Curve", "This customisable curve determines the cross-section of the heights along the path. The curve is a visual representation of what that cross-section will look like.");

        private static readonly GUIContent layersHeightToAddContent = new GUIContent("Height To Add", "Height to add, in metres, on the y-axis");
        private static readonly GUIContent layersHeightToSubtractContent = new GUIContent("Height To Subtract", "Height to subtract, in metres, on the y-axis");
        private static readonly GUIContent layersSubtractNotAddContent = new GUIContent("Subtract", "The height scale will be subtracted from the y-axis rather than added");
        private static readonly GUIContent layersMapPathMinHeightContent = new GUIContent("Min Height", "Minimum height, in metres, on the y-axis");
        private static readonly GUIContent layersMapPathMaxHeightContent = new GUIContent("Max Height", "Maximum height, in metres, on the y-axis");

        private static readonly GUIContent layersLabelContent = new GUIContent("<b>Layers</b>", "Layers that together make up your topography");
        private static readonly GUIContent layersImportHeightmapContent = new GUIContent("Import", "Import existing terrains into a new Layer");
        private static readonly GUIContent layersImportRAWContent = new GUIContent("RAW", "Import RAW heightmap files into a new Unity Terrains Layer. There should be one file per terrain in the folder in the correct order. See Help for more details.");
        private static readonly GUIContent layersImportTIFFContent = new GUIContent("TIFF", "Import a single GeoTIFF heightmap file into a new Unity Terrains Layer. Typically SRTM NASA Space Shuttle data (30m or 90m) or airborne DEM data (1m or 30m pixels).");
        private static readonly GUIContent layersExportRAWContent = new GUIContent("Export RAW", "Export existing terrains as RAW heightmap files");
        private static readonly GUIContent layersRAWHeightScaleContent = new GUIContent("Height Scale", "Scaling of the RAW heightmap data on the y-axis (default: 1.0)");
        private static readonly GUIContent layersRAWFloorOffsetContent = new GUIContent("Floor Offset", "The height, in metres, that the floor of the data is raised to allow for you to add river bed, valleys, or swamps to the lowest point in the landscape (default: 0m).");
        private static readonly GUIContent layersRAWNormaliseInputContent = new GUIContent("Normalise Input", "The data values are adjusted to cover the whole range from the lowest point to the highest, and match those to your landscape height. For example, if the lowest point in the data is 100m, this will now be the set to a height of 0 in your terrain.");
        private static readonly GUIContent layersRAWisBelowSeaLevelContent = new GUIContent("Includes Below Sealevel", "Does the source data include height data that is below sea level. i.e. negative data. An example is GRMT data.");
        private static readonly GUIContent layersIsSourceDataNormalisedContent = new GUIContent("Is Source Normalised", "If the source data is already normalised. e.g. greyscale TIFF files from 3rd party products like World Creator");

        private static GUIContent layerFilterMapColourContent = new GUIContent("Colour", "The colour on the Map texture. For maps created with Map Paths, the colour should always be white");
        private static GUIContent layerFilterMapInverseContent = new GUIContent("Inverse", "Layer will not appear in the map areas");
        private static GUIContent layerFilterMapSmoothRateContent = new GUIContent("Smooth Rate", "The amount of smoothing that will be applied to the filtered area of the topography");
        private static GUIContent layerFilterStencilContent = new GUIContent("Stencil", "Layer Filter Stencil. NOTE: Stencil must be a child of the current landscape gameobject. Filters are AND'd together. A multi-layer Stencil can be added from the Landscape tab. Typically, you create 1 Stencil with 1 or more Stencil Layers.");
        #endregion

        #region Static GUIContent for Topography Layer Modifiers
        private static GUIContent layersModifierImportRAWContent = new GUIContent("Custom RAW", "Select and import a RAW image file for use in this image modifier layer");
        private static GUIContent layersModifierImportPNGContent = new GUIContent("Custom PNG", "Select and import a PNG image file for use in this image modifier layer");
        private static GUIContent layersModifierRefreshLandformListContent = new GUIContent("Refresh", "Refresh the list of landforms. This may be required if you've added files directly into the project folder.");
        private static GUIContent layersModifierModeContent = new GUIContent("Modifier Mode", "The modifier layer type mode. ADD will directly add (or remove) heights to the landscape. SET will set landscape heights directly, removing base noise");
        private static GUIContent layersModifierCategoryContent = new GUIContent("Category", "The modifier category is the style of landform. e.g. Hills, mountains, lakes etc.");
        private static GUIContent layersModifierAreaRectContent = new GUIContent("Area Rect", "The size and location of the area this modifier will affect");
        private static GUIContent layersModifierAreaRectRotationContent = new GUIContent("Area Rect Rotation", "The rotation of the area this modifier will affect");
        private static GUIContent layersModifierAdditiveAmountContent = new GUIContent("Additive Amount", "How much of this layer is added onto your landscape");
        private static GUIContent layersModifierSubtractiveAmountContent = new GUIContent("Subtractive Amount", "How much of this layer is subtracted from your landscape");
        private static GUIContent layersModifierSizeYContent = new GUIContent("Height", "Size of the modifier, in metres, on the y-axis");
        private static GUIContent layersModifierInvertContent = new GUIContent("Invert", "All the heights of the modifier will be inverted, so that the modifier cuts into the landscape instead of adding to it");
        private static GUIContent layersModifierYOffsetContent = new GUIContent("Y Offset", "Offset, in metres, of the modifier on the y-axis. When Invert is enabled, offset should be -ve to have effect.");
        private static GUIContent layersModifierUseBlendingContent = new GUIContent("Use Blending", "Whether the edges of the modifier will be blended with the surrounding landscape");
        private static GUIContent layersModifiersResetContent = new GUIContent("Reset", "Reset Modifier Settings to factory defaults");
        private static GUIContent layersModifiersUseWaterContent = new GUIContent("Add Water", "Add water to the Lake or Valley");
        private static GUIContent layersModifiersWaterMeshLandscapeUVContent = new GUIContent("Water Landscape UVs", "UVs for mesh that is created will be based on the dimensions of the landscape, rather than the actual mesh.");
        private static GUIContent layersModifiersWaterMeshUVTilingContent = new GUIContent("Water UV Tiling", "UVs for mesh that is created will be scaled or tiled in x and z directions of the landscape");
        private static GUIContent layersModifiersWaterLevelContent = new GUIContent("Water Level Offset", "The distance the water is offset from the top of the valley or lake modifier.");
        //private static GUIContent layersModifiersPrimaryCausticPrefabContent = new GUIContent("Primary Caustic Prefab", "Creates the primary caustics that are projected below the surface");
        //private static GUIContent layersModifiersSecondaryCausticPrefabContent = new GUIContent("Second. Caustic Prefab", "Creates the secondary caustics that are projected below the surface");
        private static GUIContent layersModifiersWaterResizingModeContent = new GUIContent("Water Type", "Which type of water to use for a lake or valley. Select Custom if your water type is not in the list and adjust UVs accordingly. You may also need to attach custom scripts to the camera if using Custom.");
        //private static GUIContent layersModifiersWaterKeepAspectRatioContent = new GUIContent("Keep Aspect Ratio", "Keep the aspect ratio of the water prefab");
        //private static GUIContent layersModifiersWaterPrefabContent = new GUIContent("Water Prefab", "The water prefab for this lake or valley");
        private static GUIContent layersModifiersWaterMeshMaterialContent = new GUIContent("Water Material", "The material used for the water");
        private static GUIContent commonMainCameraContent = new GUIContent("Main Camera", "The scene's main camera");

        #endregion

        #region GUIContent for Final Pass
        //private static GUIContent erosionTypeContent = new GUIContent("Erosion Type", "The type of erosion to apply to the topography in the final pass");

        private static GUIContent useThermalErosionContent = new GUIContent("Thermal Erosion", "Whether thermal erosion is applied to the topography in the final pass");
        private static GUIContent thermalErosionIterationsContent = new GUIContent("Iterations", "The number of iterations used during thermal erosion. More iterations will erode the topography more and will generally yield more accurate results, but will take more time to complete");
        private static GUIContent thermalErosionTalusAngleContent = new GUIContent("Talus Angle", "The angle that the slope of the topography will approach. Only slopes steeper than this angle will be eroded. Lower values will result in more erosion, while higher values will result in less (but more dramatic) erosion");
        private static GUIContent thermalErosionStrengthContent = new GUIContent("Strength", "How quickly the topography slope approaches the talus angle. Lower strengths will generally yield more accurate results but will require more iterations to reach the same level of erosion");
        private static GUIContent finalPassThErosionStencilContent = new GUIContent("Stencil", "Stencil. NOTE: Stencil must be a child of the current landscape gameobject.");

        private static GUIContent useFinalPassSmoothingContent = new GUIContent("Smoothing", "Whether smoothing is applied to the topography in the final pass");
        private static GUIContent finalPassSmoothingIterationsContent = new GUIContent("Iterations", "The number of iterations used during smoothing. More iterations will smooth the topography more, but will take more time to complete");
        private static GUIContent finalPassSmoothingPixelRangeContent = new GUIContent("Pixel Range", "The number of heightmap pixels on either side of each point in the topography that will be used for smoothing. A higher pixel range will result in smoothing over a larger distance, but will take more time to complete");
        private static GUIContent finalPassSmoothingStencilContent = new GUIContent("Stencil", "Stencil Layers can be used as a filter for where to smooth or not smooth. NOTE: Stencil must be a child of the current landscape gameobject.");
        #endregion

        #region GUIContent for Groups
        private static GUIContent[] groupsDesignerToolbarContent = new GUIContent[6];
        private readonly static GUIContent groupsDesignerToolbarGeneralContent = new GUIContent("General");
        private readonly static GUIContent groupsDesignerToolbarDefaultContent = new GUIContent("Default");
        private readonly static GUIContent groupsDesignerToolbarStencilContent = new GUIContent("Filters");
        private readonly static GUIContent groupsDesignerToolbarZoneContent = new GUIContent("Zones");
        private readonly static GUIContent groupsDesignerToolbarTextureContent = new GUIContent("Tex");
        private readonly static GUIContent groupsDesignerToolbarGrassContent = new GUIContent("Grass");

        #if VEGETATION_STUDIO_PRO
        private readonly static GUIContent groupsVSPBiomeContent = new GUIContent("Biome", "The biome or Vegetation Studio Pro package to use when creating the Biome Mask Area in the scene.");
        private readonly static GUIContent groupsVSPBiomeMinBlendDistContent = new GUIContent("Blend Distance", "The distance over which the edge of the biome will be blended with the surroundings.");
        #endif

        private readonly static GUIContent meshConvertToGroupsContent = new GUIContent("Convert", "Convert compatible meshes to Uniform Groups. Converted Mesh/Prefabs will be disabled. Some adjustments will need to be made and the Mesh/Prefab and Groups will need to be applied to the landscape.");
        private readonly static GUIContent groupsHeaderContent = new GUIContent("A powerful prefab placement system combining manual and procedural techniques. Turn off Auto Generate on Unity Lighting panel. If Flatten Terrain is used in a Group or Member, Topography tab settings will be applied first.");
        private readonly static GUIContent groupsTutorialsURLContent = new GUIContent("Tutorials", "Go to our website for a link to Video Tutorials about Groups and other LB concepts");
        private readonly static GUIContent groupsImportContent = new GUIContent("Import", "Create a new clearing group or subgroup based on prefabs selected in the Scene. Then give the new group a unique name and select the group type. NOTE: Ignore Proximity of Others is enabled on all imported members.");
        private readonly static GUIContent groupsScriptContent = new GUIContent("S", "Script Group to Console window. If output is truncated, Open Editor Log from console menu, scroll to end, and copy full text.");
        private readonly static GUIContent groupsMoveGroupDownButtonContent = new GUIContent("V", "Move Group down. If this is the last Group, make it the first. Groups higher in the list are placed in the scene before items lower in the list.");
        private readonly static GUIContent groupsInsertGroupButtonContent = new GUIContent("I", "Insert new Group above this Group");
        private readonly static GUIContent groupsDesignerEnableButtonContent = new GUIContent("Open Group Designer", "Used to visually design your group in the scene view. While in the Group Designer, right-click in the scene view for context menu.");
        private readonly static GUIContent groupsDesignerDisableButtonContent = new GUIContent("Close Group Designer", "Used to visually design your group in the scene view. Right-click in the scene view for context menu.");
        private readonly static GUIContent groupsManualClearingPosEnableButtonContent = new GUIContent("Edit Clearing Positions", "Used to add/edit/remove clearing positions in the scene view. While in Edit mode, right-click in the scene view for context menu.");
        private readonly static GUIContent groupsManualClearingPosDisableButtonContent = new GUIContent("Save Clearing Positions", "Stop editing clearing postions in the scene view. Right-click in scene view for context menu.");
        private readonly static GUIContent groupsDesignerRefreshButtonContent = new GUIContent("Refresh", "Refresh the group designer. Used when Auto Refresh is disable or is useful when changing the maximum radius of a clearing group or when testing potential locations for prefabs not placed with an offset from the centre. Right-click in the scene view for context menu.");
        private readonly static GUIContent groupsNameContent = new GUIContent("Group Name", "The unique name of this group");
        private readonly static GUIContent groupsTypeContent = new GUIContent("Group Type", "The type of group this is");
        private readonly static GUIContent groupsShowDetailsButtonContent = new GUIContent("","Show or hide group-wide settings");
        private readonly static GUIContent groupsMaxGroupsSqKmContent = new GUIContent("Max Groups Per Sqr Km", "Maximum number of groups that can be placed per square kilometre");
        private readonly static GUIContent groupsMinClearingRadiusContent = new GUIContent("Minimum Radius", "The minimum radius this group can be in the scene");
        private readonly static GUIContent groupsMaxClearingRadiusContent = new GUIContent("Maximum Radius", "The maximum radius this group can be in the scene");
        private readonly static GUIContent groupsIsFixedRotationContent = new GUIContent("Fixed Y Rotations", "Set a fixed y-axis rotation at each Clearing location in the scene. Edit Clearing Positions, select a clearing location in the scene, then use the rotation tool or set the value below.");
        private readonly static GUIContent groupsFixedRotationYContent = new GUIContent("Clearing Rotation Y", "The fixed y-axis rotation of the selected Clearing location in the scene. Adjust this value, use rotation tool or right-click for context menu on a location in the scene.");
        private readonly static GUIContent groupsStartClearingRotationYContent = new GUIContent("Start Rotation", "The starting rotation (in degrees) that the group will be randomly rotated on the Y-Axis");
        private readonly static GUIContent groupsEndClearingRotationYContent = new GUIContent("End Rotation", "The ending rotation (in degrees) that the group will be randomly rotated on the Y-Axis");
        private readonly static GUIContent groupsIsRemoveExistingGrassContent = new GUIContent("Remove Existing Grass", "Remove any existing (Unity Terrain Detail) grass from the group");
        private readonly static GUIContent groupsRemoveExistingGrassBlendDistContent = new GUIContent("Remove Min. Blend Dist", "The mininum distance over which grass being removed should be blended");
        private readonly static GUIContent groupsIsRemoveExistingTreesContent = new GUIContent("Remove Existing Trees", "Remove any existing (Unity Terrain) trees from the group");
        private readonly static GUIContent groupsProximityExtentContent = new GUIContent("Proximity Extent", "The minimum distance this group's centre can be from any other group's extent or edge");
        private readonly static GUIContent groupsIsTerrainFlattenContent = new GUIContent("Flatten Terrain", "Whether the topography (terrain) under and whole group will be flattened. If you wish to flatten the terrain for individual group members, disable this and set the member flatten options");
        private readonly static GUIContent groupsFlattenBlendRateContent = new GUIContent("Flatten Blend Rate", "The amount of the edges of the flattened area that will blend with the terrain. To apply the original terrain, on the Topography tab, click Generate Heightmap.");
        private readonly static GUIContent groupsFlattenHeightOffsetContent = new GUIContent("Flatten Height Offset", "Height in metres above the centre point to flatten (Default: 0). Used to raise or lower the flattened area.");
        private readonly static GUIContent groupsMinScaleContent = new GUIContent("Minimum Scale", "Default Group minimum scaling on the xyz-axes for members");
        private readonly static GUIContent groupsMaxScaleContent = new GUIContent("Maximum Scale", "Default Group maximum scaling on the xyz-axes for members");
        private readonly static GUIContent groupsMinHeightContent = new GUIContent("Minimum Height", "Default Group minimum height in metres that the members can be placed");
        private readonly static GUIContent groupsMaxHeightContent = new GUIContent("Maximum Height", "Default Group maximum height in metres that the members can be placed");
        private readonly static GUIContent groupsMinInclinationContent = new GUIContent("Minimum Inclination", "Default Group minimum inclination in degrees that the group can be placed");
        private readonly static GUIContent groupsMaxInclinationContent = new GUIContent("Maximum Inclination", "Default Group maximum inclination in degrees that the group can be placed");
        private readonly static GUIContent groupsFilterStencilContent = new GUIContent("Stencil", "Stencil Filter. Typically, you create 1 Stencil per landscape, with 1 or more Stencil Layers. NOTE: Stencil must be a child of the current landscape gameobject.");
        private readonly static GUIContent groupsFilterClearingRadiusContent = new GUIContent(" Consider Radius", "Consider the radius of the clearing when determining Group placement with a Stencil filter. For performance reasons this is only an estimate.");
        private readonly static GUIContent groupsIsWholeGroupContent = new GUIContent("Apply to whole Group", "Applies to all the area of each group in the scene");
        private readonly static GUIContent groupsTextureMinBlendDistContent = new GUIContent("Min. Blend Distance", "The minimum distance over which the texture is blended with A. the surroundings outside the extent of the clearing if >= 0 or B. the surroundings inside the extent of the clearing.");
        private readonly static GUIContent groupsGrassMinBlendDistContent = new GUIContent("Min. Blend Distance", "The minimum distance over which the grass is blended with A. the surroundings outside the extent of the clearing if >= 0 or B. the surroundings inside the extent of the clearing.");
        private readonly static GUIContent groupsTextureEdgeBlendDistContent = new GUIContent("Edge Blend Distance", "The number of metres over which to blend the zones with the surroundings");
        private readonly static GUIContent groupsGrassEdgeBlendDistContent = new GUIContent("Edge Blend Distance", "The number of metres over which to blend the zones with the surroundings");
        private readonly static GUIContent groupsZoneShowInSceneContent = new GUIContent("Hide in Designer", "Hide this zone in the Group Designer when the zones are displayed. Can be useful when zones overlap. All zones will still be applied, however this one will be hidden in the scene view.");
        private readonly static GUIContent groupsZoneAutoScaleContent = new GUIContent("Auto Scale", "When the Group Radius is changed, should the zone position and size also change?");
        //private readonly static GUIContent groupsTextureStrengthContent = new GUIContent("Strength")

        // GUIContent for Group Members
        private static GUIContent[] groupsMemberDesignerToolbarContent = new GUIContent[5];
        private readonly static GUIContent groupsMemberDesignerToolbarGeneralContent = new GUIContent("General");
        private readonly static GUIContent groupsMemberDesignerToolbarXYZContent = new GUIContent("XYZ");
        private readonly static GUIContent groupsMemberDesignerToolbarProximityContent = new GUIContent("Proximity");
        private readonly static GUIContent groupsMemberDesignerToolbarZoneContent = new GUIContent("Zones");
        private readonly static GUIContent groupsMemberDesignerToolbarPathContent = new GUIContent("Path");
        private static GUIContent[] groupsMemberObjPathToolbarContent = new GUIContent[4];
        private readonly static GUIContent groupsMemberObjPathToolbarObjectsContent = new GUIContent("Objects");
        private readonly static GUIContent groupsMemberObjPathToolbarPointsContent = new GUIContent("Points");
        private readonly static GUIContent groupsMemberObjPathToolbarSurfaceContent = new GUIContent("Surface");

        private readonly static GUIContent groupsMemberObjectPathButtonContent = new GUIContent("O", "Object Path group member type. Used to create objects along a spline and/or modify the topography in the group.");
        private readonly static GUIContent groupsMemberPrefabButtonContent = new GUIContent("O", "Switch from Object Path to the default Prefab group member type.");
        private readonly static GUIContent groupsMemberObjPathDesignerButtonContent = new GUIContent("Edit Object Path", "Open Object Path Designer. Once open, right-click in the scene view for context menu. In U2019+ Gizmos need to enabled to see the path.");
        private readonly static GUIContent groupsMemberObjPathDesignerClearingButtonContent = new GUIContent("Edit Object Path", "Open Object Path Designer. When the Object Path Designer is turned off, manually click the Refresh button at the top of the Group or right-click and select 'Refresh Group Designer' to redisplay all the Object Paths. Right-click in the scene view for context menu. In U2019+ Gizmos need to enabled to see the path.");
        private readonly static GUIContent groupsMemberObjPathRefreshButtonContent = new GUIContent("Refresh", "Refresh or repopulate the path with objects");
        private readonly static GUIContent groupsMoveGroupMemberDownButtonContent = new GUIContent("V", "Move Group Member down. If this is the last Group Member, make it the first.  Members higher in the list are placed in the scene before items lower in the list.");
        private readonly static GUIContent groupsInsertGroupMemberButtonContent = new GUIContent("I", "Insert new Group Member above this Group Member");
        private readonly static GUIContent groupsMemberShowHideAllButtonContent = new GUIContent("Group Members","Show or Hide all Group Members");
        private readonly static GUIContent groupsMemberOverrideContent = new GUIContent("Override Group Defaults", "Override the Group default settings for this Group Member");
        private readonly static GUIContent groupsMemberMinScaleContent = new GUIContent("Minimum Scale", "Minimum scaling on the xyz-axes for this member within the group");
        private readonly static GUIContent groupsMemberMaxScaleContent = new GUIContent("Maximum Scale", "Maximum scaling on the xyz-axes for this member within the group");
        private readonly static GUIContent groupsMemberMinHeightContent = new GUIContent("Minimum Height", "Minimum height in metres that this member can be placed within the group");
        private readonly static GUIContent groupsMemberMaxHeightContent = new GUIContent("Maximum Height", "Maximum height in metres that this member can be placed within the group");
        private readonly static GUIContent groupsMemberMinInclinationContent = new GUIContent("Minimum Inclination", "Minimum inclination in degrees that the member can be placed within the group");
        private readonly static GUIContent groupsMemberMaxInclinationContent = new GUIContent("Maximum Inclination", "Maximum inclination in degrees that the member can be placed within the group");
        private readonly static GUIContent groupsMemberPrefabContent = new GUIContent("Prefab", "Prefab to use for this group member");
        private readonly static GUIContent groupsMemberMaxPrefabSqKmContent = new GUIContent("Max Prefabs Per Sqr Km", "Maximum number of prefabs that can be placed per square kilometre for this group member.  For Object Path spacing, use the layout settings of a Default or Width-based Series in the Objects tab on the Object Path member.");
        private readonly static GUIContent groupsMemberMaxPrefabSqHectareContent = new GUIContent("Max Per Sqr Hectare", "Maximum number of prefabs that can be placed per square hectare (100m x 100m) within the clearing for this group member. For Object Path spacing, use the layout settings of a Default or Width-based Series in the Objects tab on the Object Path member.");
        private readonly static GUIContent groupsMemberMaxPerGroupContent = new GUIContent("Max Per Clearing","Maximum number of prefabs per Group clearing within the scene. Further restricts the number in a group AFTER Max Per Sqr Hectare is calculated.");
        private readonly static GUIContent groupsMemberKeepPrefabConnectionContent = new GUIContent("Keep Prefab Connection", "Keep the connection between the instantiated prefabs in the scene and the Prefab asset. Changing the Prefab will change all instances in the scene(s)");
        private readonly static GUIContent groupsMemberIsCombineMeshContent = new GUIContent("Combine Meshes", "Whether all the prefab meshes will be combined. Only recommended for static objects. Not recommended for prefabs that use LOD.");
        private readonly static GUIContent groupsMemberIsRemoveAnimatorContent = new GUIContent("Remove Animator", "When combining prefab meshes, remove any Animator components.");
        private readonly static GUIContent groupsMemberIsRemoveEmptyGameObjectContent = new GUIContent("Remove Empty", "Whether to remove empty gameobjects when combining Meshes. This can reduce the number of GameObjects in the scene if the prefabs don't contain additional scripts or components.");
        private readonly static GUIContent groupsMemberAddMeshColliderContent = new GUIContent("Add Mesh Collider", "Whether a mesh collider is added for each prefab's mesh. This will remove existing colliders.");
        private readonly static GUIContent groupsMemberIsPlacedInCentreContent = new GUIContent("Place in centre w/offset", "Is this prefab placed in a fixed location with an offset from the centre of the group? Turn off if you want one or more randomly placed within the group or zone(s) in the group.");
        private readonly static GUIContent groupsMemberMinOffsetYRandomiseOffContent = new GUIContent("Offset Y", "The offset on the y-axis for this member within the group");
        private readonly static GUIContent groupsMemberModelOffsetXYZContent = new GUIContent("Model Offset", "Local offset this prefab model. Typically, this can be left at 0, 0, 0 if the prefab is correctly zeroed.");
        private readonly static GUIContent groupsMemberMinOffsetXZContent = new GUIContent("Offset XZ", "Offset on the x and z-axis from the clearing centre for this prefab within the group");
        private readonly static GUIContent groupsMemberMinOffsetYContent = new GUIContent("Min Offset Y", "Minimum offset on the y-axis for this member within the group");
        private readonly static GUIContent groupsMemberMaxOffsetYContent = new GUIContent("Max Offset Y", "Maximum offset on the y-axis for this member within the group");
        private readonly static GUIContent groupsMemberRotationTypeContent = new GUIContent("Rotation Type", "How the group member will be rotated in relation to other items in the group.");
        private readonly static GUIContent groupsMemberRandomiseOffsetYContent = new GUIContent("Randomise Offset Y", "Randomly select an offset for the prefab on the y-axis between the minimum and maximum offset Y values");
        private readonly static GUIContent groupsMemberRandomiseRotationYContent = new GUIContent("Randomise Rotation Y", "Whether the y-axis rotation should be randomised");
        private readonly static GUIContent groupsMemberFixedRotationYContent = new GUIContent("Rotation Y", "The fixed Y rotation (in degrees) that the prefab will be rotated on the Y-Axis");
        private readonly static GUIContent groupsMemberStartRotationYContent = new GUIContent("Start Rotation Y", "The starting Y rotation (in degrees) that the prefab will be rotated on the Y-Axis");
        private readonly static GUIContent groupsMemberEndRotationYContent = new GUIContent("End Rotation Y", "The ending Y rotation (in degrees) that the prefab will be rotated on the Y-Axis");
        private readonly static GUIContent groupsMemberRandomiseRotationXZContent = new GUIContent("Randomise Rotation XZ", "Whether the additional x-axis and/or z-axis rotation should be randomised. This could be helpful to add some random wobble to a prefab.");
        private readonly static GUIContent groupsMemberOverrideRotationContent = new GUIContent("Rotation Override", "Used to override the X and Z rotations of a model that has a non-0 rotation");
        private readonly static GUIContent groupsMemberStartRotationXContent = new GUIContent("Start Rotation X", "The starting X rotation (in degrees) that the prefab will be additionally rotated on the X-Axis");
        private readonly static GUIContent groupsMemberEndRotationXContent = new GUIContent("End Rotation X", "The ending X rotation (in degrees) that the prefab will be additionally rotated on the X-Axis");
        private readonly static GUIContent groupsMemberStartRotationZContent = new GUIContent("Start Rotation Z", "The starting Z rotation (in degrees) that the prefab will be additionally rotated on the Z-Axis");
        private readonly static GUIContent groupsMemberEndRotationZContent = new GUIContent("End Rotation Z", "The ending Z rotation (in degrees) that the prefab will be additionally rotated on the Z-Axis");
        private readonly static GUIContent groupsMemberZoneEdgeFillContent = new GUIContent("Zone Edge Fill", "Only fill the edges of a zone. Select any edge for circle zones. Top, Bottom, Left and/or Right.");
        private readonly static GUIContent groupsMemberZoneEdgeFillDistContent = new GUIContent("Zone Fill Distance", "Distance towards centre of zone, to fill with prefabs.");
        private readonly static GUIContent groupsUseNoiseContent = new GUIContent("Use Noise", "Whether noise will be used to add variation to the prefab placement. For Path Objects, use the Placement Cutoff on the Layout tab.");
        private readonly static GUIContent groupsNoiseTileSizeContent = new GUIContent("Noise Tile Size", "Scaling of the noise on the x-z plane");
        private readonly static GUIContent groupsNoisePlacementCutoffContent = new GUIContent("Placement Cutoff", "The noise cutoff value for prefab placement. Increasing this value will mean more prefabs are placed");
        private readonly static GUIContent groupsMemberAlignWithTerrainContent = new GUIContent("Align with Terrain", "Whether the prefab will be aligned with the terrain normal or slope");
        private readonly static GUIContent groupsMemberIsTerrainFlattenContent = new GUIContent("Flatten Terrain", "Whether the topography (terrain) under and surrounding the prefab will be flattened. If you wish to flatten the terrain for all members of the group, consider using the Group Type of Clearing.");
        private readonly static GUIContent groupsMemberFlattenDistanceContent = new GUIContent("Flatten Distance", "Is the distance the terrain is flattened from the centre of the prefab.");
        private readonly static GUIContent groupsMemberFlattenBlendRateContent = new GUIContent("Flatten Blend Rate", "The amount of the edges of the flattened area that will blend with the terrain. To apply the original terrain, on the Topography tab, click Generate Heightmap.");
        private readonly static GUIContent groupsMemberFlattenHeightOffsetContent = new GUIContent("Flatten Height Offset", "Height in metres above the centre point to flatten (Default: 0). Used to raise or lower the flattened area.");
        private readonly static GUIContent groupsMemberFlattenCalcDistanceContent = new GUIContent("Estimate Flatten Dist.", "Estimate the flatten distance based on the extents of the prefab");
        private readonly static GUIContent groupsMemberCalcProximityButtonContent = new GUIContent("Calc Proximity", "Calculate the minimum proximity from the extents of the prefab");
        private readonly static GUIContent groupsMemberProximityExtentContent = new GUIContent("Proximity Extent", "The minimum distance this member can be from any other member's extents in any group");
        private readonly static GUIContent groupsMinGrassProximityContent = new GUIContent("Min Grass Proximity", "Grass within this distance of the centre of the object (multiplied by its scale) will be removed");
        private readonly static GUIContent groupsMemberRemoveGrassBlendDistContent = new GUIContent("Remove Min. Blend Dist", "The minimum distance over which grass being remove should be blended");
        private readonly static GUIContent groupsMemberIsIgnoreProximityOfOthersContent = new GUIContent("Ignore Prox of Others", "When this prefab is placed, it will not take into consideration the Proximity Extent of other prefabs in the Group. It may be placed close to other objects.");
        private readonly static GUIContent groupsMemberIsProximityIgnoredByOthersContent = new GUIContent("Prox Ignored by Others", "Other prefabs can be placed at the same position or near this prefab");
        private readonly static GUIContent groupsIsRemoveTreeContent = new GUIContent("Remove Trees", "Whether terrain trees near the prefab will be removed if within the Min Tree Proximity. If not enabled, prefabs will not be placed within the minimum tree proximity of a terrain tree.");
        private readonly static GUIContent groupsMinTreeProximityContent = new GUIContent("Min Tree Proximity", "Trees within this distance of the prefab will be removed (from the centre of the tree to the edge of the prefab proximity extent)");
        private readonly static GUIContent groupsMemberIsPathOnlyContent = new GUIContent("Use in Paths only", "This member will only be used to populate Object Paths");
        private readonly static GUIContent groupsMemberUsePathHeightContent = new GUIContent("Use Path Height", "Off by default, this can be used to make the prefabs follow the height of the Object Path rather than the terrain.");
        private readonly static GUIContent groupsMemberUseTerrainTrendContent = new GUIContent("Use Terrain Trend", "When the member is in a clearing or subgroup and Use Path Height is enabled, this will allow the path to also follow the trend or contours of the terrain.");
        private readonly static GUIContent groupsMemberUsePathSlopeContent = new GUIContent("Use Path Slope", "Off by default, this can be used to make the prefabs follow the slope of the Object Path. Only applies when the Object Path has Width.");
        private readonly static GUIContent groupsMemberIsLockTiltContent = new GUIContent("Lock Tilt", "If Align with Terrain is enabled, and the Orientation is Path Space, locking the Tilt angle will keep the Object upright along the path. Note: Other rotation settings will still be applied.");
        private readonly static GUIContent groupsMemberPathObjOrientationContent = new GUIContent("Orientation", "How the object is rotated and offset on Object Paths. When Path Space is used, x is in the forward direction of the path.");

        // GUIContent for Group Member Object Path
        private readonly static GUIContent groupsMemberPathNameContent = new GUIContent("Path Name", "Create a unique name for the Object Path in the project.");
        private readonly static GUIContent groupsMemberUseWidthContent = new GUIContent("Path has Width", "When enabled the object path can also be used to flatten topography, apply textures, and create meshes. It can also create objects with different layouts and offsets");
        private readonly static GUIContent groupsMemberShowPathInSceneContent = new GUIContent("Show Path in Scene", "When enabled the path will be displayed in the scene view");
        private readonly static GUIContent groupsMemberShowDistancesInSceneContent = new GUIContent("Show Distances", "When enabled the distances from the start will be displayed in the scene view");
        private readonly static GUIContent groupsMemberShowPointLabelsInSceneContent = new GUIContent("Show Point Labels", "When enabled the point labels will be displayed in the scene view.");
        private readonly static GUIContent groupsMemberShowSurroundingInSceneContent = new GUIContent("Show Surrounding", "When enabled the extent to which the path is blended with the surrounding topography is displayed in the scene view.");
        private readonly static GUIContent groupsMemberPathPointColourContent = new GUIContent("Display Colour", "The display path point and spline colour in the scene view.");
        private readonly static GUIContent groupsMemberPathResolutionContent = new GUIContent("Path Resolution", "This is the size of the segments that make up the path. A lower number will be a result in a higher quality path but will be slower to render. (Default: 2)");
        private readonly static GUIContent groupsMemberPathSnapToTerrainContent = new GUIContent("Snap to Terrain", "Should the path points follow the height of the terrain? When enabled, the Height Offset will be added to the terrain height.");
        private readonly static GUIContent groupsMemberPathResnapToTerrainButtonContent = new GUIContent("RE-SNAP", "Re-snap the path to the terrain.");
        private readonly static GUIContent groupsMemberZoomOnFindContent = new GUIContent("Zoom On Find", "Display the path point in the scene view, and zoom to the indicated distance");
        private readonly static GUIContent groupsMemberFindZoomDistanceContent = new GUIContent("Find Zoom", "The distance to zoom out when (F)inding a path point in the scene view");
        private readonly static GUIContent groupsMemberHeightOffsetContent = new GUIContent("Height Offset", "The points will maintain the height above the ground specified as they are drawn in the scene view. This will not affect how the prefabs (or subgroups) are placed unless 'Snap to Terrain' is enabled, and 'Use Path Height' is enabled on the member Path tab");
        private readonly static GUIContent groupsMemberPointDisplayScaleContent = new GUIContent("Point Display Size", "The relative size of the path point gizmos in the scene view");
        private readonly static GUIContent groupsMemberObjDefaultSeriesContent = new GUIContent("<b>Default Series</b>");
        private readonly static GUIContent groupsMemberObjSeriesListContent = new GUIContent("<b>Width-based Series</b>");
        private readonly static GUIContent groupsMemberObjSeriesNameContent = new GUIContent("Series Name", "Use a unique Series Name for the Object Path ");
        private readonly static GUIContent groupsMemberObjSeriesUseSubGroupsContent = new GUIContent("Use SubGroups", "Place whole groups of prefabs rather than individual prefabs along the Object Path");
        private readonly static GUIContent groupsMemberObjSeriesDownButtonContent = new GUIContent("V", "Move Series down. If this is the last Series, make it the first.  Series higher in the list are placed in the scene before items lower in the list.");
        private readonly static GUIContent groupsMemberObjSeriesButtonContent = new GUIContent("I", "Insert new Series above this Series");
        private readonly static GUIContent groupsMemberPathShowMemberButtonContent = new GUIContent("..", "Show the member and hide others");
        private readonly static GUIContent groupsMemberStartPrefabContent = new GUIContent("Start Member", "[Optional] Start prefab (or subgroup) to place as the first object in the path");
        private readonly static GUIContent groupsMemberEndPrefabContent = new GUIContent("End Member", "[Optional] End prefab to place as the last object in the path");
        private readonly static GUIContent groupsMemberStartSubGroupContent = new GUIContent("Start SubGroup", "[Optional] Start (Sub)Group to place as the first object in the path");
        private readonly static GUIContent groupsMemberEndSubGroupContent = new GUIContent("End SubGroup", "[Optional] End (Sub)Group to place as the last object in the path");
        private readonly static GUIContent groupsMemberObjTypeLayoutMethodContent = new GUIContent("Layout Method", "How the main prefabs (or subgroups) will be procedurally placed along the path");
        private readonly static GUIContent groupsMemberObjCopyButtonContent = new GUIContent("Cp", "Copy all points on the object path to the LB Copy Buffer");
        private readonly static GUIContent groupsMemberObjPasteButtonContent = new GUIContent("Paste", "Paste (REPLACE) all points in the object path with points in the LB Copy Buffer. WARNING: There is NO UNDO");
        private readonly static GUIContent groupsMemberObjSetWidthButtonContent = new GUIContent("W", "Change the width of all points on the object path");
        private readonly static GUIContent groupsMemberObjGetPointsButtonContent = new GUIContent("Get", "Get path points from an existing Map Path or the LB Copy Buffer");
        private readonly static GUIContent groupsMemberObjPointSpacingButtonContent = new GUIContent("Dis", "Evenly distribute the path points along the spline with a target spacing distance");
        private readonly static GUIContent groupsMemberObjReverseButtonContent = new GUIContent("<->", "Reverse the direction of the path points");
        private readonly static GUIContent groupsMemberObjResetRotationButtonContent = new GUIContent("Reset Rot.", "Will reset the rotation on each path point to 0 degrees on the z-axis. This will not affect member rotation rules.");
        private readonly static GUIContent groupsMemberObjSelectionMethodContent = new GUIContent("Selection Method", "How the main prefabs (or subgroups) will be selected from the list when being placed along the path");
        private readonly static GUIContent groupsMemberObjIsLastObjSnappedToEndContent = new GUIContent("Snap last obj to End", "If the objects do not fit evenly along the path, place the last object at the end of the path (rather than before the end)");
        private readonly static GUIContent groupsMemberObjPrefabsOnPathContent = new GUIContent("Objects on Path", "Exact number of prefabs on the path. You may also need to adjust the proximity settings for each member object on the path.");
        private readonly static GUIContent groupsMemberObjMaxMainPrefabsContent = new GUIContent("Objects per 100m", "Maximum number of prefabs (or subgroups) per 100m on the path. You may also need to adjust the proximity settings for each member object on the path.");
        private readonly static GUIContent groupsMemberObjPointSpacingDistContent = new GUIContent("Target Distance", "The target distance apart the spline path points should be.");
        private readonly static GUIContent groupsMemberObjSpacingDistContent = new GUIContent("Spacing Distance", "Distance apart each main prefab (or subgroup) should be placed (centre to centre). You may also need to adjust the proximity settings for each member object on the path to be slightly less than the spacing distance.");
        private readonly static GUIContent groupsMemberObjPathRanPerGroupRegionContent = new GUIContent("Randomise Per Group", "Each Group region or instance placed will use its own random seed. Has no effect for Uniform Groups.");
        private readonly static GUIContent groupsMemberObjPlacementCutoffContent = new GUIContent("Placement Cutoff", "How likely the objects will be placed at each position. Set below 1 for sparse placement.");
        private readonly static GUIContent groupsMemberObjRotationZContent = new GUIContent("Rotation Z", "The rotation on the z-axis (in degrees) of this path point. Prefab rotation will be blended between this point and the next. Prefabs will also have their own rotation applied.");
        private readonly static GUIContent groupsMemberObjPathWidthContent = new GUIContent("Total Width", "The total width of the path at this point.");
        private readonly static GUIContent groupsMemberObjPathSetWidthContent = new GUIContent("Set Width", "Set the same width to the whole path");
        private readonly static GUIContent groupsMemberObjPathAddWidthContent = new GUIContent("Add Width", "Add or subtract width to each point along the path");
        private readonly static GUIContent groupsMemberObjPathRemoveGrassContent = new GUIContent("Remove Existing Grass", "Remove existing grass from the path");
        private readonly static GUIContent groupsMemberObjPathRemoveTreesContent = new GUIContent("Remove Existing Trees", "Remove existing Unity terrain trees from the path");
        private readonly static GUIContent groupsMemberObjPathTreeDistFromEdgeContent = new GUIContent("Trees Dist. from Edge", "The distance from the left and right edges of the path that Unity terrain trees will be removed");

        // GUIContent for Group Member Object Path - Series
        private readonly static GUIContent groupsMemberObjPathSeriesOverrideContent = new GUIContent("Series Override", "Use a set of Series from another Group Member Object Path within the same Group. This allows you to use a common set of Series across multiple Object Paths.");
        private readonly static GUIContent groupsMemberObjPathSeriesOverrideMemberContent = new GUIContent("Override Path", "The Group Member (Object Path) which contains the master set of Series being used for the current Object Path.");
        private readonly static GUIContent groupsMemberObjPathStartMemberOffsetContent = new GUIContent("Start Member Offset", "Offset to positions after the start member. This is useful when the Start Member prefab is not the same size as the Main Members in the Object Path.");
        private readonly static GUIContent groupsMemberObjPathEndMemberOffsetContent = new GUIContent("End Member Offset", "Offset to end member if Snapped last obj to End is not enabled. This is useful when the End Member prefab is not the same size as the Main Members in the Object Path.");

        private readonly static GUIContent groupsMemberObjPathSplineContent = new GUIContent("Placement Spline", "The spline prefabs (or subgroups) will be procedurally placed along");
        private readonly static GUIContent groupsMemberObjPathPrefabOffsetZContent = new GUIContent("Object Offset Z", "The prefab (or subgroup) offset in path-space on the Z axis");
        private readonly static GUIContent groupsMemberObjPathPrefabStartOffsetContent = new GUIContent("Object Start Offset", "The distance from the start of the path to place the first prefab (or subgroup)");
        private readonly static GUIContent groupsMemberObjPathPrefabEndOffsetContent = new GUIContent("Object End Offset", "The distance from the end of the path to finish prefab (or subgroup) placement (actual last position will depend on spacing distance and if Snap last obj to End is enabled)");
        private readonly static GUIContent groupsMemberObjPathUse3DDistanceContent = new GUIContent("Use 3D Distance", "The distance along the path is calculated in 3D space rather than 2D space.");
        private readonly static GUIContent groupsMemberObjPathUseNonOffsetDistanceContent = new GUIContent("Use Non-Offset Distance", "The distance along the path is calculated on the Placement Spline rather than the spline created with the z-offset. This could be useful when aligning multiple Series of objects with a different Offset Z distance.");

        // GUIContent for Group Member Object Path - Surface
        private readonly static GUIContent groupsMemberObjPathIsTerrainFlattenContent = new GUIContent("Flatten Terrain", "Flatten the terrain along the length of the object path");
        private readonly static GUIContent groupsMemberObjPathProfileHeightCurveContent = new GUIContent("Profile Height", "The profile or cross-section of the surface height left to right on the path. Add Terrrain Height must be non-zero to have an effect.");
        private readonly static GUIContent groupsMemberObjPathProfileHeightCurvePresetContent = new GUIContent("Profile Preset", "Select one of the presets to modify the Profile Height curve (no undo)");
        private readonly static GUIContent groupsMemberObjPathSurroundBlendCurveContent = new GUIContent("Blend Curve", "Determines how the path is blended with the surrounding topography");
        private readonly static GUIContent groupsMemberObjPathFlattenDistanceContent = new GUIContent("Surround Distance", "The distance over which the surroundings will be blended with the flattened or textured object path surface");
        private readonly static GUIContent groupsMemberObjPathBlendStartContent = new GUIContent("Blend Start", "Blend the starting edge with the surrounds using the Surround Distance");
        private readonly static GUIContent groupsMemberObjPathBlendEndContent = new GUIContent("Blend End", "Blend the ending edge with the surrounds using the Surround Distance");
        private readonly static GUIContent groupsMemberObjPathSmoothSurroundingContent = new GUIContent("Surround Smoothing", "Apply some smoothing to the blended surroundings (Default: Off)");
        private readonly static GUIContent groupsMemberObjPathAddTerrainHeightContent = new GUIContent("Add Terrain Height", "Height to add in metres. Has no effect when the Profile Height curve is flat. To add height to the path, raise the height of the path points.");
        private readonly static GUIContent groupsMemberObjPathUseMeshSurfaceContent = new GUIContent("Surface Mesh", "Create a mesh for the surface of the Object Path");
        private readonly static GUIContent groupsMemberObjPathIsCreateSurfaceMeshColliderContent = new GUIContent("Mesh Collider", "Create a mesh collider for the surface mesh");
        private readonly static GUIContent groupsMemberObjPathMeshLandscapeUVContent = new GUIContent("Mesh Landscape UVs", "UVs for the surface mesh that is created will be based on the dimensions of the landscape, rather than the actual mesh. Can be useful when creating the water surface of a river.");
        private readonly static GUIContent groupsMemberObjPathMeshSwitchUVContent = new GUIContent("Mesh Switch UVs", "Switch the UVs so that they are tiled in path-space x (left-right) across the path and z (start-end) direction of the path.");
        private readonly static GUIContent groupsMemberObjPathMeshUVTilingContent = new GUIContent("Mesh UV Tiling", "UVs for mesh that is created will be scaled or tiled in path-space z (start-end) direction of path and x (left-right) across the path.");
        private readonly static GUIContent groupsMemberObjPathMeshYOffsetContent = new GUIContent("Mesh Y Offset", "The offset on the Y-axis between the Object Path spline and the mesh");
        private readonly static GUIContent groupsMemberObjPathFlattenMeshIndentContent = new GUIContent("Mesh Indent", "The distance the mesh is indented from the edge of the Object Path");
        private readonly static GUIContent groupsMemberObjPathMeshEdgeSnapToTerrain = new GUIContent("Mesh Edge Snap", "The edges of the mesh will be snapped to the height of the terrain");
        private readonly static GUIContent groupsMemberObjPathMeshSnapTypeContent = new GUIContent("Edge Snap Type", "How to snap the edges of the path to the terrain height");
        private readonly static GUIContent groupsMemberObjPathMeshIsDoubleSidedContent = new GUIContent("Is Double-sided", "Make the mesh double-sided. It will have twice the number of triangles as single-sided.");
        private readonly static GUIContent groupsMemberObjPathMeshMaterialContent = new GUIContent("Mesh Material", "The material used to render onto the path surface mesh");
        private readonly static GUIContent groupsMemberObjPathMeshBaseMaterialContent = new GUIContent("Mesh Base Material", "The material used to render onto the path base mesh");
        private readonly static GUIContent groupsMemberObjPathMeshBaseThicknessContent = new GUIContent("Mesh Base Thickness", "The thickness of a base mesh created under the surface mesh (Default 0 - no base will be created)");
        private readonly static GUIContent groupsMemberObjPathMeshBaseSwitchUVContent = new GUIContent("Mesh Base Switch UVs", "Switch the UVs so that they are tiled in path-space x (left-right) across the path and z (start-end) direction of the path.");
        private readonly static GUIContent groupsMemberObjPathMeshBaseUVTilingContent = new GUIContent("Mesh Base UV Tiling", "UVs for base mesh that is created will be scaled or tiled in path-space z (start-end) direction of path and x (left-right) across the path.");
        private readonly static GUIContent groupsMemberObjPathMeshBaseUseIndentContent = new GUIContent("Mesh Base Use Indent", "Use the (surface) Mesh Indent distance. This will make the base the same width as the surface mesh.");
        private readonly static GUIContent groupsMemberObjPathMeshBaseCreateColliderContent = new GUIContent("Mesh Base Collider", "Create a mesh collider for the Base Mesh");
        private readonly static GUIContent groupsMemberObjPathCoreTextureContent = new GUIContent("Core Texture", "The Texture from the Texturing Tab that will be used to texture the core of the Object Path on the terrain. Textures first need to be applied to the landscape from the Texturing tab. ");
        private readonly static GUIContent groupsMemberObjPathCoreStrengthContent = new GUIContent("Core Strength", "The strength of the texture on the core path being applied over any existing textures on the terrains");
        private readonly static GUIContent groupsMemberObjPathSurroundStrengthContent = new GUIContent("Surround Strength", "The strength of the texture on the path surroundings being applied over any existing textures on the terrains");
        private readonly static GUIContent groupsMemberObjPathSurroundTextureContent = new GUIContent("Surround Texture", "The Texture from the Texturing Tab that will be used to texture the surround of the Object Path on the terrain");
        private static readonly GUIContent groupsMemberObjPathTexNoiseTileSizeContent = new GUIContent("Noise Tile Size", "Scaling of the noise on the x-z plane. A value of 0 means no noise is applied. Small sizes will result in smaller regions of texture, while larger values will give larger textured areas.");

        #endregion

        #region Static GUIContent for Texturing
        private static readonly GUIContent texturingHeaderContent = new GUIContent("The texturing tab allows you to procedurally texture your landscape according to rules you define." +
                                             " To use Textures in other tabs, they must first be applied to the landscape here.");
        private static readonly GUIContent texturingImportContent = new GUIContent("Import", "Import existing textures (splatmaps) in the terrains");
        private static readonly GUIContent texturingScriptContent = new GUIContent("S", "Script Texture to Console window");
        private static readonly GUIContent texturingAddFilterContent = new GUIContent("Add Filter", "Add Area or Stencil Layer filter");
        private static readonly GUIContent texturingAreaRectContent = new GUIContent("       Area Rectangle", "The area in the landscape that this texture will be applied to");
        private static readonly GUIContent texturingFilterStencilContent = new GUIContent("Stencil", "Filter Stencil. NOTE: Stencil must be a child of the current landscape gameobject. A multi-layer Stencil can be added from the Landscape tab. Typically, you create 1 Stencil with 1 or more Stencil Layers.");
        private static readonly GUIContent texturingDisableAllContent = new GUIContent("Disable All Textures", "Can be used to temporarily remove all textures from the landscape by setting it on and clicking the 'Texture Landscape' button.");
        private static readonly GUIContent texturingIsTintedContent = new GUIContent("Is Tinted", "A tint is applied to the texture");
        private static readonly GUIContent texturingTintColourContent = new GUIContent("Tint Colour", "The tint to apply to the texture");
        private static readonly GUIContent texturingTintStrengthContent = new GUIContent("Tint Strength", "The amount of tint to apply to the texture");
        private static readonly GUIContent texturingIsRotatedContent = new GUIContent("Is Rotated", "Rotation is applied to the texture - Not available with Textures that have a Normal Map");
        private static readonly GUIContent texturingMinHeightContent = new GUIContent("Min Height", "Minimum height in metres that the texture will appear at");
        private static readonly GUIContent texturingMaxHeightContent = new GUIContent("Max Height", "Maximum height in metres that the texture will appear at");
        private static readonly GUIContent texturingMinInclinationContent = new GUIContent("Min Inclination", "Minimum inclination in degrees that the texture will appear at");
        private static readonly GUIContent texturingMaxInclinationContent = new GUIContent("Max Inclination", "Maximum inclination in degrees that the texture will appear at");
        private static readonly GUIContent texturingCurvatureTypeContent = new GUIContent("Curvature Type", "Concave (hollow, valley or cavity) or Convex (raised, cambered or curved outwards)");
        private static readonly GUIContent texturingCurvatureMinHeightDiffContent = new GUIContent("Min Height Difference", "The minimum difference in height required between surrounding points");
        private static readonly GUIContent texturingCurvatureDistanceContent = new GUIContent("Curvature Distance", "The distance in metres over which curvature of the terrain is calculated");
        private static readonly GUIContent texturingMapIsPathContent = new GUIContent("Is Map from Path?", "Was this map created from a Map Path or is it a grayscale texture? (Required when GPU acceleration is enabled)");
        private static readonly GUIContent texturingUseAdvMapToleranceContent = new GUIContent("Advanced", "Allows adjustment of tolerance per colour channel and curve-based blending");
        private static readonly GUIContent texturingMapToleranceContent = new GUIContent("Tolerance", "Colour tolerance on the map to allow for blended edges");
        private static readonly GUIContent texturingMapInverseContent = new GUIContent("Inverse", "The texture will not appear in the map areas unless Tolerance allows blended edges");
        private static readonly GUIContent texturingUseNoiseContent = new GUIContent("Use Noise", "Whether noise will be used to add variation to the texturing");
        private static readonly GUIContent texturingIsMinimalBlendContent = new GUIContent("Minimal Blending", "The strongest texture will rendered but edge blending will still take place");
        private static readonly GUIContent texturingNoiseTileSizeContent = new GUIContent("Noise Tile Size", "Scaling of the noise on the x-z plane. Small sizes will result in smaller regions of texture, while larger values will give larger areas.");
        private static readonly GUIContent texturingStrengthContent = new GUIContent("Strength", "Strength of the texture in the splatmap");

        #endregion

        #region Static GUIContent for Trees
        private readonly static GUIContent treesHeaderContent = new GUIContent("This allows you to procedurally populate your landscape with" +
                                           " trees according to rules you define. Stencil Layer filters can help define areas where trees should or should not be placed.");
        private readonly static GUIContent treeScriptContent = new GUIContent("S", "Script Tree to Console window");
        private readonly static GUIContent treeInsertAboveContent = new GUIContent("I", "Insert new (duplicate) Tree above this Tree");
        private readonly static GUIContent treeImportContent = new GUIContent("Import", "Import existing trees in the terrains");
        private readonly static GUIContent treePrefabContent = new GUIContent("Prefab", "Tree prefab to use");
        private readonly static GUIContent treeMaxTreePerSqKmContent = new GUIContent("Max Trees Per Sqr Km", "Maximum amount of this tree type that can be placed per square kilometre");
        private readonly static GUIContent treeBendFactorContent = new GUIContent("Bend Factor", "Bend factor of the tree - must be non-zero for it to be affected by a wind zone");
        private readonly static GUIContent treeMinScaleContent = new GUIContent("Min Scale", "Minimum scale (relative to the prefab) of each placed tree");
        private readonly static GUIContent treeMaxScaleContent = new GUIContent("Max Scale", "Maximum scale (relative to the prefab) of each placed tree");
        private readonly static GUIContent treeMinHeightContent = new GUIContent("Min Height", "Minimum height in metres that the tree can be placed at");
        private readonly static GUIContent treeMaxHeightContent = new GUIContent("Max Height", "Maximum height in metres that the tree can be placed at");
        private readonly static GUIContent treeMinInclinationContent = new GUIContent("Min Inclination", "Minimum inclination in degrees that the tree can be placed at");
        private readonly static GUIContent treeMaxInclinationContent = new GUIContent("Max Inclination", "Maximum inclination in degrees that the tree can be placed at");
        private readonly static GUIContent treeCurvatureTypeContent = new GUIContent("Curvature Type", "Concave (hollow, valley or cavity) or Convex (raised, cambered or curved outwards)");
        private readonly static GUIContent treeCurvatureMinHeightDiffContent = new GUIContent("Min Height Difference", "The minimum difference in height required between surrounding points");
        private readonly static GUIContent treeCurvatureDistanceContent = new GUIContent("Curvature Distance", "The distance in metres over which curvature of the terrain is calculated");
        private readonly static GUIContent treeMinProximityContent = new GUIContent("Min Proximity", "Minimum distance this tree can be from any other tree");
        private readonly static GUIContent treeOffsetYContent = new GUIContent("Offset Y", "The position the tree is offset from the ground level on the Y-Axis");
        private readonly static GUIContent treeLockWidthToHeightContent = new GUIContent("Lock Width To Height", "Whether the width to height ratio is locked to 1:1");
        private readonly static GUIContent treeUseNoiseContent = new GUIContent("Use Noise", "Whether noise will be used to add variation to the tree placement");
        private readonly static GUIContent treeNoiseTileSizeContent = new GUIContent("Noise Tile Size", "Scaling of the noise on the x-z plane");
        private readonly static GUIContent treePlacementCutoffContent = new GUIContent("Tree Placement Cutoff", "The noise cutoff value for tree placement. Increasing this value will mean more trees are placed");
        private readonly static GUIContent treeMapToleranceContent = new GUIContent("Tolerance", "Colour tolerance on the map to allow for blended edges");
        private readonly static GUIContent treeMapIsPathContent = new GUIContent("Is Map from Path?", "Was this map created from a Map Path?");
        private readonly static GUIContent treeMapInverseContent = new GUIContent("Inverse", "Trees will not appear in the map areas");
        private readonly static GUIContent treeIsTintedContent = new GUIContent("Is Tinted", "Whether the trees will be randomly colour tinted to provide colour variation in a forest. NOTE: Has no effect if the tree shader does not honour Unity Terrain TreeInstance color property.");
        private readonly static GUIContent treeMaxTintStrengthContent = new GUIContent("Max Tint Strength", "The maximum strength of the tint or colour variation that will be applied to trees");
        private readonly static GUIContent treeAddFilterContent = new GUIContent("Add Filter", "Add Texture, Area, or Stencil Layer filter");
        private readonly static GUIContent treeFilterStencilContent = new GUIContent("Stencil", "Filter Stencil. NOTE: Stencil must be a child of the current landscape gameobject. A multi-layer Stencil can be added from the Landscape tab. Typically, you create 1 Stencil with 1 or more Stencil Layers.");
        private readonly static GUIContent treeFilterAreaRectContent = new GUIContent("       Area Rectangle", "The area in the landscape that this tree type will be applied to");
        #endregion

        #region Static GUIContent for Grass
        private static readonly GUIContent grassHeaderContent = new GUIContent("The grass tab allows you to procedurally populate your landscape with" +
                                             " grass according to rules you define. Grass can also be used with Groups.");
        private static readonly GUIContent grassScriptContent = new GUIContent("S", "Script Grass to Console window");
        private static readonly GUIContent grassUseMeshPrefabContent = new GUIContent("Use Mesh Prefab", "Whether to use a mesh prefab instead of a texture. Consider turning off Auto Generate on Unity Lighting panel.");
        private static readonly GUIContent grassMeshPrefabContent = new GUIContent("Mesh Prefab", "Grass Mesh Prefab to use");
        private static readonly GUIContent grassImportContent = new GUIContent("Import", "Import existing grass patches in the terrains");
        private static readonly GUIContent grassAddFilterContent = new GUIContent("Add Filter", "Add Texture, Area or Stencil Layer filter");
        private static readonly GUIContent grassFilterStencilContent = new GUIContent("Stencil", "Filter Stencil. NOTE: Stencil must be a child of the current landscape gameobject");
        private static readonly GUIContent grassHealthyColourContent = new GUIContent("Healthy Colour", "The tint colour of the grass when it is 'healthy'");
        private static readonly GUIContent grassDryColourContent = new GUIContent("Dry Colour", "The tint colour of the grass when it is 'dry'");
        private static readonly GUIContent grassMinHeightContent = new GUIContent("Min Grass Height", "The minimum height of the grass in metres");
        private static readonly GUIContent grassMaxHeightContent = new GUIContent("Max Grass Height", "The maximum height of the grass in metres");
        private static readonly GUIContent grassMinWidthContent = new GUIContent("Min Grass Width", "The minimum width of the grass in metres");
        private static readonly GUIContent grassMaxWidthContent = new GUIContent("Max Grass Width", "The maximum width of the grass in metres");
        private static readonly GUIContent grassMinInclination = new GUIContent("Min Inclination", "Minimum inclination in degrees that the grass can be placed at");
        private static readonly GUIContent grassMaxInclination = new GUIContent("Max Inclination", "Maximum inclination in degrees that the grass can be placed at");
        private static readonly GUIContent grassCurvatureTypeContent = new GUIContent("Curvature Type", "Concave (hollow, valley or cavity) or Convex (raised, cambered or curved outwards)");
        private static readonly GUIContent grassCurvatureMinHeightDiffContent = new GUIContent("Min Height Difference", "The minimum difference in height required between surrounding points");
        private static readonly GUIContent grassCurvatureDistanceContent = new GUIContent("Curvature Distance", "The distance in metres over which curvature of the terrain is calculated");

        private static readonly GUIContent grassMinDensityContent = new GUIContent("Min Density", "The minimum density this grass can be in a patch");
        private static readonly GUIContent grassDensityContent = new GUIContent("Max Density", "How densely packed the grass is. Start with low values of 1 or 2 if using a mesh prefab for grass, flowers or detail objects. For mesh grass, consider turning off Auto Generate on Unity Lighting panel.");
        private static readonly GUIContent grassUseNoiseContent = new GUIContent("Use Noise", "Whether noise will be used to add variation to the grass placement");
        private static readonly GUIContent grassNoiseTileSizeContent = new GUIContent("Noise Tile Size", "Scaling of the noise on the x-z plane. The larger the tile size, the larger the grass patches become.");
        private static readonly GUIContent grassNoiseOctavesContent = new GUIContent("Noise Octaves", "Detail layers of the noise. Higher values will give more detailed shapes with less grass. To maintain similar amounts of grass, increase the Placement Cutoff.");
        private static readonly GUIContent grassNoisePlacementCutoffContent = new GUIContent("Grass Placement Cutoff", "The noise cutoff value for grass placement. Increasing this value will mean more grass is placed");
        #endregion

        #region Static GUIContent for Mesh
        private readonly static GUIContent meshPlacementSpeedContent = new GUIContent("Placement Speed", "Best is more accurate but slower");
        private readonly static GUIContent meshInsertAboveContent = new GUIContent("I", "Insert new (duplicate) Mesh above this Mesh");
        private readonly static GUIContent meshUsePrefabContent = new GUIContent("Use Prefab", "Whether to use a prefab instead of a mesh");
        private readonly static GUIContent meshPrefabContent = new GUIContent("Prefab", "Prefab to use");
        private readonly static GUIContent meshKeepPrefabConnectionContent = new GUIContent("Keep Prefab Connection", "Keep the connection between the instantiated prefabs in the scene and the Prefab asset. Changing the Prefab will change all instances in the scene(s)");
        private readonly static GUIContent meshIsCombineMeshContent = new GUIContent("Combine Meshes", "Whether all the prefab meshes will be combined. Only recommended for static objects. Not recommended for Prefabs that use LOD.");
        private readonly static GUIContent meshIsRemoveEmptyGameObjectContent = new GUIContent("Remove Empty", "Whether to remove empty gameobjects when combining Meshes. This can reduce the number of GameObjects in the scene if the prefabs don't contain additional scripts or components.");
        private readonly static GUIContent meshMeshContent = new GUIContent("Mesh", "The reference mesh to use");
        private readonly static GUIContent meshMaterialsContent = new GUIContent("Materials", "An array of materials to apply to the mesh");
        private readonly static GUIContent meshAddMeshColliderContent = new GUIContent("Add Mesh Collider", "Whether a mesh collider is added for each mesh. On Prefabs, this will remove existing colliders.");
        private readonly static GUIContent meshOffsetContent = new GUIContent("Offset", "A Vector3 offset to add to the position of each mesh");
        private readonly static GUIContent meshMaxMeshesContent = new GUIContent("Max Meshes Per Sqr Km", "Maximum amount of meshes that can be placed per square kilometre");
        private readonly static GUIContent meshMinScaleContent = new GUIContent("Min Scale", "Minimum scale of any placed mesh");
        private readonly static GUIContent meshMaxScaleContent = new GUIContent("Max Scale", "Maximum scale of any placed mesh");
        private readonly static GUIContent meshMinProximityContent = new GUIContent("Min Proximity", "The minimum proximity (in metres) to any other mesh or tree. Trees within this distance of the mesh will be removed. If Deploy as Clusters is enabled, it is the minimum distance between the centres of each cluster of objects.");
        private readonly static GUIContent meshRandomiseYRotationContent = new GUIContent("Randomise Y Rotation", "Whether the y-axis rotation should be randomised");
        private readonly static GUIContent meshFixedYRotationContent = new GUIContent("Y Rotation", "The fixed Y rotation (in degrees) that the mesh or prefab will be rotated on the Y-Axis");
        private readonly static GUIContent meshOverrideRotationContent = new GUIContent("Rotation Override", "Used to override the X and Z rotations of a model that has a non-0 rotation");
        private readonly static GUIContent meshAlignWithTerrainContent = new GUIContent("Align with Terrain", "Whether the mesh or prefab will be aligned with the terrain normal or slope");
        private readonly static GUIContent meshMinHeightContent = new GUIContent("Min Height", "Minimum height in metres that the mesh can be placed at");
        private readonly static GUIContent meshMaxHeightContent = new GUIContent("Max Height", "Maximum height in metres that the mesh can be placed at");
        private readonly static GUIContent meshMinInclinationContent = new GUIContent("Min Inclination", "Minimum inclination in degrees that the mesh can be placed at");
        private readonly static GUIContent meshMaxInclinationContent = new GUIContent("Max Inclination", "Maximum inclination in degrees that the mesh can be placed at");
        private readonly static GUIContent meshMapToleranceContent = new GUIContent("Tolerance", "Colour tolerance on the map to allow for blended edges");
        private readonly static GUIContent meshIsMapPathContent = new GUIContent("Is Map from Path?", "Was this map created from a Map Path?");
        private readonly static GUIContent meshMapInverseContent = new GUIContent("Inverse", "Meshes will not appear in the map areas");
        private readonly static GUIContent meshUseNoiseContent = new GUIContent("Use Noise", "Whether noise will be used to add variation to the mesh or prefab placement");
        private readonly static GUIContent meshNoiseTileSizeContent = new GUIContent("Noise Tile Size", "Scaling of the noise on the x-z plane");
        private readonly static GUIContent meshPlacementCutoffContent = new GUIContent("Placement Cutoff", "The noise cutoff value for mesh or prefab placement. Increasing this value will mean more meshes or prefabs are placed");
        private readonly static GUIContent meshIsClusteredContent = new GUIContent("Deploy as Clusters", "Whether multiple meshes or prefabs will be deployed around the same location. The central deployment position of the cluster is determined first according to the general Mesh or Prefab placement rules like Height, Inclination, Noise etc.");
        private readonly static GUIContent meshClusterDistanceContent = new GUIContent("Cluster Distance", "The x and z distance from the central placement position to the edge of the placement boundary.");
        private readonly static GUIContent meshClusterDensityContent = new GUIContent("Cluster Density", "The density influences the number of objects that are deployed in each cluster");
        private readonly static GUIContent meshClusterResolutionContent = new GUIContent("Cluster Resolution", "The distance apart the objects can be potentially placed within the cluster (from centre to centre)");

        private readonly static GUIContent meshRemoveGrassContent = new GUIContent("Remove Grass", "Whether grass near the mesh will be removed");
        private readonly static GUIContent meshMinGrassProximityContent = new GUIContent("Min Grass Proximity", "Grass within this distance of the centre of the object (mutliplied by its scale) will be removed");
        private readonly static GUIContent meshMinTreeProximityContent = new GUIContent("Min Tree Proximity", "Trees within this distance of the mesh or prefab will be removed (from the centre of the tree to the centre of the mesh or prefab)");
        private readonly static GUIContent meshIsTerrainFlattenContent = new GUIContent("Flatten Terrain", "Whether the topography (terrain) under and surrounding the mesh or prefab will be flattened.");
        private readonly static GUIContent meshFlattenDistanceContent = new GUIContent("Flatten Distance", "Is the distance the terrain is flattened from the centre of the mesh or prefab.");
        private readonly static GUIContent meshFlattenBlendRateContent = new GUIContent("Flatten Blend Rate", "The amount of the edges of the flattened area that will blend with the terrain. To apply the original terrain, on the Topography tab, click Generate Heightmap.");
        private readonly static GUIContent meshFlattenHeightOffsetContent = new GUIContent("Flatten Height Offset", "Height in metres above the centre point to flatten (Default: 0). Used to raise or lower the flattened area.");
        private readonly static GUIContent meshAddFilterContent = new GUIContent("Add Filter", "Add Texture, Area, Proximity or Stencil Layer filter");
        private readonly static GUIContent meshFilterAreaRectContent = new GUIContent("       Area Rectangle", "The area in the landscape that this mesh or prefab will be applied to");
        private readonly static GUIContent meshFilterMinProximityContent = new GUIContent("      Min Proximity", "Minimum distance this mesh or prefab can be from another object in the selected Unity Layers");
        private readonly static GUIContent meshFilterStencilContent = new GUIContent("Stencil", "Filter Stencil. NOTE: Stencil must be a child of the current landscape gameobject");
        #endregion

        #region Static GUIContent for Export
        private readonly static GUIContent exportSaveDataTerrainFilesContent = new GUIContent("Save Terrain Data Assets", "Whether the TerrainData files of the landscape will be saved in the project");
        private readonly static GUIContent exportTerrainDataAssetNameContent = new GUIContent("Terrain Data Asset Name", "The name of the saved TerrainData asset(s) - each will also have a numerical appendage");
        private readonly static GUIContent exportTerrainDataFolderContent = new GUIContent("Terrain Data Folder", "The path to the project folder where the terrain data will be stored");
        private readonly static GUIContent exportCreateLandscapePrefab = new GUIContent("Create Landscape Prefab", "Whether a prefab asset of the landscape will be created");
        private readonly static GUIContent exportLandscapePrefabName = new GUIContent("Prefab Asset Name", "The name of the saved Landscape Prefab asset");
        private readonly static GUIContent exportIsLandscapePackage = new GUIContent("Export Package", "Whether a package containing the saved assets will be exported");
        private readonly static GUIContent exportLandscapePackageName = new GUIContent("Package Name", "The name of the exported package");
        private readonly static GUIContent exportIncludeDependencies = new GUIContent("Include Dependencies", "Whether the exported package will include the dependencies of the saved assets");
        private readonly static GUIContent exportMoveTerrainDataBtnContent = new GUIContent("Move Terrain Data", "Move the terrain data from the scene to a project folder");

        private readonly static GUIContent exportHeightmapNormaliseContent = new GUIContent("Normalise Heights", "Output the heightmap so that it covers the full range of values from the minimum height to the maximum height of any point in the landscape.");
        private readonly static GUIContent exportMeshAddCollidersContent = new GUIContent("Add Colliders", "Whether colliders are added to the meshes created in the scene");
        private readonly static GUIContent exportMeshIsStaticContent = new GUIContent("Make Static", "Whether to make the terrain meshes static objects. NOTE: If Unity Lighting Auto baking is enabled, baking could take a considerable amount of time to complete.");
        private readonly static GUIContent exportMeshIncludeInclusionAreasContent = new GUIContent("Add Occlusion Areas", "Whether occlusion culling areas are added for each mesh. Once Occlusion Areas are baked, this can improve render performance.");
        private readonly static GUIContent exportMeshBakeInclusionContent = new GUIContent("Bake Occlusion", "Bake the Occlusion data after the Occlusion Areas have been added. This can also be done manually from the Unity Occlusion window after the meshes have been created.");
        private readonly static GUIContent exportMeshUseMegaSplatContent = new GUIContent("Use MegaSplat", "Configure the terrain meshes to use the MegaSplat shader. NOTE: Currently this feature is in Tech Preview.");
        private readonly static GUIContent exportMeshIncludeSplatmapsContent = new GUIContent("Include Splatmaps", "(Experimental) Whether to add splatmap textures to the meshes that are created in the scene. The current shader, LBMeshTerrain, only supports the first 5 textures.");
        private readonly static GUIContent exportMeshAddToProjectFolderContent = new GUIContent("Add to Project folder", "Save the Mesh Terrains to Assets/LandscapeBuilder/Meshes Project folder (Default: False - create in scene only). Landscape name must be unique in Project. Typically only used if you want to transfer mesh terrains to another scene, project or computer.");
        #endregion

        #region Static GUIContent Common
        private static GUIContent commonStencilEditButtonContent = new GUIContent("Edit", "Edit this Stencil in the scene view");
        private static GUIContent commonStencilNewButtonContent = new GUIContent("New", "Create a new Stencil in the scene view. Typically, you only need one Stencil as each one can have multiple Stencil Layers");

        #endregion

        #region Public Editor Window Methods

        // Add a menu item so that the editor window can be opened via the window menu tab
        [MenuItem("Window/Landscape Builder/Landscape Builder Editor")]
        public static void ShowWindow()
        {
            // Show existing window instance. If one doesn't exist, make one.
            EditorWindow.GetWindow(typeof(LandscapeBuilderWindow), false, "Landscape");
        }

        /// <summary>
        /// Select the LB Editor Window, and prepare the landscape for editing.
        /// Optionally, in the scene view, zoom into the landscape
        /// </summary>
        /// <param name="landscape"></param>
        /// <param name="zoomAll"></param>
        public static void SetLandscape(LBLandscape landscape, bool zoomAll = false)
        {
            // Show existing window instance. If one doesn't exist, make one.
            LandscapeBuilderWindow lbWin = EditorWindow.GetWindow(typeof(LandscapeBuilderWindow), false, "Landscape") as LandscapeBuilderWindow;
            if (lbWin != null)
            {
                lbWin.SelectLandscape(landscape);
                if (zoomAll) { lbWin.ZoomAllLandscape(); }
            }
        }

        #if UNITY_2019_1_OR_NEWER
        [UnityEditor.ShortcutManagement.Shortcut("Landscape Builder/Generate Heightmap",typeof(LandscapeBuilderWindow))]
        #endif
        /// <summary>
        /// Apply topography for the current landscape
        /// </summary>
        public static void ApplyCurrentTopography()
        {
            LBLandscape landscape = LBEditorCommon.currentLandscape;
            if (landscape != null && !EditorApplication.isPlayingOrWillChangePlaymode)
            {
                LandscapeBuilderWindow lbWin = GetActiveLBW();
                    
                if (lbWin != null && !lbWin.IsObjPathDesignerOpen(false))
                {
                    lbWin.GenerateTopography();
                    landscape.ApplyLayerWater(false, true);
                    if (lbWin.IsAutoSaveEnabled) { EditorSceneManager.SaveScene(EditorSceneManager.GetActiveScene()); }
                    else { EditorSceneManager.MarkSceneDirty(EditorSceneManager.GetActiveScene()); }
                }
            }
        }

        #if UNITY_2019_1_OR_NEWER
        [UnityEditor.ShortcutManagement.Shortcut("Landscape Builder/Texture Landscape",typeof(LandscapeBuilderWindow))]
        #endif
        /// <summary>
        /// Apply trees for the current landscape
        /// </summary>
        private static void ApplyCurrentTextures()
        {
            LBLandscape landscape = LBEditorCommon.currentLandscape;
            if (landscape != null && !EditorApplication.isPlayingOrWillChangePlaymode)
            {
                LandscapeBuilderWindow lbWin = GetActiveLBW();

                if (lbWin != null && !lbWin.IsObjPathDesignerOpen(false))
                {
                    lbWin.TextureLandscape();
                    if (lbWin.IsAutoSaveEnabled) { EditorSceneManager.SaveScene(EditorSceneManager.GetActiveScene()); }
                    else { EditorSceneManager.MarkSceneDirty(EditorSceneManager.GetActiveScene()); }
                }
            }
        }

        #if UNITY_2019_1_OR_NEWER
        [UnityEditor.ShortcutManagement.Shortcut("Landscape Builder/Populate Landscape with Trees",typeof(LandscapeBuilderWindow))]
        #endif
        /// <summary>
        /// Apply trees for the current landscape
        /// </summary>
        private static void ApplyCurrentTrees()
        {
            LBLandscape landscape = LBEditorCommon.currentLandscape;
            if (landscape != null && !EditorApplication.isPlayingOrWillChangePlaymode)
            {
                LandscapeBuilderWindow lbWin = GetActiveLBW();

                if (lbWin != null && !lbWin.IsObjPathDesignerOpen(false))
                {
                    lbWin.DisableTreeAreaHighlighter();
                    lbWin.ApplyTrees();
                    if (lbWin.IsAutoSaveEnabled) { EditorSceneManager.SaveScene(EditorSceneManager.GetActiveScene()); }
                    else { EditorSceneManager.MarkSceneDirty(EditorSceneManager.GetActiveScene()); }
                }
            }
        }

        #if UNITY_2019_1_OR_NEWER
        [UnityEditor.ShortcutManagement.Shortcut("Landscape Builder/Populate Landscape with Grass",typeof(LandscapeBuilderWindow))]
        #endif
        /// <summary>
        /// Apply grass for the current landscape
        /// </summary>
        private static void ApplyCurrentGrass()
        {
            LBLandscape landscape = LBEditorCommon.currentLandscape;
            if (landscape != null && !EditorApplication.isPlayingOrWillChangePlaymode)
            {
                LandscapeBuilderWindow lbWin = GetActiveLBW();

                if (lbWin != null && !lbWin.IsObjPathDesignerOpen(false))
                {
                    lbWin.DisableGrassAreaHighlighter();
                    lbWin.ApplyGrass();
                    if (lbWin.IsAutoSaveEnabled) { EditorSceneManager.SaveScene(EditorSceneManager.GetActiveScene()); }
                    else { EditorSceneManager.MarkSceneDirty(EditorSceneManager.GetActiveScene()); }
                }
            }
        }

        /// <summary>
        /// Get the current Landscape Builder editor which has focus
        /// </summary>
        /// <returns></returns>
        public static LandscapeBuilderWindow GetActiveLBW()
        {
            EditorWindow win = EditorWindow.focusedWindow;
            if (win != null && win.GetType() == typeof(LandscapeBuilderWindow))
            {
                return win as LandscapeBuilderWindow;
            }
            else { return null; };
        }

        public bool IsAutoSaveEnabled { get { return autoSaveEnabled; } }

        #endregion

        void OnGUI()
        {
            #region Initialisation

            // Set repaint to false at the start of every OnGUI call
            allowRepaint = false;

            defaultEditorLabelWidth = EditorGUIUtility.labelWidth;
            defaultEditorFieldWidth = EditorGUIUtility.fieldWidth;

            // Set up rich text GUIStyles

            helpBoxRichText = new GUIStyle("HelpBox");
            helpBoxRichText.richText = true;

            labelFieldRichText = new GUIStyle("Label");
            labelFieldRichText.richText = true;

            if (labelFieldRichTextCentred == null)
            {
                labelFieldRichTextCentred = new GUIStyle("Label")
                {
                    richText = true,
                    alignment = TextAnchor.MiddleCenter
                };
                labelFieldRichTextCentred.normal.textColor = Color.white;
                labelFieldRichTextCentred.fontSize = 14;
            }

            if (labelFieldHeaderBox == null)
            {
                labelFieldHeaderBox = new GUIStyle("Label")
                {
                    richText = true,
                    alignment = TextAnchor.UpperLeft,
                    fontSize = 10,
                    wordWrap = true
                };
                labelFieldHeaderBox.normal.textColor = Color.white;
            }

            if (versionBox == null) { versionBox = new GUIStyle("HelpBox") { fixedHeight = 22f }; }
            if (headerBox == null) { headerBox = new GUIStyle("HelpBox"); }

            buttonCompact = new GUIStyle("Button");
            buttonCompact.fontSize = 10;

            buttonCompactNoOffset = new UnityEngine.GUIStyle("Button");
            buttonCompactNoOffset.fontSize = 9;
            //buttonCompactNoOffset.margin = new RectOffset(0, 0, 1, 0);

            // For some reasons sometimes, it can be not null but be not set.. 
            //if (buttonCompact8 == null)
            {
                buttonCompact8 = new GUIStyle("Button");
                buttonCompact8.fontSize = 8;
            }

            labelsmallFieldRichText = new GUIStyle("Label");
            labelsmallFieldRichText.richText = true;
            labelsmallFieldRichText.wordWrap = true;
            labelsmallFieldRichText.fontSize = 9;

            displayTerrainNameLabel = new GUIStyle("Label");
            displayTerrainNameLabel.fontSize = 15;
            displayTerrainNameLabel.alignment = TextAnchor.MiddleCenter;
            displayTerrainNameLabel.normal.textColor = displayLabelColor;

            // Overide default styles
            EditorStyles.foldout.fontStyle = FontStyle.Bold;

            // When using a no-label foldout, don't forget to set the global
            // EditorGUIUtility.fieldWidth to a small value like 15, then back
            // to the original afterward.
            foldoutStyleNoLabel = new GUIStyle(EditorStyles.foldout);
            foldoutStyleNoLabel.fixedWidth = 0.01f;

            if (searchTextFieldStyle == null)
            {
                searchTextFieldStyle = new GUIStyle(GUI.skin.FindStyle("ToolbarSeachTextField"));
                searchTextFieldStyle.stretchHeight = false;
                searchTextFieldStyle.stretchWidth = false;
                searchTextFieldStyle.fontSize = 10;
                searchTextFieldStyle.fixedHeight = 16f;
                searchTextFieldStyle.fixedWidth = defaultSearchTextFieldWidth;
            }

            if (searchCancelButtonStyle == null)
            {
                searchCancelButtonStyle = new GUIStyle(GUI.skin.FindStyle("ToolbarSeachCancelButton"));
            }

            if (line1Style == null)
            {
                line1Style = new GUIStyle(EditorStyles.helpBox);
                // Pad top and bottom of line by 3 pixels
                line1Style.margin = new RectOffset(0, 0, 4, 3);
                line1Style.border = new RectOffset(0, 0, 1, 1);
            }

            // Set up the toggle buttons styles
            if (toggleCompactButtonStyleNormal == null)
            {
                // Create a new button or else will effect the Button style for other buttons too
                toggleCompactButtonStyleNormal = new GUIStyle("Button");
                toggleCompactButtonStyleToggled = new GUIStyle(toggleCompactButtonStyleNormal);
                toggleCompactButtonStyleNormal.fontStyle = FontStyle.Normal;
                toggleCompactButtonStyleToggled.fontStyle = FontStyle.Bold;
                toggleCompactButtonStyleToggled.normal.background = toggleCompactButtonStyleToggled.active.background;
            }

            if (toggleTinyButtonStyleNormal == null)
            {
                // Create a new button or else will effect the Button style for other buttons too
                toggleTinyButtonStyleNormal = new GUIStyle(toggleCompactButtonStyleNormal);
                toggleTinyButtonStyleToggled = new GUIStyle(toggleCompactButtonStyleToggled);
                toggleTinyButtonStyleNormal.fontSize = 9;
                toggleTinyButtonStyleToggled.fontSize = 9;
                toggleTinyButtonStyleToggled.normal.background = toggleTinyButtonStyleToggled.active.background;
            }

            if (!hasRetrievedSavedData)
            {
                // Retrieve saved data if needed
                autoSaveEnabled = LBLandscape.GetAutoSaveState();
                isNonSquareTerrainsEnabled = LBLandscape.GetIsNonSquareTerrainsEnabled();
                isLegacyNoiseOffsetEnabled = LBLandscape.GetIsLegacyNoiseOffsetEnabled();

                // Fetch the last used landscape name from disk and try and find it in the scene
                string lastLandscapeGameObjectName = LBLandscape.GetLastLandscapeGameObjectSelection();
                landscapeGameObjectSelection = GameObject.Find(lastLandscapeGameObjectName);

                disableAllTerrains = LBLandscape.GetDisableAllTextures();

                megaSplatAutoClosePainter = LBLandscape.GetMegaSplatAutoClosePainter();

                hasRetrievedSavedData = true;
            }

            if (isModifierLandformListsRefreshRequired) { RefreshModifierLists(layerModifierSourceFileType.ToString()); }

            // If can't find LB Default Resources prefab the user has probably moved
            // the LandscapeBuilder folder from it's original location in Assets/LandscapeBuilder.
            if (!isDefaultResourcesValid)
            {
                EditorGUILayout.HelpBox("Did you move the LandscapeBuilder folder into a non-default location? i.e. Is not directly under the Assets folder.", MessageType.Error, true);
            }

            // Retrieve preset names from Default Resources prefab
            if (texturingPresetNames == null || treePresetNames == null || grassPresetNames == null) { GetDRPresetNames(); }

            EditorGUILayout.Space();
            // Display the different tabs
            //selectedTabInt = GUILayout.SelectionGrid(selectedTabInt, tabTexts, 3);
            selectedTabInt = GUILayout.SelectionGrid(selectedTabInt, tabTexts, 3, EditorStyles.toolbarButton);
            EditorGUILayout.Space();

            if (landscape != null && (topographyLayers != null || terrainTexturesList != null || terrainTreesList != null || terrainGrassList != null || landscapeMeshList != null || lbGroupList != null))
            {
                landscape.SaveEditorSettings(topographyLayers, terrainTexturesList, terrainTreesList, terrainGrassList, landscapeMeshList, lbGroupList);
            }

            if (landscape != null) { landscape.gameObject.SetActive(true); }

            if (selectedTabInt != 0)
            {
                // If the water higlighter exists but we are not in the landscape tab, get rid of it
                if (waterHighlighter != null) { DestroyImmediate(waterHighlighter.gameObject); waterHighlighterEnabled = false; }

                // If we are not in the landscape tab, set mouseClickEvent to false so that it doesn't appear as true
                // when you first go into the landscape tab, except when the modifier terrainHighlighter is in use
                if (selectedTabInt != 2 && terrainHighlighter == null) { mouseClickEvent = false; terrainHighlighterEnabled = false; }

                // Added in Version 1.1
                if (landscapeGameObjectSelection != null)
                {
                    CheckSwitchLandscapeSelection(false);
                }
                else if (landscape != null)
                {
                    // "None" was selected from the list of assets in the scene
                    landscapeGameObjectSelection = null;
                    landscapeSelection = null;
                    landscape = null;
                    lbGroupShowLocations = null;
                    // Added 2.1.5
                    LBEditorCommon.currentLandscape = null;
                    isReparentRequired = false;
                }

                // Set settings variables to the corresponding settings of the selected landscape
                if (landscape != null && landscapeGameObject != null)
                {
                    GetLandscapeTerrainSettings();
                }

                // Disable the height picker if not in the landscape tab
                heightPickerEnabled = false;
                if (heightPickerHighlighter != null) { DestroyImmediate(heightPickerHighlighter.gameObject); mouseClickEvent = false; }
            }
            if (selectedTabInt != 1)
            {
                // If the area higlighter exists but we are not in the topography tab, get rid of it
                if (areaHighlighter != null) { DestroyImmediate(areaHighlighter.gameObject); areaHighlighterEnabled = false; }
                // If the volume higlighter exists but we are not in the topography tab, get rid of it
                if (volumeHighlighter != null) { DestroyImmediate(volumeHighlighter.gameObject); volumeHighlighterEnabled = false; }
            }
            if (selectedTabInt != 2)
            {
                // If the terrain higlighter exists but we are not in the modifiers tab, get rid of it
                if (terrainHighlighter != null) { DestroyImmediate(terrainHighlighter.gameObject); terrainHighlighterEnabled = false; }

                // If we are not in the modifiers tab, set mouseClickEvent to false so that it doesn't appear as true
                // when you first go into the modifiers tab, except when the waterHighlighter is in use
                if (selectedTabInt != 0 && waterHighlighter == null) { mouseClickEvent = false; }
            }
            if (selectedTabInt != 3)
            {
                // If the texture filter area higlighter exists but we are not in the texturing tab, get rid of it
                if (textureFilterAreaHighlighter != null) { DestroyImmediate(textureFilterAreaHighlighter.gameObject); textureFilterAreaHighlighterEnabled = false; }
            }

            if (selectedTabInt != 4)
            {
                // If the tree filter area higlighter exists but we are not in the tree tab, get rid of it
                if (treeAreaHighlighter != null) { DestroyImmediate(treeAreaHighlighter.gameObject); treeAreaHighlighterEnabled = false; }
            }

            if (selectedTabInt != 5)
            {
                // If the grass filter area higlighter exists but we are not in the grass tab, get rid of it
                if (grassAreaHighlighter != null) { DestroyImmediate(grassAreaHighlighter.gameObject); grassAreaHighlighterEnabled = false; }
            }

            if (selectedTabInt != 6)
            {
                // If the mesh filter area higlighter exists but we are not in the mesh tab, get rid of it
                if (meshAreaHighlighter != null) { DestroyImmediate(meshAreaHighlighter.gameObject); meshAreaHighlighterEnabled = false; }
            }

            if (selectedTabInt != 7)
            {
                if (landscape != null && landscapeGameObject != null)
                {
                    terrainDataName = landscapeGameObject.name + "TerrainData";
                    landscapePrefabName = landscapeGameObject.name + "Prefab";
                    exportedPackageName = landscapeGameObject.name + "Package";
                }
            }
            if (selectedTabInt != 8)
            {
                if (landscape != null && landscapeGameObject != null)
                {
                    drawTreesAndFoliage = landscape.GetLandscapeTerrainDrawTreesAndFoliage();
                }
            }

            #endregion

            if (selectedTabInt == 0)
            {
                // Landscape tab
                #region LandscapeTab

                DrawTitleTex();

                #region Initialise URLs Update Import Create Landscape
                GUILayout.BeginVertical("HelpBox");
                //EditorGUILayout.LabelField("<b>Landscape Builder</b> Version " + LBVersion + " " + LBBetaVersion, labelFieldRichText);
                GUILayout.BeginHorizontal();
                if (GUILayout.Button(btnTxtGetSupport, buttonCompact)) { Application.OpenURL(urlGetSupport); }
                if (GUILayout.Button(btnTxtBetaProgram, buttonCompact)) { Application.OpenURL(urlBetaProgram); }
                //if (GUILayout.Button(btnTxtGetSupport, buttonCompact)) { Application.OpenURL("https://community.unity.com/t5/Asset-Store/Landscape-Builder/td-p/2575993"); }
                //if (GUILayout.Button(btnTxtBetaProgram, buttonCompact)) { Application.OpenURL("https://community.unity.com/t5/Asset-Store/BETA-PROGRAM-Landscape-Builder/m-p/2567080"); }
                if (GUILayout.Button(btnDiscordContent, buttonCompact)) { Application.OpenURL(urlDiscordChannel); }
                if (GUILayout.Button(btnTxtAssetPage, buttonCompact)) { Application.OpenURL(urlAssetPage); }
                if (GUILayout.Button(btnHelpContent, buttonCompact)) { Application.OpenURL(lbHelpPDF); }
                EditorGUILayout.EndHorizontal();

                EditorGUILayout.Space();
                EditorGUI.BeginChangeCheck();
                landscapeGameObjectSelection = (GameObject)EditorGUILayout.ObjectField(new GUIContent("Landscape to Edit", "Create a new Landscape or drag in the Landscape parent GameObject from the scene."), landscapeGameObjectSelection, typeof(GameObject), true);
                if (EditorGUI.EndChangeCheck()) { isSceneDirtyRequired = true; }

                if (landscapeGameObjectSelection != null)
                {
                    CheckSwitchLandscapeSelection(!isJustEnabled);
                }
                else if (landscape != null)
                {
                    // "None" was selected from the list of assets in the scene
                    landscapeGameObjectSelection = null;
                    landscapeSelection = null;
                    landscape = null;
                    // Added LB 2.1.5
                    LBEditorCommon.currentLandscape = null;
                    isReparentRequired = false;
                    isSceneDirtyRequired = true;
                }

                // This must follow ObjectField to avoid repaint issues introduced with new import workflow
                if (landscapeGameObjectSelection == null)
                {
                    EditorGUILayout.HelpBox("Create a new Landscape OR edit an existing one by dragging in the Landscape parent GameObject from the scene hierarchy window", MessageType.Info, true);
                }

                GUILayout.EndVertical();

                scrollPosition = EditorGUILayout.BeginScrollView(scrollPosition);

                if (landscapeGameObject != null && landscape != null)
                {
                    #region Import LB into existing terrains (not built by LB)
                    if (landscapeSize.x < 1f && landscapeSize.y < 1f)
                    {
                        if (landscapeTerrains == null || landscape.landscapeTerrains == null)
                        {
                            landscape.SetLandscapeTerrains(true);
                            landscapeTerrains = landscape.landscapeTerrains;
                        }

                        int numTerrainsToImport = landscape.landscapeTerrains == null ? 0 : landscape.landscapeTerrains.Length;

                        // If there are terrains under this GameObject, then we know that
                        // the landscape size is wrong, and was likely not built with Landscape Builder
                        if (numTerrainsToImport > 0)
                        {
                            EditorGUILayout.HelpBox("This landscape may not have been built with Landscape Builder", MessageType.Warning, true);

                            if (GUILayout.Button("Import Now"))
                            {
                                if (EditorUtility.DisplayCancelableProgressBar("Importing Terrains", "Please Wait", 0.5f))
                                {
                                    // Cannot do much if cancel part way through import 
                                }
                                try
                                {
                                    // Always do an upgrade first
                                    if (!LBUpdate.LandscapeUpdate(landscape.LastUpdatedVersion, LBVersion, ref landscape, false)) { }
                                    else if (LBImport.ImportLandscape(ref landscape, LBVersion))
                                    {
                                        // Set the local Editor variables so they don't get overwritten by LoadLandscapeSettings()
                                        landscapeSize = landscape.size;
                                        topographyLayers = landscape.topographyLayersList;
                                        terrainTexturesList = landscape.terrainTexturesList;
                                        terrainTreesList = landscape.terrainTreesList;
                                        terrainGrassList = landscape.terrainGrassList;
                                        lbGroupList = landscape.lbGroupList;

                                        TextureListExpand(false);
                                        TreeListExpand(false);
                                        GrassListExpand(false);

                                        // GPU off (see below)
                                        landscape.useGPUTopography = false;
                                        landscape.useGPUTexturing = false;
                                        landscape.useGPUGrass = false;
                                        landscape.useGPUPath = false;

                                        // Enable GPU Acceleration by default if available on supported platforms
#if (UNITY_STANDALONE_OSX || UNITY_STANDALONE_WIN || UNITY_XBOXONE || UNITY_WSA_10_0)
                                        if (landscape.IsGPUAccelerationAvailable())
                                        {
                                            // GPU accel is not supported for imported Grass types
                                            landscape.useGPUTopography = true;
                                            landscape.useGPUTexturing = true;
                                            landscape.useGPUPath = true;
                                        }
#endif

                                        if (landscape != null)
                                        {
                                            landscapeGameObject = landscape.gameObject;
                                            landscapeGameObjectSelection = landscapeGameObject;
                                        }

                                        isReparentRequired = false;

                                        useProjectForTerrainData = landscape.useProjectForTerrainData;

                                        isSceneSaveRequired = true;
                                    }
                                }
                                catch (Exception ex)
                                {
                                    Debug.LogError("LB ImportLandscape " + ex.Message);
                                }
                                EditorUtility.ClearProgressBar();
                            }
                            EditorGUILayout.Space();
                        }
                    }
                    #endregion

                    #region Check landscape version
                    else if (landscape.LastUpdatedVersion != LBVersion)
                    {
                        EditorGUILayout.HelpBox("The current version of Landscape Builder is " + LBVersion.ToString() +
                        ", however the selected landscape in the scene is " + landscape.LastUpdatedVersion, MessageType.Warning, true);

                        if (GUILayout.Button("Fix Now"))
                        {
                            if (LBUpdate.LandscapeUpdate(landscape.LastUpdatedVersion, LBVersion, ref landscape, false)) { isSceneSaveRequired = true; }
                        }
                        EditorGUILayout.Space();
                    }
                    #endregion

                    #region Reparent Terrain
                    else if (isReparentRequired)
                    {
                        // This is probably too dangerous here - just show a warning for now. See LBImport.ImportLandscape(..) instead
                        EditorGUILayout.HelpBox("The terrain doesn't seem to be a child of the landscape. Please Report", MessageType.Warning, true);
                    }
                    #endregion

                    GUILayout.BeginHorizontal(EditorStyles.helpBox);
                    if (GUILayout.Button(zoomAllLandscapeContent, GUILayout.MaxWidth(60)))
                    {
                        ZoomAllLandscape();
                        // The following avoids a NullReferenceException from GUILayoutUtility.BeginLayoutGroup
#if UNITY_2017_1_OR_NEWER
                        return;
#endif
                    }
                    if (GUILayout.Button(createNewLandscapeContent))
                    {
                        landscapeGameObjectSelection = null;
                        landscapeSelection = null;
                        landscape = null;
                        TerrainTexturesAvailableList = null;
                        useProjectForTerrainData = false;
                        terrainGroupingID = 100; // default for LB. 0 default for Unity
                        useTerrainAutoConnect = true;
                        // Added LB 2.1.5
                        LBEditorCommon.currentLandscape = null;
                        isReparentRequired = false;
                    }
                    GUILayout.EndHorizontal();
                }
                else if (landscapeGameObject == null || landscape == null)
                {
                    EditorGUILayout.Space();
                    EditorGUILayout.LabelField("<b>Landscape Settings</b>\n\nLandscape Settings gives you control over the shape, size and general setup of your landscape", helpBoxRichText);
                    landscapeName = EditorGUILayout.TextField(landscapeNameContent, landscapeName);
                    if (landscapeName == string.Empty) { landscapeName = "Landscape 01"; }
                    landscapeSize = EditorGUILayout.Vector2Field(landscapeSizeContent, landscapeSize);
                    if (landscapeSize.x != landscapeSize.y)
                    {
                        EditorGUILayout.HelpBox("Non-Standard landscape size. Not all features are supported, and some may give unpredictable results. Use square landscapes where possible.", MessageType.Warning, true);
                    }
                    startPosition = EditorGUILayout.Vector3Field(landscapeStartPositionContent, startPosition);
                    terrainWidth = EditorGUILayout.FloatField(landscapeTerrainWidthContent, terrainWidth);

                    if (isNonSquareTerrainsEnabled)
                    {
                        terrainLength = EditorGUILayout.FloatField(landscapeTerrainLengthContent, terrainLength);
                    }
                    else { terrainLength = terrainWidth; }
                }
                #endregion

                #region Terrain Settings
                EditorGUILayout.Space();
                GUILayout.BeginHorizontal();
                showTerrainSettings = EditorGUILayout.Foldout(showTerrainSettings, "Terrain Settings");
                if (landscape != null)
                {
                    // Script out the landscape terrain settings to the console window
                    if (GUILayout.Button(scriptTerrainSettingsContent, buttonCompact, GUILayout.MaxWidth(20f)))
                    {
#if UNITY_2018_2_OR_NEWER
                        LBEditorHelper.CallMenu("Window/General/Console");
#else
                        LBEditorHelper.CallMenu("Window/Console");
#endif
                        Debug.Log(landscape.ScriptLandscapeSettings(landscapeName, "\n"));
                    }
                }
                GUILayout.EndHorizontal();
                if (showTerrainSettings)
                {
                    EditorGUIUtility.labelWidth += 10f;
                    EditorGUILayout.HelpBox("Terrain Settings gives you control over the default Unity functionality of the terrains in your landscape.", MessageType.None, true);

                    terrainSettingsType = (TerrainSettingsType)EditorGUILayout.EnumPopup(terrainSettingsPresetContent, terrainSettingsType);

                    terrainMaterialType = (LBLandscape.TerrainMaterialType)EditorGUILayout.EnumPopup(terrainMaterialTypeContent, terrainMaterialType);
                    if (terrainMaterialType == LBLandscape.TerrainMaterialType.BuiltInLegacySpecular)
                    {
                        terrainLegacySpecular = EditorGUILayout.ColorField(terrainLegacySpecularContent, terrainLegacySpecular);
                        terrainLegacyShininess = EditorGUILayout.Slider(terrainLegacyShinninessContent, terrainLegacyShininess, 0f, 1f);
                    }
                    else if (terrainMaterialType == LBLandscape.TerrainMaterialType.Custom)
                    {
                        terrainCustomMaterial = (Material)EditorGUILayout.ObjectField(terrainCustomMatContent, terrainCustomMaterial, typeof(Material), false);
                    }

                    #region MegaSplat Terrain Material
                    else if (terrainMaterialType == LBLandscape.TerrainMaterialType.MegaSplat && landscape != null)
                    {
                        // If the current shader isn't set up for MegaSplat, remove it from the editor field
                        if (terrainCustomMaterial != null)
                        {
                            if (terrainCustomMaterial.shader.name.Contains("LB Standard") || terrainCustomMaterial.shader.name.Contains("Relief Pack"))
                            {
                                terrainCustomMaterial = null;
                            }
                        }

                        if (isMegaSplatInstalled)
                        {
                            // Display the material but don't let the user update it
                            EditorGUILayout.ObjectField(terrainMatMegaSplatContent, terrainCustomMaterial, typeof(Material), false);

                            GUILayout.BeginHorizontal();
                            if (GUILayout.Button("Initialise", buttonCompact, GUILayout.MaxWidth(100f)))
                            {
                                terrainCustomMaterial = LBIntegration.MegaSplatConfigureMaterial(landscape, megaSplatAutoClosePainter, false, true);
                                //Debug.Log("configured megaslat material shader: " + terrainCustomMaterial.shader.name);
                            }
                            if (terrainCustomMaterial != null)
                            {
                                if (GUILayout.Button("Shader Config", buttonCompact, GUILayout.MaxWidth(120f)))
                                {
                                    LBEditorHelper.SelectObjectInProjectWindow(terrainCustomMaterial, true);
                                }

                                if (landscape.terrainCustomMaterial == null)
                                {
                                    landscape.terrainCustomMaterial = terrainCustomMaterial;
                                    isSceneSaveRequired = true;
                                    //Debug.Log("INFO: LB updating landscape custom material for MegaSplat");
                                }
                            }
                            GUILayout.EndHorizontal();
                        }
                        else { EditorGUILayout.HelpBox("To integrate with MegaSplat, install MegaSplat 1.73+ in your project.", MessageType.Info, true); }
                    }
                    #endregion

                    #region MicroSplat Terrain Material
                    else if (terrainMaterialType == LBLandscape.TerrainMaterialType.MicroSplat && landscape != null)
                    {
                        if (isMicroSplatInstalled)
                        {
                            if (terrainCustomMaterial == null || !terrainCustomMaterial.shader.name.Contains("MicroSplat"))
                            {
                                // Initialise button should only appear after the MicroSplat Terrain scripts have been applied via the "Apply Terrain Settings" button
                                int numTerrains = (landscapeTerrains == null ? 0 : landscapeTerrains.Length);

                                // Sometimes numTerrains > 0 but terrains are null.
                                if (numTerrains == 0 || landscapeTerrains[0] == null)
                                {
                                    landscapeTerrains = landscapeGameObject.GetComponentsInChildren<Terrain>();
                                    numTerrains = (landscapeTerrains == null ? 0 : landscapeTerrains.Length);
                                }

                                if (numTerrains > 0 && LBIntegration.MicroSplatComponentAdded(landscapeTerrains[0], true))
                                {
                                    if (GUILayout.Button("Initialise", buttonCompact, GUILayout.MaxWidth(100f)))
                                    {
                                        // Multi-select all the terrain objects
                                        Selection.activeObject = null;

                                        GameObject[] gos = new GameObject[numTerrains];
                                        for (int tIdx = 0; tIdx < numTerrains; tIdx++) { gos[tIdx] = landscapeTerrains[tIdx].gameObject; }
                                        Selection.objects = gos;

                                        // Prompt user
                                        EditorUtility.DisplayDialog("MicroSplat Integration", "Click the \"Convert to MicroSplat\" button to setup MicroSplat in this landscape.\n\nIMPORTANT\nReturn to Landscape Terrain Settings after it is done and click \"FIX NOW\".", "Got it!");
                                        // Switch away from Landscape tab to force a reload of settings next time user comes to Terrain Settings
                                        selectedTabInt = 1;

                                        // Switch to the MicroSplat editor
#if UNITY_2018_2_OR_NEWER
                                        LBEditorHelper.CallMenu("Window/General/Inspector");
#else
                                        LBEditorHelper.CallMenu("Window/Inspector");
#endif
                                    }
                                }
                            }
                            else
                            {
                                if (!isMicroSplatInstalled)
                                {
                                    // Don't allow user to change MicroSplat material if MicroSplat is not installed
                                    EditorGUILayout.ObjectField(terrainMatMicroSplatContent, terrainCustomMaterial, typeof(Material), false);
                                }
                                else
                                {
                                    EditorGUI.BeginChangeCheck();
                                    Material tempTerrainMat = (Material)EditorGUILayout.ObjectField(terrainMatMicroSplatContent, terrainCustomMaterial, typeof(Material), false);
                                    if (EditorGUI.EndChangeCheck())
                                    {
                                        if (tempTerrainMat != null && tempTerrainMat.shader.name.Contains("MicroSplat"))
                                        {
                                            terrainCustomMaterial = tempTerrainMat;
                                        }
                                        else { Debug.LogWarning("Please select a MicroSplat material"); }
                                    }
                                }
#if __MICROSPLAT__
                                GUILayout.BeginHorizontal();
                                EditorGUILayout.LabelField("MicroSplat Settings");

                                if (GUILayout.Button("Config", buttonCompact, GUILayout.MaxWidth(100f)))
                                {
                                    JBooth.MicroSplat.TextureArrayConfig textureArrayConfig = LBEditorIntegration.GetTextureArrayConfig(terrainCustomMaterial);

                                    if (textureArrayConfig != null)
                                    {
                                        LBEditorHelper.SelectObjectInProjectWindow(textureArrayConfig, true);
                                    }
                                }
                                if (GUILayout.Button("Shader", buttonCompact, GUILayout.MaxWidth(100f)))
                                {
                                    Material microSplatMat = LBEditorHelper.GetAsset<Material>(LBEditorIntegration.GetMicroSplatDataFolder(terrainCustomMaterial, true), terrainCustomMaterial.name + ".mat");
                                    if (microSplatMat != null) { LBEditorHelper.SelectObjectInProjectWindow(microSplatMat, true); }
                                }
                                GUILayout.EndHorizontal();

                                if (terrainCustomMaterial.shader.name.Contains("LandscapeTerrain0"))
                                {
                                    GUILayout.BeginHorizontal();
                                    EditorGUILayout.HelpBox("The default shader name needs to be updated to match the (hopefully unique) landscape name", MessageType.Warning);
                                    if (GUILayout.Button("Fix Now", GUILayout.MinHeight(40f)))
                                    {
                                        // Recompile shaders and update names to match the landscape name
                                        if (LBEditorIntegration.MicroSplatCompileShader(landscape, terrainCustomMaterial, true))
                                        {
                                            landscape.terrainCustomMaterial = terrainCustomMaterial;
                                        }

                                        isSceneSaveRequired = true;
                                    }
                                    GUILayout.EndHorizontal();
                                }
#endif

                                EditorGUILayout.Space();
                            }
                        }
                        else { EditorGUILayout.HelpBox("To integrate with MicroSplat, install MicroSplat 2.15+ in your project.", MessageType.Info, true); }
                    }
                    #endregion

                    #region RTP Terrain Material
                    else if (terrainMaterialType == LBLandscape.TerrainMaterialType.ReliefTerrainPack && landscape != null)
                    {
                        landscape.rtpUseTessellation = EditorGUILayout.Toggle(terrainUseRTPTesselationContent, landscape.rtpUseTessellation);
                    }
                    #endregion

                    heightmapResolution = EditorGUILayout.IntPopup("Heightmap Resolution", heightmapResolution, possibleHMRStrings, possibleHMRs);
                    terrainHeight = EditorGUILayout.FloatField(terrainSettingsHeightContent, terrainHeight);
                    pixelError = EditorGUILayout.Slider(terrainSettingsPixelErrorContent, pixelError, 0, 200);
                    if (terrainMaterialType == LBLandscape.TerrainMaterialType.ReliefTerrainPack)
                    {
                        EditorGUILayout.LabelField("Base Map Distance is controlled by Relief Terrain Pack");
                    }
                    else if (terrainMaterialType == LBLandscape.TerrainMaterialType.MicroSplat)
                    {
                        EditorGUILayout.LabelField("Base Map Distance is controlled by MicroSplat");
                    }
                    else
                    {
                        baseMapDistance = EditorGUILayout.Slider(terrainSettingsBaseMapDistanceContent, baseMapDistance, 0f, 5000f);
                    }
                    if (terrainMaterialType == LBLandscape.TerrainMaterialType.MicroSplat)
                    {
                        EditorGUILayout.LabelField("Base Texture Resolution is controlled by MicroSplat");
                    }
                    else
                    {
                        baseTextureResolution = EditorGUILayout.IntPopup("Base Texture Resolution", baseTextureResolution, possibleBTRStrings, possibleBTRs);
                    }

                    // Display editor performance warning if GPU Texturing not enabled for higher-resolution splatmaps
                    if (landscape != null && !landscape.useGPUTexturing && alphaMapResolution > 512)
                    {
                        EditorGUILayout.HelpBox("It might take a while to Texture the landscape without GPU Acceleration - Texturing enabled on the Advanced tab", MessageType.Warning, true);
                    }

                    alphaMapResolution = EditorGUILayout.IntPopup(terrainSettingsAlphaMapResolutionContent, alphaMapResolution, AMRGUIContent, possibleAMRs);

                    EditorGUI.BeginChangeCheck();
                    selectedLandscapeLayerIndex = EditorGUILayout.Popup("Unity Layer", LBEditorHelper.GetSelectedIndex(layerNameListRestricted, LayerMask.LayerToName(landscapeLayerIndex)), layerNameListRestricted.ToArray());
                    if (EditorGUI.EndChangeCheck())
                    {
                        landscapeLayerIndex = LBEditorHelper.GetLayerIndex(layerNameListRestricted[selectedLandscapeLayerIndex]);
                    }

                    treeDistance = EditorGUILayout.FloatField(terrainSettingsTreeDistanceContent, treeDistance);
                    treeBillboardDistance = EditorGUILayout.Slider(terrainSettingsTreeBillboardStartContent, treeBillboardDistance, 5f, 2000f);
                    treeFadeDistance = EditorGUILayout.Slider(terrainSettingsTreeFadeDistanceContent, treeFadeDistance, 0f, 200f);
                    detailResolution = EditorGUILayout.IntPopup(terrainSettingsDetailResolutionContent, detailResolution, DTRGUIContent, possibleDTRs);
                    detailDistance = EditorGUILayout.Slider(terrainSettingsDetailDistanceContent, detailDistance, 0f, 500f);
                    detailDensity = EditorGUILayout.Slider(terrainSettingsDetailDensityContent, detailDensity, 0f, 1f);

#if UNITY_2018_3_OR_NEWER
                    useTerrainDrawInstanced = EditorGUILayout.Toggle(terrainSettingsDrawInstancedContent, useTerrainDrawInstanced);
                    if (useTerrainDrawInstanced)
                    {
                        // Per-Pixel normals (new in U2018.3, requires Terrain Draw Instanced AND LWRP 4.0.1+ or U2019.3+ and URP 7.1.2+)
                        useTerrainPerPixelNormals = EditorGUILayout.Toggle(terrainSettingsPerPixelNormalsContent, useTerrainPerPixelNormals);
                    }

                    useTerrainAutoConnect = EditorGUILayout.Toggle(terrainSettingsAutoConnectContent, useTerrainAutoConnect);
                    terrainGroupingID = EditorGUILayout.IntField(terrainSettingsGroupingIDContent, terrainGroupingID);
#else
                    // keep compiler happy
                    if (useTerrainDrawInstanced) { }
                    if (useTerrainPerPixelNormals) { }
                    if (useTerrainAutoConnect) { }
                    if (terrainGroupingID > 0) { }
#endif

                    if (landscape == null)
                    {
                        // New landscape
                        useProjectForTerrainData = EditorGUILayout.Toggle(terrainSettingsUseProjectForTDataContent, useProjectForTerrainData);
                        if (useProjectForTerrainData)
                        {
                            EditorGUILayout.HelpBox("This feature is currently in technical preview", MessageType.Warning);
                            GUILayout.BeginHorizontal();
                            EditorGUI.BeginChangeCheck();
                            terrainDataFolder = EditorGUILayout.TextField(exportTerrainDataFolderContent, terrainDataFolder);
                            if (GUILayout.Button("..", toggleTinyButtonStyleNormal, GUILayout.Width(20f)))
                            {
                                LBEditorHelper.CheckFolderStructure("Assets" + (terrainDataFolder.StartsWith("/") ? "" : "/") + terrainDataFolder);
                                LBEditorHelper.GetPathFromUser("Terrain Data Folder", "Landscape/TerrainData", true, ref terrainDataFolder);
                            }
                            if (string.IsNullOrEmpty(terrainDataFolder)) { terrainDataFolder = "Landscape/TerrainData"; }
                            GUILayout.EndHorizontal();
                        }
                    }
                    else
                    {
                        // Existing landscape
                        EditorGUILayout.BeginHorizontal();
                        EditorGUILayout.LabelField("Terrain Data Location", GUILayout.Width(defaultEditorLabelWidth));
                        EditorGUILayout.LabelField(useProjectForTerrainData ? " Project Folder (not LB default)" : " Scene (Default)");
                        // Only display Find folder if this has already been applied to terrains
                        if (landscape.useProjectForTerrainData)
                        {
                            if (GUILayout.Button("F", toggleTinyButtonStyleNormal, GUILayout.Width(20f)))
                            {
                                LBEditorHelper.HighlightFolderInProjectWindow("Assets/" + landscape.terrainDataFolder, true, true);
                            }
                        }
                        EditorGUILayout.EndHorizontal();

                        // Give use the option to Move existing terrains to Project folder without having to go to Export tab
                        if (!landscape.useProjectForTerrainData)
                        {
                            useProjectForTerrainData = EditorGUILayout.Toggle(terrainSettingsUseProjectForTDataContent, useProjectForTerrainData);
                            if (useProjectForTerrainData)
                            {
                                EditorGUILayout.HelpBox("This feature is currently in technical preview", MessageType.Warning);
                                GUILayout.BeginHorizontal();
                                EditorGUI.BeginChangeCheck();
                                terrainDataFolder = EditorGUILayout.TextField(exportTerrainDataFolderContent, terrainDataFolder);
                                if (GUILayout.Button("..", toggleTinyButtonStyleNormal, GUILayout.Width(20f)))
                                {
                                    LBEditorHelper.CheckFolderStructure("Assets" + (terrainDataFolder.StartsWith("/") ? "" : "/") + terrainDataFolder);
                                    LBEditorHelper.GetPathFromUser("Terrain Data Folder", "Landscape/TerrainData", true, ref terrainDataFolder);
                                }
                                if (string.IsNullOrEmpty(terrainDataFolder)) { terrainDataFolder = "Landscape/TerrainData"; }
                                GUILayout.EndHorizontal();
                            }
                        }
                    }


                    #region Grass Wind Settings
                    showTerrainGrassWindSettings = EditorGUILayout.Foldout(showTerrainGrassWindSettings, "Grass Wind Settings");
                    if (showTerrainGrassWindSettings)
                    {
                        grassWindSpeed = EditorGUILayout.Slider(terrainSettingsGrassWindSpeedContent, grassWindSpeed, 0f, 1f);
                        grassWindRippleSize = EditorGUILayout.Slider(terrainSettingsGrassRippleSizeContent, grassWindRippleSize, 0f, 1f);
                        grassWindBending = EditorGUILayout.Slider(terrainSettingsGrassWindBendingContent, grassWindBending, 0f, 1f);
                        grassWindTint = EditorGUILayout.ColorField(terrainSettingsGrassWindTintContent, grassWindTint);
                    }
                    #endregion

                    #region Vegetation Studio / Pro
                    if (isVegetationStudioInstalled && landscape != null)
                    {
                        EditorGUILayout.LabelField("<b>Vegetation Studio Settings</b>", labelFieldRichText);
                        landscape.useVegetationSystem = EditorGUILayout.Toggle(terrainSettingsUseVegetationSystemContent, landscape.useVegetationSystem);
                        if (landscape.useVegetationSystem)
                        {
                            landscape.useVegetationSystemTextures = EditorGUILayout.Toggle(terrainSettingsUseVegetationSystemTexturesContent, landscape.useVegetationSystemTextures);
                        }
                    }
                    else if (isVegetationStudioProInstalled && landscape != null)
                    {
                        EditorGUILayout.LabelField("<b>Vegetation Studio Pro Settings</b>", labelFieldRichText);
                        landscape.useVegetationSystem = EditorGUILayout.Toggle(terrainSettingsUseVegetationSystemProContent, landscape.useVegetationSystem);
                        if (landscape.useVegetationSystem)
                        {
                            landscape.useVegetationSystemTextures = EditorGUILayout.Toggle(terrainSettingsUseVegetationSystemTexturesAutoContent, landscape.useVegetationSystemTextures);
                        }
                    }
                    #endregion

                    #region Terrain Settings Presets
                    if (GUILayout.Button("Get " + terrainSettingsType.ToString() + " Preset"))
                    {
                        if (terrainSettingsType == TerrainSettingsType.Performance1)
                        {
                            terrainMaterialType = LBLandscape.TerrainMaterialType.BuiltInStandard;
                            heightmapResolution = 513;
                            terrainHeight = 2000f;
                            pixelError = 5;
                            baseMapDistance = 1000f;
                            baseTextureResolution = 512;
                            alphaMapResolution = 512;
                            treeDistance = 750f;
                            treeBillboardDistance = 100f;
                            detailResolution = 1024;
                            detailDistance = 125f;
                            detailDensity = 1f;
                            treeFadeDistance = 20f;
                            grassWindSpeed = 0.5f;
                            grassWindRippleSize = 0.2f;
                            grassWindBending = 0.5f;
                            grassWindTint = Color.white;
                        }
                        else if (terrainSettingsType == TerrainSettingsType.Performance2)
                        {
                            terrainMaterialType = LBLandscape.TerrainMaterialType.BuiltInStandard;
                            heightmapResolution = 257;
                            terrainHeight = 2000f;
                            pixelError = 10;
                            baseMapDistance = 250f;
                            baseTextureResolution = 512;
                            alphaMapResolution = 512;
                            treeDistance = 750f;
                            treeBillboardDistance = 50f;
                            detailResolution = 1024;
                            detailDistance = 90f;
                            detailDensity = 1f;
                            treeFadeDistance = 5f;
                            grassWindSpeed = 0.5f;
                            grassWindRippleSize = 0.2f;
                            grassWindBending = 0.5f;
                            grassWindTint = Color.white;
                        }
                        else if (terrainSettingsType == TerrainSettingsType.Quality1)
                        {
                            terrainMaterialType = LBLandscape.TerrainMaterialType.BuiltInStandard;
                            heightmapResolution = 1025;
                            terrainHeight = 2000f;
                            pixelError = 0.1f;
                            baseMapDistance = 5000f;
                            baseTextureResolution = 2048;
                            alphaMapResolution = 1024;
                            treeDistance = 10000f;
                            treeBillboardDistance = 500f;
                            detailDistance = 500f;
                            detailResolution = 1024;
                            detailDensity = 1f;
                            treeFadeDistance = 50f;
                            grassWindSpeed = 0.5f;
                            grassWindRippleSize = 0.2f;
                            grassWindBending = 0.5f;
                            grassWindTint = Color.white;
                        }
                        else // Default settings
                        {
                            terrainMaterialType = LBLandscape.TerrainMaterialType.BuiltInStandard;
                            heightmapResolution = 513;
                            terrainHeight = 2000f;
                            pixelError = 1;
                            baseMapDistance = 1500f;
                            baseTextureResolution = 512;
                            alphaMapResolution = 512;
                            treeDistance = 10000f;
                            treeBillboardDistance = 200f;
                            detailDistance = 200f;
                            detailResolution = 1024;
                            detailDensity = 1f;
                            treeFadeDistance = 20f;
                            grassWindSpeed = 0.5f;
                            grassWindRippleSize = 0.2f;
                            grassWindBending = 0.5f;
                            grassWindTint = Color.white;
                        }
                    }
                    #endregion

                    #region Apply Terrain Settings
                    if (landscapeGameObject != null && landscape != null && !(terrainMaterialType == LBLandscape.TerrainMaterialType.MegaSplat && terrainCustomMaterial == null))
                    {
                        if (GUILayout.Button("Apply Terrain Settings"))
                        {
                            int oldHeightmapResolution = landscape.GetLandscapeTerrainHeightmapResolution();
                            int oldBaseTextureResolution = landscape.GetLandscapeTerrainBaseTextureResolution();
                            int oldAlphaMapResolution = landscape.GetLandscapeTerrainAlphaMapResolution();
                            int oldDetailResolution = landscape.GetLandscapeTerrainDetailResolution();
                            int oldLayerIndex = landscape.GetLandscapeTerrainLayerIndex();

                            // Find all landscape terrains
                            landscapeTerrains = landscapeGameObject.GetComponentsInChildren<Terrain>();
                            EditorUtility.DisplayProgressBar("Applying Terrain Settings", "Please Wait", 0.5f);

                            LBLandscape.TerrainMaterialType previousMaterialType = landscape.GetTerrainMaterialType();
                            //Debug.Log("Previous terrain material type: " + previousMaterialType.ToString());

                            if (useProjectForTerrainData)
                            {
                                LBEditorHelper.CheckFolderStructure("Assets/" + terrainDataFolder);
                            }

                            for (index = 0; index < landscapeTerrains.Length; index++)
                            {
                                if (landscapeTerrains[index] == null) { Debug.LogWarning("Apply Terrain Settings - terrain is null. PLEASE REPORT"); continue; }
                                if (landscapeTerrains[index].terrainData == null) { Debug.LogWarning("Apply Terrain Settings - terrain data is null. PLEASE REPORT"); continue; }

                                // Set their settings to the current editor settings
                                if (terrainMaterialType == LBLandscape.TerrainMaterialType.ReliefTerrainPack)
                                {
                                    if (landscape.rtpUseTessellation) { pixelError = 200f; }
                                    landscapeTerrains[index].heightmapPixelError = pixelError;
                                }
                                else
                                {
                                    landscapeTerrains[index].heightmapPixelError = pixelError;
                                    landscapeTerrains[index].basemapDistance = baseMapDistance;
                                }
                                // Only set baseMapResolution if it has changed
                                if (oldBaseTextureResolution != baseTextureResolution)
                                {
                                    landscapeTerrains[index].terrainData.baseMapResolution = baseTextureResolution;
                                }
                                // Only set alphamapResolution if it has changed to prevent from having to re-texture landscape if not changed
                                if (oldAlphaMapResolution != alphaMapResolution)
                                {
                                    landscapeTerrains[index].terrainData.alphamapResolution = alphaMapResolution;
                                }

                                // Only set the Layer if it has changed
                                if (oldLayerIndex != landscapeLayerIndex)
                                {
                                    landscapeTerrains[index].gameObject.layer = landscapeLayerIndex;
                                }

#if UNITY_2018_3_OR_NEWER
                                landscapeTerrains[index].drawInstanced = this.useTerrainDrawInstanced;
                                // To avoid or correct a Terrain LOD issue which SetTerrainNeighbours doesn't entirely
                                // correct, use allowAutoConnect.
                                landscapeTerrains[index].groupingID = terrainGroupingID;
                                landscapeTerrains[index].allowAutoConnect = useTerrainAutoConnect;
#endif

                                // Only set the detail resolution if it has changed
                                if (oldDetailResolution != detailResolution)
                                {
                                    landscapeTerrains[index].terrainData.SetDetailResolution(detailResolution, 16);
                                }

                                landscapeTerrains[index].treeDistance = treeDistance;
                                landscapeTerrains[index].treeBillboardDistance = treeBillboardDistance;
                                landscapeTerrains[index].detailObjectDistance = detailDistance;
                                landscapeTerrains[index].detailObjectDensity = detailDensity;   // in LB 2.0.8 and earlier this was always 1.0
                                landscapeTerrains[index].treeCrossFadeLength = treeFadeDistance;
                                landscapeTerrains[index].terrainData.size = new Vector3(landscapeTerrains[index].terrainData.size.x,
                                                                                        terrainHeight, landscapeTerrains[index].terrainData.size.z);
                                if (oldHeightmapResolution != heightmapResolution)
                                {
                                    // Set heightmap resolution - set heights from interpolated height data
                                    landscapeTerrains[index].terrainData = LBLandscapeTerrain.AdjustHeightmapResolution(landscapeTerrains[index].terrainData, heightmapResolution);

#if UNITY_2019_1_OR_NEWER
                                    if (landscapeTerrains[index].terrainData != null) { landscapeTerrains[index].terrainData.SyncHeightmap(); }
#else
                                    landscapeTerrains[index].ApplyDelayedHeightmapModification();
#endif
                                }
                                landscapeTerrains[index].terrainData.wavingGrassSpeed = grassWindSpeed;
                                landscapeTerrains[index].terrainData.wavingGrassAmount = grassWindRippleSize;
                                landscapeTerrains[index].terrainData.wavingGrassStrength = grassWindBending;
                                landscapeTerrains[index].terrainData.wavingGrassTint = grassWindTint;
                                // Set terrain material
                                SetTerrainMaterial(landscapeTerrains[index], index, (index == landscapeTerrains.Length - 1), terrainMaterialType, previousMaterialType);
                            }

                            // Required for SetTerrainNeighbours and VS, VSP if installed.
                            landscape.SetLandscapeTerrains(true);
                            // Added 2.2.0
                            landscape.SetTerrainNeighbours(true);

                            // Assumes only VegStudio OR VegStudioPro are installed (not both)
                            #if VEGETATION_STUDIO
                            if (!LBIntegration.VegetationStudioEnable(landscape, landscape.useVegetationSystem, true))
                            {
                                Debug.LogWarning("Could not modifiy landscape with Vegetation Studio attributes. Please Report");
                            }

                            // Update any changes made by Vegetation Studio to the terrain settings
                            LoadLandscapeSettings();

                            #elif VEGETATION_STUDIO_PRO
                            if (!LBIntegration.VegetationStudioProEnable(landscape, landscape.useVegetationSystem, true))
                            {
                                Debug.LogWarning("Could not modifiy landscape with Vegetation Studio Pro attributes. Please Report");
                            }

                            // Update any changes made by Vegetation Studio Pro to the terrain settings
                            LoadLandscapeSettings();

                            #endif

                            #region Move Terrain Data from Scene to Project folder
                            // Does the user what to move the terrain data to a project folder?
                            if (!landscape.useProjectForTerrainData && useProjectForTerrainData && landscapeTerrains.Length > 0)
                            {
                                string outputTDFolder = "Assets" + (terrainDataFolder.StartsWith("/") ? "" : "/") + terrainDataFolder;
                                outputTDFolder += outputTDFolder.EndsWith("/") ? "" : "/";

                                LBEditorHelper.CheckFolderStructure(outputTDFolder);

                                terrainDataName = landscapeName + "TerrainData";

                                // Check if terrain data already exists
                                UnityEngine.Object obj = AssetDatabase.LoadMainAssetAtPath(outputTDFolder + terrainDataName + "0000.asset");

                                if (obj != null)
                                {
                                    EditorUtility.DisplayDialog("Apply Terrain Settings", "Terrain Data already exists in the folder. Select or create another folder or store the terrain data in the scene (recommended for landscapes < 25 terrains)", "Got it!");
                                }
                                else
                                {
                                    Terrain terrainScene = null;
                                    TerrainData terrainDataScene = null;

                                    AssetDatabase.StartAssetEditing();
                                    int numTerrains = landscapeTerrains.Length;
                                    for (index = 0; index < numTerrains; index++)
                                    {
                                        terrainScene = landscapeTerrains[index];

                                        if (terrainScene != null)
                                        {
                                            terrainDataScene = terrainScene.terrainData;
                                            terrainDataScene.name = terrainDataName + index.ToString("0000");

                                            // Create an asset in the project folder
                                            // Automatically removes the data from the scene when the scene is saved
                                            // Automatically links the TerrainCollider
                                            AssetDatabase.CreateAsset(terrainDataScene, outputTDFolder + terrainDataScene.name + ".asset");

                                            Debug.Log("[INFO] terrainData moved from scene to " + AssetDatabase.GetAssetPath(terrainDataScene));
                                        }
                                    }
                                    useProjectForTerrainData = true;
                                    // The terrainDataFolder does not include the Assets/ prefix.
                                    landscape.useProjectForTerrainData = true;
                                    landscape.terrainDataFolder = terrainDataFolder;
                                    AssetDatabase.StopAssetEditing();
                                }
                            }
                            #endregion

                            EditorUtility.ClearProgressBar();
                            isSceneSaveRequired = true;
                        }
                    }
                    #endregion

                    EditorGUIUtility.labelWidth = defaultEditorLabelWidth;
                }

                #endregion

                #region Generate Landscape
                if (landscapeGameObject == null || landscape == null)
                {
                    // NOTE: currently only the Standard terrain material is applied. The user is then
                    // expected to set the Terrain Material after initial generation.
                    if (GUILayout.Button(generateLandscapeContent))
                    {
                        // Verify that terrain size makes sense for this landscape size

                        // Are the sides of the landscape divisible by the terrain width? (All terrains must be square)
                        float numberOfTerrainsWide = landscapeSize.x / terrainWidth;
                        float numberOfTerrainsLong = landscapeSize.y / terrainLength;

                        int numberOfTerrainsWideInt = Mathf.RoundToInt(numberOfTerrainsWide);
                        int numberOfTerrainsLongInt = Mathf.RoundToInt(numberOfTerrainsLong);

                        // Check that a named scene has been saved. This avoids some issues including
                        // creating terrain materials for 2019.2+
                        bool isSceneNamed = !string.IsNullOrEmpty(currentScene);

                        if (!isSceneNamed)
                        {
                            EditorUtility.DisplayDialog("Generate Landscape", "Please save the scene before adding a landscape.", "Got it!");
                        }

                        // By default, terrainData is saved to the scene in LB
                        bool isTerrainDataFolderValid = true;

                        // Validate the terrain data folder if it is required
                        if (useProjectForTerrainData)
                        {
                            string outputTDFolder = "Assets" + (terrainDataFolder.StartsWith("/") ? "" : "/") + terrainDataFolder;
                            outputTDFolder += outputTDFolder.EndsWith("/") ? "" : "/";

                            LBEditorHelper.CheckFolderStructure(outputTDFolder);

                            // Check if terrain data already exists
                            UnityEngine.Object obj = AssetDatabase.LoadMainAssetAtPath(outputTDFolder + landscapeName + "TerrainData0000.asset");

                            if (obj != null)
                            {
                                EditorUtility.DisplayDialog("Generate Landscape", "Terrain Data already exists in the folder. Select or create another folder or store the terrain data in the scene (recommended)", "Got it!");
                                isTerrainDataFolderValid = false;
                            }
                        }

                        if ((Mathf.Abs(numberOfTerrainsWide - (float)numberOfTerrainsWideInt) > 0.0001f) || (Mathf.Abs(numberOfTerrainsLong - (float)numberOfTerrainsLongInt) > 0.0001f))
                        {
                            string msg = "The terrain size must be equally divisible by both the landscape X and Y values. " +
                                         "Landscape Builder version " + LBVersion + " only supports rectangular or square landscapes. " +
                                         "To create irregular-shaped scenes, create more than one landscape with different start positions.";
                            EditorUtility.DisplayDialog("Generate Landscape", msg, "OK");
                        }
                        else if (isTerrainDataFolderValid && isSceneNamed)
                        {
                            // Clear existing lists so that multiple landscapes don't get reference to same lists
                            topographyLayers = new List<LBLayer>();
                            terrainTexturesList = new List<LBTerrainTexture>();
                            terrainTreesList = new List<LBTerrainTree>();
                            terrainGrassList = new List<LBTerrainGrass>();
                            landscapeMeshList = new List<LBLandscapeMesh>();
                            lbGroupList = new List<LBGroup>();

                            landscapeGameObject = new GameObject(landscapeName);
                            landscapeGameObject.transform.position = startPosition;
                            index = 0;
                            int numberOfTerrains = Mathf.FloorToInt((landscapeSize.x / terrainWidth) * (landscapeSize.y / terrainLength));
                            for (xF = 0f; xF < landscapeSize.x; xF += terrainWidth)
                            {
                                for (yF = 0f; yF < landscapeSize.y; yF += terrainLength)
                                {
                                    GameObject newTerrainObj = new GameObject("Landscape Terrain " + index.ToString("0000"));
                                    newTerrainObj.transform.position = new Vector3(xF, 0f, yF) + startPosition;
                                    newTerrainObj.transform.parent = landscapeGameObject.transform;
                                    Terrain newTerrain = newTerrainObj.AddComponent<Terrain>();
                                    newTerrain.heightmapPixelError = pixelError;
#if UNITY_2018_3_OR_NEWER
                                    newTerrain.drawInstanced = useTerrainDrawInstanced;
                                    // Use autoconnect to avoid a terrain LOD issue that SetTerrainNeighbours doesn't seem to fix
                                    newTerrain.groupingID = 100; // default is 0
                                    newTerrain.allowAutoConnect = true;
#endif
                                    newTerrain.basemapDistance = baseMapDistance;
                                    newTerrain.treeDistance = treeDistance;
                                    newTerrain.treeBillboardDistance = treeBillboardDistance;
                                    newTerrain.detailObjectDistance = detailDistance;
                                    newTerrain.detailObjectDensity = detailDensity; // In LB 2.0.8 and earlier this was always the default
                                    newTerrain.treeCrossFadeLength = treeFadeDistance;
                                    newTerrain.name = "LandscapeTerrain" + index.ToString("0000");
                                    TerrainCollider newTerrainCol = newTerrainObj.AddComponent<TerrainCollider>();
                                    TerrainData newTerrainData = new TerrainData();
                                    newTerrainData.heightmapResolution = heightmapResolution;
                                    newTerrainData.size = new Vector3(terrainWidth, terrainHeight, terrainLength);
                                    newTerrainData.alphamapResolution = alphaMapResolution; // In LB 2.2.1 and earlier, this was always the default of 512
                                    newTerrainData.SetDetailResolution(1024, 16);
                                    newTerrainData.wavingGrassSpeed = grassWindSpeed;
                                    newTerrainData.wavingGrassAmount = grassWindRippleSize;
                                    newTerrainData.wavingGrassStrength = grassWindBending;
                                    newTerrainData.wavingGrassTint = grassWindTint;
                                    if (useProjectForTerrainData)
                                    {
                                        newTerrainData.name = landscapeName + "TerrainData" + index.ToString("0000");
                                        AssetDatabase.CreateAsset(newTerrainData, "Assets/" + terrainDataFolder + "/" + newTerrainData.name + ".asset");
                                    }
                                    else { newTerrainData.name = "LandscapeTerrain" + index.ToString("0000"); }
                                    newTerrain.terrainData = newTerrainData;
                                    newTerrainCol.terrainData = newTerrainData;
                                    index++;
                                    if (EditorUtility.DisplayCancelableProgressBar("Creating Terrains", "Creating " + index.ToString() + " of " + numberOfTerrains.ToString() + " terrains",
                                                                                   (float)index / (float)numberOfTerrains))
                                    {
                                        xF = landscapeSize.x;
                                        yF = landscapeSize.y;
                                        DestroyImmediate(landscapeGameObject);
                                    }
                                }
                            }
                            if (landscapeGameObject != null)
                            {
                                landscape = landscapeGameObject.AddComponent<LBLandscape>();
                                landscapeSelection = landscape;
                                landscapeGameObjectSelection = landscapeGameObject;
                                landscape.SetTerrainNeighbours(true);
                                landscape.size = landscapeSize;
                                landscape.start = startPosition;
                                landscape.LastUpdatedVersion = LBVersion;
                                landscape.useLegacyNoiseOffset = isLegacyNoiseOffsetEnabled;
                                selectedTabInt = 1;
                                isReparentRequired = false;

                                // Added LB 2.1.5
                                LBEditorCommon.currentLandscape = landscape;

                                RefreshTerrainTexturesAvailableList();
                                RefreshAppliedTexturesList();
                                RefreshAppliedGrassList();

                                // In U2019.2+, when new terrains are created, no terrain material is applied.
                                // So apply the standard material.
#if UNITY_2019_2_OR_NEWER
                                landscape.SetLandscapeTerrains(true);
                                numberOfTerrains = landscape.landscapeTerrains == null ? 0 : landscape.landscapeTerrains.Length;
                                for (index = 0; index < numberOfTerrains; index++)
                                {
                                    SetTerrainMaterial(landscape.landscapeTerrains[index], index, (index == numberOfTerrains - 1), terrainMaterialType, LBLandscape.TerrainMaterialType.BuiltInStandard);
                                }
#endif

                                // Check the main camera far clipping plane
                                if (Camera.main != null)
                                {
                                    if (Camera.main.farClipPlane < landscape.size.x * 1.5f)
                                    {
                                        string msg = "Your main camera far clipping plane is not ideal for editing this landscape " +
                                                     "Do you want to automatically fix that now? You can change it again later when you want to publish your project.";
                                        if (EditorUtility.DisplayDialog("Adjust main camera far clipping plane", msg, "Yes", "No"))
                                        {
                                            Camera.main.farClipPlane = landscape.size.x * 1.5f;
                                        }
                                    }
                                }

#if VEGETATION_STUDIO
                                if (landscape.vegetationStudioCameraList == null) { landscape.vegetationStudioCameraList = new List<Camera>(); }
#endif

                                // Position the new landscape in the centre of the scene view
                                Selection.activeGameObject = landscapeGameObject;
                                LBEditorHelper.FrameObjectInSceneView(landscape.size.x * 1.5f, new Vector3(30f, 0f, 0f), this.GetType());

                                // Update Landscape stats
                                landscapeMinMaxHeight = landscape.GetLandscapeMinMaxHeights();

                                // GPU off (see below)
                                landscape.useGPUTopography = false;
                                landscape.useGPUTexturing = false;
                                landscape.useGPUGrass = false;
                                landscape.useGPUPath = false;

                                // Enable GPU Acceleration by default if available on supported platforms
#if (UNITY_STANDALONE_OSX || UNITY_STANDALONE_WIN || UNITY_XBOXONE || UNITY_WSA_10_0)
                                if (landscape.IsGPUAccelerationAvailable())
                                {
                                    landscape.useGPUTopography = true;
                                    landscape.useGPUTexturing = true;
                                    landscape.useGPUGrass = true;
                                    landscape.useGPUPath = true;
                                }
#endif

                                landscape.useProjectForTerrainData = useProjectForTerrainData;
                                landscape.terrainDataFolder = terrainDataFolder;
                            }
                            EditorUtility.ClearProgressBar();
                            isSceneSaveRequired = true;
                        }
                    }
                }
                #endregion

                #region Landscape Stats
                // Only give option to display Landscape Stats if a Landscape is selected in the editor
                if (landscapeGameObject != null && landscape != null)
                {
                    EditorGUILayout.Space();
                    showLandscapeStats = EditorGUILayout.Foldout(showLandscapeStats, "Landscape Stats");

                    if (!showLandscapeStats)
                    {
                        // if the stats aren't expanded, turn off the height picker
                        heightPickerEnabled = false;
                        if (heightPickerHighlighter != null) { DestroyImmediate(heightPickerHighlighter.gameObject); }
                    }
                    else
                    {
                        bool isNonStandardSize = landscapeSize.x != landscapeSize.y;

                        // Find all landscape terrains
                        landscapeTerrains = landscapeGameObject.GetComponentsInChildren<Terrain>();
                        int numTerrains = landscapeTerrains == null ? 0 : landscapeTerrains.Length;
                        int numTerrainsWide = (int)Mathf.Sqrt(numTerrains);

                        // Cater for a rare problem (we're not sure how this occurs) - Don't detect non-imported terrains
                        if (numTerrainsWide * terrainWidth != landscapeSize.x && landscapeSize.x > 0f)
                        {
                            EditorGUILayout.HelpBox("The current landscape size does not match your terrains", MessageType.Error, true);
                            if (GUILayout.Button("Fix Now"))
                            {
                                landscapeSize.x = numTerrainsWide * terrainWidth;
                                landscapeSize.y = numTerrainsWide * terrainLength;
                                landscape.size = landscapeSize;
                                isSceneSaveRequired = true;
                            }
                        }

                        EditorGUILayout.HelpBox("Landscape Stats provides you with useful information about your landscape.", MessageType.None, true);

                        if (numTerrains > 16 && !landscape.useProjectForTerrainData)
                        {
                            EditorGUILayout.HelpBox("With 25+ terrains, we recommend storing terrain data in a Project folder. This can be set in Terrain Settings.", MessageType.Info, true);
                        }

                        EditorGUILayout.LabelField("Start Position: x:" + landscape.start.x + " y:" + landscape.start.y + " z:" + +landscape.start.z);
                        EditorGUILayout.LabelField("Landscape Size: " + landscapeSize.x + "m by " + landscapeSize.y + "m" + (isNonStandardSize ? "  ** Non-Standard **" : ""));
                        EditorGUILayout.LabelField("Terrain Size: " + terrainWidth + "m by " + terrainLength + "m");
                        EditorGUILayout.LabelField("Terrain Height: " + terrainHeight + "m");
                        EditorGUILayout.LabelField("Terrain Heightmap Resolution: " + heightmapResolution);
                        int numberOfTrees = 0;
                        for (index = 0; index < numTerrains; index++)
                        {
                            // Avoid null reference if the terrainData has been deleted on a non-LB imported terrain
                            if (landscapeTerrains[index].terrainData != null) { numberOfTrees += landscapeTerrains[index].terrainData.treeInstanceCount; }
                        }
                        EditorGUILayout.LabelField("Terrains In Landscape: " + landscapeTerrains.Length.ToString());
                        EditorGUILayout.LabelField("Trees In Landscape: " + numberOfTrees.ToString());
                        EditorGUILayout.LabelField("Meshes In Landscape: " + landscape.numberOfMeshes.ToString());
                        EditorGUILayout.LabelField("Prefabs In Landscape: " + landscape.numberOfMeshPrefabs.ToString());
                        EditorGUILayout.LabelField("Prefabs In Landscape: " + landscape.numberOfGroupPrefabs.ToString() + " (Groups)");

                        if (float.IsInfinity(landscapeMinMaxHeight.x) || float.IsInfinity(landscapeMinMaxHeight.y))
                        {
                            EditorGUILayout.LabelField("Landscape Height Min: 0m Max: 0m");
                        }
                        else
                        {
                            EditorGUILayout.LabelField("Landscape Height Min: " + landscapeMinMaxHeight.x.ToString("0.0") + "m Max: " + landscapeMinMaxHeight.y.ToString("0.0") + "m");
                        }

                        if (isNonStandardSize)
                        {
                            EditorGUILayout.HelpBox("Not all features are supported, and some may give unpredictable results. Use square landscapes where possible. **", MessageType.Warning, true);
                        }

                        GUILayout.BeginHorizontal();
                        if (GUILayout.Button("Refresh", GUILayout.MaxWidth(60f)))
                        {
                            if (landscapeGameObject.transform.position != landscape.start)
                            {
                                landscape.MoveLandscape(landscapeGameObject.transform.position);
                                Debug.Log("Updated landscape to new position at " + landscape.start);
                            }

                            // We need to flush each terrain so that the sceneview is updated in the editor
                            landscape.SetTerrainNeighbours(true);

                            isSceneSaveRequired = true;

                            landscapeMinMaxHeight = landscape.GetLandscapeMinMaxHeights();
                        }
                        if (GUILayout.Button("Display Labels", GUILayout.MaxWidth(100f))) { displayTerrainLabels = !displayTerrainLabels; SceneView.RepaintAll(); }

                        displayLabelColor = EditorGUILayout.ColorField(displayLabelColor, GUILayout.MaxWidth(40f));

                        GUILayout.EndHorizontal();

                        #region Height picker

#if UNITY_2019_1_OR_NEWER
                        if (heightPickerHighlighter != null && SceneView.lastActiveSceneView != null && !SceneView.lastActiveSceneView.drawGizmos)
                        {
                            EditorGUILayout.HelpBox("Turn on Gizmos to allow heights to be updated as you move the mouse in the scene view", MessageType.Warning, true);
                        }
#endif

                        GUILayout.BeginHorizontal();

                        if (GUILayout.Button(new GUIContent("Height Picker", "Toggle Height Picker in scene view On/Off. Click in scene to get terrain slope."), GUILayout.Width(90f)))
                        {
                            mouseClickEvent = false;
                            // If the height picker highlighter does not exist, create a new one
                            if (heightPickerHighlighter == null)
                            {
                                heightPickerHighlighter = GameObject.FindObjectOfType<LBTerrainHighlight>();
                                if (heightPickerHighlighter != null)
                                {
                                    heightPickerEnabled = false;
                                    DestroyImmediate(heightPickerHighlighter.gameObject);
                                    heightPickerSlopeOutput = 0f;
                                }
                                else
                                {
                                    LBEditorHelper.ShowSceneView(this.GetType());
                                    heightPickerHighlighter = LBTerrainHighlight.CreateTerrainHighLighter("HeightPickerHighlighter");
                                    heightPickerEnabled = true;
                                    heightPickerSlopeOutput = 0f;
                                }
                            }
                            else
                            {
                                heightPickerEnabled = false;
                                DestroyImmediate(heightPickerHighlighter.gameObject);
                            }
                        }
                        else if (heightPickerHighlighter != null)
                        {
                            // Update the highlighter position in the scene view window
                            heightPickerHighlighter.SetProjectorValues(10f, terrainHeight);

                            // Get the current world space position of the heightpicker
                            heightPickerWorldPosition = heightPickerHighlighter.GetRealWorldPosition();

                            // Get the current height in the terrain
                            heightPickerOutput = heightPickerWorldPosition.y;

                            if (mouseClickEvent)
                            {
                                mouseClickEvent = false;
                                if (!EditorApplication.isPlaying)
                                {
                                    heightPickerSlopeOutput = LBLandscapeTerrain.GetSlope(landscape, new Vector2(heightPickerWorldPosition.x, heightPickerWorldPosition.z));
                                }
                            }

                            EditorGUILayout.LabelField("Height: " + heightPickerOutput.ToString("0.0") + "m " + heightPickerSlopeOutput.ToString("0.0") + " deg  WS: " + heightPickerWorldPosition.x.ToString("0.0") + "," + heightPickerWorldPosition.z.ToString("0.0"), GUILayout.MaxWidth(275f));
                        }
                        GUILayout.EndHorizontal();
                        #endregion
                    }
                }
                #endregion

                #region Scene Settings
                EditorGUILayout.Space();
                showSceneSettings = EditorGUILayout.Foldout(showSceneSettings, "Scene Settings");
                if (!showSceneSettings)
                {
                    // If the scene settings foldout is collapsed, make sure the water highlighter is not displayed in the scene view
                    if (waterHighlighter != null)
                    {
                        waterHighlighterEnabled = false;
                        DestroyImmediate(waterHighlighter.gameObject);
                    }
                }
                else
                {
                    // Show scene settings
                    EditorGUILayout.HelpBox("Scene Settings gives you control over the overall look and feel of your scene.", MessageType.None, true);

                    #region Water
                    // WATER
                    if (waterResizingMode == LBWater.WaterResizingMode.CalmWater)
                    {
                        waterPrefab = null; // Calm Water doesn't use a prefab, we need to create a custom plane
                    }
                    else
                    {
                        waterPrefab = (Transform)EditorGUILayout.ObjectField(sceneWaterPrefabContent, waterPrefab, typeof(Transform), false);
                    }
                    waterIsPrimary = EditorGUILayout.Toggle(scenePrimaryBodyOfWaterContent, waterIsPrimary);
                    if (waterIsPrimary)
                    {
                        waterHeight = EditorGUILayout.Slider(sceneWaterLevelContent, waterHeight, 0f, terrainHeight);

                        if (!waterIsRiver)
                        {
                            // The number of times greater in size that the water is than then landscape
                            waterScaleFactorIndex = EditorGUILayout.Popup("Water Size Factor", waterScaleFactorIndex, LBWaterOperations.WaterPrimarySizeFactorArray, GUILayout.Width(220f));
                        }
                    }

                    // AQUAS Lite always keeps the aspect ratio
                    if (waterResizingMode == LBWater.WaterResizingMode.AQUASLite)
                    {
                        if (waterPrefab == null)
                        {
                            // Attempt to find AQUAS Lite in the project
                            waterPrefab = (Transform)AssetDatabase.LoadAssetAtPath("Assets/AQUAS-Lite/Prefabs/WaterPlane.prefab", typeof(Transform));
                        }
                        waterKeepPrefabAspectRatio = true;
                    }
                    else if (waterResizingMode == LBWater.WaterResizingMode.AQUAS)
                    {
                        if (waterPrefab == null)
                        {
                            // Attempt to find AQUAS in the project
                            waterPrefab = (Transform)AssetDatabase.LoadAssetAtPath("Assets/AQUAS/Prefabs/AQUASWater.prefab", typeof(Transform));
                        }
                        waterKeepPrefabAspectRatio = true;
                    }
                    else if (waterResizingMode == LBWater.WaterResizingMode.CalmWater)
                    {
                        waterKeepPrefabAspectRatio = true;
                    }
                    else
                    {
                        waterKeepPrefabAspectRatio = EditorGUILayout.Toggle(sceneKeepWaterAspectRatioContent, waterKeepPrefabAspectRatio);
                    }

                    EditorGUI.BeginChangeCheck();
                    waterResizingMode = (LBWater.WaterResizingMode)EditorGUILayout.EnumPopup(sceneWaterResizingModeContent, waterResizingMode);
                    if (EditorGUI.EndChangeCheck())
                    {
                        if (waterResizingMode == LBWater.WaterResizingMode.StandardAssets)
                        {
                            waterIsRiver = false;
                            waterScaleFactorIndex = 3; // 2x
                                                       // Reset water prefab if AQUAS was being used last
                            if (waterPrefab != null) { if (waterPrefab.name.StartsWith("AQUAS")) { waterPrefab = null; } }
                            waterMaterial = null;

                            LBEditorHelper.HighlightItemInProjectWindow("Assets/LandscapeBuilder/Standard Assets/Environment/Water");
                        }
                        else if (waterResizingMode == LBWater.WaterResizingMode.DuplicatingMeshes || waterResizingMode == LBWater.WaterResizingMode.TransformScaling)
                        {
                            waterIsRiver = false;
                            waterScaleFactorIndex = 3; // 2x
                                                       // Reset water prefab if AQUAS was being used last
                            if (waterPrefab != null) { if (waterPrefab.name.StartsWith("AQUAS")) { waterPrefab = null; } }
                            waterMaterial = null;
                        }
                        else if (waterResizingMode == LBWater.WaterResizingMode.AQUASLite)
                        {
                            waterIsRiver = false;
                            waterScaleFactorIndex = 3; // 2x
                            waterMaterial = null;
                        }
                        else if (waterResizingMode == LBWater.WaterResizingMode.AQUAS)
                        {
                            if (waterIsRiver) { waterScaleFactorIndex = 0; } // 1x - same size as landscape
                            else { waterScaleFactorIndex = 3; } // 2x
                            waterMaterial = null;
                        }
                        else if (waterResizingMode == LBWater.WaterResizingMode.CalmWater)
                        {
                            waterIsRiver = false;
                            waterRiverMaterial = null;
                            LBEditorHelper.HighlightItemInProjectWindow("Assets/Calm Water/Demo/Materials");
                        }
                    }

                    if (waterResizingMode == LBWater.WaterResizingMode.AQUASLite || waterResizingMode == LBWater.WaterResizingMode.AQUAS)
                    {
                        waterMainCamera = (Camera)EditorGUILayout.ObjectField(sceneWaterMainCameraContent, waterMainCamera, typeof(Camera), true);
                        if (waterMainCamera == null) { waterMainCamera = Camera.main; }
                    }

                    if (waterResizingMode == LBWater.WaterResizingMode.AQUAS)
                    {
                        if (waterCausticsList == null) { waterCausticsList = new List<LBWaterCaustics>(); }
                        if (waterCausticsList != null)
                        {
                            // AQUAS uses a primary and secondary caustic.
                            if (waterCausticsList.Count == 0)
                            {
                                waterCausticsList.Add(new LBWaterCaustics());
                                waterCausticsList.Add(new LBWaterCaustics());
                                waterCausticsList[0].isPrimaryWaterCaustics = true;
                            }

                            // Get the prefabs and store them in a list
                            if (waterCausticsList.Count == 2)
                            {
                                if (waterCausticsPrefabList == null) { waterCausticsPrefabList = new List<Transform>(); }
                                if (waterCausticsPrefabList != null)
                                {
                                    while (waterCausticsPrefabList.Count < 2)
                                    {
                                        waterCausticsPrefabList.Add(null);
                                    }

                                    // Auto-fill the prefabs if they are in the default folders
                                    if (waterCausticsPrefabList[0] == null)
                                    {
                                        waterCausticsPrefabList[0] = (Transform)AssetDatabase.LoadAssetAtPath("Assets/AQUAS/Prefabs/PrimaryCausticsProjector.prefab", typeof(Transform));
                                    }
                                    if (waterCausticsPrefabList[1] == null)
                                    {
                                        waterCausticsPrefabList[1] = (Transform)AssetDatabase.LoadAssetAtPath("Assets/AQUAS/Prefabs/SecondaryCausticsProjector.prefab", typeof(Transform));
                                    }

                                    waterCausticsPrefabList[0] = (Transform)EditorGUILayout.ObjectField(sceneWaterPrimaryCausticPrefabContent, waterCausticsPrefabList[0], typeof(Transform), false);
                                    waterCausticsPrefabList[1] = (Transform)EditorGUILayout.ObjectField(sceneWaterSecondaryCausticPrefabContent, waterCausticsPrefabList[1], typeof(Transform), false);
                                }
                            }
                            else
                            {
                                Debug.LogError("Landscape Builder - could not create LBWaterCaustic instances for AQUAS");
                            }
                        }
                    }
                    else if (isCalmWaterInstalled && waterResizingMode == LBWater.WaterResizingMode.CalmWater)
                    {
                        if (waterCausticsList == null) { waterCausticsList = new List<LBWaterCaustics>(); }
                        if (waterCausticsList != null)
                        {
                            // Calm Water uses a primary caustic.
                            if (waterCausticsList.Count == 0)
                            {
                                waterCausticsList.Add(new LBWaterCaustics());
                                waterCausticsList[0].isPrimaryWaterCaustics = true;
                            }

                            // Get the prefab and store them in a list
                            if (waterCausticsList.Count == 1)
                            {
                                if (waterCausticsPrefabList == null) { waterCausticsPrefabList = new List<Transform>(); }
                                if (waterCausticsPrefabList != null)
                                {
                                    if (waterCausticsPrefabList.Count == 0) { waterCausticsPrefabList.Add(null); }

                                    // Auto-fill the prefabs if they are in the default folders
                                    if (waterCausticsPrefabList[0] == null)
                                    {
                                        waterCausticsPrefabList[0] = (Transform)AssetDatabase.LoadAssetAtPath("Calm Water/Demo/Prefabs/CausticsProjector.prefab", typeof(Transform));
                                    }

                                    waterCausticsPrefabList[0] = (Transform)EditorGUILayout.ObjectField(sceneWaterCausticPrefabContent, waterCausticsPrefabList[0], typeof(Transform), false);
                                }
                            }
                            else
                            {
                                Debug.LogError("Landscape Builder - could not create LBWaterCaustic instance for Calm Water");
                            }
                        }
                    }

                    // AQUAS River mode should work with Primary and Secondary water bodies
                    if (isAQUASRiverInstalled && waterResizingMode == LBWater.WaterResizingMode.AQUAS)
                    {
                        if (waterIsPrimary) { labelText = "Is this primary water body going to be used to create rivers anywhere in the landscape? This will enable you to create flowing rivers "; }
                        else { labelText = "Is this a river? This will enable you to create a flowing river "; }
                        labelText += "with the Map Path feature in Landscape Builder.";

                        EditorGUI.BeginChangeCheck();
                        waterIsRiver = EditorGUILayout.Toggle(new GUIContent("Is River", labelText), waterIsRiver);
                        if (EditorGUI.EndChangeCheck())
                        {
                            if (waterIsRiver) { waterScaleFactorIndex = 0; } // 1x - same size as landscape
                            else { waterScaleFactorIndex = 3; } // 2x
                            isSceneSaveRequired = true;
                        }
                        // Preload the AQUAS river material
                        if (waterRiverMaterial == null)
                        {
                            waterRiverMaterial = (Material)AssetDatabase.LoadAssetAtPath("Assets/AQUAS/Materials/Water/Desktop&Web/River.mat", typeof(Material));
                        }
                        if (waterIsRiver)
                        {
                            waterRiverMaterial = (Material)EditorGUILayout.ObjectField(new GUIContent("River Material"), waterRiverMaterial, typeof(Material), true);
                        }
                    }
                    else if (waterResizingMode == LBWater.WaterResizingMode.CalmWater)
                    {
                        if (isCalmWaterInstalled)
                        {
                            waterMaterial = (Material)EditorGUILayout.ObjectField(sceneWaterCalmWaterMaterialContent, waterMaterial, typeof(Material), true);
                        }
                        else
                        {
                            labelText = "Did you import the Calm Water package into your project?";
                            EditorGUILayout.HelpBox(labelText, MessageType.Info, true);
                        }
                    }

                    if (!waterIsPrimary)
                    {
                        if (landscape != null)
                        {
                            waterSecondarySize = EditorGUILayout.Slider(sceneWaterSecondarySizeContent, waterSecondarySize, 2f, landscape.size.x);

                            // Allow the user to control the size of the water highlighter with the square bracket keys
                            Event currentEvent = Event.current;
                            if (currentEvent.type == EventType.KeyDown && currentEvent.keyCode == KeyCode.RightBracket)
                            {
                                waterSecondarySize = Mathf.Clamp(waterSecondarySize * 1.1f, 2f, landscapeSize.x);
                            }
                            else if (currentEvent.type == EventType.KeyDown && currentEvent.keyCode == KeyCode.LeftBracket)
                            {
                                waterSecondarySize = Mathf.Clamp(waterSecondarySize / 1.1f, 2f, landscapeSize.x);
                            }
                        }

                        if (GUILayout.Button("Toggle Highlighter", GUILayout.Width(120f)))
                        {
                            // If the terrain highlighter does not exist, create a new one
                            if (waterHighlighter == null)
                            {
                                waterHighlighter = GameObject.FindObjectOfType<LBTerrainHighlight>();
                                if (waterHighlighter != null)
                                {
                                    waterHighlighterEnabled = false;
                                    DestroyImmediate(waterHighlighter.gameObject);
                                }
                                else
                                {
                                    waterHighlighter = LBTerrainHighlight.CreateTerrainHighLighter();
                                    waterHighlighterEnabled = true;
                                }
                            }
                            else
                            {
                                waterHighlighterEnabled = false;
                                DestroyImmediate(waterHighlighter.gameObject);
                            }
                        }
                        else if (waterHighlighter != null)
                        {
                            // Update the highlighter position in the scene view window
                            waterHighlighter.SetProjectorValues(waterSecondarySize / 2f, terrainHeight);
                        }
                    }
                    else if (waterHighlighter != null)
                    {
                        waterHighlighterEnabled = false;
                        DestroyImmediate(waterHighlighter.gameObject);
                    }

                    // If there is no landscape or prefab, let the user know
                    if (landscapeGameObject == null || landscape == null)
                    {
                        EditorGUILayout.HelpBox("To add water to the scene, select a landscape to edit.", MessageType.Info, true);
                    }
                    else if ((waterPrefab == null && waterResizingMode != LBWater.WaterResizingMode.CalmWater) && landscapeGameObject != null && landscape != null)
                    {
                        if (waterResizingMode == LBWater.WaterResizingMode.AQUAS)
                        {
                            labelText = "Did you import the AQUAS package into your project?\nTo add water to the scene, add a Water Prefab";
                        }
                        else { labelText = "To add water to the scene, add a Water Prefab or select AQUAS or Calm Water from the Water Resizing Mode"; }
                        EditorGUILayout.HelpBox(labelText, MessageType.Info, true);
                    }

                    if ((waterPrefab != null || (waterResizingMode == LBWater.WaterResizingMode.CalmWater && waterMaterial != null)) && landscapeGameObject != null && landscape != null)
                    {
                        if (waterIsPrimary)
                        {
                            if (GUILayout.Button("Add Water To Scene"))
                            {
                                // Check to see if the primary body of water already exists in the scene
                                LBWater primaryLBWater = LBWaterOperations.GetPrimaryWaterBody(landscape);

                                // The primary water body is placed in the centre of the landscape
                                waterPosition = landscape.start + (0.5f * new Vector3(landscape.size.x, 0f, landscape.size.y));

                                AddWaterToScene(waterIsPrimary, primaryLBWater, waterScaleFactorIndex, waterHeight, waterPrefab, waterKeepPrefabAspectRatio,
                                                waterResizingMode, waterPosition, Vector2.zero, waterMaxMeshThreshold, waterMainCamera, waterCausticsPrefabList, true, false,
                                                waterIsRiver, waterRiverMaterial, null, waterMaterial);
                            }
                        }
                        else
                        {
                            // Add Secondary water
                            EditorGUILayout.HelpBox("Toggle the Highlighter on, move the mouse over the scene view, then left click in the scene view to add the water", MessageType.None, true);

                            if (mouseClickEvent)
                            {
                                if (waterHighlighter != null)
                                {
                                    waterPosition = waterHighlighter.GetRealWorldPosition();

                                    // Put the height of the water 10 metres above the select terrain
                                    currentWaterHeight = waterPosition.y + 10f;

                                    // Water will be located at highligher x and z positions
                                    waterPosition = new Vector3(waterPosition.x, 0f, waterPosition.z);

                                    Vector2 waterSize = new Vector2(waterSecondarySize, waterSecondarySize);

                                    // Add Secondary body of Water To Scene
                                    AddWaterToScene(waterIsPrimary, null, waterScaleFactorIndex, currentWaterHeight, waterPrefab, waterKeepPrefabAspectRatio,
                                                    waterResizingMode, waterPosition, waterSize, waterMaxMeshThreshold, waterMainCamera, waterCausticsPrefabList, false, false,
                                                    waterIsRiver, waterRiverMaterial, null, waterMaterial);

                                    // Disable the water highlighter after use
                                    waterHighlighterEnabled = false;
                                    DestroyImmediate(waterHighlighter.gameObject);
                                }

                                mouseClickEvent = false;
                            }
                        }
                    }

                    // Display controls for water that is a child of the Landscape
                    if (landscapeGameObject != null && landscape != null)
                    {
                        if (landscape.landscapeWaterList != null)
                        {
                            EditorGUILayout.Space();
                            lbWaterToRemove = null;
                            foreach (LBWater lbWater in landscape.landscapeWaterList)
                            {
                                if (lbWater != null)
                                {
                                    GUILayout.BeginVertical(EditorStyles.helpBox);

                                    waterLabel = lbWater.name;
                                    if (lbWater.isPrimaryWater) { waterLabel += " (Primary)"; }
                                    GUILayout.BeginHorizontal();
                                    EditorGUI.BeginChangeCheck();
                                    lbWater.isDisabled = !EditorGUILayout.Toggle(!lbWater.isDisabled, GUILayout.MaxWidth(20f));
                                    waterEnabledStateChanged = EditorGUI.EndChangeCheck();
                                    EditorGUILayout.LabelField(waterLabel);
                                    GUILayout.EndHorizontal();

                                    // Calm Water doesn't have a prefab, so only display prefab name for other water types
                                    if (lbWater.resizingMode != LBWater.WaterResizingMode.CalmWater)
                                    {
                                        EditorGUILayout.LabelField("Water Prefab", lbWater.waterPrefabName);
                                    }
                                    currentWaterHeight = lbWater.waterLevel;
                                    lbWater.waterLevel = EditorGUILayout.Slider(new GUIContent("Water Level", "The height above 0 in metres"), lbWater.waterLevel, 0f, terrainHeight);

                                    // AQUAS and Calm Water always keeps the aspect ratio the same
                                    if (lbWater.resizingMode != LBWater.WaterResizingMode.AQUAS && lbWater.resizingMode != LBWater.WaterResizingMode.AQUASLite && lbWater.resizingMode != LBWater.WaterResizingMode.CalmWater)
                                    {
                                        if (!lbWater.isPrimaryWater)
                                        {
                                            lbWater.waterSize.x = EditorGUILayout.Slider(new GUIContent("Water Size X", "The size of the body of water on the x axis"), lbWater.waterSize.x, 1f, landscape.size.x);
                                            lbWater.waterSize.y = EditorGUILayout.Slider(new GUIContent("Water Size Z", "The size of the body of water on the z axis"), lbWater.waterSize.y, 1f, landscape.size.y);
                                        }

                                        lbWater.keepPrefabAspectRatio = EditorGUILayout.Toggle(new GUIContent("Keep Aspect Ratio", "Keep the aspect ratio of the water prefab"), lbWater.keepPrefabAspectRatio);
                                    }
                                    else
                                    {
                                        // AQUAS Water Set and AQUAS Lite require the same x and z ratio (Keep same for Calm Water too although not strickly a requirement)
                                        if (!lbWater.isPrimaryWater)
                                        {
                                            lbWater.waterSize.x = EditorGUILayout.Slider(new GUIContent("Water Size", "The size of the body of water"), lbWater.waterSize.x, 1f, landscape.size.x);
                                            lbWater.waterSize.y = lbWater.waterSize.x;
                                        }
                                        // The camera will not be set if the project or unity has been restarted or reloaded.
                                        if (waterMainCamera == null && lbWater.resizingMode != LBWater.WaterResizingMode.CalmWater) { waterMainCamera = Camera.main; }
                                    }

                                    EditorGUILayout.Space();

                                    if (waterEnabledStateChanged)
                                    {
                                        // Find water in landscape
                                        waterTransform = LBWaterOperations.FindWaterInLandscape(landscapeGameObject, lbWater);
                                        if (waterTransform != null)
                                        {
                                            waterTransform.gameObject.SetActive(!lbWater.isDisabled);
                                            if (!EditorApplication.isPlayingOrWillChangePlaymode)
                                            {
                                                EditorSceneManager.MarkSceneDirty(EditorSceneManager.GetActiveScene());
                                            }
                                        }
                                        else if (EditorUtility.DisplayDialog("Missing Water", "The water cannot be found in the Landscape. Do you want to remove it from the Landscape Tab?", "Yes", "Cancel"))
                                        {
                                            lbWaterToRemove = lbWater;
                                        }
                                    }

                                    if (currentWaterHeight != lbWater.waterLevel)
                                    {
                                        // Find water in landscape
                                        waterTransform = LBWaterOperations.FindWaterInLandscape(landscapeGameObject, lbWater);

                                        if (waterTransform != null)
                                        {
                                            Vector3 waterPos = waterTransform.position;

                                            // Adjust the water level
                                            waterTransform.position = new Vector3(waterPos.x, lbWater.waterLevel, waterPos.z);

                                            // If the user has changed the name of the gameobject, update the name in the list
                                            if (waterTransform.name != lbWater.name) { lbWater.name = waterTransform.name; }

                                            if (lbWater.resizingMode == LBWater.WaterResizingMode.AQUAS && lbWater.isUnderWaterFXEnabled)
                                            {
                                                LBIntegration.AQUASUpdateBorders(landscape, waterTransform.gameObject, lbWater.waterSize, lbWater.waterLevel, true);
                                            }

                                            // Should save the scene if autoSaveEnabled but may be too expensive with each slider movement
                                            EditorSceneManager.MarkSceneDirty(EditorSceneManager.GetActiveScene());
                                        }
                                        else if (EditorUtility.DisplayDialog("Missing Water", "The water cannot be found in the Landscape. Do you want to remove it from the Landscape Tab?", "Yes", "Cancel"))
                                        {
                                            lbWaterToRemove = lbWater;
                                        }
                                    }
                                    EditorGUILayout.LabelField("Water Resizing Mode", lbWater.resizingMode.ToString());
                                    if (lbWater.resizingMode == LBWater.WaterResizingMode.AQUAS && isAQUASRiverInstalled)
                                    {
                                        if (!lbWater.isPrimaryWater)
                                        {
                                            lbWater.isRiver = EditorGUILayout.Toggle(new GUIContent("Is River", ""), lbWater.isRiver);
                                        }

                                        EditorGUI.BeginChangeCheck();
                                        lbWater.isUnderWaterFXEnabled = EditorGUILayout.Toggle(new GUIContent("Under Water FX", "Adds Underwater effect to the camera"), lbWater.isUnderWaterFXEnabled);
                                        if (EditorGUI.EndChangeCheck())
                                        {
                                            Transform underWaterFXPrefab = null;
                                            if (lbWater.isUnderWaterFXEnabled)
                                            {
                                                // Find the AQUAS Underwater FX prefab
                                                underWaterFXPrefab = (Transform)AssetDatabase.LoadAssetAtPath("Assets/AQUAS/Prefabs/UnderWaterCameraEffects.prefab", typeof(Transform));

                                                if (underWaterFXPrefab == null) { Debug.LogWarning("Landscape Builder - could not find AQUAS UnderWaterCameraEffects.prefab - have you moved it from the default location?"); }
                                                else
                                                {
                                                    lbWater.underWaterFXPrefabName = underWaterFXPrefab.name;
                                                    lbWater.underWaterFXPrefabPath = AssetDatabase.GetAssetPath(underWaterFXPrefab);
                                                }
                                            }

                                            waterTransform = LBWaterOperations.FindWaterInLandscape(landscapeGameObject, lbWater);
                                            if (waterTransform == null) { Debug.Log("Adding underwater FX - Could not find water in landscape"); }

                                            LBIntegration.AQUASEnableUnderwaterFX(landscape, waterTransform.gameObject, lbWater.waterSize, lbWater.waterLevel, waterMainCamera.gameObject, lbWater.isUnderWaterFXEnabled, underWaterFXPrefab, true);
                                            isSceneSaveRequired = true;
                                        }

                                        if (lbWater.isRiver)
                                        {
                                            // Adjust the river flow speed in the shader
                                            EditorGUI.BeginChangeCheck();
                                            lbWater.riverFlowSpeed = EditorGUILayout.Slider(new GUIContent("Flow Speed", "Set the speed the river will flow. Negative values make the river flow in the opposite direction."), lbWater.riverFlowSpeed, -25f, 25f);
                                            if (EditorGUI.EndChangeCheck())
                                            {
                                                lbWater.riverMaterial.SetFloat("_FlowSpeed", lbWater.riverFlowSpeed);
                                                // Should save the scene if autoSaveEnabled but may be too expensive with each slider movement
                                                if (!Application.isPlaying)
                                                {
                                                    EditorSceneManager.MarkSceneDirty(EditorSceneManager.GetActiveScene());
                                                }
                                            }

                                            labelText = "The Flow Map Texture. Open and edit in Flow Map Painter (http://teckartist.com) Save the output PNG file into the same folder, then add the PNG texture to the Flow Map provided here.";
                                            EditorGUI.BeginChangeCheck();
                                            lbWater.flowMapTexture = (Texture2D)EditorGUILayout.ObjectField(new GUIContent("Flow Map", labelText), lbWater.flowMapTexture, typeof(Texture2D), false);
                                            if (EditorGUI.EndChangeCheck())
                                            {
                                                if (lbWater.flowMapTexture != null)
                                                {
#if UNITY_5_5_OR_NEWER
                                                    LBTextureOperations.SetTextureAttributes(lbWater.flowMapTexture, TextureImporterCompression.Uncompressed, FilterMode.Trilinear, false, 256, false);
#else
                                                LBTextureOperations.SetTextureAttributes(lbWater.flowMapTexture, TextureImporterFormat.AutomaticTruecolor, FilterMode.Trilinear, false, 256, false);
#endif
                                                }

                                                // Update the Flow Map texture in the shader
                                                lbWater.riverMaterial.SetTexture("_FlowMap", lbWater.flowMapTexture);

                                                if ((lbWater.riverMaterial.GetFloat("_UsingLinearColorSpace") == 1f) != isLinearColourSpace)
                                                {
                                                    lbWater.riverMaterial.SetFloat("_UsingLinearColorSpace", isLinearColourSpace ? 1 : 0);
                                                }

                                                isSceneSaveRequired = true;
                                            }
                                        }
                                    }

                                    GUILayout.BeginHorizontal();
                                    if (GUILayout.Button("Remove Water", GUILayout.Width(100f)))
                                    {
                                        lbWaterToRemove = lbWater;
                                    }
                                    if (!lbWater.isPrimaryWater)
                                    {
                                        if (GUILayout.Button("Resize Water", GUILayout.MaxWidth(95f)))
                                        {
                                            lbWaterToResize = lbWater;
                                            waterResizing = true;
                                        }
                                    }
                                    if (lbWater.resizingMode == LBWater.WaterResizingMode.AQUAS)
                                    {
                                        if (GUILayout.Button("AQUAS Support", GUILayout.MaxWidth(105f))) { Application.OpenURL("http://forum.unity3d.com/threads/401340/"); }
                                    }

                                    GUILayout.EndHorizontal();

                                    if (lbWater.isRiver && lbWater.resizingMode == LBWater.WaterResizingMode.AQUAS && isAQUASRiverInstalled)
                                    {
                                        labelText = "1. Create River Ref Texture\n";
                                        labelText += "2. Open Flow Map Painter\n";
                                        labelText += "3. Add the path of the ref jpg texture to custom Texture Path.\n";
                                        labelText += "4. Set UV Tiling to 1.\n";
                                        labelText += "5. Load Custom Tiling Texture\n";
                                        labelText += "6. Click Flow Lines (F)\n";
                                        labelText += "7. Draw the flow map\n";
                                        labelText += "8. Set Save to file name\n";
                                        labelText += "9. Bake to Texture.\n";
                                        labelText += "10. In LB add the new flow map to the water flow map.";
                                        EditorGUILayout.LabelField(labelText, helpBoxRichText);
                                        //EditorGUILayout.HelpBox(labelText, MessageType.Info, true);

                                        GUILayout.BeginHorizontal();
                                        if (GUILayout.Button(new GUIContent("Create River Ref Texture", "Create a new River Reference Image which will be used to paint the AQUAS flow map"), GUILayout.MaxWidth(160f)))
                                        {
                                            waterTransform = LBWaterOperations.FindWaterInLandscape(landscapeGameObject, lbWater);
                                            LBIntegration.AQUASCreateReferenceImage(waterMainCamera.gameObject, waterTransform.gameObject, true);

                                            // Find the reference image that was added and highlight it in the Project window
                                            string lastFileUpdated = LBIntegration.GetLastUpdatedFile("Assets/RiverReferences", "jpg");
                                            if (!string.IsNullOrEmpty(lastFileUpdated))
                                            {
                                                LBEditorHelper.HighlightItemInProjectWindow("Assets/RiverReferences/" + lastFileUpdated);
                                            }
                                        }

                                        // If flow map painter path is not set, show the "Get Flow Map Painter" button
                                        if (string.IsNullOrEmpty(pathFlowMapPainter))
                                        {
                                            if (GUILayout.Button(new GUIContent("Get Flow Map Painter", "This is required to paint the flow map on the AQUAS River Reference texture"), GUILayout.MaxWidth(145f)))
                                            {
                                                Application.OpenURL("http://teckartist.com/?page_id=107");
                                            }
                                        }
                                        // If Flow Map Painter seems to be installed, attempt to open it.
                                        else if (GUILayout.Button(new GUIContent("Flow Map Painter", "This is required to paint the flow map on the AQUAS River Reference texture"), GUILayout.MaxWidth(145f)))
                                        {
                                            // Convert spaces and format for OpenURL.
                                            string _flowmappainterPath = "file:///" + pathFlowMapPainter.Replace(" ", "%20");

                                            if (!File.Exists(pathFlowMapPainter))
                                            {
                                                Debug.Log("Could not find Flow Map Painter at " + pathFlowMapPainter + " Is it installed?");
                                                string msg = "Flow Map Painter may not be installed. Did you download it and set the path to the EXE/APP on the LB Advanced Tab?";
                                                EditorUtility.DisplayDialog("Flow Map Painter", msg, "OK");
                                            }
                                            else { Application.OpenURL(_flowmappainterPath); }
                                        }
                                        GUILayout.EndHorizontal();
                                    }

                                    GUILayout.EndVertical();
                                    EditorGUILayout.Space();
                                }
                            }

                            // Did the user wish to remove any water assets from landscape?
                            if (lbWaterToRemove != null)
                            {
                                RemoveWaterFromScene(lbWaterToRemove);

                                landscape.landscapeWaterList.Remove(lbWaterToRemove);
                                lbWaterToRemove = null;
                                EditorSceneManager.MarkSceneDirty(EditorSceneManager.GetActiveScene());
                            }
                            else if (lbWaterToResize != null && waterResizing)
                            {
                                EditorUtility.DisplayProgressBar("Adding water to scene", "Please Wait", 0.5f);

                                // Resizing involves four steps
                                //  1. Find the original prefabs (none will exist for Calm Water)
                                //  2. Remove the old water from the scene
                                //  3. Create a new copy the correct size
                                //  4. Replace the LBWater instance in the landscape list

                                // Get the prefab
                                Transform resizePrefab = (Transform)AssetDatabase.LoadAssetAtPath(lbWaterToResize.waterPrefabPath, typeof(Transform));

                                bool continueToResize = true;

                                // AQUAS - populate the waterCausticsPrefabList
                                if (lbWaterToResize.resizingMode == LBWater.WaterResizingMode.AQUAS)
                                {
                                    if (waterCausticsPrefabList == null) { waterCausticsPrefabList = new List<Transform>(); }
                                    if (lbWaterToResize.waterCausticList != null)
                                    {
                                        foreach (LBWaterCaustics lbWaterCaustics in lbWaterToResize.waterCausticList)
                                        {
                                            // Get the prefab path and find the prefab in the project
                                            Transform waterCausticsPrefab = (Transform)AssetDatabase.LoadAssetAtPath(lbWaterCaustics.waterCausticPrefabPath, typeof(Transform));
                                            if (waterCausticsPrefab != null)
                                            {
                                                waterCausticsPrefabList.Add(waterCausticsPrefab);
                                            }
                                            else
                                            {
                                                continueToResize = false;
                                                Debug.LogError("Could not find AQUAS Water Caustic prefab at " + lbWaterCaustics.waterCausticPrefabPath + ". Did you move it?");
                                            }
                                        }
                                    }
                                }

                                LBWater addedWater = null;

                                if (!continueToResize) { } // Something went wrong, do nothing further
                                else if (resizePrefab == null && lbWaterToResize.resizingMode != LBWater.WaterResizingMode.CalmWater)
                                {
                                    Debug.Log("Could not find original water prefab at " + lbWaterToResize.waterPrefabPath);
                                }
                                else
                                {
                                    // Find water in landscape (the user may have changed it directly in the scene view
                                    waterTransform = LBWaterOperations.FindWaterInLandscape(landscapeGameObject, lbWaterToResize);

                                    if (waterTransform != null)
                                    {
                                        // Adjust the position to what is current in the scene
                                        lbWaterToResize.waterPosition = new Vector3(waterTransform.position.x, 0f, waterTransform.position.z);

                                        // If the user has changed the name of the gameobject, update the name in the list
                                        if (waterTransform.name != lbWaterToResize.name) { lbWaterToResize.name = waterTransform.name; }
                                    }

                                    // Remove the original body of water from the scene
                                    RemoveWaterFromScene(lbWaterToResize);

                                    // Generate a replacement water body with the new size
                                    int numberOfMeshes = 0;

                                    // Populate the paramaters to pass to AddWaterToScene()
                                    LBWaterParameters lbWaterParms = new LBWaterParameters();
                                    lbWaterParms.landscape = landscape;
                                    lbWaterParms.landscapeGameObject = landscapeGameObject;
                                    lbWaterParms.waterPosition = lbWaterToResize.waterPosition;
                                    lbWaterParms.waterSize = lbWaterToResize.waterSize;
                                    lbWaterParms.waterIsPrimary = lbWaterToResize.isPrimaryWater;
                                    lbWaterParms.waterHeight = lbWaterToResize.waterLevel;
                                    lbWaterParms.waterPrefab = resizePrefab;
                                    lbWaterParms.keepPrefabAspectRatio = lbWaterToResize.keepPrefabAspectRatio;
                                    lbWaterParms.waterResizingMode = lbWaterToResize.resizingMode;
                                    lbWaterParms.waterMaxMeshThreshold = waterMaxMeshThreshold;
                                    lbWaterParms.waterMainCamera = waterMainCamera;
                                    lbWaterParms.waterCausticsPrefabList = waterCausticsPrefabList;
                                    lbWaterParms.isRiver = lbWaterToResize.isRiver;
                                    lbWaterParms.riverMaterial = lbWaterToResize.riverMaterial;
                                    lbWaterParms.isUnderWaterFXEnabled = lbWaterToResize.isUnderWaterFXEnabled;
                                    lbWaterParms.underWaterFXPrefabName = lbWaterToResize.underWaterFXPrefabName;
                                    lbWaterParms.underWaterFXPrefabPath = lbWaterToResize.underWaterFXPrefabPath;
                                    lbWaterParms.flowMapTexture = lbWaterToResize.flowMapTexture;
                                    lbWaterParms.riverFlowSpeed = lbWaterToResize.riverFlowSpeed;
                                    lbWaterParms.waterMaterial = lbWaterToResize.waterMaterial;
                                    lbWaterParms.lbLighting = GameObject.FindObjectOfType<LBLighting>();

                                    addedWater = LBWaterOperations.AddWaterToScene(lbWaterParms, ref numberOfMeshes);
                                }

                                if (addedWater != null)
                                {
                                    // Set the prefab path so that the water can be resized / reinstantiated later
                                    addedWater.waterPrefabPath = lbWaterToResize.waterPrefabPath;
                                    addedWater.waterCausticList = lbWaterToResize.waterCausticList;

                                    if (addedWater.name != lbWaterToResize.name) { addedWater.name = lbWaterToResize.name; }

                                    if (addedWater.isUnderWaterFXEnabled)
                                    {
                                        // After water is resized (replaced) in the scene if UnderWaterFX is enabled, we need to update
                                        // the AQUAS Lens Effects component with the new water gameobject
                                        waterTransform = LBWaterOperations.FindWaterInLandscape(landscapeGameObject, addedWater);
                                        if (waterTransform == null) { Debug.Log("Landscape Builder: While updating underwater FX after resizing water,  could not find water in landscape"); }
                                        else if (waterMainCamera != null)
                                        {
                                            LBIntegration.AQUASUpdateWaterPlanes(waterMainCamera.gameObject, waterTransform.gameObject, true);
                                        }
                                    }

                                    // Find the location in the list so that the resized LBWater can be placed in the
                                    // same location in the list.
                                    int oldWaterIndex = landscape.landscapeWaterList.IndexOf(lbWaterToResize);

                                    if (oldWaterIndex == landscape.landscapeWaterList.Count - 1)
                                    {
                                        // Remove the old one from the list and add the new one
                                        landscape.landscapeWaterList.Remove(lbWaterToResize);
                                        landscape.landscapeWaterList.Add(addedWater);
                                    }
                                    else
                                    {
                                        // Remove the old one from the list and insert the new one
                                        landscape.landscapeWaterList.Remove(lbWaterToResize);
                                        landscape.landscapeWaterList.Insert(oldWaterIndex, addedWater);
                                    }
                                    lbWaterToResize = null;

                                    if (autoSaveEnabled)
                                    {
                                        sceneSaved = EditorSceneManager.SaveScene(EditorSceneManager.GetActiveScene());
                                    }
                                    else
                                    {
                                        EditorSceneManager.MarkSceneDirty(EditorSceneManager.GetActiveScene());
                                    }
                                }
                                EditorUtility.ClearProgressBar();
                                waterResizing = false;
                            }
                        }
                    }
                    #endregion

                    #region LBLighting

                    if (isURP || isHDRP || isLWRP)
                    {
                        EditorGUILayout.HelpBox("Looking for LBLighting? Sorry, it is not supported in Universal, Lightweight or High Definition Render Pipeline.", MessageType.Info, true);
                    }
                    else
                    {
                        LBLighting lightingScript = GameObject.FindObjectOfType<LBLighting>();

                        if (lightingScript == null)
                        {
                            EditorGUILayout.Space();
                            removeOtherDirectionalLights = EditorGUILayout.Toggle(new GUIContent("Remove Directional Lights", "Whether all existing directional lights should" +
                                            " be removed from the scene when setting up lighting"), removeOtherDirectionalLights);

                            if (GUILayout.Button("Set Up Scene Lighting"))
                            {
                                LBLighting lbLighting = LBLighting.AddLightingToScene(removeOtherDirectionalLights);

                                if (autoSaveEnabled) { sceneSaved = EditorSceneManager.SaveScene(EditorSceneManager.GetActiveScene()); }
                                else { EditorSceneManager.MarkSceneDirty(EditorSceneManager.GetActiveScene()); }

                                // Show the LBLighting customer editor
                                if (lbLighting)
                                {
                                    Selection.activeObject = lbLighting.gameObject;
                                    #if UNITY_2018_2_OR_NEWER
                                    LBEditorHelper.CallMenu("Window/General/Inspector");
                                    #else
                                    LBEditorHelper.CallMenu("Window/Inspector");
                                    #endif
                                }
                            }
                        }
                    }
                    #endregion

                    #region WindZone
                    EditorGUILayout.Space();
                    windZonePreset = (WindZonePreset)EditorGUILayout.EnumPopup("Wind Zone Preset", windZonePreset);

                    if (GUILayout.Button("Add Wind Zone To Scene"))
                    {
                        GameObject windZoneGameObject = new GameObject("Landscape Wind Zone");
                        if (landscapeGameObject != null)
                        {
                            windZoneGameObject.transform.parent = landscapeGameObject.transform;
                            windZoneGameObject.name = landscapeGameObject.name + " Wind Zone";
                        }
                        WindZone windZone = windZoneGameObject.AddComponent<WindZone>();
                        SetWindZonePresetValues(windZonePreset, windZone);

                        isSceneSaveRequired = true;
                    }
                    #endregion

                    #region ScreenShot
                    // Screen shot is designed to only work in the Unity Editor
                    LBScreenShot screenshotScript = GameObject.FindObjectOfType<LBScreenShot>();

                    if (screenshotScript == null)
                    {
                        EditorGUILayout.Space();

                        if (GUILayout.Button("Add Screenshot Device to Scene"))
                        {
                            GameObject screenshotObject = new GameObject("LB ScreenShot");
                            if (screenshotObject != null)
                            {
                                screenshotObject.AddComponent<LBScreenShot>();
                            }
                            isSceneSaveRequired = true;
                        }
                    }
                    else if (GUILayout.Button("Remove Screenshot Device from Scene"))
                    {
                        // Register the screenshot device in the UnityEditor undo list, and remove it from the scene
                        Undo.DestroyObjectImmediate(screenshotScript.gameObject);
                        isSceneSaveRequired = true;
                    }
                    #endregion

                    #region Landscape Extension
                    if (landscapeGameObject != null && landscape != null)
                    {
                        EditorGUILayout.HelpBox("An extension can help give the illusion that the landscape goes all the way to the horizon.", MessageType.None, true);
                        GUILayout.BeginVertical(EditorStyles.helpBox);
                        EditorGUILayout.LabelField("<b>Landscape Extension</b>", labelFieldRichText);
                        EditorGUI.BeginChangeCheck();
                        landscape.useLandscapeExtension = EditorGUILayout.Toggle(sceneUseLandscapeExtensionContent, landscape.useLandscapeExtension);
                        if (EditorGUI.EndChangeCheck())
                        {
                            landscape.EnableLandscapeExtension(landscape.useLandscapeExtension, true);
                            isSceneSaveRequired = true;
                        }

                        if (landscape.useLandscapeExtension)
                        {
                            if (landscape.lbLandscapeExtension == null) { landscape.lbLandscapeExtension = new LBLandscapeExtension(); }

                            GUILayout.BeginHorizontal();
                            EditorGUILayout.LabelField(sceneLandscapeExtensionHeightOffsetContent, GUILayout.Width(80f));
                            if (float.IsInfinity(landscapeMinMaxHeight.x))
                            {
                                EditorGUILayout.LabelField(" (Recommended: 0.00m");
                            }
                            else { EditorGUILayout.LabelField(" (Recommended: " + landscapeMinMaxHeight.x.ToString("0.00") + "m)"); }
                            EditorGUI.BeginChangeCheck();
                            landscape.lbLandscapeExtension.heightOffset = EditorGUILayout.FloatField(landscape.lbLandscapeExtension.heightOffset, GUILayout.MaxWidth(65f));
                            GUILayout.EndHorizontal();
                            if (EditorGUI.EndChangeCheck())
                            {
                                landscape.UpdateLandscapeExtensionHeight(false, true);
                                // Mark dirty but don't autosave
                                isSceneDirtyRequired = true;
                            }

                            EditorGUIUtility.labelWidth = 250f;

                            EditorGUI.BeginChangeCheck();
                            // GetTextureName() will return either the name of the normalmap or the last known name of the normalmap if the Texture2D image is missing.
                            landscape.lbLandscapeExtension.texture = (Texture2D)EditorGUILayout.ObjectField("Texture" + GetTextureName(landscape.lbLandscapeExtension.texture, landscape.lbLandscapeExtension.textureName), landscape.lbLandscapeExtension.texture, typeof(Texture2D), false);
                            if (EditorGUI.EndChangeCheck())
                            {
                                if (landscape.lbLandscapeExtension.texture == null) { landscape.lbLandscapeExtension.textureName = string.Empty; }
                                else { landscape.lbLandscapeExtension.textureName = landscape.lbLandscapeExtension.texture.name; }
                                landscape.UpdateLandscapeExtensionTextures(true);
                                isSceneSaveRequired = true;
                            }

                            EditorGUI.BeginChangeCheck();
                            // GetTextureName() will return either the name of the normalmap or the last known name of the normalmap if the Texture2D image is missing.
                            landscape.lbLandscapeExtension.normalMap = (Texture2D)EditorGUILayout.ObjectField("Normal Map" + GetTextureName(landscape.lbLandscapeExtension.normalMap, landscape.lbLandscapeExtension.normalMapName), landscape.lbLandscapeExtension.normalMap, typeof(Texture2D), false);
                            if (EditorGUI.EndChangeCheck())
                            {
                                if (landscape.lbLandscapeExtension.normalMap == null) { landscape.lbLandscapeExtension.normalMapName = string.Empty; }
                                else { landscape.lbLandscapeExtension.normalMapName = landscape.lbLandscapeExtension.normalMap.name; }
                                landscape.UpdateLandscapeExtensionTextures(true);
                                isSceneSaveRequired = true;
                            }

                            EditorGUIUtility.labelWidth = defaultEditorLabelWidth;

                            EditorGUI.BeginChangeCheck();
                            landscape.lbLandscapeExtension.tileSize = (Vector2)EditorGUILayout.Vector2Field("Tiling", landscape.lbLandscapeExtension.tileSize);
                            landscape.lbLandscapeExtension.metallic = EditorGUILayout.Slider("Metallic", landscape.lbLandscapeExtension.metallic, 0f, 1f);
                            landscape.lbLandscapeExtension.smoothness = EditorGUILayout.Slider("Smoothness", landscape.lbLandscapeExtension.smoothness, 0f, 1f);
                            if (EditorGUI.EndChangeCheck())
                            {
                                landscape.UpdateLandscapeExtensionMaterial(true);
                                // Mark dirty but don't autosave when moving sliders etc.
                                isSceneDirtyRequired = true;
                            }
                        }
                        GUILayout.EndVertical();
                    }
                    #endregion
                }
                #endregion

                #region Scene Paths
                if (landscapeGameObject != null && landscape != null)
                {
                    // SCENE PATHS
                    EditorGUILayout.Space();
                    showScenePaths = EditorGUILayout.Foldout(showScenePaths, "Scene Paths");
                    if (showScenePaths)
                    {
                        EditorGUILayout.HelpBox("To create an Object Path (using our advanced spline tool) in the scene, add a Group with an Object Path Member type.", MessageType.None, true);

                        GUILayout.BeginHorizontal();

                        if (GUILayout.Button(addCameraAnimatorToSceneContent))
                        {
                            LBCameraPath lbCameraPath = LBCameraPath.CreateCameraPath(landscape, landscapeGameObject);
                            LBCameraAnimator lbCameraAnimator = LBCameraAnimator.CreateCameraAnimator(landscape, "Camera Animation", true);

                            if (lbCameraAnimator != null)
                            {
                                lbCameraAnimator.cameraPath = lbCameraPath;

                                // Select the new path and highlight in Hierarchy
                                Selection.activeGameObject = lbCameraPath.gameObject;
                                EditorGUIUtility.PingObject(lbCameraPath.gameObject);
                                
                                #if UNITY_2018_2_OR_NEWER
                                LBEditorHelper.CallMenu("Window/General/Inspector");
                                #else
                                LBEditorHelper.CallMenu("Window/Inspector");
                                #endif
                                LBEditorHelper.ShowSceneView(this.GetType());
                            }
                            isSceneSaveRequired = true;
                        }

                        // MAP PATHS
                        if (GUILayout.Button(addMapPathToLandscapeContent))
                        {
                            LBMapPath lbMapPath = LBMapPath.CreateMapPath(landscape, landscapeGameObject);

                            if (lbMapPath != null)
                            {
                                // Select the new path and highlight in Hierarchy
                                Selection.activeGameObject = lbMapPath.gameObject;
                                EditorGUIUtility.PingObject(lbMapPath.gameObject);
                                #if UNITY_2018_2_OR_NEWER
                                LBEditorHelper.CallMenu("Window/General/Inspector");
                                #else
                                LBEditorHelper.CallMenu("Window/Inspector");
                                #endif
                                LBEditorHelper.ShowSceneView(this.GetType());
                            }
                            isSceneSaveRequired = true;
                        }

                        GUILayout.EndHorizontal();
                    }
                }
                #endregion

                #region Stencils

                if (landscapeGameObject != null && landscape != null)
                {
                    // Stencils
                    EditorGUILayout.Space();
                    showStencils = EditorGUILayout.Foldout(showStencils, "Stencils");

                    if (showStencils)
                    {
                        if (!isNonSquareTerrainsEnabled && landscape.size.x == landscape.size.y)
                        {
                            if (GUILayout.Button("Add Stencil to Landscape"))
                            {
                                LBStencil lbStencil = LBStencil.CreateStencilInScene(landscape, landscapeGameObject);

                                if (lbStencil != null)
                                {
                                    // Select the new stencil and highlight in Hierarchy
                                    Selection.activeGameObject = lbStencil.gameObject;
                                    EditorGUIUtility.PingObject(lbStencil.gameObject);
                                    #if UNITY_2018_2_OR_NEWER
                                    LBEditorHelper.CallMenu("Window/General/Inspector");
                                    #else
                                    LBEditorHelper.CallMenu("Window/Inspector");
                                    #endif
                                    LBEditorHelper.ShowSceneView(this.GetType());
                                }
                                isSceneSaveRequired = true;
                            }
                        }
                        else
                        {
                            EditorGUILayout.HelpBox("Stencils are not available while using non-square terrains. Turn off this in Advanced and create a standard square landscape.", MessageType.Warning, true);
                        }
                    }
                }

                #endregion

                #region Templates
                if (landscapeGameObject != null && landscape != null)
                {
                    // LANDSCAPE TEMPLATES
                    EditorGUILayout.Space();
                    showLandscapeTemplate = EditorGUILayout.Foldout(showLandscapeTemplate, "Templates");
                    if (showLandscapeTemplate)
                    {
                        EditorGUILayout.LabelField("Create a template of the current landscape settings. This can be applied in the same project" +
                        " or another project. It can also be moved to another computer. Templates are saved in Assets/LandscapeBuilder/Templates. " +
                        " Packages are saved in " + GetProjectName() + " /LandscapeBuilder/TemplatePackages and overwrite ones of the same name.", helpBoxRichText);

                        GUILayout.BeginVertical(EditorStyles.helpBox);

#region Save Template

                        landscapeTemplateName = EditorGUILayout.TextField(saveTemplateNameContent, landscapeTemplateName);
                        addLBLightingToTemplate = EditorGUILayout.Toggle(saveTemplateIncludeLBLightingContent, addLBLightingToTemplate);
                        addPathsToTemplate = EditorGUILayout.Toggle(saveTemplateIncludePathsContent, addPathsToTemplate);
                        if (addPathsToTemplate)
                        {
                            addPathMeshMaterialsToTemplate = EditorGUILayout.Toggle(saveTemplateIncludePathMeshMatContent, addPathMeshMaterialsToTemplate);
                        }
                        else { addPathMeshMaterialsToTemplate = false; }

                        addStencilsToTemplate = EditorGUILayout.Toggle(saveTemplateIncludeStencilContent, addStencilsToTemplate);

                        createTemplatePackage = EditorGUILayout.Toggle(saveTemplateExportPackageContent, createTemplatePackage);
                        if (createTemplatePackage)
                        {
                            addMapTexturesToTemplatePackage = EditorGUILayout.Toggle(saveTemplateIncludeMapTexturesContent, addMapTexturesToTemplatePackage);
                            addLayerHeightmapTexturesToTemplatePackage = EditorGUILayout.Toggle(saveTemplateIncludeLayerHeightmapTexturesContent, addLayerHeightmapTexturesToTemplatePackage);
                        }
                        GUILayout.BeginHorizontal();
                        if (GUILayout.Button("Save Template", GUILayout.MaxWidth(110f)))
                        {
                            LBEditorCommon.SaveTemplate(landscape, LBVersion,
                                                        landscapeTemplateName,
                                                        ref isSceneSaveRequired,
                                                        createTemplatePackage,
                                                        addMapTexturesToTemplatePackage,
                                                        addLayerHeightmapTexturesToTemplatePackage,
                                                        addLBLightingToTemplate,
                                                        addPathsToTemplate,
                                                        addStencilsToTemplate,
                                                        addPathMeshMaterialsToTemplate);
                        }
                        GUILayout.EndHorizontal();
                        EditorGUILayout.Space();
#endregion

                        #region Import Template

                        GUILayout.BeginHorizontal();
                        if (GUILayout.Button(applyTemplateGotoFolderBtnContent, buttonCompact, GUILayout.Width(20f))) { LBEditorHelper.HighlightItemInProjectWindow(LBSetup.templatesFolder); }
                        EditorGUILayout.LabelField("Template to Apply", GUILayout.Width(defaultEditorLabelWidth - 28f));
                        //lbTemplateToRestore = (LBTemplate)EditorGUILayout.ObjectField("Template to Apply", lbTemplateToRestore, typeof(LBTemplate), false);
                        lbTemplateToRestore = (LBTemplate)EditorGUILayout.ObjectField(lbTemplateToRestore, typeof(LBTemplate), false);
                        GUILayout.EndHorizontal();

                        // Let user control which items are imported to the landscape from the template
                        EditorGUI.BeginChangeCheck();
                        importTerrainSettingsFromTemplate = EditorGUILayout.Toggle(applyTemplateImportTerrainSettingsContent, importTerrainSettingsFromTemplate);
                        if (EditorGUI.EndChangeCheck() && !importTerrainSettingsFromTemplate)
                        {
                            // By default, ignore start position of template when not applying Terrain Settings from template
                            templateIgnoreStartPosition = true;
                            templateUpdateTerrainHeight = false;
                        }
                        importTopographyFromTemplate = EditorGUILayout.Toggle(applyTemplateImportTopographyContent, importTopographyFromTemplate);
                        importTexturesFromTemplate = EditorGUILayout.Toggle(applyTemplateImportTexturesContent, importTexturesFromTemplate);
                        importTreesFromTemplate = EditorGUILayout.Toggle(applyTemplateImportTreesContent, importTreesFromTemplate);
                        importGrassFromTemplate = EditorGUILayout.Toggle(applyTemplateImportGrassContent, importGrassFromTemplate);
                        importGroupsFromTemplate = EditorGUILayout.Toggle(applyTemplateImportGroupsContent, importGroupsFromTemplate);
                        importMeshesFromTemplate = EditorGUILayout.Toggle(applyTemplateImportMeshesContent, importMeshesFromTemplate);
                        importLBLightingFromTemplate = EditorGUILayout.Toggle(applyTemplateImportLBLightingContent, importLBLightingFromTemplate);
                        importWaterFromTemplate = EditorGUILayout.Toggle(applyTemplateImportWaterContent, importWaterFromTemplate);
                        importPathsFromTemplate = EditorGUILayout.Toggle(applyTemplateImportPathsContent, importPathsFromTemplate);
                        if (importPathsFromTemplate)
                        {
                            removeExistingPathsInLandscape = EditorGUILayout.Toggle(applyTemplateRemoveOtherPathsContent, removeExistingPathsInLandscape);
                            templateReplaceExistingCameraAnimators = EditorGUILayout.Toggle(applyTemplateReplaceCamAnimatorsContent, templateReplaceExistingCameraAnimators);
                        }
                        importStencilsFromTemplate = EditorGUILayout.Toggle(applyTemplateImportStencilsContent, importStencilsFromTemplate);
                        if (importStencilsFromTemplate)
                        {
                            removeExistingStencilsInLandscape = EditorGUILayout.Toggle(applyTemplateRemoveOtherStencilsContent, removeExistingStencilsInLandscape);
                        }

                        templateIgnoreStartPosition = EditorGUILayout.Toggle(applyTemplateIgnoreStartPositionContent, templateIgnoreStartPosition);
                        templateUpdateTerrainHeight = EditorGUILayout.Toggle(applyTemplateUpdateTerrainHeightContent, templateUpdateTerrainHeight);

                        waterMainCamera = (Camera)EditorGUILayout.ObjectField(applyTemplateMainCameraContent, waterMainCamera, typeof(Camera), true);
                        if (waterMainCamera == null) { waterMainCamera = Camera.main; }

                        // Let user control which items are automatically apply to the landscape after the template has been loaded
                        if (importTopographyFromTemplate)
                        {
                            templateApplyTopography = EditorGUILayout.Toggle(applyTemplateApplyTopographyContent, templateApplyTopography);
                        }
                        if (importTexturesFromTemplate)
                        {
                            templateApplyTextures = EditorGUILayout.Toggle(applyTemplateApplyTexturesContent, templateApplyTextures);
                        }
                        if (importTreesFromTemplate)
                        {
                            templateApplyTrees = EditorGUILayout.Toggle(applyTemplateApplyTreesContent, templateApplyTrees);
                        }
                        if (importGrassFromTemplate)
                        {
                            templateApplyGrass = EditorGUILayout.Toggle(applyTemplateApplyGrassContent, templateApplyGrass);
                        }
                        if (importGroupsFromTemplate)
                        {
                            templateApplyGroups = EditorGUILayout.Toggle(applyTemplateApplyGroupsContent, templateApplyGroups);
                        }
                        if (importMeshesFromTemplate)
                        {
                            templateApplyMeshes = EditorGUILayout.Toggle(applyTemplateApplyMeshContent, templateApplyMeshes);
                        }
                        if (importPathsFromTemplate)
                        {
                            templateApplyPathMeshes = EditorGUILayout.Toggle(applyTemplateApplyPathMeshesContent, templateApplyPathMeshes);
                        }
                        if (lbTemplateToRestore != null)
                        {
                            GUILayout.BeginHorizontal();
                            if (GUILayout.Button("Apply Template", GUILayout.MaxWidth(110f)))
                            {
                                // Check if there are any existing settings
                                bool continueToRestore = false;
                                bool settingsAlreadyExist = false;

                                if (this.topographyLayers != null && importTopographyFromTemplate) { settingsAlreadyExist = (settingsAlreadyExist || this.topographyLayers.Count > 0); }
                                if (this.terrainTexturesList != null && importTexturesFromTemplate) { settingsAlreadyExist = (settingsAlreadyExist || this.terrainTexturesList.Count > 0); }
                                if (this.terrainTreesList != null && importTreesFromTemplate) { settingsAlreadyExist = (settingsAlreadyExist || this.terrainTreesList.Count > 0); }
                                if (this.terrainGrassList != null && importGrassFromTemplate) { settingsAlreadyExist = (settingsAlreadyExist || this.terrainGrassList.Count > 0); }
                                if (this.landscapeMeshList != null && importMeshesFromTemplate) { settingsAlreadyExist = (settingsAlreadyExist || this.landscapeMeshList.Count > 0); }
                                if (this.lbGroupList != null && importGroupsFromTemplate) { settingsAlreadyExist = (settingsAlreadyExist || this.lbGroupList.Count > 0); }
                                if (landscape.landscapeWaterList != null) { settingsAlreadyExist = (settingsAlreadyExist || landscape.landscapeWaterList.Count > 0); }

                                if (settingsAlreadyExist)
                                {
                                    continueToRestore = EditorUtility.DisplayDialog("Landscape contains existing settings", "WARNING: Are you sure you want to apply this template? ALL landscape " +
                                                                " settings may be lost. Undo is not supported with templates", "Overwrite", "Cancel");
                                }
                                else { continueToRestore = true; }

                                if (continueToRestore)
                                {
                                    // Should check the size of the landscape and the size of each terrain

                                    // Apply landscape settings (don't resize)
                                    if (templateIgnoreStartPosition) { landscape.start = landscape.gameObject.transform.position; }
                                    else
                                    {
                                        landscape.start = lbTemplateToRestore.start;
                                        landscape.gameObject.transform.position = landscape.start;
                                    }

                                    if (importWaterFromTemplate)
                                    {
                                        // Remove any existing water from the landscape
                                        List<LBWaterItem> existingWater = new List<LBWaterItem>(landscape.gameObject.GetComponentsInChildren<LBWaterItem>());
                                        if (existingWater != null)
                                        {
                                            for (int w = existingWater.Count; w > 0; w--)
                                            {
                                                DestroyImmediate(existingWater[w - 1].gameObject);
                                            }

                                            // Remove any reflection cameras from scene
                                            LBWaterOperations.RemoveWaterReflectionCamera("Main Camera");
                                            LBWaterOperations.RemoveWaterReflectionCamera("Animation Camera");
                                            LBWaterOperations.RemoveWaterReflectionCamera("SceneCamera");
                                        }
                                    }

                                    lbTemplateToRestore.RemoveWindZones(landscape);

                                    // Clear current lists (if required)
                                    if (importTopographyFromTemplate)
                                    {
                                        landscape.topographyLayersList = new List<LBLayer>();

                                        // Any template created before 1.4.2 automatically uses the legacy noise offset of 0.
                                        if (landscape.GetLastUpdateMajorVersion == 1 && (landscape.GetLastUpdateMinorVersion < 4 || (landscape.GetLastUpdateMinorVersion == 4 && landscape.GetLastUpdatePatchVersion < 2)))
                                        {
                                            landscape.useLegacyNoiseOffset = true;
                                        }
                                        else { landscape.useLegacyNoiseOffset = lbTemplateToRestore.useLegacyNoiseOffset; }
                                    }
                                    if (importTexturesFromTemplate) { landscape.terrainTexturesList = new List<LBTerrainTexture>(); }
                                    if (importTreesFromTemplate) { landscape.terrainTreesList = new List<LBTerrainTree>(); }
                                    if (importGrassFromTemplate) { landscape.terrainGrassList = new List<LBTerrainGrass>(); }
                                    if (importMeshesFromTemplate) { landscape.landscapeMeshList = new List<LBLandscapeMesh>(); }
                                    if (importGroupsFromTemplate) { landscape.lbGroupList = new List<LBGroup>(); }

                                    landscape.landscapeWaterList = new List<LBWater>();

                                    // Restore Stencils before the topography list as a stencil maybe used in a Topography LayerFilter
                                    if (importStencilsFromTemplate)
                                    {
                                        lbTemplateToRestore.ApplyStencilsToScene(landscape, removeExistingStencilsInLandscape, true);
                                    }

                                    landscape.SetLandscapeTerrains(true);
                                    landscapeTerrains = landscape.landscapeTerrains;

                                    // Apply the lists
                                    // Rather than add the template lists to a new List, we need to add clones or copies
                                    // of each class instance just in case there are other landscapes in the same scene that
                                    // are using the same Templates. For example, the following code could allow 2 landscapes
                                    // in the same scene to contain the same instances of LBLayer which would result in an
                                    // alteration in one landscape topographyLayersList altering that layer in another landscape.
                                    // e.g. landscape.topographyLayersList = new List<LBLayer>(lbTemplateToRestore.topographyLayersList);
                                    if (lbTemplateToRestore.topographyLayersList != null && importTopographyFromTemplate)
                                    {
                                        foreach (LBLayer lbLayer in lbTemplateToRestore.topographyLayersList)
                                        {
                                            LBLayer lbLayerTemplate = new LBLayer(lbLayer);

                                            if (lbLayerTemplate != null)
                                            {
                                               landscape.topographyLayersList.Add(lbLayerTemplate);
                                            }
                                        }

                                        lbTemplateToRestore.UpdateTopographyLayerLBTerrainData(landscape, true);
                                    }

                                    if (importTopographyFromTemplate)
                                    {
                                        // Apply Topography Mask - there is one per landscape
                                        landscape.topographyMaskMode = (LBLandscape.MaskMode)lbTemplateToRestore.topographyMaskMode;
                                        landscape.distanceToCentreMask = lbTemplateToRestore.distanceToCentreMask;
                                        landscape.maskWarpAmount = lbTemplateToRestore.maskWarpAmount;
                                        landscape.maskNoiseTileSize = lbTemplateToRestore.maskNoiseTileSize;
                                        landscape.maskNoiseOffsetX = lbTemplateToRestore.maskNoiseOffsetX;
                                        landscape.maskNoiseOffsetY = lbTemplateToRestore.maskNoiseOffsetY;
                                        landscape.maskNoiseCurveModifier = lbTemplateToRestore.maskNoiseCurveModifier;
                                    }

                                    // Final Pass variables
                                    landscape.useFinalPassSmoothing = lbTemplateToRestore.useFinalPassSmoothing;
                                    landscape.finalPassSmoothingIterations = lbTemplateToRestore.finalPassSmoothingIterations;
                                    landscape.finalPassPixelRange = lbTemplateToRestore.finalPassPixelRange;

                                    landscape.thermalErosionPreset = lbTemplateToRestore.thermalErosionPreset;
                                    landscape.useThermalErosion = lbTemplateToRestore.useThermalErosion;
                                    landscape.thermalErosionIterations = lbTemplateToRestore.thermalErosionIterations;
                                    landscape.thermalErosionTalusAngle = lbTemplateToRestore.thermalErosionTalusAngle;
                                    landscape.thermalErosionStrength = lbTemplateToRestore.thermalErosionStrength;

                                    // Group Settings
                                    landscape.autoRefreshGroupDesigner = lbTemplateToRestore.autoRefreshGroupDesigner;

                                    // Vegetation Studio integration
                                    landscape.useVegetationSystem = lbTemplateToRestore.useVegetationSystem;
                                    landscape.useVegetationSystemTextures = lbTemplateToRestore.useVegetationSystemTextures;

                                    // Landscape Extension
                                    landscape.useLandscapeExtension = lbTemplateToRestore.useLandscapeExtension;

                                    // GPU acceleration
                                    landscape.useGPUTexturing = lbTemplateToRestore.useGPUTexturing;
                                    landscape.useGPUTopography = lbTemplateToRestore.useGPUTopography;
                                    landscape.useGPUGrass = lbTemplateToRestore.useGPUGrass;
                                    landscape.useGPUPath = lbTemplateToRestore.useGPUPath;

                                    // Undo override
                                    landscape.isUndoTopographyDisabled = lbTemplateToRestore.isUndoTopographyDisabled;

                                    // Apply terrain settings to the terrains
                                    if (landscapeTerrains != null)
                                    {
                                        if (importTerrainSettingsFromTemplate)
                                        {
                                            Vector3 terrainSize = new Vector3(2000f, 2000f, 2000f);
                                            if (landscapeTerrains.Length > 0)
                                            {
                                                terrainSize = landscapeTerrains[0].terrainData.size;
                                                // Override the current terrain height
                                                if (templateUpdateTerrainHeight) { terrainSize.y = lbTemplateToRestore.terrainHeight; }
                                                //Debug.Log("Terrain size " + terrainSize + " template H: " + lbTemplateToRestore.terrainHeight);
                                            }

                                            int terrainIndex = 0;
                                            foreach (Terrain terrain in landscapeTerrains)
                                            {
                                                if (terrain != null)
                                                {
                                                    if (importTopographyFromTemplate)
                                                    {
                                                        // Must set the resolution first because Unity will resize the terrain
                                                        terrain.terrainData.heightmapResolution = lbTemplateToRestore.heightmapResolution;
                                                        // Must then set the size back to original
                                                        terrain.terrainData.size = terrainSize;
                                                    }
                                                    SetTerrainMaterial(terrain, terrainIndex, (terrainIndex == landscapeTerrains.Length - 1), (LBLandscape.TerrainMaterialType)lbTemplateToRestore.terrainMaterialType);
                                                    terrain.heightmapPixelError = lbTemplateToRestore.pixelError;
                                                    terrain.basemapDistance = lbTemplateToRestore.baseMapDistance;
                                                    terrain.treeDistance = lbTemplateToRestore.treeDistance;
                                                    terrain.treeBillboardDistance = lbTemplateToRestore.treeBillboardDistance;
                                                    terrain.treeCrossFadeLength = lbTemplateToRestore.treeFadeDistance;
                                                    terrain.detailObjectDistance = lbTemplateToRestore.detailDistance;
                                                    terrain.detailObjectDensity = lbTemplateToRestore.detailDensity;
                                                    terrain.terrainData.baseMapResolution = lbTemplateToRestore.baseTextureResolution;
                                                    if (importTexturesFromTemplate) { terrain.terrainData.alphamapResolution = lbTemplateToRestore.alphaMapResolution; }
                                                    if (importGrassFromTemplate) { terrain.terrainData.SetDetailResolution(lbTemplateToRestore.detailResolution, 16); }
                                                    terrain.gameObject.layer = lbTemplateToRestore.landscapeLayerIndex;
                                                    if (importGrassFromTemplate)
                                                    {
                                                        terrain.terrainData.wavingGrassSpeed = lbTemplateToRestore.grassWindSpeed;
                                                        terrain.terrainData.wavingGrassAmount = lbTemplateToRestore.grassWindRippleSize;
                                                        terrain.terrainData.wavingGrassStrength = lbTemplateToRestore.grassWindBending;
                                                        terrain.terrainData.wavingGrassTint = lbTemplateToRestore.grassWindTint;
                                                    }
#if !UNITY_2019_2_OR_NEWER
                                                    terrain.legacySpecular = lbTemplateToRestore.terrainLegacySpecular;
                                                    terrain.legacyShininess = lbTemplateToRestore.terrainLegacyShininess;
#endif
#if UNITY_2018_3_OR_NEWER
                                                    terrain.drawInstanced = lbTemplateToRestore.useTerrainDrawInstanced;
                                                    terrain.groupingID = lbTemplateToRestore.terrainGroupingID;
                                                    terrain.allowAutoConnect = lbTemplateToRestore.terrainAutoConnect;
#endif
                                                    terrainIndex++;
                                                }
                                            }

#if VEGETATION_STUDIO
                                            landscape.SetLandscapeTerrains(true);

                                            if (!LBIntegration.VegetationStudioEnable(landscape, landscape.useVegetationSystem, true))
                                            {
                                                Debug.LogWarning("Could not modifiy landscape with Vegetation Studio attributes when applying template. Please Report");
                                            }
#elif VEGETATION_STUDIO_PRO
                                            landscape.SetLandscapeTerrains(true);

                                            if (!LBIntegration.VegetationStudioProEnable(landscape, landscape.useVegetationSystem, true))
                                            {
                                                Debug.LogWarning("Could not modifiy landscape with Vegetation Studio Pro attributes when applying template. Please Report");
                                            }
#endif
                                        }
                                        // Load the values into the editor
                                        LoadLandscapeSettings();
                                        isSceneSaveRequired = true;
                                    }

                                    Vector3 landscapeChangeOffset = lbTemplateToRestore.GetLandscapeChangeOffset(landscape, templateIgnoreStartPosition);
                                    Vector3 landscapeChangeScale = lbTemplateToRestore.GetLandscapeChangeScale(landscape, landscape.GetLandscapeTerrainHeight());

#region Check if we need to update Topography settings
                                    if (landscapeChangeScale.x != 1f || landscapeChangeScale.z != 1f | landscapeChangeOffset.x != 0f || landscapeChangeOffset.z != 0f)
                                    {
                                        int numTLayers = (landscape.topographyLayersList == null ? 0 : landscape.topographyLayersList.Count);
                                        for (int tLyrIdx = 0; tLyrIdx < numTLayers; tLyrIdx++)
                                        {
                                            // Update the rectangle of ImageModifier layers
                                            LBLayer lbLayerFromTemplate = landscape.topographyLayersList[tLyrIdx];
                                            if (lbLayerFromTemplate != null && lbLayerFromTemplate.type == LBLayer.LayerType.ImageModifier)
                                            {
                                                // Apply position first
                                                // The modifier areaRect is relative to bottom-left of landscape (not Worldspace).
                                                // The centre of the areaRect does NOT get offset by the change in landscape position
                                                // Only adjust min/max x/y positions
                                                lbLayerFromTemplate.areaRect.xMin *= landscapeChangeScale.x;
                                                lbLayerFromTemplate.areaRect.yMin *= landscapeChangeScale.z;
                                                lbLayerFromTemplate.areaRect.xMax *= landscapeChangeScale.x;
                                                lbLayerFromTemplate.areaRect.yMax *= landscapeChangeScale.z;
                                            }
                                        }
                                    }
#endregion

                                    if (importWaterFromTemplate && lbTemplateToRestore.landscapeWaterList != null)
                                    {
                                        foreach (LBWater lbWater in lbTemplateToRestore.landscapeWaterList)
                                        {
                                            // To be unique in the scene, we may need to update the GUID
                                            landscape.landscapeWaterList.Add(new LBWater(lbWater, false));
                                        }
                                        isSceneSaveRequired = true;
                                    }

                                    if (lbTemplateToRestore.isLBLightingIncluded && importLBLightingFromTemplate)
                                    {
                                        LBLighting lbLighting = GameObject.FindObjectOfType<LBLighting>();
                                        if (lbLighting == null)
                                        {
                                            // If LBLighting isn't already in the scene, add it.
                                            lbLighting = LBLighting.AddLightingToScene(true);
                                            isSceneSaveRequired = true;
                                        }

                                        if (lbLighting != null)
                                        {
                                            // Restore the lighting settings from the template
                                            lbTemplateToRestore.ApplyLBLightingSettings(landscape, ref lbLighting, waterMainCamera, true);
                                            isSceneSaveRequired = true;
                                        }
                                    }

                                    if (importPathsFromTemplate)
                                    {
                                        if (templateReplaceExistingCameraAnimators) { LBCameraAnimator.RemoveCameraAnimatorsFromScene(landscape, true); }
                                        lbTemplateToRestore.ApplyPathsToScene(landscape, removeExistingPathsInLandscape, templateReplaceExistingCameraAnimators, templateIgnoreStartPosition, templateApplyPathMeshes);
                                        isSceneSaveRequired = true;
                                    }

                                    if (lbTemplateToRestore.terrainTexturesList != null && importTexturesFromTemplate)
                                    {
                                        foreach (LBTerrainTexture lbTexture in lbTemplateToRestore.terrainTexturesList)
                                        {
                                            LBTerrainTexture importedLBTerrainTexture = new LBTerrainTexture(lbTexture);
                                            if (importedLBTerrainTexture != null)
                                            {
                                                // Re-apply Tinting and texture rotation if they are enabled
                                                if (importedLBTerrainTexture.isTinted && importedLBTerrainTexture.texture != null)
                                                {
                                                    LBTextureOperations.SetTextureAttributes(importedLBTerrainTexture.texture, TextureImporterCompression.Uncompressed, FilterMode.Trilinear, true, 0, true);
                                                    importedLBTerrainTexture.tintedTexture = LBTextureOperations.TintTexture(importedLBTerrainTexture.texture, importedLBTerrainTexture.tintColour, importedLBTerrainTexture.tintStrength);
                                                }
                                                if (importedLBTerrainTexture.isRotated && importedLBTerrainTexture.normalMap == null && importedLBTerrainTexture.texture != null)
                                                {
                                                    LBTextureOperations.SetTextureAttributes(importedLBTerrainTexture.texture, TextureImporterCompression.Uncompressed, FilterMode.Trilinear, true, 0, true);
                                                    importedLBTerrainTexture.rotatedTexture = LBTextureOperations.RotateTexture(importedLBTerrainTexture.texture, importedLBTerrainTexture.rotationAngle);
                                                }

                                                landscape.terrainTexturesList.Add(importedLBTerrainTexture);
                                            }
                                        }

                                        lbTemplateToRestore.UpdateTextureLBTerrainData(landscape, true);

                                        terrainTexturesList = landscape.TerrainTexturesList();
                                        isSceneSaveRequired = true;
                                    }

                                    // NOTE: Topography and Textures get applied to the terrains (if ticked by user),
                                    // before Tree, Grass and Mesh imported from template. This will enable any Texture Filters
                                    // to be applied (which requires the textures to be first read from the TerrainData).

                                    // Apply the topography settings to the landscape
                                    if (importTopographyFromTemplate && templateApplyTopography && landscape.topographyLayersList != null)
                                    {
                                        if (landscape.topographyLayersList.Count > 0) { GenerateTopography(); }
                                    }

                                    // Apply the textures to the landscape
                                    if (importTexturesFromTemplate && templateApplyTextures && landscape.terrainTexturesList != null)
                                    {
                                        if (landscape.terrainTexturesList.Count > 0) { TextureLandscape(); }
                                    }

                                    //RefreshTerrainTexturesAvailableList();

                                    if (importTreesFromTemplate && lbTemplateToRestore.terrainTreesList != null)
                                    {
                                        foreach (LBTerrainTree lbTerrainTree in lbTemplateToRestore.terrainTreesList)
                                        {
                                            // Find matching texture for filters in landscape and update
                                            LBFilter.UpdateTextures(lbTerrainTree.filterList, TerrainTexturesAvailableList, true);

                                            landscape.terrainTreesList.Add(new LBTerrainTree(lbTerrainTree));
                                        }

                                        lbTemplateToRestore.UpdateTreesLBTerrainData(landscape, true);

                                        terrainTreesList = landscape.TerrainTreesList();
                                        isSceneSaveRequired = true;
                                    }

                                    if (importGrassFromTemplate && lbTemplateToRestore.terrainGrassList != null)
                                    {
                                        foreach (LBTerrainGrass lbTerrainGrass in lbTemplateToRestore.terrainGrassList)
                                        {
                                            // Find matching texture for filters in landscape and update
                                            LBFilter.UpdateTextures(lbTerrainGrass.filterList, TerrainTexturesAvailableList, true);

                                            landscape.terrainGrassList.Add(new LBTerrainGrass(lbTerrainGrass));
                                        }
                                        lbTemplateToRestore.UpdateGrassLBTerrainData(landscape, true);

                                        terrainGrassList = landscape.TerrainGrassList();
                                        isSceneSaveRequired = true;
                                    }

                                    if (importMeshesFromTemplate && lbTemplateToRestore.landscapeMeshList != null)
                                    {
                                        foreach (LBLandscapeMesh lbLandscapeMesh in lbTemplateToRestore.landscapeMeshList)
                                        {
                                            // Find matching texture for filters in landscape and update
                                            LBFilter.UpdateTextures(lbLandscapeMesh.filterList, TerrainTexturesAvailableList, true);

                                            landscape.landscapeMeshList.Add(new LBLandscapeMesh(lbLandscapeMesh));
                                        }
                                        landscapeMeshList = landscape.LandscapeMeshList();
                                        isSceneSaveRequired = true;
                                    }

                                    if (importGroupsFromTemplate && lbTemplateToRestore.lbGroupList != null)
                                    {
                                        foreach (LBGroup lbGroup in lbTemplateToRestore.lbGroupList)
                                        {
                                            landscape.lbGroupList.Add(new LBGroup(lbGroup));
                                        }

                                        LBGroup.LandscapeDimensionLocationChanged(landscape.lbGroupList, landscapeChangeOffset, landscapeChangeScale);

                                        lbGroupList = landscape.GroupList();
                                        isSceneSaveRequired = true;
                                    }

                                    // Probably should always refresh SubGroups list
                                    RefreshSubGroupLists();

                                    // Apply the water after paths so that water based on a LBPath mesh will load correctly
                                    if (importWaterFromTemplate && landscapeTerrains != null)
                                    {
                                        // Apply the water from the Template
                                        int lbWaterCount = landscape.landscapeWaterList.Count;
                                        Vector2 waterSizeAdjusted = Vector2.zero;

                                        for (int waterIndex = 0; waterIndex < lbWaterCount; waterIndex++)
                                        {
                                            LBWater lbWater = landscape.landscapeWaterList[waterIndex];

                                            if (lbWater != null)
                                            {
                                                // Get the prefab
                                                Transform templateWaterPrefab = (Transform)AssetDatabase.LoadAssetAtPath(lbWater.waterPrefabPath, typeof(Transform));

                                                bool continueToApplyWater = true;

                                                // AQUAS - populate the waterCausticsPrefabList
                                                if (lbWater.resizingMode == LBWater.WaterResizingMode.AQUAS)
                                                {
                                                    if (waterCausticsPrefabList == null) { waterCausticsPrefabList = new List<Transform>(); }
                                                    if (lbWater.waterCausticList != null)
                                                    {
                                                        foreach (LBWaterCaustics lbWaterCaustics in lbWater.waterCausticList)
                                                        {
                                                            // Get the prefab path and find the prefab in the project
                                                            Transform waterCausticsPrefab = (Transform)AssetDatabase.LoadAssetAtPath(lbWaterCaustics.waterCausticPrefabPath, typeof(Transform));
                                                            if (waterCausticsPrefab != null)
                                                            {
                                                                waterCausticsPrefabList.Add(waterCausticsPrefab);
                                                            }
                                                            else
                                                            {
                                                                continueToApplyWater = false;
                                                                Debug.LogError("Applying Template - Could not find AQUAS Water Caustic prefab at " + lbWaterCaustics.waterCausticPrefabPath + ". Is AQUAS in this project?");
                                                            }
                                                        }
                                                    }
                                                }

                                                if (continueToApplyWater)
                                                {
                                                    // Adjust Water position taking into consideration difference between original and target landscape sizes
                                                    waterPosition = new Vector3(lbWater.waterPosition.x * landscape.size.x / lbTemplateToRestore.size.x, 0f, lbWater.waterPosition.z * landscape.size.y / lbTemplateToRestore.size.y);

                                                    // Change the position of the water if the landscape
                                                    // may have a different start position than the template
                                                    if (templateIgnoreStartPosition)
                                                    {
                                                        // Consider offset and scaling
                                                        waterPosition.x -= ((lbTemplateToRestore.start.x - landscape.start.x) * (landscape.size.x / lbTemplateToRestore.size.x));
                                                        waterPosition.z -= ((lbTemplateToRestore.start.z - landscape.start.z) * (landscape.size.y / lbTemplateToRestore.size.y));
                                                    }

                                                    // Adjust Water size taking into consideration difference between original and target landscape sizes
                                                    waterSizeAdjusted = new Vector2(lbWater.waterSize.x * landscape.size.x / lbTemplateToRestore.size.x, lbWater.waterSize.x * landscape.size.x / lbTemplateToRestore.size.x);

                                                    // NOTE: Currently doesn't enable AQUAS Under Water FX
                                                    lbWater.isUnderWaterFXEnabled = false;

                                                    AddWaterToScene(lbWater.isPrimaryWater, lbWater, 0, lbWater.waterLevel, templateWaterPrefab, lbWater.keepPrefabAspectRatio,
                                                                   lbWater.resizingMode, waterPosition, waterSizeAdjusted, waterMaxMeshThreshold, waterMainCamera, waterCausticsPrefabList, false, true,
                                                                   lbWater.isRiver, lbWater.riverMaterial, null, lbWater.waterMaterial);
                                                }
                                            }
                                        }
                                    }

                                    // Build the trees in the landscape
                                    if (importTreesFromTemplate && templateApplyTrees && landscape.terrainTreesList != null)
                                    {
                                        if (landscape.terrainTreesList.Count > 0) { ApplyTrees(); }
                                    }

                                    // Apply the grass in the landscape
                                    if (importGrassFromTemplate && templateApplyGrass && landscape.terrainGrassList != null)
                                    {
                                        if (landscape.terrainGrassList.Count > 0) { ApplyGrass(); }
                                    }

                                    // Apply Groups in the landscape
                                    if (importGroupsFromTemplate && templateApplyGroups && landscape.lbGroupList != null)
                                    {
                                        if (landscape.lbGroupList.Count > 0) { ApplyGroups(); }
                                    }

                                    // Apply the mesh in the landscape
                                    if (importMeshesFromTemplate && templateApplyMeshes && landscape.landscapeMeshList != null)
                                    {
                                        if (landscape.landscapeMeshList.Count > 0) { ApplyMeshes(); }
                                    }
                                }
                            }
                            if (GUILayout.Button(new GUIContent("Get Info", "Get info about the template and write it to the console window"), GUILayout.MaxWidth(70f)))
                            {
                                // lbTemplateToRestore.CreateLandscapeFromTemplate();
                                string _info = string.Empty;
                                _info = "Template Information for template: " + lbTemplateToRestore.gameObject.name + "\n";
                                _info += "Landscape Size: " + lbTemplateToRestore.size.x + " x " + lbTemplateToRestore.size.y + "\n";
                                _info += "Landscape Height: " + lbTemplateToRestore.terrainHeight + "\n";
                                _info += "Terrain Size: " + lbTemplateToRestore.terrainWidth + " x " + lbTemplateToRestore.terrainWidth + "\n";
                                _info += "Terrain Resolution: " + lbTemplateToRestore.heightmapResolution + "\n";
                                _info += "Texture Resolution: " + lbTemplateToRestore.alphaMapResolution + "\n";
                                Debug.Log(_info);
                            }
                            GUILayout.EndHorizontal();
                        }

                        #endregion

                        GUILayout.EndVertical();
                    }
                    EditorGUILayout.Space();
                    // End Template              
                }
                #endregion

                EditorGUILayout.EndScrollView();

                #endregion
            }
            else if (selectedTabInt == 1)
            {
                // Topography tab
                #region TopographyTab

                if (landscapeGameObject != null && landscape != null)
                {
                    DrawTopoHeaderTex();
                    scrollPosition = EditorGUILayout.BeginScrollView(scrollPosition);

                    #region Topography Layers

                    // If the area highlighter is required this value will be set to true at some point before the end of 
                    // this block of code. If it is not set to true we will need to make sure the area highlighter is removed.
                    areaHighlighterRequired = false;

                    // If the volume highlighter is required this value will be set to true at some point before the end of 
                    // this block of code. If it is not set to true we will need to make sure the volume highlighter is removed.
                    volumeHighlighterRequired = false;

                    #region Check AutoSave scene

                    if (landscape.IsBigHeightmap() && autoSaveEnabled)
                    {
                        EditorGUILayout.HelpBox("To improve performance, disable AutoSave in the Advanced tab", MessageType.Info, true);
                    }

                    #endregion

                    #region Topography Layer List Buttons
                    if (topographyLayers == null) { topographyLayers = new List<LBLayer>(); }

                    EditorGUILayout.Space();

                    // Setting the labeWidth to a small value, prevents LabelField from forcing the Buttons wide and scrolling the window to the right.
                    EditorGUIUtility.labelWidth = 1f;
                    GUILayout.BeginHorizontal();
                    EditorGUILayout.LabelField(layersLabelContent, labelFieldRichText);
                    if (GUILayout.Button(layersImportHeightmapContent, GUILayout.Width(60))) { LBImport.ImportTerrainHeightmaps(landscape, true); }
                    if (GUILayout.Button(layersImportRAWContent, GUILayout.Width(50))) { ImportRAWTerrainHeightmaps(true); }
                    if (GUILayout.Button(layersImportTIFFContent, GUILayout.Width(50))) { ImportTIFFHeightmap(true); }
                    if (GUILayout.Button(layersExportRAWContent, GUILayout.Width(85))) { ExportTerrainHeightmaps(true); }
                    // Manipulate and display a list of layers
                    arrayInt = topographyLayers.Count;
                    if (GUILayout.Button("+", GUILayout.Width(25))) { arrayInt++; }
                    if (GUILayout.Button("-", GUILayout.Width(25))) { if (arrayInt > 0) { if (LBEditorHelper.PromptForDelete("Layer", "", arrayInt - 1, false)) { arrayInt--; } } }
                    if (arrayInt < 0) { arrayInt = 0; }
                    GUILayout.EndHorizontal();
                    // Reset the labelWidth
                    EditorGUIUtility.labelWidth = defaultEditorLabelWidth;
                    // Add items to the list
                    if (arrayInt > topographyLayers.Count)
                    {
                        temp = arrayInt - topographyLayers.Count;
                        for (index = 0; index < temp; index++)
                        {
                            topographyLayers.Add(LBLayer.SetLayerFromPreset(LBLayer.LayerPreset.MountainRangeBase));
                        }
                    }
                    // Remove items from the list
                    else if (arrayInt < topographyLayers.Count)
                    {
                        temp = topographyLayers.Count - arrayInt;
                        for (index = 0; index < temp; index++)
                        {
                            topographyLayers.RemoveAt(topographyLayers.Count - 1);
                        }
                    }

                    #endregion

                    // No layers to insert/move/remove/delete at the start of the loop
                    layerToRemove = null;
                    insertLayerPos = -1;
                    layerToMove = null;
                    moveLayerPos = -1;

                    for (index = 0; index < topographyLayers.Count; index++)
                    {
                        // Show the elements of the list
                        GUILayout.BeginVertical(EditorStyles.helpBox);

                        #region Topography Layer-Level Buttons
                        GUILayout.BeginHorizontal();
                        topographyLayers[index].isDisabled = !EditorGUILayout.Toggle(!topographyLayers[index].isDisabled, GUILayout.Width(20f));

                        // If expanded slow Layer x. If collapsed with a layerName, show Layer x (layerName), else show the layer type.
                        if (topographyLayers[index].showLayer) { labelText = "<color=" + txtColourName + "><b>Layer " + (index + 1) + "</b></color>"; }
                        else if (string.IsNullOrEmpty(topographyLayers[index].layerName))
                        {
                            // For ImageModifiers format the collapsed name as Layer N (ImageModifier Mountai..)
                            labelText2 = (topographyLayers[index].type == LBLayer.LayerType.ImageModifier ? " " + LBEditorHelper.TruncateString(topographyLayers[index].modifierLandformCategory.ToString(), 9, true) : string.Empty);
                            labelText = "<color=" + txtColourName + "><b>Layer " + (index + 1) + "</b> (" + topographyLayers[index].type.ToString() + labelText2 + ")</color>";
                        }
                        else
                        {
                            labelText = "<color=" + txtColourName + "><b>Layer " + (index + 1) + "</b> (" + topographyLayers[index].layerName + ")</color>";
                        }
                        EditorGUILayout.LabelField(labelText, labelFieldRichText);

                        if (GUILayout.Button(layersScriptContent, buttonCompact, GUILayout.MaxWidth(20f))) { Debug.Log(topographyLayers[index].ScriptLayer(index, "\n")); }

                        // MOVE or INSERT topography layers
                        if (GUILayout.Button(layersMoveLayerDownButtonContent, buttonCompact, GUILayout.Width(20f)))
                        {
                            layerToMove = new LBLayer(topographyLayers[index]);
                            moveLayerPos = index;
                        }
                        if (GUILayout.Button(layersInsertLayerButtonContent, buttonCompact, GUILayout.Width(20f))) { insertLayerPos = index; }

                        if (topographyLayers[index].showLayer) { if (GUILayout.Button("Hide", buttonCompact, GUILayout.Width(40f))) { GUI.FocusControl(null); topographyLayers[index].showLayer = false; } }
                        else { if (GUILayout.Button("Show", buttonCompact, GUILayout.Width(40f))) { GUI.FocusControl(null); topographyLayers[index].showLayer = true; } }
                        if (GUILayout.Button("X", buttonCompact, GUILayout.MaxWidth(20f))) { layerToRemove = topographyLayers[index]; }
                        GUILayout.EndHorizontal();
                        #endregion

                        if (topographyLayers[index].showLayer)
                        {
                            topographyLayers[index].layerName = EditorGUILayout.TextField(layersNameContent, topographyLayers[index].layerName);

                            EditorGUI.BeginChangeCheck();
                            topographyLayers[index].type = (LBLayer.LayerType)EditorGUILayout.EnumPopup(layersTypeContent, topographyLayers[index].type);
                            if (EditorGUI.EndChangeCheck())
                            {
                                if (topographyLayers[index].type == LBLayer.LayerType.ImageModifier)
                                {
                                    // Reset the modifier to be placed in the centre of the landscape
                                    topographyLayers[index].SetDefaultImageModifierValues(landscape.size);
                                }
                                else if (topographyLayers[index].type == LBLayer.LayerType.MapPath)
                                {
                                    // Default to 2m to add
                                    topographyLayers[index].heightScale = 2f / terrainHeight;
                                }
                            }

                            #region Perlin Layer Types

                            if (topographyLayers[index].type == LBLayer.LayerType.PerlinBase || topographyLayers[index].type == LBLayer.LayerType.PerlinAdditive ||
                                topographyLayers[index].type == LBLayer.LayerType.PerlinSubtractive || topographyLayers[index].type == LBLayer.LayerType.PerlinDetail)
                            {
                                // Perlin noise layer

                                LBLayer.LayerPreset newLayerPreset = (LBLayer.LayerPreset)EditorGUILayout.EnumPopup("Preset", topographyLayers[index].preset);
                                if (newLayerPreset != topographyLayers[index].preset)
                                {
                                    // Create a temporary copy of the existing layer
                                    LBLayer prevLayer = new LBLayer(topographyLayers[index]);

                                    // Get a new layer from the preset
                                    topographyLayers[index] = LBLayer.SetLayerFromPreset(newLayerPreset);
                                    topographyLayers[index].preset = newLayerPreset;

                                    if (newLayerPreset == LBLayer.LayerPreset.GentleRiverSubtractive)
                                    {
                                        topographyLayers[index].AddRiverMapFilter();
                                    }

                                    // If the type hasn't changed, copy over some existing values
                                    if (prevLayer.type == topographyLayers[index].type)
                                    {
                                        topographyLayers[index].restrictArea = prevLayer.restrictArea;
                                        topographyLayers[index].areaRect = prevLayer.areaRect;
                                        topographyLayers[index].areaRectRotation = prevLayer.areaRectRotation;
                                        if (prevLayer.filters != null && prevLayer.filters.Count > 0)
                                        {
                                            topographyLayers[index].filters = prevLayer.filters.ConvertAll(filter => new LBLayerFilter(filter));
                                        }
                                    }

                                    prevLayer = null;
                                }

                                // Layer noise
                                topographyLayers[index].noiseTileSize = EditorGUILayout.FloatField(layersNoiseTileSizeContent, topographyLayers[index].noiseTileSize);
                                if (topographyLayers[index].noiseTileSize == 0) { topographyLayers[index].noiseTileSize = 5000f; }
                                topographyLayers[index].noiseOffsetX = EditorGUILayout.Slider(layersNoiseOffsetXContent, topographyLayers[index].noiseOffsetX, landscapeSize.x * -2f, landscapeSize.x * 2f);
                                topographyLayers[index].noiseOffsetZ = EditorGUILayout.Slider(layersNoiseOffsetZContent, topographyLayers[index].noiseOffsetZ, landscapeSize.x * -2f, landscapeSize.x * 2f);
                                topographyLayers[index].octaves = EditorGUILayout.IntSlider(layersNoiseOctavesContent, topographyLayers[index].octaves, 1, 15);

                                // Show/hide foldout for advanced settings
                                topographyLayers[index].showAdvancedSettings = EditorGUILayout.Foldout(topographyLayers[index].showAdvancedSettings, "Advanced Settings");
                                if (topographyLayers[index].showAdvancedSettings)
                                {
                                    // Only show downscaling for perlin detail layers
                                    if (topographyLayers[index].type == LBLayer.LayerType.PerlinDetail)
                                    {
                                        // Populate string and int arrays for downscaling IntPopup
                                        GUIContent[] downscalingOptions = new GUIContent[10];
                                        downscalingOptions[0] = new GUIContent("None", "");
                                        downscalingOptions[1] = new GUIContent("2x", "");
                                        downscalingOptions[2] = new GUIContent("4x", "");
                                        downscalingOptions[3] = new GUIContent("8x", "");
                                        downscalingOptions[4] = new GUIContent("16x", "");
                                        downscalingOptions[5] = new GUIContent("32x", "");
                                        downscalingOptions[6] = new GUIContent("64x", "");
                                        downscalingOptions[7] = new GUIContent("128x", "");
                                        downscalingOptions[8] = new GUIContent("256x", "");
                                        downscalingOptions[9] = new GUIContent("512x", "");
                                        int[] downscalingValues = new int[10] { 1, 2, 4, 8, 16, 32, 64, 128, 256, 512 };

                                        topographyLayers[index].downscaling = EditorGUILayout.IntPopup(layersNoiseDownscalingContent, topographyLayers[index].downscaling, downscalingOptions, downscalingValues);
                                    }

                                    topographyLayers[index].lacunarity = EditorGUILayout.Slider(layersNoiseLacunarityContent, topographyLayers[index].lacunarity, 1.5f, 3f);

                                    topographyLayers[index].gain = EditorGUILayout.Slider(layersNoiseGainContent, topographyLayers[index].gain, 0.25f, 0.75f);
                                    topographyLayers[index].warpAmount = EditorGUILayout.Slider(layersNoiseWarpAmountContent, topographyLayers[index].warpAmount, 0f, 2f);
                                    if (!Mathf.Approximately(topographyLayers[index].warpAmount, 0f))
                                    {
                                        topographyLayers[index].warpOctaves = EditorGUILayout.IntSlider(layersNoiseWarpOctavesContent, topographyLayers[index].warpOctaves, 1, 5);
                                    }
                                }

                                topographyLayers[index].heightScale = EditorGUILayout.Slider(layersHeightScaleContent, topographyLayers[index].heightScale, 0.01f, 2f);
                                //topographyLayers[index].detailSmoothRate = EditorGUILayout.Slider(new GUIContent("Detail Smoothing", "The amount of detail-level smoothing to be applied after topography has been added"), topographyLayers[index].detailSmoothRate, 0f, 1f);

                                // Perlin additive/subtractive layer variables
                                if (topographyLayers[index].type == LBLayer.LayerType.PerlinAdditive || topographyLayers[index].type == LBLayer.LayerType.PerlinSubtractive)
                                {
                                    if (topographyLayers[index].type == LBLayer.LayerType.PerlinAdditive)
                                    {
                                        topographyLayers[index].additiveAmount = EditorGUILayout.Slider(layersAdditiveAmountContent, topographyLayers[index].additiveAmount, 0f, 1f);
                                        topographyLayers[index].additiveCurve = LBLayer.CreateAdditiveCurve(topographyLayers[index].additiveAmount);

                                        topographyLayers[index].removeBaseNoise = EditorGUILayout.Toggle(layersRemoveBaseNoiseContent, topographyLayers[index].removeBaseNoise);

                                        if (topographyLayers[index].removeBaseNoise)
                                        {
                                            // Check to see how many terrains are in the landscape
                                            if (landscapeTerrains == null)
                                            {
                                                landscapeTerrains = landscapeGameObject.GetComponentsInChildren<Terrain>();
                                            }

                                            if (landscapeTerrains != null)
                                            {
                                                // Currently addMinHeight only works with 1 terrain in the landscape
                                                if (landscapeTerrains.Length == 1)
                                                {
                                                    topographyLayers[index].addMinHeight = EditorGUILayout.Toggle(layersAddMinHeightContent, topographyLayers[index].addMinHeight);
                                                }
                                                else { topographyLayers[index].addMinHeight = false; }
                                            }
                                            else { topographyLayers[index].addMinHeight = false; }

                                            if (!topographyLayers[index].addMinHeight)
                                            {
                                                topographyLayers[index].addHeight = EditorGUILayout.Slider(layersAddHeightContent, topographyLayers[index].addHeight * terrainHeight, 0f, terrainHeight) / terrainHeight;
                                            }
                                        }
                                    }
                                    else
                                    {
                                        topographyLayers[index].subtractiveAmount = EditorGUILayout.Slider(layersSubtractiveAmountContent, topographyLayers[index].subtractiveAmount, 0f, 1f);
                                        topographyLayers[index].subtractiveCurve = LBLayer.CreateSubtractiveCurve(topographyLayers[index].subtractiveAmount);

                                        topographyLayers[index].removeBaseNoise = EditorGUILayout.Toggle(layersRemoveBaseNoiseContent, topographyLayers[index].removeBaseNoise);

                                        if (topographyLayers[index].removeBaseNoise)
                                        {
                                            // Add min height doesn't make much sense for subtractive layers
                                            topographyLayers[index].addMinHeight = false;
                                            topographyLayers[index].addHeight = EditorGUILayout.Slider(layersAddHeightContent, topographyLayers[index].addHeight * terrainHeight, 0f, terrainHeight) / terrainHeight;
                                        }
                                    }

#region Topography Layer Perlin Restrict Area
                                    GUILayout.BeginHorizontal();
                                    GUILayoutOption[] guiLayoutOptions = { GUILayout.Width(EditorGUIUtility.labelWidth + 20f), GUILayout.MinHeight(20f) };
                                    topographyLayers[index].restrictArea = EditorGUILayout.Toggle(layersRestrictAreaContent, topographyLayers[index].restrictArea, guiLayoutOptions);
                                    if (topographyLayers[index].restrictArea)
                                    {
                                        // Is area highlighter is required
                                        areaHighlighterRequired = (areaHighlighterRequired || topographyLayers[index].showAreaHighlighter);

                                        if (topographyLayers[index].showAreaHighlighter)
                                        {
                                            if (GUILayout.Button("Disable Picker", buttonCompact, GUILayout.MaxWidth(90f)))
                                            {
                                                topographyLayers[index].showAreaHighlighter = false;
                                                areaHighlighterRequired = false;
                                            }
                                            if (GUILayout.Button("Move->View", buttonCompact, GUILayout.MaxWidth(80f)))
                                            {
                                                areaHighlighter.MoveToSceneView();
                                            }
                                        }
                                        else if (!areaHighlighterEnabled)
                                        {
                                            if (GUILayout.Button("Enable Area Picker", buttonCompact, GUILayout.MaxWidth(125f)))
                                            {
                                                topographyLayers[index].showAreaHighlighter = true;
                                                areaHighlighterRequired = true;
                                            }
                                        }
                                        GUILayout.EndHorizontal();

                                        if (areaHighlighter != null && topographyLayers[index].showAreaHighlighter && areaHighlighter.AreaRectSet())
                                        {
                                            topographyLayers[index].areaRect = areaHighlighter.GetAreaRect();
                                        }
                                        topographyLayers[index].areaRect = EditorGUILayout.RectField(layersAreaRectangleContent, topographyLayers[index].areaRect);
                                        if (areaHighlighter != null && topographyLayers[index].showAreaHighlighter)
                                        {
                                            areaHighlighter.AssignAreaRect(topographyLayers[index].areaRect, landscape.transform.position, terrainHeight);
                                        }

                                        topographyLayers[index].areaBlendRate = EditorGUILayout.Slider(layersAreaBlendRateContent, topographyLayers[index].areaBlendRate, 0f, 1f);
                                    }
                                    else { GUILayout.EndHorizontal(); }
#endregion
                                }
                                // Disable area highlighter when not an additive/subtractive layer
                                else { topographyLayers[index].showAreaHighlighter = false; }

#region Topography Layer Perlin Curve Modifiers

                                // Show/hide foldout for curves
                                topographyLayers[index].showCurvesAndFilters = EditorGUILayout.Foldout(topographyLayers[index].showCurvesAndFilters, "Curve Modifiers And Filters");
                                if (topographyLayers[index].showCurvesAndFilters)
                                {
                                    // Curve modifiers

                                    // Create lists if they are null
                                    if (topographyLayers[index].outputCurveModifiers == null) { topographyLayers[index].outputCurveModifiers = new List<AnimationCurve>(); }
                                    if (topographyLayers[index].outputCurveModifierPresets == null) { topographyLayers[index].outputCurveModifierPresets = new List<LBCurve.CurvePreset>(); }
                                    if (topographyLayers[index].perOctaveCurveModifiers == null) { topographyLayers[index].perOctaveCurveModifiers = new List<AnimationCurve>(); }
                                    if (topographyLayers[index].perOctaveCurveModifierPresets == null) { topographyLayers[index].perOctaveCurveModifierPresets = new List<LBCurve.CurvePreset>(); }

                                    EditorGUILayout.Space();

                                    // Output curve modfiers

                                    arrayInt = topographyLayers[index].outputCurveModifiers.Count;
                                    GUILayout.BeginHorizontal();
                                    EditorGUILayout.LabelField(layersOutputCurveModifiersContent, labelFieldRichText);
                                    if (GUILayout.Button("+")) { arrayInt++; }
                                    if (GUILayout.Button("-")) { if (arrayInt > 0) { if (LBEditorHelper.PromptForDelete("Output Curve Modifier", "", arrayInt - 1, false)) { arrayInt--; } } }
                                    if (arrayInt < 0) { arrayInt = 0; }
                                    GUILayout.EndHorizontal();
                                    // Add items to the list
                                    if (arrayInt > topographyLayers[index].outputCurveModifiers.Count)
                                    {
                                        temp = arrayInt - topographyLayers[index].outputCurveModifiers.Count;
                                        for (index2 = 0; index2 < temp; index2++)
                                        {
                                            topographyLayers[index].outputCurveModifiers.Add(AnimationCurve.Linear(0f, 0f, 1f, 1f));
                                            topographyLayers[index].outputCurveModifierPresets.Add(LBCurve.CurvePreset.None);
                                        }
                                    }
                                    // Remove items from the list
                                    else if (arrayInt < topographyLayers[index].outputCurveModifiers.Count)
                                    {
                                        temp = topographyLayers[index].outputCurveModifiers.Count - arrayInt;
                                        for (index2 = 0; index2 < temp; index2++)
                                        {
                                            topographyLayers[index].outputCurveModifiers.RemoveAt(topographyLayers[index].outputCurveModifiers.Count - 1);
                                            topographyLayers[index].outputCurveModifierPresets.RemoveAt(topographyLayers[index].outputCurveModifierPresets.Count - 1);
                                        }
                                    }
                                    for (index2 = 0; index2 < topographyLayers[index].outputCurveModifiers.Count; index2++)
                                    {
                                        // Show the elements of the list
                                        LBCurve.CurvePreset newCurvePreset;
                                        newCurvePreset = (LBCurve.CurvePreset)EditorGUILayout.EnumPopup("Preset", topographyLayers[index].outputCurveModifierPresets[index2]);
                                        if (newCurvePreset != topographyLayers[index].outputCurveModifierPresets[index2])
                                        {
                                            topographyLayers[index].outputCurveModifiers[index2] = LBCurve.SetCurveFromPreset(newCurvePreset);
                                            topographyLayers[index].outputCurveModifierPresets[index2] = newCurvePreset;
                                        }

                                        EditorGUILayout.BeginHorizontal();
                                        // GUIContent for Curve Modifiers need to be dynamically created
                                        GUILayout.Label(new GUIContent("Curve Modifier " + (index2 + 1), "Used to modify the overall output of the noise"), GUILayout.Width(EditorGUIUtility.labelWidth - 28f));
                                        AddScriptCurveButton(topographyLayers[index].outputCurveModifiers[index2], "layer" + (index + 1).ToString() + "outputCurve" + (index2 + 1).ToString());
                                        topographyLayers[index].outputCurveModifiers[index2] = EditorGUILayout.CurveField(topographyLayers[index].outputCurveModifiers[index2], GUILayout.Height(30f));
                                        EditorGUILayout.EndHorizontal();
                                    }

                                    EditorGUILayout.Space();

                                    // Per octave curve modifiers

                                    arrayInt = topographyLayers[index].perOctaveCurveModifiers.Count;
                                    GUILayout.BeginHorizontal();
                                    EditorGUILayout.LabelField(layersPerOctaveCurveModifiersContent, labelFieldRichText);
                                    if (GUILayout.Button("+")) { arrayInt++; }
                                    if (GUILayout.Button("-")) { if (arrayInt > 0) { if (LBEditorHelper.PromptForDelete("Per Octave Curve Modifier", "", arrayInt - 1, false)) { arrayInt--; } } }
                                    if (arrayInt < 0) { arrayInt = 0; }
                                    GUILayout.EndHorizontal();
                                    // Add items to the list
                                    if (arrayInt > topographyLayers[index].perOctaveCurveModifiers.Count)
                                    {
                                        temp = arrayInt - topographyLayers[index].perOctaveCurveModifiers.Count;
                                        for (index2 = 0; index2 < temp; index2++)
                                        {
                                            topographyLayers[index].perOctaveCurveModifiers.Add(AnimationCurve.Linear(0f, 0f, 1f, 1f));
                                            topographyLayers[index].perOctaveCurveModifierPresets.Add(LBCurve.CurvePreset.None);
                                        }
                                    }
                                    // Remove items from the list
                                    else if (arrayInt < topographyLayers[index].perOctaveCurveModifiers.Count)
                                    {
                                        temp = topographyLayers[index].perOctaveCurveModifiers.Count - arrayInt;
                                        for (index2 = 0; index2 < temp; index2++)
                                        {
                                            topographyLayers[index].perOctaveCurveModifiers.RemoveAt(topographyLayers[index].perOctaveCurveModifiers.Count - 1);
                                            topographyLayers[index].perOctaveCurveModifierPresets.RemoveAt(topographyLayers[index].perOctaveCurveModifierPresets.Count - 1);
                                        }
                                    }
                                    for (index2 = 0; index2 < topographyLayers[index].perOctaveCurveModifiers.Count; index2++)
                                    {
                                        // Show the elements of the list
                                        LBCurve.CurvePreset newCurvePreset;
                                        newCurvePreset = (LBCurve.CurvePreset)EditorGUILayout.EnumPopup("Preset", topographyLayers[index].perOctaveCurveModifierPresets[index2]);
                                        if (newCurvePreset != topographyLayers[index].perOctaveCurveModifierPresets[index2])
                                        {
                                            topographyLayers[index].perOctaveCurveModifiers[index2] = LBCurve.SetCurveFromPreset(newCurvePreset);
                                            topographyLayers[index].perOctaveCurveModifierPresets[index2] = newCurvePreset;
                                        }
                                        EditorGUILayout.BeginHorizontal();
                                        GUILayout.Label(new GUIContent("Curve Modifier " + (index2 + 1), "Used to modify the output of each individual octave (or detail layer) of the noise"), GUILayout.Width(EditorGUIUtility.labelWidth - 28f));
                                        AddScriptCurveButton(topographyLayers[index].perOctaveCurveModifiers[index2], "layer" + (index + 1).ToString() + "perOctaveCurve" + (index2 + 1).ToString());
                                        topographyLayers[index].perOctaveCurveModifiers[index2] = EditorGUILayout.CurveField(topographyLayers[index].perOctaveCurveModifiers[index2], GUILayout.Height(30f));
                                        EditorGUILayout.EndHorizontal();
                                    }
                                }
#endregion
                            }
                            #endregion

                            #region Image Layer Types
                            else if (topographyLayers[index].type == LBLayer.LayerType.ImageBase || topographyLayers[index].type == LBLayer.LayerType.ImageAdditive ||
                                        topographyLayers[index].type == LBLayer.LayerType.ImageSubtractive || topographyLayers[index].type == LBLayer.LayerType.ImageDetail)
                            {
                                // Image layer

                                EditorGUILayout.HelpBox("Image Layers use 8bit heighmap data. Consider importing a 16/32bit (Geo)TIFF file and/or use 16bit Image Modifier Layers", MessageType.Info, true);

                                topographyLayers[index].heightmapImage = (Texture2D)EditorGUILayout.ObjectField(new GUIContent("Heightmap Image", "Image the layer output will be based on"), topographyLayers[index].heightmapImage, typeof(Texture2D), false);
                                EditorGUI.BeginChangeCheck();
                                topographyLayers[index].imageSource = (LBLayer.LayerImageSource)EditorGUILayout.EnumPopup(new GUIContent("Image Source", "The source of the image data. If in doubt, select Default."), topographyLayers[index].imageSource);

                                // If the landscape has just been loaded or switched to, update the image settings base on the input source
                                if (EditorGUI.EndChangeCheck() && !landscapeHasSwitched)
                                {
                                    if (topographyLayers[index].imageSource == LBLayer.LayerImageSource.TerrainParty)
                                    {
                                        topographyLayers[index].interpolationSmoothing = 0;
                                        topographyLayers[index].detailSmoothRate = 0.2f;
                                        topographyLayers[index].normaliseImage = false;
                                        topographyLayers[index].imageRepairHoles = false;
                                        topographyLayers[index].threshholdRepairHoles = 0f;
                                        topographyLayers[index].imageHeightScale = 1;
                                    }
                                    else if (topographyLayers[index].imageSource == LBLayer.LayerImageSource.MIT_LRO_LOLA)
                                    {
                                        topographyLayers[index].interpolationSmoothing = 2;
                                        topographyLayers[index].detailSmoothRate = 0.3f;
                                        topographyLayers[index].normaliseImage = false;
                                        topographyLayers[index].imageRepairHoles = true;
                                        topographyLayers[index].threshholdRepairHoles = 0.5f;
                                        topographyLayers[index].imageHeightScale = 1;
                                    }
                                    else
                                    {
                                        topographyLayers[index].normaliseImage = true;
                                        topographyLayers[index].imageRepairHoles = false;
                                        topographyLayers[index].threshholdRepairHoles = 0f;
                                    }
                                }
                                topographyLayers[index].normaliseImage = EditorGUILayout.Toggle(layersNormaliseInputContent, topographyLayers[index].normaliseImage);
                                topographyLayers[index].imageRepairHoles = EditorGUILayout.Toggle(layersImageRepairHolesContent, topographyLayers[index].imageRepairHoles);
                                if (topographyLayers[index].imageRepairHoles)
                                {
                                    topographyLayers[index].threshholdRepairHoles = EditorGUILayout.Slider(layersThresholdRepairHolesContent, topographyLayers[index].threshholdRepairHoles, 0f, 1f);
                                }

                                int[] possibleISs = { 0, 2, 4, 8 };
                                string[] possibleISStrings = { "0", "2", "4", "8" };
                                if (heightmapResolution == 65)
                                {
                                    EditorGUILayout.HelpBox("Interpolation Smoothing is not available for a heightmap resolution of 65", MessageType.Info, true);
                                    EditorGUILayout.Space();
                                    topographyLayers[index].interpolationSmoothing = 0;
                                }
                                else
                                {
                                    topographyLayers[index].interpolationSmoothing = EditorGUILayout.IntPopup("Interpolation Smoothing", topographyLayers[index].interpolationSmoothing, possibleISStrings, possibleISs);
                                }
                                // Images are now normalised, so max HeightScale is 1.
                                topographyLayers[index].imageHeightScale = EditorGUILayout.Slider(layersImageHeightScaleContent, topographyLayers[index].imageHeightScale, 0.01f, 1f);
                                topographyLayers[index].detailSmoothRate = EditorGUILayout.Slider(layersDetailSmoothRateContent, topographyLayers[index].detailSmoothRate, 0f, 1f);

                                // Interpolation smoothing doesn't support heightmap resolution of 129 and Int.Smoothing = 2
                                if (heightmapResolution == 129)
                                {
                                    // Override value of 2
                                    if (topographyLayers[index].interpolationSmoothing == 2) { topographyLayers[index].interpolationSmoothing = 4; }
                                    EditorGUILayout.HelpBox("Not all Intepolation Smoothing options are available for a heightmap resolution of 129", MessageType.Info, true);
                                    EditorGUILayout.Space();
                                }

                                // Image additive layer variables
                                if (topographyLayers[index].type == LBLayer.LayerType.ImageAdditive || topographyLayers[index].type == LBLayer.LayerType.ImageSubtractive)
                                {
                                    if (topographyLayers[index].type == LBLayer.LayerType.ImageAdditive)
                                    {
                                        topographyLayers[index].additiveAmount = EditorGUILayout.Slider(new GUIContent("Additive Amount", "Approximately how much of this layer is added onto your landscape. " +
                                            "If this layer does not appear to affect your topography, increase this value"), topographyLayers[index].additiveAmount, 0f, 1f);
                                        topographyLayers[index].additiveCurve = LBLayer.CreateAdditiveCurve(topographyLayers[index].additiveAmount);
                                    }
                                    else
                                    {
                                        topographyLayers[index].subtractiveAmount = EditorGUILayout.Slider(new GUIContent("Subtractive Amount", "Approximately how much of this layer is subtracted from your landscape. " +
                                            "If this layer does not appear to affect your topography, increase this value"), topographyLayers[index].subtractiveAmount, 0f, 1f);
                                        topographyLayers[index].subtractiveCurve = LBLayer.CreateSubtractiveCurve(topographyLayers[index].subtractiveAmount);
                                    }
                                    topographyLayers[index].isSmoothLayerOnly = EditorGUILayout.Toggle(layersIsSmoothLayerOnlyContent, topographyLayers[index].isSmoothLayerOnly);
                                    topographyLayers[index].removeBaseNoise = EditorGUILayout.Toggle(new GUIContent("Remove Base Noise", "Whether the base noise will be removed when adding this layer on top of it"), topographyLayers[index].removeBaseNoise);

                                    GUILayout.BeginHorizontal();
                                    GUILayoutOption[] guiLayoutOptions = { GUILayout.Width(EditorGUIUtility.labelWidth + 20f), GUILayout.MinHeight(20f) };
                                    topographyLayers[index].restrictArea = EditorGUILayout.Toggle(new GUIContent("Restrict Area", "Only apply this layer to a particular area or region of the landscape"),
                                                                                                    topographyLayers[index].restrictArea, guiLayoutOptions);
                                    if (topographyLayers[index].restrictArea)
                                    {
                                        // Is area highlighter is required
                                        areaHighlighterRequired = (areaHighlighterRequired || topographyLayers[index].showAreaHighlighter);

                                        if (topographyLayers[index].showAreaHighlighter)
                                        {
                                            if (GUILayout.Button("Disable Picker", buttonCompact, GUILayout.MaxWidth(90f)))
                                            {
                                                topographyLayers[index].showAreaHighlighter = false;
                                                areaHighlighterRequired = false;
                                            }
                                            if (GUILayout.Button("Move->View", buttonCompact, GUILayout.MaxWidth(80f)))
                                            {
                                                areaHighlighter.MoveToSceneView();
                                            }
                                        }
                                        else if (!areaHighlighterEnabled)
                                        {
                                            if (GUILayout.Button("Enable Area Picker", buttonCompact, GUILayout.MaxWidth(125f)))
                                            {
                                                topographyLayers[index].showAreaHighlighter = true;
                                                areaHighlighterRequired = true;
                                            }
                                        }
                                        GUILayout.EndHorizontal();

                                        if (areaHighlighter != null && topographyLayers[index].showAreaHighlighter && areaHighlighter.AreaRectSet())
                                        {
                                            topographyLayers[index].areaRect = areaHighlighter.GetAreaRect();
                                        }
                                        topographyLayers[index].areaRect = EditorGUILayout.RectField(new GUIContent("Area Rect", "The size and location of the area this layer will affect"), topographyLayers[index].areaRect);
                                        if (areaHighlighter != null && topographyLayers[index].showAreaHighlighter)
                                        {
                                            areaHighlighter.AssignAreaRect(topographyLayers[index].areaRect, landscape.transform.position, terrainHeight);
                                        }
                                        topographyLayers[index].areaBlendRate = EditorGUILayout.Slider(new GUIContent("Blend Rate", "The amount to blend the edges with the surrounding topography"), topographyLayers[index].areaBlendRate, 0f, 1f);
                                    }
                                    else { GUILayout.EndHorizontal(); }
                                }
                                // Disable area highlighter when not an additive/subtractive layer
                                else { topographyLayers[index].showAreaHighlighter = false; }

                                // Show/hide foldout for curves
                                topographyLayers[index].showCurvesAndFilters = EditorGUILayout.Foldout(topographyLayers[index].showCurvesAndFilters, "Curve Modifiers And Filters");
                                if (topographyLayers[index].showCurvesAndFilters)
                                {
                                    // Curve modifiers

                                    // Create lists if they are null
                                    if (topographyLayers[index].imageCurveModifiers == null) { topographyLayers[index].imageCurveModifiers = new List<AnimationCurve>(); }
                                    if (topographyLayers[index].imageCurveModifierPresets == null) { topographyLayers[index].imageCurveModifierPresets = new List<LBCurve.CurvePreset>(); }

                                    arrayInt = topographyLayers[index].imageCurveModifiers.Count;
                                    GUILayout.BeginHorizontal();
                                    EditorGUILayout.LabelField(new GUIContent("<b>Output Curve Modifiers</b>", "Curve Modifiers that modify the overall output of this layer"), labelFieldRichText);
                                    if (GUILayout.Button("+")) { arrayInt++; }
                                    if (GUILayout.Button("-")) { if (arrayInt > 0) { if (LBEditorHelper.PromptForDelete("Output Curve Modifier", "", arrayInt - 1, false)) { arrayInt--; } } }
                                    if (arrayInt < 0) { arrayInt = 0; }
                                    GUILayout.EndHorizontal();
                                    // Add items to the list
                                    if (arrayInt > topographyLayers[index].imageCurveModifiers.Count)
                                    {
                                        temp = arrayInt - topographyLayers[index].imageCurveModifiers.Count;
                                        for (index2 = 0; index2 < temp; index2++)
                                        {
                                            topographyLayers[index].imageCurveModifiers.Add(AnimationCurve.Linear(0f, 0f, 1f, 1f));
                                            topographyLayers[index].imageCurveModifierPresets.Add(LBCurve.CurvePreset.None);
                                        }
                                    }
                                    // Remove items from the list
                                    else if (arrayInt < topographyLayers[index].imageCurveModifiers.Count)
                                    {
                                        temp = topographyLayers[index].imageCurveModifiers.Count - arrayInt;
                                        for (index2 = 0; index2 < temp; index2++)
                                        {
                                            topographyLayers[index].imageCurveModifiers.RemoveAt(topographyLayers[index].imageCurveModifiers.Count - 1);
                                            topographyLayers[index].imageCurveModifierPresets.RemoveAt(topographyLayers[index].imageCurveModifierPresets.Count - 1);
                                        }
                                    }
                                    for (index2 = 0; index2 < topographyLayers[index].imageCurveModifiers.Count; index2++)
                                    {
                                        // Show the elements of the list
                                        LBCurve.CurvePreset newCurvePreset;
                                        newCurvePreset = (LBCurve.CurvePreset)EditorGUILayout.EnumPopup("Preset", topographyLayers[index].imageCurveModifierPresets[index2]);
                                        if (newCurvePreset != topographyLayers[index].imageCurveModifierPresets[index2])
                                        {
                                            topographyLayers[index].imageCurveModifiers[index2] = LBCurve.SetCurveFromPreset(newCurvePreset);
                                            topographyLayers[index].imageCurveModifierPresets[index2] = newCurvePreset;
                                        }
                                        topographyLayers[index].imageCurveModifiers[index2] = EditorGUILayout.CurveField("Curve Modifier " + (index2 + 1), topographyLayers[index].imageCurveModifiers[index2], GUILayout.Height(30f));
                                    }
                                }
                            }
                            #endregion

                            #region MapPath Layer Type
                            else if (topographyLayers[index].type == LBLayer.LayerType.MapPath)
                            {
                                // MapPath LayerType
                                topographyLayers[index].layerTypeMode = (LBLayer.LayerTypeMode)EditorGUILayout.EnumPopup(layersTypeModeContent, topographyLayers[index].layerTypeMode);

                                EditorGUI.BeginChangeCheck();
                                topographyLayers[index].lbMapPath = (LBMapPath)EditorGUILayout.ObjectField("Map Path", topographyLayers[index].lbMapPath, typeof(LBMapPath), true);
                                if (EditorGUI.EndChangeCheck())
                                {
                                    if (topographyLayers[index].lbMapPath != null)
                                    {
                                        topographyLayers[index].lbPath = topographyLayers[index].lbMapPath.lbPath;
                                    }
                                }

                                // MapPath Blend Presets                                    
                                newMapPathBlendCurvePreset = (LBCurve.MapPathBlendCurvePreset)EditorGUILayout.EnumPopup(layersMapPathBlendPresetContent, topographyLayers[index].mapPathBlendCurvePreset);
                                if (newMapPathBlendCurvePreset != topographyLayers[index].mapPathBlendCurvePreset)
                                {
                                    topographyLayers[index].mapPathBlendCurve = LBCurve.SetCurveFromPreset(newMapPathBlendCurvePreset);
                                    topographyLayers[index].mapPathBlendCurvePreset = newMapPathBlendCurvePreset;
                                }

                                EditorGUILayout.BeginHorizontal();
                                GUILayout.Label(layersBlendCurveContent, GUILayout.Width(EditorGUIUtility.labelWidth - 28f));
                                AddScriptCurveButton(topographyLayers[index].mapPathBlendCurve, "layer" + (index + 1).ToString() + "mapPathBlendCurve");
                                topographyLayers[index].mapPathBlendCurve = EditorGUILayout.CurveField(topographyLayers[index].mapPathBlendCurve, GUILayout.Height(30f));
                                EditorGUILayout.EndHorizontal();

                                // MapPath Height Presets
                                newMapPathHeightCurvePreset = (LBCurve.MapPathHeightCurvePreset)EditorGUILayout.EnumPopup(layersMapPathHeightPresetContent, topographyLayers[index].mapPathHeightCurvePreset);
                                if (newMapPathHeightCurvePreset != topographyLayers[index].mapPathHeightCurvePreset)
                                {
                                    topographyLayers[index].mapPathHeightCurve = LBCurve.SetCurveFromPreset(newMapPathHeightCurvePreset);
                                    topographyLayers[index].mapPathHeightCurvePreset = newMapPathHeightCurvePreset;

                                    string newMapPathHeightCurvePresetName = newMapPathHeightCurvePreset.ToString();

                                    if (newMapPathHeightCurvePresetName.EndsWith("Set")) { topographyLayers[index].mapPathAddInvert = false; }
                                    else if (newMapPathHeightCurvePresetName.EndsWith("Subtract")) { topographyLayers[index].mapPathAddInvert = true; }
                                }

                                EditorGUILayout.BeginHorizontal();
                                GUILayout.Label(layersMapPathHeightCurveContent, GUILayout.Width(EditorGUIUtility.labelWidth - 28f));
                                AddScriptCurveButton(topographyLayers[index].mapPathHeightCurve, "layer" + (index + 1).ToString() + "mapPathHeightCurve");
                                topographyLayers[index].mapPathHeightCurve = EditorGUILayout.CurveField(topographyLayers[index].mapPathHeightCurve, GUILayout.Height(30f));
                                EditorGUILayout.EndHorizontal();

                                if (topographyLayers[index].layerTypeMode == LBLayer.LayerTypeMode.Add)
                                {
                                    mapPathMaxHeight = topographyLayers[index].heightScale * terrainHeight;

                                    EditorGUI.BeginChangeCheck();
                                    if (topographyLayers[index].mapPathAddInvert)
                                    {
                                        mapPathMaxHeight = EditorGUILayout.Slider(layersHeightToSubtractContent, mapPathMaxHeight, 0.001f, terrainHeight / 10f);
                                    }
                                    else
                                    {
                                        mapPathMaxHeight = EditorGUILayout.Slider(layersHeightToAddContent, mapPathMaxHeight, 0.001f, terrainHeight / 10f);
                                    }

                                    if (EditorGUI.EndChangeCheck() && terrainHeight > 0f)
                                    {
                                        topographyLayers[index].heightScale = mapPathMaxHeight / terrainHeight;
                                    }

                                    topographyLayers[index].mapPathAddInvert = EditorGUILayout.Toggle(layersSubtractNotAddContent, topographyLayers[index].mapPathAddInvert);
                                }
                                else if (topographyLayers[index].layerTypeMode == LBLayer.LayerTypeMode.Set)
                                {
                                    mapPathMinHeight = topographyLayers[index].minHeight * terrainHeight;
                                    mapPathMaxHeight = topographyLayers[index].heightScale * terrainHeight;

                                    EditorGUI.BeginChangeCheck();
                                    mapPathMinHeight = EditorGUILayout.Slider(layersMapPathMinHeightContent, mapPathMinHeight, 0f, terrainHeight);
                                    if (mapPathMaxHeight < mapPathMinHeight) { mapPathMaxHeight = mapPathMinHeight; }
                                    mapPathMaxHeight = EditorGUILayout.Slider(layersMapPathMaxHeightContent, mapPathMaxHeight, 1f, terrainHeight);
                                    if (EditorGUI.EndChangeCheck() && terrainHeight > 0f)
                                    {
                                        topographyLayers[index].minHeight = mapPathMinHeight / terrainHeight;
                                        topographyLayers[index].heightScale = mapPathMaxHeight / terrainHeight;
                                    }
                                }
                                else if (topographyLayers[index].layerTypeMode == LBLayer.LayerTypeMode.Flatten)
                                {
                                    mapPathMaxHeight = topographyLayers[index].heightScale * terrainHeight;
                                    EditorGUI.BeginChangeCheck();
                                    mapPathMaxHeight = EditorGUILayout.Slider(layersHeightToAddContent, mapPathMaxHeight, 0.001f, terrainHeight / 10f);
                                    if (EditorGUI.EndChangeCheck() && terrainHeight > 0f)
                                    {
                                        topographyLayers[index].heightScale = mapPathMaxHeight / terrainHeight;
                                    }
                                }
                                topographyLayers[index].detailSmoothRate = EditorGUILayout.Slider(new GUIContent("Edge Smoothing", "The amount of edge smoothing to be applied to the path after the topography has been added. Smoothing is slow, so if you don't need it set to 0."), topographyLayers[index].detailSmoothRate, 0f, 0.25f);
                            }
                            #endregion

                            #region Unity Terrains Layer Type (can be imported from existing Terrain, RAW files, or GeoTIFF files

                            else if (topographyLayers[index].type == LBLayer.LayerType.UnityTerrains)
                            {
                                if (index > 0) { EditorGUILayout.HelpBox("Unity Terrain Layers must always appear at the top of the list", MessageType.Info, true); }

                                if (topographyLayers[index].lbTerrainDataList == null) { EditorGUILayout.HelpBox("No terrain data", MessageType.Info, true); }
                                else
                                {
                                    if (LBTerrainData.HasRAWHeightData(topographyLayers[index].lbTerrainDataList))
                                    {
                                        int rawHeightResolution = LBTerrainData.GetRAWHeightResolution(topographyLayers[index].lbTerrainDataList);

                                        EditorGUILayout.LabelField("TerrainData (RAW)", labelFieldRichText);
                                        EditorGUILayout.BeginHorizontal();
                                        EditorGUILayout.LabelField("Height Resolution", labelFieldRichText, GUILayout.Width(defaultEditorLabelWidth));
                                        EditorGUILayout.LabelField(rawHeightResolution.ToString(), labelFieldRichText);
                                        EditorGUILayout.EndHorizontal();

                                        if (rawHeightResolution != heightmapResolution)
                                        {
                                            EditorGUILayout.HelpBox("Unity Terrains Layer resolution does not match Landscape terrains", MessageType.Warning, true);
                                        }

                                        rawDataSourceDisplayName = LBTerrainData.GetDataSourceDisplayName(topographyLayers[index].lbTerrainDataList);

                                        if (!LBTerrainData.GetRAWMinMaxHeights(topographyLayers[index].lbTerrainDataList, ref rawMinHeight, ref rawMaxHeight))
                                        {
                                            rawMinHeight = 0; rawMaxHeight = 0;
                                        }

                                        EditorGUILayout.BeginHorizontal();
                                        EditorGUILayout.LabelField("Original Data Source", labelFieldRichText, GUILayout.Width(defaultEditorLabelWidth));
                                        EditorGUILayout.LabelField(rawDataSourceDisplayName, labelFieldRichText);
                                        EditorGUILayout.EndHorizontal();

                                        EditorGUILayout.BeginHorizontal();
                                        EditorGUILayout.LabelField("Source Dimensions", labelFieldRichText, GUILayout.Width(defaultEditorLabelWidth));
                                        EditorGUILayout.LabelField(LBTerrainData.GetDataSourceDimensionsDisplay(topographyLayers[index].lbTerrainDataList), labelFieldRichText);
                                        EditorGUILayout.EndHorizontal();

                                        EditorGUILayout.BeginHorizontal();
                                        EditorGUILayout.LabelField("Min/Max Heights", labelFieldRichText, GUILayout.Width(defaultEditorLabelWidth));
                                        EditorGUILayout.LabelField(rawMinHeight + ", " + rawMaxHeight, labelFieldRichText);
                                        EditorGUILayout.EndHorizontal();

                                        // Check to see if the terrain height matches the RAW data max height
                                        // Ignore normalised source data and data including below sea level (typically GMRT)
                                        if (topographyLayers[index].isCheckHeightRangeDiff && rawMinHeight != rawMaxHeight && !topographyLayers[index].isSourceDataNormalised && !topographyLayers[index].isBelowSeaLevelDataIncluded && !Mathf.Approximately((rawMaxHeight - rawMinHeight + topographyLayers[index].floorOffsetY), terrainHeight))
                                        {
                                            GUILayout.BeginHorizontal();
                                            EditorGUILayout.HelpBox("The data heights (" + rawMaxHeight + "-" + rawMinHeight + "+" + topographyLayers[index].floorOffsetY + "=" + (rawMaxHeight - rawMinHeight + topographyLayers[index].floorOffsetY).ToString() + ") does not match your landscape height (" + terrainHeight + "). Click 'Fix Now' to adjust the landscape height", MessageType.Warning, true);
                                            if (GUILayout.Button("Fix Now", GUILayout.MinHeight(40f)))
                                            {
                                                landscape.SetLandscapeTerrainHeight(rawMaxHeight - rawMinHeight + topographyLayers[index].floorOffsetY);
                                            }
                                            GUILayout.EndHorizontal();
                                        }

                                        if (rawDataSourceDisplayName.ToLower().Contains("tif"))
                                        {
                                            if ((rawMaxHeight >= 65000u && !topographyLayers[index].isSourceDataNormalised) || (rawMaxHeight > 55536u && topographyLayers[index].isBelowSeaLevelDataIncluded))
                                            {
                                                GUILayout.BeginHorizontal();
                                                EditorGUILayout.HelpBox("The original data looks like it has some extreme values.", MessageType.Warning, true);
                                                if (GUILayout.Button("Fix Now", GUILayout.MinHeight(40f)))
                                                {
                                                    LBImportTIFF.FixGeoTIFFHeightmap(landscape, topographyLayers[index], true);
                                                }
                                                GUILayout.EndHorizontal();
                                            }
                                            topographyLayers[index].isSourceDataNormalised = EditorGUILayout.Toggle(layersIsSourceDataNormalisedContent, topographyLayers[index].isSourceDataNormalised);
                                            topographyLayers[index].normaliseImage = EditorGUILayout.Toggle(layersRAWNormaliseInputContent, topographyLayers[index].normaliseImage);
                                            topographyLayers[index].isBelowSeaLevelDataIncluded = EditorGUILayout.Toggle(layersRAWisBelowSeaLevelContent, topographyLayers[index].isBelowSeaLevelDataIncluded);
                                            topographyLayers[index].floorOffsetY = EditorGUILayout.Slider(layersRAWFloorOffsetContent, topographyLayers[index].floorOffsetY, 0f, terrainHeight / 5f);
                                        }
                                        topographyLayers[index].heightScale = EditorGUILayout.Slider(layersRAWHeightScaleContent, topographyLayers[index].heightScale, 0.01f, 3f);
                                        //topographyLayers[index].imageRepairHoles = EditorGUILayout.Toggle(layersImageRepairHolesContent, topographyLayers[index].imageRepairHoles);
                                    }
                                    else { EditorGUILayout.HelpBox("No terrain heightmap data", MessageType.Info, true); }
                                }
                            }

                            #endregion

                            #region Image Modifier Layer Type

                            else if (topographyLayers[index].type == LBLayer.LayerType.ImageModifier)
                            {
#region ImageModifier Buttons and User file selection

                                // Allow user to select an image to use for the modifier - this must be a RAW file
                                EditorGUILayout.BeginVertical(EditorStyles.helpBox);

                                // NOTE: To avoid "ArgumentException: GUILayout: Mismatched LayoutGroup.Repaint",
                                // all conditions must return the same number and type of controls.
                                labelText = topographyLayers[index].modifierRAWFile != null ? topographyLayers[index].modifierRAWFile.dataSourceName : "WARNING: Image modifiers require a RAW file input";
                                EditorGUILayout.LabelField(labelText);

                                // Buttons
                                EditorGUILayout.BeginHorizontal();
                                if (GUILayout.Button(layersModifierImportRAWContent))
                                {
                                    // Remove any existing water
                                    if (topographyLayers[index].modifierUseWater)
                                    {
                                        RemoveModifierWater(topographyLayers[index]);
                                        topographyLayers[index].modifierUseWater = false;
                                    }

                                    ImportRAWToLayer(topographyLayers[index], true);
                                    if (topographyLayers[index].showVolumeHighlighter && volumeHighlighter != null)
                                    {
                                        // Set preview mesh if volume highlighter already exists
                                        volumeHighlighter.UpdatePreviewMesh(topographyLayers[index].modifierRAWFile);
                                    }
                                    layerModifierSourceFileType = topographyLayers[index].modifierSourceFileType;

                                    isSceneSaveRequired = true;
                                }
                                if (GUILayout.Button(layersModifierImportPNGContent))
                                {
                                    // Remove any existing water
                                    if (topographyLayers[index].modifierUseWater)
                                    {
                                        RemoveModifierWater(topographyLayers[index]);
                                        topographyLayers[index].modifierUseWater = false;
                                    }

                                    ImportPNGToLayer(topographyLayers[index], true);
                                    if (topographyLayers[index].showVolumeHighlighter && volumeHighlighter != null)
                                    {
                                        // Set preview mesh if volume highlighter already exists
                                        volumeHighlighter.UpdatePreviewMesh(topographyLayers[index].modifierRAWFile);
                                    }
                                    layerModifierSourceFileType = topographyLayers[index].modifierSourceFileType;
                                    isSceneSaveRequired = true;
                                }
                                if (GUILayout.Button(layersModifierRefreshLandformListContent, GUILayout.MaxWidth(70f))) { isModifierLandformListsRefreshRequired = true; }
                                EditorGUILayout.EndHorizontal();

                                EditorGUILayout.EndVertical();

#endregion

#region Image Modifier Landform selection
                                previousLandformCategory = topographyLayers[index].modifierLandformCategory.ToString();
                                topographyLayers[index].modifierLandformCategory = (LBModifierOperations.ModifierLandformCategory)EditorGUILayout.EnumPopup(layersModifierCategoryContent, topographyLayers[index].modifierLandformCategory);
                                hasLandformCategorySelectionChanged = (topographyLayers[index].modifierLandformCategory.ToString() != previousLandformCategory || isLandformCategoryDropdownRefreshRequired);

                                EditorGUI.BeginChangeCheck();
                                topographyLayers[index].modifierSourceFileType = (LBRaw.SourceFileType)EditorGUILayout.EnumPopup("File Type", topographyLayers[index].modifierSourceFileType);
                                hasLandformFileTypeChanged = EditorGUI.EndChangeCheck();

                                isModifierCategoryCustom = topographyLayers[index].modifierLandformCategory == LBModifierOperations.ModifierLandformCategory.Custom;

                                // Only rebuild the dropdown list of modifier files, if the category has changed OR if there is nothing in the list for this category and type
                                // #SMS 2.1.1 Beta 1i
                                //if (hasLandformCategorySelectionChanged || hasLandformFileTypeChanged || (topographyLayers[index].modifierLandformList == null ? true : (!isModifierCategoryCustom && topographyLayers[index].modifierLandformList.Count < 1 ? true : false)))
                                if (hasLandformCategorySelectionChanged || hasLandformFileTypeChanged || (topographyLayers[index].modifierLandformList == null ? !isModifierCategoryCustom : (topographyLayers[index].modifierLandformList.Count < 1 ? !isModifierCategoryCustom : false)))
                                {
                                    isLandformCategoryDropdownRefreshRequired = false;
                                    if (topographyLayers[index].modifierLandformList == null) { topographyLayers[index].modifierLandformList = new List<string>(); }
                                    else { topographyLayers[index].modifierLandformList.Clear(); }
                                    // Reset to first Landform file in list
                                    modifierLandformFileIndex = 0;

                                    bool isPNG = (topographyLayers[index].modifierSourceFileType == LBRaw.SourceFileType.PNG);

                                    isModifierCategoryLakeOrValley = (previousLandformCategory == LBModifierOperations.ModifierLandformCategory.Lakes.ToString() || previousLandformCategory == LBModifierOperations.ModifierLandformCategory.Valleys.ToString());

                                    switch (topographyLayers[index].modifierLandformCategory)
                                    {
                                        case LBModifierOperations.ModifierLandformCategory.Hills:
                                            topographyLayers[index].modifierLandformList.AddRange(isPNG ? modifierLandformHills : modifierLandformHillsRAW);
                                            topographyLayers[index].modifierAddInvert = false;
                                            if (isModifierCategoryLakeOrValley)
                                            {
                                                RemoveModifierWater(topographyLayers[index]);
                                                topographyLayers[index].modifierUseWater = false;
                                                isSceneSaveRequired = true;
                                            }
                                            break;
                                        case LBModifierOperations.ModifierLandformCategory.Lakes:
                                            topographyLayers[index].modifierLandformList.AddRange(isPNG ? modifierLandformLakes : modifierLandformLakesRAW);
                                            topographyLayers[index].modifierAddInvert = true;
                                            break;
                                        case LBModifierOperations.ModifierLandformCategory.Mesas:
                                            topographyLayers[index].modifierLandformList.AddRange(isPNG ? modifierLandformMesas : modifierLandformMesasRAW);
                                            topographyLayers[index].modifierAddInvert = false;
                                            if (isModifierCategoryLakeOrValley)
                                            {
                                                RemoveModifierWater(topographyLayers[index]);
                                                topographyLayers[index].modifierUseWater = false;
                                                isSceneSaveRequired = true;
                                            }
                                            break;
                                        case LBModifierOperations.ModifierLandformCategory.Mountains:
                                            topographyLayers[index].modifierLandformList.AddRange(isPNG ? modifierLandformMountains : modifierLandformMountainsRAW);
                                            topographyLayers[index].modifierAddInvert = false;
                                            if (isModifierCategoryLakeOrValley)
                                            {
                                                RemoveModifierWater(topographyLayers[index]);
                                                topographyLayers[index].modifierUseWater = false;
                                                isSceneSaveRequired = true;
                                            }
                                            break;
                                        case LBModifierOperations.ModifierLandformCategory.Valleys:
                                            topographyLayers[index].modifierLandformList.AddRange(isPNG ? modifierLandformValleys : modifierLandformValleysRAW);
                                            // The RAW Valleys included come from GeoTIFF files
                                            topographyLayers[index].modifierAddInvert = isPNG;
                                            if (!topographyLayers[index].modifierAddInvert)
                                            {
                                                RemoveModifierWater(topographyLayers[index]);
                                                isSceneSaveRequired = true;
                                            }
                                            break;
                                        case LBModifierOperations.ModifierLandformCategory.Custom:
                                            // When user selects Custom from another type, clear the current RAW data
                                            // Don't just change on a forced dropdown refresh.
                                            if (hasLandformFileTypeChanged || topographyLayers[index].modifierLandformCategory.ToString() != previousLandformCategory)
                                            {
                                                topographyLayers[index].modifierRAWFile = null;
                                                topographyLayers[index].modifierAddInvert = false;
                                                if (isModifierCategoryLakeOrValley)
                                                {
                                                    RemoveModifierWater(topographyLayers[index]);
                                                    topographyLayers[index].modifierUseWater = false;
                                                    isSceneSaveRequired = true;
                                                }
                                            }
                                            break;
                                    }
                                }

                                // Custom category is now used for user-selected RAW/PNG files which are not in the Modifiers folder.
                                if (topographyLayers[index].modifierLandformCategory != LBModifierOperations.ModifierLandformCategory.Custom)
                                {
                                    // Display the list of landforms in the current category
                                    if (topographyLayers[index].modifierLandformList != null && topographyLayers[index].modifierLandformList.Count > 0)
                                    {
                                        // Look up existing LBRaw dataSourceName and try and find it in the list
                                        if (topographyLayers[index].modifierRAWFile != null)
                                        {
                                            // Try to find a match using the stored name in the current modifier list.
                                            string modSourceName = topographyLayers[index].modifierRAWFile.dataSourceName;
                                            if (!string.IsNullOrEmpty(modSourceName) && modSourceName.Length > 4)
                                            {
                                                modifierLandformFileIndex = topographyLayers[index].modifierLandformList.FindIndex(lfm => lfm.ToLower() == modSourceName.Substring(0, modSourceName.Length - 4).ToLower());
                                            }
                                        }

                                        previousLandformFileIndex = modifierLandformFileIndex;
                                        modifierLandformFileIndex = EditorGUILayout.Popup("Landform", modifierLandformFileIndex, topographyLayers[index].modifierLandformList.ToArray());

                                        if (previousLandformFileIndex != modifierLandformFileIndex || hasLandformCategorySelectionChanged || hasLandformFileTypeChanged)
                                        {
                                            hasLandformCategorySelectionChanged = false;
                                            hasLandformFileTypeChanged = false;

                                            // If the previous number in the list was greater than length of the current list, reset it to the first in the list.
                                            if (modifierLandformFileIndex > topographyLayers[index].modifierLandformList.Count - 1 || modifierLandformFileIndex < 0) { modifierLandformFileIndex = 0; }

                                            // Load RAW or PNG file into layer RAW data.
                                            string modifierFilePath = LBModifierOperations.GetModifierFilePath(topographyLayers[index].modifierLandformCategory, topographyLayers[index].modifierLandformList[modifierLandformFileIndex], topographyLayers[index].modifierSourceFileType.ToString());

                                            if (topographyLayers[index].modifierSourceFileType == LBRaw.SourceFileType.RAW)
                                            {
                                                if (LBImport.ImportRAWHeightmapToLayer(landscape, topographyLayers[index], modifierFilePath, false, true, true))
                                                {
                                                    topographyLayers[index].modifierSourceFileType = LBRaw.SourceFileType.RAW;
                                                }

                                                if (topographyLayers[index].showVolumeHighlighter && volumeHighlighter != null)
                                                {
                                                    // Set preview mesh if volume highlighter already exists
                                                    volumeHighlighter.UpdatePreviewMesh(topographyLayers[index].modifierRAWFile);
                                                }
                                            }
                                            else if (topographyLayers[index].modifierSourceFileType == LBRaw.SourceFileType.PNG)
                                            {
                                                // LOAD the PNG data into the RAW format in the layer
                                                if (LBImport.ImportPNGHeightmapToLayer(landscape, topographyLayers[index], modifierFilePath, true, true))
                                                {
                                                    topographyLayers[index].modifierSourceFileType = LBRaw.SourceFileType.PNG;
                                                }

                                                if (topographyLayers[index].showVolumeHighlighter && volumeHighlighter != null)
                                                {
                                                    // Set preview mesh if volume highlighter already exists
                                                    volumeHighlighter.UpdatePreviewMesh(topographyLayers[index].modifierRAWFile);
                                                }
                                            }
                                        }
                                    }
                                    else { EditorGUILayout.Popup("Landform", 0, layerModifierNoneFoundArray); }
                                }

#endregion

                                topographyLayers[index].modifierMode = (LBLayer.LayerModifierMode)EditorGUILayout.EnumPopup(layersModifierModeContent, topographyLayers[index].modifierMode);

#region ImageModifier Selection Area Get Data

                                // Is area highlighter is required
                                volumeHighlighterRequired = (volumeHighlighterRequired || topographyLayers[index].showVolumeHighlighter);

                                GUILayout.BeginHorizontal();
                                if (topographyLayers[index].showVolumeHighlighter)
                                {
                                    if (GUILayout.Button("Disable Picker", buttonCompact, GUILayout.MaxWidth(90f)))
                                    {
                                        topographyLayers[index].showVolumeHighlighter = false;
                                        volumeHighlighterRequired = false;
                                    }
                                }
                                else if (!volumeHighlighterEnabled)
                                {
                                    if (GUILayout.Button("Enable Volume Picker", buttonCompact, GUILayout.MaxWidth(150f)))
                                    {
                                        topographyLayers[index].showVolumeHighlighter = true;
                                        volumeHighlighterRequired = true;
                                        // When the highlighter is first enabled, it may not update or be shown in the scene view.
                                        volumeHighligherJustEnabled = true;
                                    }
                                }
                                GUILayout.EndHorizontal();

                                if (volumeHighlighter != null && topographyLayers[index].showVolumeHighlighter && volumeHighlighter.VolumeRectSet())
                                {
                                    // Remember previous values
                                    layerModifierPrevAreaRect = topographyLayers[index].areaRect;
                                    layerModifierPrevImageHeightScale = topographyLayers[index].imageHeightScale;
                                    layerModifierPrevFloorOffsetY = topographyLayers[index].floorOffsetY;
                                    layerModifierPrevAreaRectRotation = topographyLayers[index].areaRectRotation;

                                    // Get the area rect data
                                    topographyLayers[index].areaRect = volumeHighlighter.GetAreaRect();

                                    // Get all other data
                                    if (terrainHeight > 0f)
                                    {
                                        // Scale will be returned as negative value if it is inverted
                                        if (topographyLayers[index].modifierAddInvert)
                                        {
                                            topographyLayers[index].imageHeightScale = -Mathf.Clamp(volumeHighlighter.GetYScale() / terrainHeight, -1f, 0f);
                                            topographyLayers[index].floorOffsetY = Mathf.Clamp(1f - (volumeHighlighter.GetYOffset() / terrainHeight), -1f, 1f);
                                            topographyLayers[index].additiveAmount = Mathf.Clamp(1f - (volumeHighlighter.GetYOffset() / terrainHeight), 0f, 1f);
                                        }
                                        else
                                        {
                                            topographyLayers[index].imageHeightScale = Mathf.Clamp(volumeHighlighter.GetYScale() / terrainHeight, 0f, 1f);
                                            topographyLayers[index].floorOffsetY = Mathf.Clamp(volumeHighlighter.GetYOffset() / terrainHeight, -1f, 1f);
                                            topographyLayers[index].additiveAmount = Mathf.Clamp(volumeHighlighter.GetYOffset() / terrainHeight, 0f, 1f);
                                        }
                                    }
                                    topographyLayers[index].areaRectRotation = volumeHighlighter.GetYRotation();

                                    if (topographyLayers[index].modifierUseWater)
                                    {
                                        // Has the size of the modifier changed?
                                        if (layerModifierPrevAreaRect.width != topographyLayers[index].areaRect.width ||
                                            layerModifierPrevAreaRect.height != topographyLayers[index].areaRect.height)
                                        {
                                            // Re-create the mesh the correct size with the correct UVs
                                            // Also updates the transform position after the resize.
                                            landscape.ResizeLayerWater(topographyLayers[index], index, terrainHeight, true);
                                        }
                                        // Has the modifier position changed?
                                        else if (layerModifierPrevImageHeightScale != topographyLayers[index].imageHeightScale ||
                                                    layerModifierPrevFloorOffsetY != topographyLayers[index].floorOffsetY ||
                                                    layerModifierPrevAreaRectRotation != topographyLayers[index].areaRectRotation ||
                                                    layerModifierPrevAreaRect.x != topographyLayers[index].areaRect.x ||
                                                    layerModifierPrevAreaRect.y != topographyLayers[index].areaRect.y)
                                        {
                                            // Update the water if required
                                            landscape.UpdateLayerWaterTransform(topographyLayers[index], terrainHeight);
                                        }
                                    }

                                    // When the highlighter is first enabled, it may not update or be shown in the scene view.
                                    if (volumeHighligherJustEnabled) { volumeHighligherJustEnabled = false; SceneView.RepaintAll(); }
#if UNITY_2019_1_OR_NEWER
                                    else if (SceneView.lastActiveSceneView != null && !SceneView.lastActiveSceneView.drawGizmos)
                                    {
                                        EditorGUILayout.HelpBox("Turn on Gizmos to show the Image Modifier picker in the scene view", MessageType.Warning, true);
                                    }
#endif
                                }

#endregion ImageModifier Selection Area Get Data

#region ImageModifier Add/Subtract Mode

                                if (topographyLayers[index].modifierMode == LBLayer.LayerModifierMode.Add)
                                {
                                    // Add/subtract mode

                                    layerModifierAddHeight = topographyLayers[index].imageHeightScale * terrainHeight;

                                    EditorGUI.BeginChangeCheck();
                                    if (topographyLayers[index].modifierAddInvert)
                                    {
                                        layerModifierAddHeight = EditorGUILayout.Slider(layersHeightToSubtractContent, layerModifierAddHeight, 1f, terrainHeight);
                                    }
                                    else
                                    {
                                        layerModifierAddHeight = EditorGUILayout.Slider(layersHeightToAddContent, layerModifierAddHeight, 1f, terrainHeight);
                                    }

                                    if (EditorGUI.EndChangeCheck() && terrainHeight > 0f)
                                    {
                                        topographyLayers[index].imageHeightScale = layerModifierAddHeight / terrainHeight;

                                        // Update the water if required
                                        landscape.UpdateLayerWaterTransform(topographyLayers[index], terrainHeight);
                                        SceneView.RepaintAll();
                                    }

                                    topographyLayers[index].modifierAddInvert = EditorGUILayout.Toggle(layersSubtractNotAddContent, topographyLayers[index].modifierAddInvert);

                                    if (topographyLayers[index].modifierAddInvert)
                                    {
                                        topographyLayers[index].additiveAmount = EditorGUILayout.Slider(layersModifierSubtractiveAmountContent, topographyLayers[index].additiveAmount, 0f, 1f);
                                    }
                                    else
                                    {
                                        topographyLayers[index].additiveAmount = EditorGUILayout.Slider(layersModifierAdditiveAmountContent, topographyLayers[index].additiveAmount, 0f, 1f);
                                    }
                                }
#endregion

#region ImageModifier Set Mode
                                else
                                {
                                    // Set mode

                                    layerModifierAddHeight = topographyLayers[index].imageHeightScale * terrainHeight;

                                    EditorGUI.BeginChangeCheck();

                                    layerModifierAddHeight = EditorGUILayout.Slider(layersModifierSizeYContent, layerModifierAddHeight, 1f, terrainHeight);

                                    if (EditorGUI.EndChangeCheck() && terrainHeight > 0f)
                                    {
                                        topographyLayers[index].imageHeightScale = layerModifierAddHeight / terrainHeight;
                                        SceneView.RepaintAll();
                                    }

                                    EditorGUI.BeginChangeCheck();
                                    topographyLayers[index].modifierAddInvert = EditorGUILayout.Toggle(layersModifierInvertContent, topographyLayers[index].modifierAddInvert);

                                    layerModifierYOffset = topographyLayers[index].floorOffsetY * terrainHeight;
                                    if (topographyLayers[index].modifierAddInvert) { layerModifierYOffset *= -1f; }

                                    //EditorGUI.BeginChangeCheck();

                                    layerModifierYOffset = EditorGUILayout.Slider(layersModifierYOffsetContent, layerModifierYOffset, -terrainHeight, terrainHeight);

                                    if (EditorGUI.EndChangeCheck() && terrainHeight > 0f)
                                    {
                                        topographyLayers[index].floorOffsetY = layerModifierYOffset / terrainHeight;
                                        if (topographyLayers[index].modifierAddInvert) { topographyLayers[index].floorOffsetY *= -1f; }

                                        // Update the water if required
                                        landscape.UpdateLayerWaterTransform(topographyLayers[index], terrainHeight);
                                        SceneView.RepaintAll();
                                        //#if UNITY_EDITOR_OSX
                                        //LBEditorHelper.RefreshSceneView();
                                        //#endif
                                    }
                                }
#endregion

#region ImageModifier Selection Area Set Data Pt. 1

                                // Unlike in additive layers, the position is measured from the centre of the rect not from the corner
                                EditorGUILayout.BeginHorizontal();
                                EditorGUILayout.LabelField(layersModifierAreaRectContent, GUILayout.Width(EditorGUIUtility.labelWidth));
                                EditorGUI.BeginChangeCheck();
                                layerModifierPrevAreaRect = topographyLayers[index].areaRect;
                                topographyLayers[index].areaRect = EditorGUILayout.RectField(topographyLayers[index].areaRect);
                                // Did the user change the Area Rect control (in-scene mesh changes with volume picker are handled elsewhere)
                                if (EditorGUI.EndChangeCheck())
                                {
                                    // If the location has changed, update the water transform location if required.
                                    if (topographyLayers[index].modifierUseWater)
                                    {
                                        // Has the size of the modifier changed?
                                        if (layerModifierPrevAreaRect.width != topographyLayers[index].areaRect.width || layerModifierPrevAreaRect.height != topographyLayers[index].areaRect.height)
                                        {
                                            // Re-create the mesh the correct size with the correct UVs
                                            // Also updates the transform position after the resize.
                                            landscape.ResizeLayerWater(topographyLayers[index], index, terrainHeight, true);
                                        }
                                        else if (layerModifierPrevAreaRect.x != topographyLayers[index].areaRect.x || layerModifierPrevAreaRect.y != topographyLayers[index].areaRect.y)
                                        {
                                            // Update the water if required
                                            landscape.UpdateLayerWaterTransform(topographyLayers[index], terrainHeight);
                                        }
#if UNITY_EDITOR_OSX
                                        LBEditorHelper.RefreshSceneView();
#endif
                                    }
                                }
                                EditorGUILayout.EndHorizontal();

                                // Clamp possible area rect positions
                                layerModifierMinPos = new Vector3(-0.5f * topographyLayers[index].areaRect.width, -terrainHeight, -0.5f * topographyLayers[index].areaRect.height);
                                layerModifierMaxPos = new Vector3(landscape.size.x + (0.5f * topographyLayers[index].areaRect.width), terrainHeight, landscape.size.y + (0.5f * topographyLayers[index].areaRect.height));
                                topographyLayers[index].areaRect.x = Mathf.Clamp(topographyLayers[index].areaRect.x, -0.5f * topographyLayers[index].areaRect.width, landscape.size.x + (0.5f * topographyLayers[index].areaRect.width));
                                topographyLayers[index].areaRect.y = Mathf.Clamp(topographyLayers[index].areaRect.y, -0.5f * topographyLayers[index].areaRect.height, landscape.size.y + (0.5f * topographyLayers[index].areaRect.height));
                                // Get rotation of the area rect
                                EditorGUI.BeginChangeCheck();
                                topographyLayers[index].areaRectRotation = EditorGUILayout.Slider(layersModifierAreaRectRotationContent, topographyLayers[index].areaRectRotation, 0f, 360f);
                                if (EditorGUI.EndChangeCheck())
                                {
                                    // Update the water if required
                                    landscape.UpdateLayerWaterTransform(topographyLayers[index], terrainHeight);
#if UNITY_EDITOR_OSX
                                    LBEditorHelper.RefreshSceneView();
#endif
                                }

                                topographyLayers[index].modifierUseBlending = EditorGUILayout.Toggle(layersModifierUseBlendingContent, topographyLayers[index].modifierUseBlending);

#endregion

#region ImageModifier Water

                                // Currently only available for Lakes and Valleys WITH Invert enabled. Could potentially add "Custom" too
                                if (topographyLayers[index].modifierAddInvert && 
                                    (topographyLayers[index].modifierLandformCategory == LBModifierOperations.ModifierLandformCategory.Lakes ||
                                    topographyLayers[index].modifierLandformCategory == LBModifierOperations.ModifierLandformCategory.Valleys))
                                {
                                    EditorGUI.BeginChangeCheck();
                                    topographyLayers[index].modifierUseWater = EditorGUILayout.Toggle(layersModifiersUseWaterContent, topographyLayers[index].modifierUseWater);
                                    if (EditorGUI.EndChangeCheck())
                                    {
                                        if (topographyLayers[index].modifierUseWater)
                                        {
                                            topographyLayers[index].modifierLBWater = new LBWater();

                                            if (LBMeshOperations.CreateMeshForWaterFromLayer(landscape, topographyLayers[index], index, "Layer Water " + topographyLayers[index].modifierLBWater.GUID, true))
                                            {
                                                topographyLayers[index].modifierLBWater.waterLevel = -2f;
                                            }
                                        }
                                        else { RemoveModifierWater(topographyLayers[index]); }
                                        isSceneSaveRequired = true;
                                    }

                                    if (topographyLayers[index].modifierUseWater && topographyLayers[index].modifierLBWater != null)
                                    {
                                        // Has the user changed the water level with the slider?
                                        EditorGUI.BeginChangeCheck();
                                        topographyLayers[index].modifierLBWater.waterLevel = EditorGUILayout.Slider(layersModifiersWaterLevelContent, topographyLayers[index].modifierLBWater.waterLevel, -500f, 0f);
                                        if (EditorGUI.EndChangeCheck())
                                        {
                                            landscape.UpdateLayerWaterTransform(topographyLayers[index], terrainHeight);
                                        }

                                        EditorGUI.BeginChangeCheck();

                                        topographyLayers[index].modifierWaterIsMeshLandscapeUV = EditorGUILayout.Toggle(layersModifiersWaterMeshLandscapeUVContent, topographyLayers[index].modifierWaterIsMeshLandscapeUV);

                                        EditorGUILayout.BeginHorizontal();
                                        EditorGUILayout.LabelField(layersModifiersWaterMeshUVTilingContent, GUILayout.Width(EditorGUIUtility.labelWidth));
                                        EditorGUILayout.LabelField("X", GUILayout.Width(15f));
                                        // AQUAS shader expects a mesh 50 times smaller than a standard quad. Upsize the UVs in the inspector to look like 1x1 rather than 0.02x0.02
                                        if (topographyLayers[index].modifierLBWater.meshResizingMode == LBWater.WaterMeshResizingMode.AQUAS)
                                        {
                                            topographyLayers[index].modifierWaterMeshUVTileScale.x = EditorGUILayout.FloatField(topographyLayers[index].modifierWaterMeshUVTileScale.x * 50f, GUILayout.Width(60f)) / 50f;
                                            EditorGUILayout.LabelField("Z", GUILayout.Width(15f));
                                            topographyLayers[index].modifierWaterMeshUVTileScale.y = EditorGUILayout.FloatField(topographyLayers[index].modifierWaterMeshUVTileScale.y * 50f, GUILayout.Width(60f)) / 50f;
                                        }
                                        else
                                        {
                                            topographyLayers[index].modifierWaterMeshUVTileScale.x = EditorGUILayout.FloatField(topographyLayers[index].modifierWaterMeshUVTileScale.x, GUILayout.Width(60f));
                                            EditorGUILayout.LabelField("Z", GUILayout.Width(15f));
                                            topographyLayers[index].modifierWaterMeshUVTileScale.y = EditorGUILayout.FloatField(topographyLayers[index].modifierWaterMeshUVTileScale.y, GUILayout.Width(60f));
                                        }

                                        EditorGUILayout.EndHorizontal();
                                        if (EditorGUI.EndChangeCheck())
                                        {
                                            landscape.ResizeLayerWater(topographyLayers[index], index, terrainHeight, true);
                                        }

                                        EditorGUI.BeginChangeCheck();

                                        LBWater.WaterMeshResizingMode previousWaterMeshResizingMode = topographyLayers[index].modifierLBWater.meshResizingMode;

                                        topographyLayers[index].modifierLBWater.meshResizingMode = (LBWater.WaterMeshResizingMode)EditorGUILayout.EnumPopup(layersModifiersWaterResizingModeContent, topographyLayers[index].modifierLBWater.meshResizingMode);

                                        // If AQUAS get the camera which will have the AQUAS script attached to it.
                                        if (topographyLayers[index].modifierLBWater.meshResizingMode == LBWater.WaterMeshResizingMode.AQUAS)
                                        {
                                            topographyLayers[index].modifierWaterMainCamera = (Camera)EditorGUILayout.ObjectField(commonMainCameraContent, topographyLayers[index].modifierWaterMainCamera, typeof(Camera), true);
                                            if (topographyLayers[index].modifierWaterMainCamera == null) { topographyLayers[index].modifierWaterMainCamera = Camera.main; }

                                            // Preload the AQUAS river material
                                            if (topographyLayers[index].modifierLBWater.waterMaterial == null)
                                            {
                                                topographyLayers[index].modifierLBWater.waterMaterial = (Material)AssetDatabase.LoadAssetAtPath("Assets/AQUAS/Materials/Water/Desktop&Web/River.mat", typeof(Material));
                                            }
                                        }

                                        if (EditorGUI.EndChangeCheck())
                                        {
                                            // If changing Resizing mode, remove the previous mesh material
                                            if (previousWaterMeshResizingMode != topographyLayers[index].modifierLBWater.meshResizingMode)
                                            {
                                                topographyLayers[index].modifierLBWater.waterMaterial = null;

                                                if (topographyLayers[index].modifierLBWater.meshResizingMode == LBWater.WaterMeshResizingMode.Custom)
                                                {
                                                    topographyLayers[index].modifierWaterMeshUVTileScale = Vector2.one;
                                                    topographyLayers[index].modifierWaterIsMeshLandscapeUV = false;
                                                }
                                                else if (topographyLayers[index].modifierLBWater.meshResizingMode == LBWater.WaterMeshResizingMode.AQUAS)
                                                {
                                                    topographyLayers[index].modifierWaterMeshUVTileScale = Vector2.one * 0.02f;
                                                    topographyLayers[index].modifierWaterIsMeshLandscapeUV = false;
                                                }
                                                else if (topographyLayers[index].modifierLBWater.meshResizingMode == LBWater.WaterMeshResizingMode.StandardAssets)
                                                {
                                                    // Show user where they can find the water assets
                                                    LBEditorHelper.HighlightItemInProjectWindow("Assets/LandscapeBuilder/Standard Assets/Environment/Water", false);
                                                }
                                                else if (topographyLayers[index].modifierLBWater.meshResizingMode == LBWater.WaterMeshResizingMode.CalmWater)
                                                {
                                                    // Defaults
                                                    topographyLayers[index].modifierWaterMeshUVTileScale = Vector2.one;
                                                    topographyLayers[index].modifierWaterIsMeshLandscapeUV = false;

                                                    if (LBIntegration.IsCalmWaterInstalled(true))
                                                    {
                                                        // Show user where they can find the water materials
                                                        LBEditorHelper.HighlightItemInProjectWindow("Assets/Calm Water/Demo/Materials", false);
                                                    }
                                                }
                                                else if (topographyLayers[index].modifierLBWater.meshResizingMode == LBWater.WaterMeshResizingMode.RiverAutoMaterial)
                                                {
                                                    // Defaults
                                                    topographyLayers[index].modifierWaterMeshUVTileScale = Vector2.one * 0.5f;
                                                    topographyLayers[index].modifierWaterIsMeshLandscapeUV = false;

                                                    if (LBIntegration.IsRiverAutoMaterialInstalled(true))
                                                    {
                                                        // Show user where they can find the water materials
                                                        LBEditorHelper.HighlightItemInProjectWindow("Assets/River Auto Material/River/Materials", false);
                                                    }
                                                }
                                            }

                                            isSceneSaveRequired = true;
                                        }

                                        topographyLayers[index].modifierLBWater.waterMaterial = (Material)EditorGUILayout.ObjectField(layersModifiersWaterMeshMaterialContent, topographyLayers[index].modifierLBWater.waterMaterial, typeof(Material), true);
                                    }
                                    else { if (topographyLayers[index].modifierLBWater != null) { topographyLayers[index].modifierLBWater.waterLevel = 0f; } }
                                }

#endregion

                                #region ImageModifier Reset to Factory

                                // Reset to factory defaults
                                if (GUILayout.Button(layersModifiersResetContent, GUILayout.Width(60f)))
                                {
                                    GUI.FocusControl("");
                                    topographyLayers[index].SetDefaultImageModifierValues(landscape.size);
                                    landscape.ResizeLayerWater(topographyLayers[index], index, terrainHeight, true);
                                }

                                #endregion

                                #region ImageModifier Selection Area Set Data Pt. 2

                                if (volumeHighlighter != null && topographyLayers[index].showVolumeHighlighter)
                                {
                                    // Calculate volume preview height and y-scale data
                                    if (topographyLayers[index].modifierMode == LBLayer.LayerModifierMode.Add)
                                    {
                                        layerModifierVolumeYPos = topographyLayers[index].additiveAmount * terrainHeight;
                                    }
                                    else
                                    {
                                        layerModifierVolumeYPos = topographyLayers[index].floorOffsetY * terrainHeight;
                                    }
                                    layerModifierVolumeYScale = topographyLayers[index].imageHeightScale * terrainHeight;
                                    if (topographyLayers[index].modifierAddInvert)
                                    {
                                        // Invert y position and scale of volume preview if invert is checked
                                        layerModifierVolumeYPos = terrainHeight - layerModifierVolumeYPos;
                                        layerModifierVolumeYScale = -layerModifierVolumeYScale;
                                        layerModifierMinPos.y += terrainHeight;
                                        layerModifierMaxPos.y += terrainHeight;
                                    }
                                    // Set volume preview data
                                    volumeHighlighter.SetVolume(topographyLayers[index].areaRect, layerModifierVolumeYPos,
                                                                layerModifierVolumeYScale, topographyLayers[index].areaRectRotation,
                                                                landscape.transform.position);

                                    // Set volume preview limits
                                    if (topographyLayers[index].modifierAddInvert)
                                    {
                                        volumeHighlighter.SetLimits(true, layerModifierMinPos + landscape.transform.position,
                                                                    layerModifierMaxPos + landscape.transform.position,
                                                                    true, new Vector3(1f, -terrainHeight, 1f),
                                                                    new Vector3(Mathf.Infinity, -1f, Mathf.Infinity));
                                    }
                                    else
                                    {
                                        volumeHighlighter.SetLimits(true, layerModifierMinPos + landscape.transform.position,
                                                                    layerModifierMaxPos + landscape.transform.position,
                                                                    true, new Vector3(1f, 1f, 1f),
                                                                    new Vector3(Mathf.Infinity, terrainHeight, Mathf.Infinity));
                                    }

                                    if (!volumeHighlighter.VolumePreviewMeshSet())
                                    {
                                        // Set preview mesh if it is not already set
                                        volumeHighlighter.UpdatePreviewMesh(topographyLayers[index].modifierRAWFile);
                                    }
                                }

                                #endregion
                            }

                            if (topographyLayers[index].type != LBLayer.LayerType.ImageModifier)
                            {
                                // Disable area and volume highlighter when layer is not image modifier type
                                //topographyLayers[index].showVolumeHighlighter = false;
                            }

                                #endregion

                            #region Layer Filters

                            EditorGUILayout.Space();

                            // Show/hide foldout for filters
                            // Don't need to show a foldout here as it has already been shown above
                            // Only show layer filters if this is a detail layer, or perlin additive/subtractive layer
                            if (topographyLayers[index].showCurvesAndFilters && (topographyLayers[index].type == LBLayer.LayerType.PerlinDetail ||
                                topographyLayers[index].type == LBLayer.LayerType.ImageDetail || topographyLayers[index].type == LBLayer.LayerType.PerlinAdditive ||
                                topographyLayers[index].type == LBLayer.LayerType.PerlinSubtractive))
                            {
                                // Layer Filters - Availiable in both perlin noise and image modes

                                // Create the list if it doesn't already exist
                                if (topographyLayers[index].filters == null) { topographyLayers[index].filters = new List<LBLayerFilter>(); }

                                arrayInt = topographyLayers[index].filters.Count;
                                GUILayout.BeginHorizontal();
                                EditorGUILayout.LabelField(new GUIContent("<b>Layer Filters</b>", "Filters to control the strength of this layer"), labelFieldRichText);
                                if (GUILayout.Button("+")) { arrayInt++; }
                                if (GUILayout.Button("-")) { if (arrayInt > 0) { if (LBEditorHelper.PromptForDelete("Layer Filter", "", arrayInt - 1, false)) { arrayInt--; } } }
                                if (arrayInt < 0) { arrayInt = 0; }
                                GUILayout.EndHorizontal();
                                // Add items to the list
                                if (arrayInt > topographyLayers[index].filters.Count)
                                {
                                    LBEditorHelper.CheckFolder(LBMap.GetDefaultMapFolder);
                                    LBEditorHelper.HighlightItemInProjectWindow(LBMap.GetDefaultMapFolder, false);
                                    temp = arrayInt - topographyLayers[index].filters.Count;
                                    for (index2 = 0; index2 < temp; index2++)
                                    {
                                        LBLayerFilter newLayerFilter = new LBLayerFilter();
                                        if (topographyLayers[index].type == LBLayer.LayerType.PerlinAdditive)
                                        {
                                            // Default to a Stencil Layer in LB 2.1.3
                                            newLayerFilter.type = LBLayerFilter.LayerFilterType.StencilLayer;
                                            topographyLayers[index].additiveAmount = 1f;
                                        }
                                        else if (topographyLayers[index].type == LBLayer.LayerType.PerlinSubtractive)
                                        {
                                            // Default to a Stencil Layer in LB 2.1.3
                                            newLayerFilter.type = LBLayerFilter.LayerFilterType.StencilLayer;
                                            topographyLayers[index].subtractiveAmount = 1f;
                                        }
                                        topographyLayers[index].filters.Add(newLayerFilter);
                                    }
                                }
                                // Remove items from the list
                                else if (arrayInt < topographyLayers[index].filters.Count)
                                {
                                    temp = topographyLayers[index].filters.Count - arrayInt;
                                    for (index2 = 0; index2 < temp; index2++)
                                    {
                                        topographyLayers[index].filters.RemoveAt(topographyLayers[index].filters.Count - 1);
                                    }
                                }

                                if (landscape.useGPUTopography)
                                {
                                    List<LBLayerFilter> mapLayerFilters = topographyLayers[index].filters.FindAll(f => f.type == LBLayerFilter.LayerFilterType.Map);
                                    if (mapLayerFilters != null && mapLayerFilters.Count > 1)
                                    {
                                        EditorGUILayout.HelpBox("More than one Layer Map filter is not supported when GPU acceleration is enabled.", MessageType.Warning);
                                    }
                                }

                                for (index2 = 0; index2 < topographyLayers[index].filters.Count; index2++)
                                {
                                    // Show the elements of the list
                                    lbLayerFilter = topographyLayers[index].filters[index2];

                                    // Currently Perlin Additive or Subtractive layers only support Map and Stencil Layer filters
                                    if (topographyLayers[index].type == LBLayer.LayerType.PerlinAdditive || topographyLayers[index].type == LBLayer.LayerType.PerlinSubtractive)
                                    {
                                        // Display a subset of the LayerFilterTypes 
                                        EditorGUI.BeginChangeCheck();
                                        LBLayerFilter.LayerFilterTypeForAddSubLayers layerFilterTypeForAddSubLayers = (LBLayerFilter.LayerFilterTypeForAddSubLayers)EditorGUILayout.EnumPopup("Filter " + (index2 + 1) + " type", (LBLayerFilter.LayerFilterTypeForAddSubLayers)lbLayerFilter.type);
                                        if (EditorGUI.EndChangeCheck())
                                        {
                                            lbLayerFilter.type = (LBLayerFilter.LayerFilterType)layerFilterTypeForAddSubLayers;
                                        }
                                    }
                                    else
                                    {
                                        lbLayerFilter.type = (LBLayerFilter.LayerFilterType)EditorGUILayout.EnumPopup("Filter " + (index2 + 1) + " type", lbLayerFilter.type);
                                    }

                                    if (lbLayerFilter.type == LBLayerFilter.LayerFilterType.Height)
                                    {
                                        lbLayerFilter.minHeight = EditorGUILayout.Slider(new GUIContent("Min Height", "Minimum height in metres that the layer output will appear at"),
                                                                                            lbLayerFilter.minHeight * terrainHeight, 0f, terrainHeight) / terrainHeight;
                                        lbLayerFilter.maxHeight = EditorGUILayout.Slider(new GUIContent("Max Height", "Maximum height in metres that the layer output will appear at"),
                                                                                            lbLayerFilter.maxHeight * terrainHeight, 0f, terrainHeight) / terrainHeight;
                                        if (lbLayerFilter.maxHeight < topographyLayers[index].filters[index2].minHeight)
                                        {
                                            lbLayerFilter.maxHeight = lbLayerFilter.minHeight;
                                        }
                                        lbLayerFilter.heightCurve = EditorGUILayout.CurveField(new GUIContent("Height Curve", "The curve defining what the strength of the detail layer will be at differing heights of your landscape"), lbLayerFilter.heightCurve, GUILayout.Height(30f));
                                    }
                                    else if (lbLayerFilter.type == LBLayerFilter.LayerFilterType.Inclination)
                                    {
                                        lbLayerFilter.minInclination = EditorGUILayout.Slider(new GUIContent("Min Inclination", "Minimum inclination in degrees that the layer output will appear at"),
                                                                                                lbLayerFilter.minInclination, 0f, 90f);
                                        lbLayerFilter.maxInclination = EditorGUILayout.Slider(new GUIContent("Max Inclination", "Maximum inclination in degrees that the layer output will appear at"),
                                                                                                lbLayerFilter.maxInclination, 0f, 90f);
                                        if (lbLayerFilter.maxInclination < topographyLayers[index].filters[index2].minInclination)
                                        {
                                            lbLayerFilter.maxInclination = lbLayerFilter.minInclination;
                                        }
                                        lbLayerFilter.inclinationCurve = EditorGUILayout.CurveField(new GUIContent("Inclination Curve", "The curve defining what the strength of the detail layer will be at differing inclinations of your landscape"), lbLayerFilter.inclinationCurve, GUILayout.Height(30f));
                                    }
                                    else if (lbLayerFilter.type == LBLayerFilter.LayerFilterType.Map)
                                    {
                                        // If using a Map filter, ensure the Texture2D is readable
                                        EditorGUI.BeginChangeCheck();
                                        lbLayerFilter.map = (Texture2D)EditorGUILayout.ObjectField("Map" + GetTextureName(lbLayerFilter.map), lbLayerFilter.map, typeof(Texture2D), false);
                                        if (EditorGUI.EndChangeCheck())
                                        {
                                            if (lbLayerFilter.map != null) { LBTextureOperations.EnableReadable(lbLayerFilter.map, true, true); isSceneSaveRequired = true; }
                                        }
                                        if (landscape.useGPUTopography)
                                        {
                                            // Compute Shader assumes map is smoothed greyscale
                                            lbLayerFilter.mapInverse = EditorGUILayout.Toggle(layerFilterMapInverseContent, lbLayerFilter.mapInverse);
                                        }
                                        else
                                        {
                                            // Colour is currently only required for maps created from EasyRoads3D roads
                                            // Maps from LB Map Path should always be white.
                                            lbLayerFilter.mapColour = EditorGUILayout.ColorField(layerFilterMapColourContent, lbLayerFilter.mapColour);
                                            lbLayerFilter.mapInverse = EditorGUILayout.Toggle(layerFilterMapInverseContent, lbLayerFilter.mapInverse);
                                            lbLayerFilter.smoothRate = EditorGUILayout.Slider(layerFilterMapSmoothRateContent, lbLayerFilter.smoothRate, 0f, 1f);
                                        }
                                    }
                                    else if (lbLayerFilter.type == LBLayerFilter.LayerFilterType.StencilLayer)
                                    {
                                        // If there is a Stencil selected, populate the temporary class instance
                                        if (lbLayerFilter.lbStencilGUID != null && lbLayerFilter.lbStencil == null)
                                        {
                                            lbLayerFilter.lbStencil = LBStencil.GetStencilInLandscape(landscape, lbLayerFilter.lbStencilGUID, true);
                                        }

                                        EditorGUI.BeginChangeCheck();
                                        lbLayerFilter.lbStencil = (LBStencil)EditorGUILayout.ObjectField(layerFilterStencilContent, lbLayerFilter.lbStencil, typeof(LBStencil), true);
                                        if (EditorGUI.EndChangeCheck())
                                        {
                                            // Did the user select "None" from the popup list
                                            if (lbLayerFilter.lbStencil == null)
                                            {
                                                lbLayerFilter.lbStencilGUID = string.Empty;
                                                lbLayerFilter.lbStencilLayerGUID = string.Empty;
                                            }
                                            else
                                            {
                                                lbLayerFilter.lbStencilGUID = lbLayerFilter.lbStencil.GUID;
                                                lbLayerFilter.lbStencilLayerGUID = string.Empty;
                                                // When user selects a different stencil, default to the first stencil layer
                                                if (lbLayerFilter.lbStencil.stencilLayerList != null)
                                                {
                                                    if (lbLayerFilter.lbStencil.stencilLayerList.Count > 0)
                                                    {
                                                        lbLayerFilter.lbStencilLayerGUID = lbLayerFilter.lbStencil.stencilLayerList[0].GUID;
                                                    }
                                                }
                                            }
                                        }

                                        // Get list of LBStencilLayers for the current LBStencil
                                        if (lbLayerFilter.lbStencil != null)
                                        {
                                            // Get a list of the Layer Names and their GUIDs
                                            List<string> layerFilterStencilLayerGUIDList = new List<string>();
                                            List<string> layerFilterStencilLayerNameList = new List<string>();
                                            int layerFilterStencilLayerIndex = 0;

                                            if (lbLayerFilter.lbStencil.stencilLayerList != null)
                                            {
                                                foreach (LBStencilLayer lbStencilLayer in lbLayerFilter.lbStencil.stencilLayerList)
                                                {
                                                    if (!string.IsNullOrEmpty(lbStencilLayer.GUID))
                                                    {
                                                        layerFilterStencilLayerGUIDList.Add(lbStencilLayer.GUID);
                                                        layerFilterStencilLayerNameList.Add(lbStencilLayer.LayerName);
                                                    }
                                                }

                                                // Find the stencil layer that was last selected in the layer filter
                                                layerFilterStencilLayerIndex = layerFilterStencilLayerGUIDList.FindIndex(sl => sl == lbLayerFilter.lbStencilLayerGUID);
                                            }

                                            // Display the list of Stencil Layers for the selected Stencil.
                                            EditorGUI.BeginChangeCheck();
                                            layerFilterStencilLayerIndex = EditorGUILayout.Popup("Stencil Layer", layerFilterStencilLayerIndex, layerFilterStencilLayerNameList.ToArray());

                                            if (EditorGUI.EndChangeCheck() && layerFilterStencilLayerGUIDList.Count > layerFilterStencilLayerIndex && layerFilterStencilLayerIndex >= 0)
                                            {
                                                // Update the stencil layer for this layer filter
                                                lbLayerFilter.lbStencilLayerGUID = layerFilterStencilLayerGUIDList[layerFilterStencilLayerIndex];
                                            }
                                        }
                                    }
                                    EditorGUILayout.Space();
                                }
                            }
                            #endregion
                        }
                        else
                        {
                            // Disable area and volume highlighter when layer is hidden
                            topographyLayers[index].showAreaHighlighter = false;
                            topographyLayers[index].showVolumeHighlighter = false;
                        }
                        GUILayout.EndVertical();
                    }

                    EditorGUILayout.Space();

                    #region Remove, Insert or Move a Layer
                    // More than one layer "could" be removed in same frame but very unlikely so just use the last one
                    if (layerToRemove != null)
                    {
                        int layerPos = topographyLayers.FindIndex(tx => tx == layerToRemove);
                        if (LBEditorHelper.PromptForDelete("Layer", layerToRemove.type.ToString(), layerPos, false))
                        {
                            // Turn off mesh volume highlighter to avoid ArgumentException: Getting control 0's position in a group
                            if (layerToRemove.showVolumeHighlighter && volumeHighlighter != null)
                            {
                                DestroyImmediate(volumeHighlighter.gameObject);
                                volumeHighlighterRequired = false;
                                volumeHighlighterEnabled = false;
                                layerToRemove.showVolumeHighlighter = false;
                            }

                            // Remove any water attached to this layer, before deleting the layer
                            RemoveModifierWater(layerToRemove);
                            topographyLayers.Remove(layerToRemove);
                            if (layerToRemove != null) { layerToRemove = null; }
                        }
                    }
                    // Does the user wish to insert a new (duplicate) layer into the list?
                    else if (insertLayerPos >= 0)
                    {
                        if (topographyLayers[insertLayerPos].type == LBLayer.LayerType.UnityTerrains)
                        {
                            insertLayerPos = -1;
                            labelText = "Multiple Unity Terrains Layers are not supported in the same landscape.\n\nNOTE: A Unity Terrains Layer can hold data from multiple equal-sized terrains within a landscape.\n";
                            Debug.LogWarning(labelText);
                            EditorUtility.DisplayDialog("Insert Duplicate Layer", labelText, "Ok");
                        }
                        else
                        {
                            // Insert a duplicate above the selected layer
                            LBLayer insertedLayer = new LBLayer(topographyLayers[insertLayerPos]);

                            if (insertedLayer != null)
                            {
                                if (insertedLayer.modifierLBWater != null)
                                {
                                    // Assign a unique GUID
                                    insertedLayer.modifierLBWater.GUID = System.Guid.NewGuid().ToString();
                                    insertedLayer.modifierWaterTransform = null;
                                    if (insertedLayer.modifierUseWater)
                                    {
                                        // Re-create the mesh, giving it a new title to match the new LBWater GUID
                                        if (LBMeshOperations.CreateMeshForWaterFromLayer(landscape, insertedLayer, insertLayerPos, "Layer Water " + insertedLayer.modifierLBWater.GUID, true))
                                        {

                                        }
                                    }
                                    else { RemoveModifierWater(insertedLayer); }
                                }

                                topographyLayers.Insert(insertLayerPos, insertedLayer);
                                // Show the new duplicate, and hide the original
                                insertedLayer.showLayer = true;

                                topographyLayers[insertLayerPos + 1].showLayer = false;
                                isSceneSaveRequired = true;
                            }
                        }
                    }
                    // Does the user wish to move a Layer downward in the list (or move from last position to top)?
                    else if (moveLayerPos >= 0 && layerToMove != null)
                    {
                        // Attempt to move this Layer down one in the list
                        if (topographyLayers.Count > 1)
                        {
                            if (topographyLayers[moveLayerPos].type == LBLayer.LayerType.UnityTerrains)
                            {
                                labelText = "A Unity Terrains Topography Layer must always be at the top of the list.";
                                if (moveLayerPos == 0)
                                {
                                    Debug.LogWarning(labelText);
                                    EditorUtility.DisplayDialog("Move Layer Down", labelText, "Ok");
                                }
                                else
                                {
                                    topographyLayers.RemoveAt(moveLayerPos);
                                    // Move it to the top
                                    topographyLayers.Insert(0, layerToMove);
                                }
                            }
                            // If this is the last in the list we want to put it at the top
                            else if (moveLayerPos == topographyLayers.Count - 1)
                            {
                                if (topographyLayers[0].type == LBLayer.LayerType.UnityTerrains)
                                {
                                    // If only 2 in the list, then we can't move to top
                                    if (topographyLayers.Count > 2)
                                    {
                                        // Insert below Unity Terrains Topography Layer
                                        topographyLayers.Insert(1, layerToMove);
                                        topographyLayers.RemoveAt(topographyLayers.Count - 1);
                                    }
                                }
                                else
                                {
                                    topographyLayers.Insert(0, layerToMove);
                                    topographyLayers.RemoveAt(topographyLayers.Count - 1);
                                }
                            }
                            else
                            {
                                // Move down one in the list
                                topographyLayers.RemoveAt(moveLayerPos);
                                topographyLayers.Insert(moveLayerPos + 1, layerToMove);
                            }
                            isSceneSaveRequired = true;
                        }
                        layerToMove = null;
                    }
                    #endregion

                    #region Area highlight controls
                    if (areaHighlighterRequired && areaHighlighter == null)
                    {
                        areaHighlighter = GameObject.FindObjectOfType<LBAreaHighlight>();
                        if (areaHighlighter == null)
                        {
                            areaHighlighter = LBAreaHighlight.CreateAreaHighLighter();
                            // Set to enabled so that we know when we need to repaint the editor in OnInspectorUpdate()
                            areaHighlighterEnabled = true;
                        }
                    }
                    else if (!areaHighlighterRequired && areaHighlighter != null)
                    {
                        DestroyImmediate(areaHighlighter.gameObject);
                        areaHighlighterEnabled = false;
                    }
                    #endregion

                    #region Volume highlight controls
                    if (volumeHighlighterRequired && volumeHighlighter == null)
                    {
                        volumeHighlighter = GameObject.FindObjectOfType<LBVolumeHighlight>();
                        if (volumeHighlighter == null)
                        {
                            volumeHighlighter = LBVolumeHighlight.CreateVolumeHighLighter();
                            // Set to enabled so that we know when we need to repaint the editor in OnInspectorUpdate()
                            volumeHighlighterEnabled = true;
                        }
                    }
                    else if (!volumeHighlighterRequired && volumeHighlighter != null)
                    {
                        DestroyImmediate(volumeHighlighter.gameObject);
                        volumeHighlighterEnabled = false;
                    }
                    #endregion

                    #endregion

                    EditorGUILayout.EndScrollView();

                    #region Final Pass

                    finalPassSelectedTabInt = GUILayout.Toolbar(finalPassSelectedTabInt, finalPassTabTexts);

                    #region Final Pass - Masking
                    if (finalPassSelectedTabInt == 0)
                    {
                        // Masking

                        EditorGUILayout.TextArea("<b>Topography Masking</b>\n\nTopography Masking allows you to 'mask out' the topography of your landscape" +
                                            " from the output of a mathematical function or an image.", helpBoxRichText);

                        landscape.topographyMaskMode = (LBLandscape.MaskMode)EditorGUILayout.EnumPopup("Mask Mode", landscape.topographyMaskMode);

                        if (landscape.topographyMaskMode == LBLandscape.MaskMode.DistanceToCentre)
                        {
                            landscape.distanceToCentreMask = EditorGUILayout.CurveField(layersDistanceToCentreMaskContent, landscape.distanceToCentreMask, GUILayout.Height(30f));
                            landscape.maskWarpAmount = EditorGUILayout.Slider(layersMaskWarpAmountContent, landscape.maskWarpAmount, 0f, 5f);
                        }
                        else if (landscape.topographyMaskMode == LBLandscape.MaskMode.Noise)
                        {
                            landscape.maskNoiseTileSize = EditorGUILayout.FloatField(layersMaskNoiseTileSizeContent, landscape.maskNoiseTileSize);
                            landscape.maskNoiseOffsetX = EditorGUILayout.Slider(layersMaskNoiseOffsetXContent, landscape.maskNoiseOffsetX, landscapeSize.x * -2f, landscapeSize.x * 2f);
                            landscape.maskNoiseOffsetY = EditorGUILayout.Slider(layersMaskNoiseOffsetZContent, landscape.maskNoiseOffsetY, landscapeSize.y * -2f, landscapeSize.y * 2f);
                            landscape.maskWarpAmount = EditorGUILayout.Slider(layersMaskWarpAmountContent, landscape.maskWarpAmount, 0f, 5f);
                            landscape.maskNoiseCurveModifier = EditorGUILayout.CurveField(layersMaskNoiseCurveModifierContent, landscape.maskNoiseCurveModifier, GUILayout.Height(30f));
                        }

                        EditorGUILayout.BeginHorizontal();
                        // Reset to factory defaults
                        if (GUILayout.Button("Reset", GUILayout.MaxWidth(60f)))
                        {
                            landscape.distanceToCentreMask = GetDefaultMaskDistanceToCentreMask;
                            landscape.maskWarpAmount = GetDefaultMaskWarpAmount;
                            landscape.maskNoiseTileSize = GetDefaultMaskNoiseTileSize;
                            landscape.maskNoiseOffsetX = GetDefaultMaskNoiseOffsetX;
                            landscape.maskNoiseOffsetY = GetDefaultMaskNoiseOffsetY;
                            landscape.maskNoiseCurveModifier = GetDefaultMaskNoiseCurveModifier;
                        }

                        // Option to script output of the curves to the Console Window.
                        // This is helpful when writing Runtime scripts
                        if (landscape.topographyMaskMode == LBLandscape.MaskMode.DistanceToCentre)
                        {
                            if (GUILayout.Button("Script Curve", GUILayout.MaxWidth(100f))) { Debug.Log(LBCurve.ScriptCurve(landscape.distanceToCentreMask, "\n", "distanceToCentreMask")); }
                        }
                        else if (landscape.topographyMaskMode == LBLandscape.MaskMode.Noise)
                        {
                            if (GUILayout.Button("Script Curve", GUILayout.MaxWidth(100f))) { Debug.Log(LBCurve.ScriptCurve(landscape.maskNoiseCurveModifier, "\n", "noiseMask")); }
                        }
                        EditorGUILayout.EndHorizontal();
                    }
                    #endregion

                    #region Final Pass - Erosion
                    else if (finalPassSelectedTabInt == 1)
                    {
                        // Erosion

                        EditorGUILayout.TextArea("<b>Thermal Erosion</b>\n\nThermal erosion simulates the erosion of topography due to changes in temperature " +
                                            " causing material to break up and fall down steep slopes.", helpBoxRichText);

                        landscape.useThermalErosion = EditorGUILayout.Toggle(useThermalErosionContent, landscape.useThermalErosion);
                        if (landscape.useThermalErosion)
                        {
                            // Presets
                            LBLandscape.ThermalErosionPreset newThermalErosionPreset = (LBLandscape.ThermalErosionPreset)EditorGUILayout.EnumPopup("Preset", landscape.thermalErosionPreset);
                            if (newThermalErosionPreset != landscape.thermalErosionPreset)
                            {
                                landscape.thermalErosionPreset = newThermalErosionPreset;
                                landscape.SetThermalErosionSettingsFromPreset(landscape.thermalErosionPreset);
                            }

                            landscape.thermalErosionIterations = EditorGUILayout.IntSlider(thermalErosionIterationsContent, landscape.thermalErosionIterations, 25, 250);
                            landscape.thermalErosionTalusAngle = EditorGUILayout.Slider(thermalErosionTalusAngleContent, landscape.thermalErosionTalusAngle, 0f, 75f);
                            landscape.thermalErosionStrength = EditorGUILayout.Slider(thermalErosionStrengthContent, landscape.thermalErosionStrength, 0.01f, 1f);

                            #region Final Pass Thermal Erosion Stencil
                            // If there is a Stencil selected, populate the temporary class instance
                            if (landscape.fPassThErosionStencilGUID != null && landscape.fPassThErosionlbStencil == null)
                            {
                                landscape.fPassThErosionlbStencil = LBStencil.GetStencilInLandscape(landscape, landscape.fPassThErosionStencilGUID, true);
                            }

                            GUILayout.BeginHorizontal();
                            GUILayout.Label(finalPassThErosionStencilContent, GUILayout.Width(75f));
                            landscape.fPassThErosionFilterMode = (LBFilter.FilterMode)EditorGUILayout.EnumPopup((LBFilter.FilterModeAndNot)landscape.fPassThErosionFilterMode, GUILayout.MaxWidth(65f));
                            EditorGUI.BeginChangeCheck();
                            landscape.fPassThErosionlbStencil = (LBStencil)EditorGUILayout.ObjectField(landscape.fPassThErosionlbStencil, typeof(LBStencil), true);
                            if (EditorGUI.EndChangeCheck())
                            {
                                // Did the user select "None" from the popup list
                                if (landscape.fPassThErosionlbStencil == null)
                                {
                                    landscape.fPassThErosionStencilGUID = string.Empty;
                                    landscape.fPassThErosionStencilLayerGUID = string.Empty;
                                    landscape.fPassThErosionFilterMode = LBFilter.FilterMode.AND;
                                }
                                else
                                {
                                    landscape.fPassThErosionStencilGUID = landscape.fPassThErosionlbStencil.GUID;
                                    landscape.fPassThErosionStencilLayerGUID = string.Empty;
                                    // When user selects a different stencil, default to the first stencil layer
                                    if (landscape.fPassThErosionlbStencil.stencilLayerList != null)
                                    {
                                        if (landscape.fPassThErosionlbStencil.stencilLayerList.Count > 0)
                                        {
                                            landscape.fPassThErosionStencilLayerGUID = landscape.fPassThErosionlbStencil.stencilLayerList[0].GUID;
                                        }
                                    }
                                }
                            }
                            GUILayout.EndHorizontal();

                            // Get list of LBStencilLayers for the current LBStencil
                            if (landscape.fPassThErosionlbStencil != null)
                            {
                                // Get a list of the Layer Names and their GUIDs
                                List<string> fpThErosioningStencilLayerGUIDList = new List<string>();
                                List<string> fpThErosioningStencilLayerNameList = new List<string>();
                                int fpThErosioningStencilLayerIndex = 0;

                                if (landscape.fPassThErosionlbStencil.stencilLayerList != null)
                                {
                                    foreach (LBStencilLayer lbStencilLayer in landscape.fPassThErosionlbStencil.stencilLayerList)
                                    {
                                        if (!string.IsNullOrEmpty(lbStencilLayer.GUID))
                                        {
                                            fpThErosioningStencilLayerGUIDList.Add(lbStencilLayer.GUID);
                                            fpThErosioningStencilLayerNameList.Add(lbStencilLayer.LayerName);
                                        }
                                    }

                                    // Find the stencil layer that was last selected for ThErosioning
                                    fpThErosioningStencilLayerIndex = fpThErosioningStencilLayerGUIDList.FindIndex(sl => sl == landscape.fPassThErosionStencilLayerGUID);
                                }

                                // Display the list of Stencil Layers for the selected Stencil.
                                EditorGUI.BeginChangeCheck();
                                fpThErosioningStencilLayerIndex = EditorGUILayout.Popup("Stencil Layer", fpThErosioningStencilLayerIndex, fpThErosioningStencilLayerNameList.ToArray());

                                if (EditorGUI.EndChangeCheck() && fpThErosioningStencilLayerGUIDList.Count > fpThErosioningStencilLayerIndex && fpThErosioningStencilLayerIndex >= 0)
                                {
                                    // Update the stencil layer for final pass smoothing
                                    landscape.fPassThErosionStencilLayerGUID = fpThErosioningStencilLayerGUIDList[fpThErosioningStencilLayerIndex];
                                }
                            }

                            #endregion
                        }

                        //useHydraulicErosion = EditorGUILayout.Toggle("Hydraulic Erosion", useHydraulicErosion);
                        if (useHydraulicErosion)
                        {
                            hydraulicErosionIterations = EditorGUILayout.IntSlider("Iterations", hydraulicErosionIterations, 1, 1000);
                            hydraulicErosionRainfall = EditorGUILayout.Slider("Rainfall", hydraulicErosionRainfall, 0f, 1000f);
                            hydraulicErosionEvaporation = EditorGUILayout.Slider("Evaporation", hydraulicErosionEvaporation, 0f, 1f);
                            hydraulicErosionCarryingCapacity = EditorGUILayout.Slider("Carrying Capacity", hydraulicErosionCarryingCapacity, 0f, 1000f);
                            hydraulicErosionStrength = EditorGUILayout.Slider("Strength", hydraulicErosionStrength, 0f, 1f);
                            debugFinalPassWaterLevel = EditorGUILayout.Toggle("Debug Water Level", debugFinalPassWaterLevel);
                        }
                    }
                    #endregion

                    #region Final Pass - Smoothing
                    else
                    {
                        // Smoothing
                        EditorGUILayout.TextArea("<b>Smoothing</b>\n\nSmoothing can be used to smooth out bumps and jagged edges in your topography.", helpBoxRichText);

                        landscape.useFinalPassSmoothing = EditorGUILayout.Toggle(useFinalPassSmoothingContent, landscape.useFinalPassSmoothing);
                        if (landscape.useFinalPassSmoothing)
                        {
                            landscape.finalPassSmoothingIterations = EditorGUILayout.IntSlider(finalPassSmoothingIterationsContent, landscape.finalPassSmoothingIterations, 1, 25);
                            landscape.finalPassPixelRange = EditorGUILayout.IntSlider(finalPassSmoothingPixelRangeContent, landscape.finalPassPixelRange, 1, 5);

                            #region Final Pass Smoothing Stencil
                            // If there is a Stencil selected, populate the temporary class instance
                            if (landscape.fPassSmoothStencilGUID != null && landscape.fPassSmoothlbStencil == null)
                            {
                                landscape.fPassSmoothlbStencil = LBStencil.GetStencilInLandscape(landscape, landscape.fPassSmoothStencilGUID, true);
                            }

                            GUILayout.BeginHorizontal();
                            GUILayout.Label(finalPassSmoothingStencilContent, GUILayout.Width(75f));
                            landscape.fPassSmoothFilterMode = (LBFilter.FilterMode)EditorGUILayout.EnumPopup((LBFilter.FilterModeAndNot)landscape.fPassSmoothFilterMode, GUILayout.MaxWidth(65f));
                            EditorGUI.BeginChangeCheck();
                            landscape.fPassSmoothlbStencil = (LBStencil)EditorGUILayout.ObjectField(landscape.fPassSmoothlbStencil, typeof(LBStencil), true);
                            if (EditorGUI.EndChangeCheck())
                            {
                                // Did the user select "None" from the popup list
                                if (landscape.fPassSmoothlbStencil == null)
                                {
                                    landscape.fPassSmoothStencilGUID = string.Empty;
                                    landscape.fPassSmoothStencilLayerGUID = string.Empty;
                                    landscape.fPassSmoothFilterMode = LBFilter.FilterMode.AND;
                                }
                                else
                                {
                                    landscape.fPassSmoothStencilGUID = landscape.fPassSmoothlbStencil.GUID;
                                    landscape.fPassSmoothStencilLayerGUID = string.Empty;
                                    // When user selects a different stencil, default to the first stencil layer
                                    if (landscape.fPassSmoothlbStencil.stencilLayerList != null)
                                    {
                                        if (landscape.fPassSmoothlbStencil.stencilLayerList.Count > 0)
                                        {
                                            landscape.fPassSmoothStencilLayerGUID = landscape.fPassSmoothlbStencil.stencilLayerList[0].GUID;
                                        }
                                    }
                                }
                            }
                            GUILayout.EndHorizontal();

                            // Get list of LBStencilLayers for the current LBStencil
                            if (landscape.fPassSmoothlbStencil != null)
                            {
                                // Get a list of the Layer Names and their GUIDs
                                List<string> fpSmoothingStencilLayerGUIDList = new List<string>();
                                List<string> fpSmoothingStencilLayerNameList = new List<string>();
                                int fpSmoothingStencilLayerIndex = 0;

                                if (landscape.fPassSmoothlbStencil.stencilLayerList != null)
                                {
                                    foreach (LBStencilLayer lbStencilLayer in landscape.fPassSmoothlbStencil.stencilLayerList)
                                    {
                                        if (!string.IsNullOrEmpty(lbStencilLayer.GUID))
                                        {
                                            fpSmoothingStencilLayerGUIDList.Add(lbStencilLayer.GUID);
                                            fpSmoothingStencilLayerNameList.Add(lbStencilLayer.LayerName);
                                        }
                                    }

                                    // Find the stencil layer that was last selected for Smoothing
                                    fpSmoothingStencilLayerIndex = fpSmoothingStencilLayerGUIDList.FindIndex(sl => sl == landscape.fPassSmoothStencilLayerGUID);
                                }

                                // Display the list of Stencil Layers for the selected Stencil.
                                EditorGUI.BeginChangeCheck();
                                fpSmoothingStencilLayerIndex = EditorGUILayout.Popup("Stencil Layer", fpSmoothingStencilLayerIndex, fpSmoothingStencilLayerNameList.ToArray());

                                if (EditorGUI.EndChangeCheck() && fpSmoothingStencilLayerGUIDList.Count > fpSmoothingStencilLayerIndex && fpSmoothingStencilLayerIndex >= 0)
                                {
                                    // Update the stencil layer for final pass smoothing
                                    landscape.fPassSmoothStencilLayerGUID = fpSmoothingStencilLayerGUIDList[fpSmoothingStencilLayerIndex];
                                }
                            }

                            #endregion
                        }
                    }
                    #endregion

                    #endregion

                    #region Designer Open warning and apply/undo heightmaps
                    // Do not permit height generation from the Topography tab, when a Group Object Path is being edited
                    if (!IsObjPathDesignerOpen(true))
                    {
                        if (GUILayout.Button("Generate Heightmap"))
                        {
                            GenerateTopography();
                            landscape.ApplyLayerWater(false, true);
                            isSceneSaveRequired = true;
                        }

                        if (landscape.isUndoTopographyDisabled)
                        {
                            EditorGUILayout.HelpBox("Override Undo Topography is enabled. NO UNDO.", MessageType.Warning, true);
                        }
                        else if (GUILayout.Button("Undo Heightmap Modification"))
                        {
                            UndoHeightmap();
                        }
                    }
                    #endregion
                }
                else
                {
                    EditorGUILayout.HelpBox("No landscape to modify - you can add or find one in the landscape tab.", MessageType.Info, true);
                }
                #endregion
            }
            else if (selectedTabInt == 2)
            {
                #region Group tab

                if (landscapeGameObject != null && landscape != null)
                {
                    if (lbGroupList == null) { lbGroupList = new List<LBGroup>(); }

                    DrawGroupsHeaderTex();

                    // No groups to insert/move/remove/delete at the start of the loop
                    groupToRemove = null;
                    insertGroupPos = -1;
                    groupToMove = null;
                    moveGroupPos = -1;

                    #region Group-level buttons
                    arrayInt = lbGroupList.Count;
                    GUILayout.BeginHorizontal();

                    // A Foldout with no label must have a style fixedWidth of low non-zero value, and have a small (global) fieldWidth.
                    EditorGUIUtility.fieldWidth = 15f;
                    EditorGUI.BeginChangeCheck();
                    isGroupListExpanded = EditorGUILayout.Foldout(isGroupListExpanded, "", foldoutStyleNoLabel);
                    EditorGUIUtility.fieldWidth = defaultEditorFieldWidth;
                    if (EditorGUI.EndChangeCheck()) { LBGroup.GroupListExpand(lbGroupList, isGroupListExpanded); }

                    if (GUILayout.Button("Add Group")) { arrayInt++; }
                    if (GUILayout.Button("Remove Group")) { if (arrayInt > 0) { groupToRemove = lbGroupList[arrayInt - 1]; } }
                    if (GUILayout.Button(groupsTutorialsURLContent, buttonCompact)) { Application.OpenURL(urlTutorials); }
                    if (GUILayout.Button(groupsImportContent, buttonCompact))
                    {
                        if (ImportGroup())
                        {
                            // If a new Group was imported, update list and mark scene as changed
                            arrayInt = lbGroupList.Count;
                            isSceneSaveRequired = true;
                        }
                    }
                    if (arrayInt < 0) { arrayInt = 0; }
                    GUILayout.EndHorizontal();
                    scrollPosition = EditorGUILayout.BeginScrollView(scrollPosition);
                    // Add items to the list
                    if (arrayInt > lbGroupList.Count)
                    {
                        temp = arrayInt - lbGroupList.Count;
                        for (index = 0; index < temp; index++)
                        {
                            // Create a new group with a single group member
                            lbGroup = new LBGroup();
                            if (lbGroup != null)
                            {
                                lbGroupMember = new LBGroupMember();
                                if (lbGroupMember != null) { lbGroup.groupMemberList.Add(lbGroupMember); }
                                lbGroupList.Add(lbGroup);
                            }
                        }
                        RefreshSubGroupLists();
                    }
                    #endregion

                    // Check to see if any of the groups have the designer enabled (should only be 1 at a time)
                    // Check outside lbGroupList iterations so it is only checked once per editor frame refresh
                    isGroupDesignerEnabled = lbGroupList.Exists(grp => grp.showGroupDesigner == true);

                    // Check to see if any of the groups have Show (Manaul) Group placement enabled (should only be 1 at a time)
                    isShowGroupsInScene = lbGroupList.Exists(grp => grp.showGroupsInScene == true);

                    // Are there any Object Path Designers open? (There should only ever be 0 or 1 open)
                    isObjPathDesignerEnabled = lbGroupList.Exists(grp => grp.groupMemberList.Exists(m => m.showObjPathDesigner == true));

                    // Are they any non-updated Groups that don't have a GUID. These are used with SubGroups which were introduced in LB 2.1.5
                    isGroupGUIDMissing = lbGroupList.Exists(grp => string.IsNullOrEmpty(grp.GUID));

                    for (index = 0; index < lbGroupList.Count; index++)
                    {
                        lbGroup = lbGroupList[index];

                        #region Group-level settings

                        // Start of a Group
                        currentBgndColor = GUI.backgroundColor;
                        GUI.backgroundColor = GUI.backgroundColor * (EditorGUIUtility.isProSkin ? 0.7f : 1.3f);
                        GUILayout.BeginVertical(EditorStyles.helpBox);
                        GUI.backgroundColor = currentBgndColor;

                        #region Group-Level Buttons
                        GUILayout.BeginHorizontal();

                        EditorGUI.BeginChangeCheck();
                        lbGroup.isDisabled = !EditorGUILayout.Toggle(!lbGroup.isDisabled, GUILayout.Width(20f));
                        if (EditorGUI.EndChangeCheck()) { RefreshSubGroupLists(); }

                        if (lbGroup.showInEditor) { labelText = "<color=" + txtColourName + "><b>Group " + (index + 1) + "</b></color>"; }
                        else { labelText = "<color=" + txtColourName + "><b>Group " + (index + 1) + "</b> - " + lbGroup.groupName + "</color>"; }
                        EditorGUILayout.LabelField(labelText, labelFieldRichText);

                        if (GUILayout.Button(groupsScriptContent, buttonCompact, GUILayout.MaxWidth(20f))) { Debug.Log(lbGroup.ScriptGroup(index, "\n")); }

                        // MOVE or INSERT group
                        if (GUILayout.Button(groupsMoveGroupDownButtonContent, buttonCompact, GUILayout.Width(20f)))
                        {
                            groupToMove = new LBGroup(lbGroup);
                            moveGroupPos = index;
                        }
                        if (GUILayout.Button(groupsInsertGroupButtonContent, buttonCompact, GUILayout.Width(20f))) { insertGroupPos = index; }

                        if (lbGroup.showInEditor) { if (GUILayout.Button("Hide", buttonCompact, GUILayout.Width(40f))) { GUI.FocusControl(null); lbGroup.showInEditor = false; } }
                        else { if (GUILayout.Button("Show", buttonCompact, GUILayout.Width(40f))) { GUI.FocusControl(null); lbGroup.showInEditor = true; } }
                        if (GUILayout.Button("X", buttonCompact, GUILayout.MaxWidth(20f))) { groupToRemove = lbGroup; }
                        GUILayout.EndHorizontal();
                        #endregion

                        if (lbGroup.showInEditor)
                        {
                            #region Group-Level properties

                            #region Group-Level name and type
                            EditorGUI.BeginChangeCheck();
                            lbGroup.groupName = EditorGUILayout.TextField(groupsNameContent, lbGroup.groupName);
                            if (EditorGUI.EndChangeCheck())
                            {
                                // It is probably faster to change this for all group types than check the group type on each keystroke
                                // We check for changes in OnInspectorUpdate(). However, we don't do it every frame, instead we wait
                                // for x seconds to have passed since the last change.
                                isSubGroupNameListRefreshRequired = true;
                                subGroupNameListLastRefreshed = Time.realtimeSinceStartup;
                            }

                            prevGroupType = lbGroup.lbGroupType;
                            EditorGUI.BeginChangeCheck();
                            lbGroup.lbGroupType = (LBGroup.LBGroupType)EditorGUILayout.EnumPopup(groupsTypeContent, lbGroup.lbGroupType);
                            if (EditorGUI.EndChangeCheck() && lbGroup.groupMemberList != null)
                            {
                                // If the manual groups are being shown, clean them up and turn them off
                                if (lbGroup.showGroupsInScene)
                                {
                                    lbGroup.showGroupsInScene = false;
                                }

                                bool isObjPathsInGroup = lbGroup.groupMemberList.Exists(mbr => mbr.lbMemberType == LBGroupMember.LBMemberType.ObjPath);
                                string blockTitle = "Change Group Type Blocked";
                                string blockMsg = "The group contains one or more Object Path Members. These do not support changing the group type between Uniform and Clearings/SubGroups";

                                if (lbGroup.lbGroupType == LBGroup.LBGroupType.Uniform)
                                {
                                    if (lbGroup.showGroupDesigner && isGroupDesignerEnabled)
                                    {
                                        EditorUtility.DisplayDialog(blockTitle, "Please close the Group Designer before changing to a Uniform Group", "Got it!");
                                        lbGroup.lbGroupType = prevGroupType;
                                    }
                                    else if (isObjPathsInGroup)
                                    {
                                        EditorUtility.DisplayDialog(blockTitle, blockMsg, "OK");
                                        lbGroup.lbGroupType = prevGroupType;
                                    }
                                    else
                                    {
                                        bool isContinueToChangeGroupType = true;
                                        if (lbGroup.groupMemberList.Exists(mbr => mbr.isPlacedInCentre && mbr.prefab != null))
                                        {
                                            isContinueToChangeGroupType = LBEditorHelper.PromptForContinue("Change to Uniform Type", "This will modify existing members and settings for use with Uniform Groups. There is no UNDO.\n\n Are you sure?");
                                        }

                                        if (isContinueToChangeGroupType)
                                        {
                                            // Turnoff Placed In Centre, and set rotationtype at the group member level.
                                            for (lbGroupMemberIdx = 0; lbGroupMemberIdx < lbGroup.groupMemberList.Count; lbGroupMemberIdx++)
                                            {
                                                lbGroupMember = lbGroup.groupMemberList[lbGroupMemberIdx];
                                                if (lbGroupMember != null)
                                                {
                                                    lbGroupMember.isPlacedInCentre = false;
                                                    lbGroupMember.rotationType = LBGroupMember.LBRotationType.WorldSpace;
                                                }
                                            }

                                            lbGroup.isRemoveExistingGrass = false;
                                            lbGroup.isRemoveExistingTrees = false;
                                            RefreshSubGroupLists();
                                        }
                                        // Rollback the change
                                        else { lbGroup.lbGroupType = prevGroupType; }
                                    }
                                }
                                else
                                {
                                    // Switching to a clearing group or SubGroup
                                    if (isObjPathsInGroup && prevGroupType == LBGroup.LBGroupType.Uniform)
                                    {
                                        EditorUtility.DisplayDialog(blockTitle, blockMsg, "OK");
                                        lbGroup.lbGroupType = prevGroupType;
                                    }
                                    else
                                    {
                                        lbGroup.isRemoveExistingGrass = true;
                                        lbGroup.isRemoveExistingTrees = true;
                                        RefreshSubGroupLists();
                                    }
                                }
                            }

                            if (lbGroup.lbGroupType == LBGroup.LBGroupType.SubGroup)
                            {
                                EditorGUILayout.HelpBox("The SubGroup feature is currently in technical preview", MessageType.Warning);

                                if (isGroupGUIDMissing)
                                {
                                    EditorGUILayout.HelpBox("The version of this landsape needs to be updated", MessageType.Warning);
                                    if (GUILayout.Button("Fix Now"))
                                    {
                                        if (LBUpdate.LandscapeUpdate(landscape.LastUpdatedVersion, LBVersion, ref landscape, false)) { isSceneSaveRequired = true; }
                                    }
                                }
                            }
                            #endregion

                            #region Group Designers
                            isGroupDesignerInitialised = false;

                            if (lbGroup.lbGroupType == LBGroup.LBGroupType.ProceduralClearing || lbGroup.lbGroupType == LBGroup.LBGroupType.ManualClearing || lbGroup.lbGroupType == LBGroup.LBGroupType.SubGroup)
                            {
                                EditorGUILayout.BeginHorizontal();
                                if (lbGroup.showGroupDesigner)
                                {
                                    if (GUILayout.Button(groupsDesignerDisableButtonContent, GUILayout.MaxWidth(defaultEditorLabelWidth - 4f)))
                                    {
                                        // Check if the ObjPathDesigner is open in this group
                                        if (lbObjPathDesigner != null && lbObjPathDesigner.lbGroupMember != null && lbObjPathDesigner.isInitialised)
                                        {
                                            LBGroupMember lbGroupMemberEditing = lbGroup.groupMemberList.Find(gm => gm.GUID == lbObjPathDesigner.lbGroupMember.GUID);

                                            // Is there a member being edited in this group by the ObjPath Designer?
                                            if (lbGroupMemberEditing != null)
                                            {
                                                // Close the Object Path Designer
                                                LBObjPathDesigner.ShowDesigner(landscape, ref lbObjPathDesigner, lbGroup, lbGroupMemberEditing, lbGroupDesigner, false);
                                                lbGroupMemberEditing = null;
                                            }
                                        }

                                        // Close the GroupDesigner
                                        lbGroup.showGroupDesigner = false;
                                        LBGroupDesigner.ShowGroupDesigner(landscape, ref lbGroupDesigner, lbGroup, false);
                                        // Remove any designer ObjPath prefabs from the scene
                                        LBLandscapeTerrain.RemoveExistingPrefabs(landscape, true, LBPrefabItem.PrefabItemType.ObjPathDesignerPrefab, null);
                                        // Save the scene when the designer is closed by the user
                                        isSceneSaveRequired = true;
                                    }
                                    else if (lbGroupDesigner != null)
                                    {
                                        isGroupDesignerInitialised = lbGroupDesigner.isInitialised;
                                    }
                                    // Refresh all the group members in the GroupDesigner
                                    if (GUILayout.Button(groupsDesignerRefreshButtonContent, GUILayout.MaxWidth(60f)))
                                    {
                                        if (isGroupDesignerInitialised) { lbGroupDesigner.RefreshWorkspace(true); }
                                    }
                                }
                                else if (!isGroupDesignerEnabled)
                                {
                                    if (GUILayout.Button(groupsDesignerEnableButtonContent, GUILayout.MaxWidth(defaultEditorLabelWidth - 4f)))
                                    {
                                        // Editing Disabled Groups can cause issues in the Group Designer with subgroups.
                                        if (lbGroup.isDisabled)
                                        {
                                            EditorUtility.DisplayDialog("Open Group Designer", "You need to enable a Group before you can edit it in the Group Designer.", "Got it!");
                                        }
                                        else
                                        {
                                            // Check if the ObjPathDesigner is another in this group
                                            if (isObjPathDesignerEnabled && lbObjPathDesigner != null && lbObjPathDesigner.lbGroupMember != null && lbObjPathDesigner.isInitialised)
                                            {
                                                // Get the group which has the ObjPathDesigner open
                                                LBGroup lbGroupEditing = lbGroupList.Find(grp => grp.groupMemberList.Exists(m => m.showObjPathDesigner == true));
                                                if (lbGroupEditing != null)
                                                {
                                                    // Get the member of the other group which has the ObjPathDesigner open
                                                    LBGroupMember lbGroupMemberEditing = lbGroupEditing.groupMemberList.Find(gm => gm.GUID == lbObjPathDesigner.lbGroupMember.GUID);
                                                    if (lbGroupMemberEditing != null)
                                                    {
                                                        //Debug.Log("[DEBUG] Closing ObjPathDesigner in Group: " + lbGroupEditing.groupName);

                                                        // Close the Object Path Designer
                                                        LBObjPathDesigner.ShowDesigner(landscape, ref lbObjPathDesigner, lbGroupEditing, lbGroupMemberEditing, lbGroupDesigner, false);

                                                        LBLandscapeTerrain.RemoveExistingPrefabs(landscape, true, LBPrefabItem.PrefabItemType.ObjPathDesignerPrefab, lbGroupMemberEditing.GUID);

                                                        // Restore the heightmap to how it was before entering ObjPath Editor mode
                                                        if (landscape.useGPUPath && lbGroupMemberEditing.lbObjPath.useWidth && lbGroupEditing.lbGroupType == LBGroup.LBGroupType.Uniform)
                                                        {
                                                            EditorUtility.DisplayProgressBar("Restoring heightmap", "PLEASE WAIT", 0.1f);
                                                            landscape.RevertHeightmap1D("RP_" + lbGroupMemberEditing.GUID, true, true);

                                                            if (LBGroup.IsApplyObjPathTexturesPresent(lbGroupList, lbGroupEditing, lbGroupMemberEditing.lbObjPath))
                                                            //if (!string.IsNullOrEmpty(lbGroupMemberEditing.lbObjPath.coreTextureGUID) || !string.IsNullOrEmpty(lbGroupMemberEditing.lbObjPath.surroundTextureGUID))
                                                            {
                                                                EditorUtility.DisplayProgressBar("Restoring splatmaps", "PLEASE WAIT", 0.15f);
                                                                landscape.RevertTextures1D("RP_" + lbGroupMemberEditing.GUID, true);
                                                            }

                                                            if (lbGroupMemberEditing.lbObjPath.isRemoveExistingTrees)
                                                            {
                                                                EditorUtility.DisplayProgressBar("Restoring Unity terrain trees", "PLEASE WAIT", 0.2f);
                                                                landscape.RevertTrees1D("RP_" + lbGroupMemberEditing.GUID, true);
                                                            }

                                                            EditorUtility.ClearProgressBar();
                                                        }

                                                        lbGroupMemberEditing = null;
                                                        lbGroupEditing = null;
                                                    }
                                                }
                                            }

                                            // If this is a manual clearing and the positions are being edited, save them and close
                                            // before opening the Group Designer
                                            if (lbGroup.showGroupsInScene && lbGroup.lbGroupType == LBGroup.LBGroupType.ManualClearing)
                                            {
                                                LBGroupLocationItem.RemoveLocationsFromScene(landscape, true);
                                                lbGroup.showGroupsInScene = false;
                                                lbGroupShowLocations = null;
                                                landscape.LockTerrains(false);
                                                isSceneDirtyRequired = true;
                                            }
                                            LBGroup.GroupListExpand(lbGroupList, false);
                                            lbGroup.showInEditor = true;
                                            lbGroup.showGroupDesigner = LBGroupDesigner.ShowGroupDesigner(landscape, ref lbGroupDesigner, lbGroup, true);
                                        }
                                    }
                                }

                                if (lbGroup.lbGroupType == LBGroup.LBGroupType.ManualClearing)
                                {
                                    if (lbGroup.showGroupsInScene)
                                    {
                                        if (GUILayout.Button(groupsManualClearingPosDisableButtonContent))
                                        {
                                            LBGroupLocationItem.RemoveLocationsFromScene(landscape, true);
                                            lbGroup.showGroupsInScene = false;
                                            lbGroupShowLocations = null;
                                            landscape.LockTerrains(false);
                                            isSceneDirtyRequired = true;
                                        }
                                    }
                                    else if (!isShowGroupsInScene)
                                    {
                                        if (GUILayout.Button(groupsManualClearingPosEnableButtonContent))
                                        {
                                            if (isGroupDesignerEnabled) { EditorUtility.DisplayDialog("Manual Clearings", "To edit the clearing locations, first close the Group Designer", "Got it!"); }
                                            else
                                            {
                                                if (lbGroup.positionList == null) { lbGroup.positionList = new List<Vector3>(); }
                                                lbGroup.showGroupsInScene = true;
                                                lbGroupShowLocations = lbGroup;
                                                landscape.LockTerrains(true);
                                                LBGroupLocationItem.RefreshLocationsInScene(landscape, lbGroup, manualClearingGroupMaterial, true);
                                                isSceneDirtyRequired = true;
                                            }
                                        }
                                    }
                                }

                                EditorGUILayout.EndHorizontal();
                            }
                            #endregion

                            #region Get a list of the current zones to populate a dropdown list
                            List<string> zoneNameList = new List<string>();
                            if (lbGroup.zoneList != null)
                            {
                                for (int zoneIdx = 0; zoneIdx < lbGroup.zoneList.Count; zoneIdx++)
                                {
                                    zoneNameList.Add(lbGroup.zoneList[zoneIdx].zoneName);
                                }
                            }
                            #endregion

                            #region Group Options
                            EditorGUILayout.BeginHorizontal();
                            // A Foldout with no label must have a style fixedWidth of low non-zero value, and have a small (global) fieldWidth.
                            EditorGUIUtility.fieldWidth = 15f;
                            lbGroup.showGroupOptionsInEditor = EditorGUILayout.Foldout(lbGroup.showGroupOptionsInEditor, groupsShowDetailsButtonContent, foldoutStyleNoLabel);
                            EditorGUIUtility.fieldWidth = defaultEditorFieldWidth;

                            lbGroup.showtabInEditor = GUILayout.Toolbar(lbGroup.showtabInEditor, groupsDesignerToolbarContent);
                            EditorGUILayout.EndHorizontal();
                            EditorGUILayout.Separator();

                            if (lbGroup.showGroupOptionsInEditor)
                            {
                                #region General Options
                                if (lbGroup.showtabInEditor == 0)
                                {
                                    if (lbGroup.lbGroupType == LBGroup.LBGroupType.ProceduralClearing)
                                    {
                                        // For Uniform groups, items per sq km are only set at the member-level
                                        lbGroup.maxGroupSqrKm = (int)LBEditorHelper.LogarithmicSlider(groupsMaxGroupsSqKmContent, defaultEditorLabelWidth, lbGroup.maxGroupSqrKm, 1f, lbGroup.MaxGroupLimit, true, 10);

                                        #region Group Proximity

                                        lbGroup.proximityExtent = LBEditorHelper.LogarithmicSlider(groupsProximityExtentContent, defaultEditorLabelWidth, lbGroup.proximityExtent, 0.01f, 10000f, false, 10);

                                        #endregion
                                    }
                                    else if (lbGroup.lbGroupType == LBGroup.LBGroupType.ManualClearing)
                                    {
                                        EditorGUILayout.BeginHorizontal();
                                        EditorGUILayout.LabelField("Clearings in Scene", GUILayout.Width(defaultEditorLabelWidth));
                                        EditorGUILayout.LabelField((lbGroup.positionList == null ? 0 : lbGroup.positionList.Count).ToString());
                                        EditorGUILayout.EndHorizontal();
                                    }

                                    if (lbGroup.lbGroupType == LBGroup.LBGroupType.ProceduralClearing || lbGroup.lbGroupType == LBGroup.LBGroupType.ManualClearing || lbGroup.lbGroupType == LBGroup.LBGroupType.SubGroup)
                                    {
                                        // Radius x 2 = the circular size of the clearing
                                        float previousMaxScale = lbGroup.maxClearingRadius;
                                        EditorGUI.BeginChangeCheck();
                                        lbGroup.minClearingRadius = EditorGUILayout.Slider(groupsMinClearingRadiusContent, lbGroup.minClearingRadius, 0.01f, 1000f);
                                        lbGroup.maxClearingRadius = EditorGUILayout.Slider(groupsMaxClearingRadiusContent, lbGroup.maxClearingRadius, 0.01f, 1000f);
                                        if (lbGroup.maxClearingRadius < lbGroup.minClearingRadius) { lbGroup.maxClearingRadius = lbGroup.minClearingRadius; }
                                        if (EditorGUI.EndChangeCheck())
                                        {
                                            lbGroup.ResizeGroup(previousMaxScale);

                                            if (lbGroup.showGroupsInScene && lbGroup.lbGroupType == LBGroup.LBGroupType.ManualClearing)
                                            {
                                                LBGroupLocationItem.RefreshLocationSizesInScene(landscape, lbGroup, true);
                                            }
                                        }

                                        #region Manual Clearing Fixed Rotation
                                        // Manual clearings can optionally have fixed rotations for each location in the scene.
                                        if (lbGroup.lbGroupType == LBGroup.LBGroupType.ManualClearing)
                                        {
                                            EditorGUI.BeginChangeCheck();
                                            lbGroup.isFixedRotation = EditorGUILayout.Toggle(groupsIsFixedRotationContent, lbGroup.isFixedRotation);
                                            if (EditorGUI.EndChangeCheck())
                                            {
                                                if (lbGroup.isFixedRotation) { lbGroup.SyncRotationList(); }
                                                isSceneSaveRequired = true;
                                            }

                                            if (lbGroup.isFixedRotation && lbGroup.showGroupsInScene)
                                            {
                                                EditorGUILayout.BeginHorizontal();
                                                EditorGUILayout.LabelField(groupsFixedRotationYContent, GUILayout.Width(defaultEditorLabelWidth));

                                                GameObject selectedGO = Selection.activeGameObject;
                                                if (selectedGO != null)
                                                {
                                                    LBGroupLocationItem lbGroupLocationItem = selectedGO.GetComponent<LBGroupLocationItem>();
                                                    if (lbGroupLocationItem != null)
                                                    {
                                                        EditorGUI.BeginChangeCheck();
                                                        lbGroupLocationItem.rotationY = EditorGUILayout.Slider(lbGroupLocationItem.rotationY, -359.9f, 359.9f);
                                                        if (EditorGUI.EndChangeCheck())
                                                        {
                                                            lbGroupLocationItem.position = lbGroupLocationItem.transform.position - landscape.start;

                                                            // Locate the first matching clearing position
                                                            // Only check x,z axis as the y-axis may be slightly wrong
                                                            int locIdx = lbGroup.positionList.FindIndex(pos => pos.x == lbGroupLocationItem.position.x && pos.z == lbGroupLocationItem.position.z);
                                                            if (locIdx > -1)
                                                            {
                                                                lbGroup.rotationYList[locIdx] = lbGroupLocationItem.rotationY;
                                                                lbGroupLocationItem.transform.rotation = Quaternion.Euler(0f, lbGroupLocationItem.rotationY, 0f);
                                                                isSceneDirtyRequired = true;
                                                            }                                                            
                                                        }
                                                    }
                                                    else { EditorGUILayout.LabelField("No manual clearing selected in the scene"); }
                                                }
                                                else { EditorGUILayout.LabelField("No manual clearing selected in the scene"); }

                                                EditorGUILayout.EndHorizontal();
                                            }
                                        }
                                        #endregion

                                        if (!(lbGroup.isFixedRotation && lbGroup.lbGroupType == LBGroup.LBGroupType.ManualClearing))
                                        {
                                            lbGroup.startClearingRotationY = EditorGUILayout.Slider(groupsStartClearingRotationYContent, lbGroup.startClearingRotationY, -359.9f, 359.9f);
                                            lbGroup.endClearingRotationY = EditorGUILayout.Slider(groupsEndClearingRotationYContent, lbGroup.endClearingRotationY, -359.9f, 359.9f);
                                        }

                                        lbGroup.isRemoveExistingGrass = EditorGUILayout.Toggle(groupsIsRemoveExistingGrassContent, lbGroup.isRemoveExistingGrass);
                                        if (lbGroup.isRemoveExistingGrass)
                                        {
                                            lbGroup.removeExistingGrassBlendDist = EditorGUILayout.Slider(groupsRemoveExistingGrassBlendDistContent, lbGroup.removeExistingGrassBlendDist * lbGroup.minClearingRadius, 0f, lbGroup.minClearingRadius) / lbGroup.minClearingRadius;
                                        }
                                        lbGroup.isRemoveExistingTrees = EditorGUILayout.Toggle(groupsIsRemoveExistingTreesContent, lbGroup.isRemoveExistingTrees);
                                    }
                                    else { EditorGUILayout.LabelField("No general options apply to Uniform groups"); }
                                }
                                #endregion

                                #region Group-level Defaults
                                else if (lbGroup.showtabInEditor == 1)
                                {                                   
                                    EditorGUI.BeginChangeCheck();
                                    lbGroup.minScale = EditorGUILayout.Slider(groupsMinScaleContent, lbGroup.minScale, 0.1f, 10f);
                                    lbGroup.maxScale = EditorGUILayout.Slider(groupsMaxScaleContent, lbGroup.maxScale, 0.1f, 10f);
                                    if (lbGroup.maxScale < lbGroup.minScale) { lbGroup.maxScale = lbGroup.minScale; }
                                    // If the group default scale has changed, we many need to change the scale of one or more members in the Group Designer
                                    if (EditorGUI.EndChangeCheck() && isGroupDesignerInitialised) { lbGroupDesigner.UpdateGroupMembersAll(); }

                                    lbGroup.minHeight = EditorGUILayout.Slider(groupsMinHeightContent, lbGroup.minHeight * terrainHeight, 0f, terrainHeight) / terrainHeight;
                                    lbGroup.maxHeight = EditorGUILayout.Slider(groupsMaxHeightContent, lbGroup.maxHeight * terrainHeight, 0f, terrainHeight) / terrainHeight;
                                    if (lbGroup.maxHeight < lbGroup.minHeight) { lbGroup.maxHeight = lbGroup.minHeight; }

                                    lbGroup.minInclination = EditorGUILayout.Slider(groupsMinInclinationContent, lbGroup.minInclination, 0f, 90f);
                                    lbGroup.maxInclination = EditorGUILayout.Slider(groupsMaxInclinationContent, lbGroup.maxInclination, 0f, 90f);
                                    if (lbGroup.maxInclination < lbGroup.minInclination) { lbGroup.maxInclination = lbGroup.minInclination; }

                                    if (lbGroup.lbGroupType == LBGroup.LBGroupType.ProceduralClearing || lbGroup.lbGroupType == LBGroup.LBGroupType.ManualClearing || lbGroup.lbGroupType == LBGroup.LBGroupType.SubGroup)
                                    {
                                        #region Group Terrain
                                        // Group flatten terrain
                                        EditorGUI.BeginChangeCheck();
                                        lbGroup.isTerrainFlattened = EditorGUILayout.Toggle(groupsIsTerrainFlattenContent, lbGroup.isTerrainFlattened);
                                        if (EditorGUI.EndChangeCheck() && lbGroup.groupMemberList != null)
                                        {
                                            // Turn off isTerrainFlattened at the group member level.
                                            for (lbGroupMemberIdx = 0; lbGroupMemberIdx < lbGroup.groupMemberList.Count; lbGroupMemberIdx++)
                                            {
                                                lbGroupMember = lbGroup.groupMemberList[lbGroupMemberIdx];
                                                if (lbGroupMember != null) { lbGroupMember.isTerrainFlattened = false; }
                                            }
                                        }
                                        if (lbGroup.isTerrainFlattened)
                                        {
                                            lbGroup.flattenBlendRate = EditorGUILayout.Slider(groupsFlattenBlendRateContent, lbGroup.flattenBlendRate, 0.01f, 1f);
                                            lbGroup.flattenHeightOffset = EditorGUILayout.Slider(groupsFlattenHeightOffsetContent, lbGroup.flattenHeightOffset, (terrainHeight * -0.25f), terrainHeight * 0.25f);
                                        }
                                        #endregion
                                    }
                                }
                                #endregion

                                #region Group-level Stencil or Biome Filters
                                else if (lbGroup.showtabInEditor == 2)
                                {
                                    if (lbGroup.filterList == null) { lbGroup.filterList = new List<LBFilter>(); }
                                    groupLBFilterToRemove = null;

                                    EditorGUILayout.BeginHorizontal();
                                    arrayInt = (lbGroup.filterList == null ? 0 : lbGroup.filterList.Count);
                                    temp = arrayInt;
                                    EditorGUILayout.LabelField("<color=" + txtColourName + ">Group-level Filters</color>", labelFieldRichText);
                                    if (GUILayout.Button("+", GUILayout.MaxWidth(30f))) { arrayInt++; }
                                    if (GUILayout.Button("-", GUILayout.MaxWidth(30f))) { arrayInt--; }
                                    if (arrayInt < 0) { arrayInt = 0; }
                                    EditorGUILayout.EndHorizontal();

                                    // Add items to the list
                                    if (arrayInt > temp)
                                    {
                                        LBFilter lbFilter = new LBFilter(LBFilter.FilterType.StencilLayer, LBFilter.FilterMode.AND);
                                        if (lbFilter != null) { lbGroup.filterList.Add(lbFilter); }
                                    }
                                    // Remove last item from the filter list for the current Group
                                    else if (arrayInt < temp && temp > 0)
                                    {
                                        groupLBFilterToRemove = lbGroup.filterList[temp - 1];
                                    }

                                    if (lbGroup.filterList != null)
                                    {
                                        #region Group-Level Display Filters
                                        for (int filterIndex = 0; filterIndex < lbGroup.filterList.Count; filterIndex++)
                                        {
                                            groupLBFilter = lbGroup.filterList[filterIndex];

                                            // Start the Group-level filter
                                            GUILayout.BeginVertical(EditorStyles.helpBox);

                                            #region Filter Type
                                            GUILayout.BeginHorizontal();
                                            // Display a subset of the Group-Level Filters
                                            EditorGUILayout.LabelField("Filter " + (filterIndex + 1).ToString("00") + " Type", labelFieldRichText, GUILayout.Width(124f));
                                            EditorGUI.BeginChangeCheck();
                                            LBFilter.FilterTypesForGroups filterForGroups = (LBFilter.FilterTypesForGroups)EditorGUILayout.EnumPopup((LBFilter.FilterTypesForGroups)groupLBFilter.filterType);
                                            if (EditorGUI.EndChangeCheck())
                                            {
                                                groupLBFilter.filterType = (LBFilter.FilterType)filterForGroups;
                                                if (groupLBFilter.filterType == LBFilter.FilterType.Biome && groupLBFilter.lbBiome == null) { groupLBFilter.lbBiome = new LBBiome(); }
                                            }

                                            if (GUILayout.Button("X", buttonCompact, GUILayout.MaxWidth(20f))) { groupLBFilterToRemove = groupLBFilter; }
                                            GUILayout.EndHorizontal();
                                            #endregion

                                            #region Stencil Filter
                                            if (groupLBFilter.filterType == LBFilter.FilterType.StencilLayer)
                                            {
                                                // If there is a Stencil selected, populate the temporary class instance
                                                if (groupLBFilter.lbStencilGUID != null && groupLBFilter.lbStencil == null)
                                                {
                                                    groupLBFilter.lbStencil = LBStencil.GetStencilInLandscape(landscape, groupLBFilter.lbStencilGUID, true);
                                                }

                                                GUILayout.BeginHorizontal();
                                                EditorGUILayout.LabelField(groupsFilterStencilContent, GUILayout.MaxWidth(80f));

                                                if (GUILayout.Button(commonStencilNewButtonContent, buttonCompactNoOffset, GUILayout.MaxWidth(40f)))
                                                {
                                                    LBStencil lbStencil = LBStencil.CreateStencilInScene(landscape, landscapeGameObject);

                                                    if (lbStencil != null)
                                                    {
                                                        groupLBFilter.lbStencilGUID = lbStencil.GUID;
                                                        // Default to the first layer
                                                        if (lbStencil.stencilLayerList != null)
                                                        {
                                                            if (lbStencil.stencilLayerList.Count > 0)
                                                            {
                                                                groupLBFilter.lbStencilLayerGUID = lbStencil.stencilLayerList[0].GUID;
                                                            }
                                                        }
                                                        // Select the new stencil and highlight in Hierarchy
                                                        Selection.activeGameObject = lbStencil.gameObject;
                                                        EditorGUIUtility.PingObject(lbStencil.gameObject);
                                                        #if UNITY_2018_2_OR_NEWER
                                                        LBEditorHelper.CallMenu("Window/General/Inspector");
                                                        #else
                                                        LBEditorHelper.CallMenu("Window/Inspector");
                                                        #endif
                                                        LBEditorHelper.ShowSceneView(this.GetType());
                                                    }
                                                    isSceneSaveRequired = true;
                                                }

                                                groupLBFilter.filterMode = (LBFilter.FilterMode)EditorGUILayout.EnumPopup((LBFilter.FilterModeAndNot)groupLBFilter.filterMode, GUILayout.Width(60f));

                                                EditorGUI.BeginChangeCheck();
                                                groupLBFilter.lbStencil = (LBStencil)EditorGUILayout.ObjectField(groupLBFilter.lbStencil, typeof(LBStencil), true);
                                                if (EditorGUI.EndChangeCheck())
                                                {
                                                    groupLBFilter.lbStencilGUID = groupLBFilter.lbStencil.GUID;
                                                    groupLBFilter.lbStencilLayerGUID = string.Empty;
                                                    // When user selects a different stencil, default to the first stencil layer
                                                    if (groupLBFilter.lbStencil.stencilLayerList != null)
                                                    {
                                                        if (groupLBFilter.lbStencil.stencilLayerList.Count > 0)
                                                        {
                                                            groupLBFilter.lbStencilLayerGUID = groupLBFilter.lbStencil.stencilLayerList[0].GUID;
                                                        }
                                                    }
                                                }
                                                GUILayout.EndHorizontal();

                                                // Get list of LBStencilLayers for the current LBStencil
                                                if (groupLBFilter.lbStencil != null)
                                                {
                                                    // Get a list of the Layer Names and their GUIDs
                                                    List<string> groupFilterStencilLayerGUIDList = new List<string>();
                                                    List<string> groupFilterStencilLayerNameList = new List<string>();
                                                    int groupFilterStencilLayerIndex = 0;

                                                    if (groupLBFilter.lbStencil.stencilLayerList != null)
                                                    {
                                                        foreach (LBStencilLayer lbStencilLayer in groupLBFilter.lbStencil.stencilLayerList)
                                                        {
                                                            if (!string.IsNullOrEmpty(lbStencilLayer.GUID))
                                                            {
                                                                groupFilterStencilLayerGUIDList.Add(lbStencilLayer.GUID);
                                                                groupFilterStencilLayerNameList.Add(lbStencilLayer.LayerName);
                                                            }
                                                        }

                                                        // Find the stencil layer that was last selected in the tree filter
                                                        groupFilterStencilLayerIndex = groupFilterStencilLayerGUIDList.FindIndex(sl => sl == groupLBFilter.lbStencilLayerGUID);
                                                    }

                                                    GUILayout.BeginHorizontal();
                                                    EditorGUILayout.LabelField("Stencil Layer", GUILayout.MaxWidth(80f));
                                                    
                                                    // Provide a quick way of editing the selected Stencil
                                                    // It should really be beside the Stencil (in case there are no layers) however this looks better
                                                    if (GUILayout.Button(commonStencilEditButtonContent, buttonCompactNoOffset, GUILayout.MaxWidth(40f)))
                                                    {
                                                        if (groupLBFilter.lbStencil != null)
                                                        {
                                                            if (isGroupDesignerInitialised)
                                                            {
                                                                EditorUtility.DisplayDialog("Edit Stencil", "To edit the stencil, first close the Group Designer", "Got it!");
                                                            }
                                                            else
                                                            {
                                                                Transform stencilTransform = groupLBFilter.lbStencil.transform;
                                                                if (stencilTransform != null)
                                                                {
                                                                    Selection.activeTransform = stencilTransform;
                                                                    #if UNITY_2018_2_OR_NEWER
                                                                    LBEditorHelper.CallMenu("Window/General/Inspector");
                                                                    #else
                                                                    LBEditorHelper.CallMenu("Window/Inspector");
                                                                    #endif
                                                                }
                                                            }
                                                        }
                                                    }

                                                    // Display the list of Stencil Layers for the selected Stencil.
                                                    EditorGUI.BeginChangeCheck();
                                                    groupFilterStencilLayerIndex = EditorGUILayout.Popup(groupFilterStencilLayerIndex, groupFilterStencilLayerNameList.ToArray());

                                                    if (EditorGUI.EndChangeCheck() && groupFilterStencilLayerGUIDList.Count > groupFilterStencilLayerIndex && groupFilterStencilLayerIndex >= 0)
                                                    {
                                                        // Update the stencil layer for this tree filter
                                                        groupLBFilter.lbStencilLayerGUID = groupFilterStencilLayerGUIDList[groupFilterStencilLayerIndex];
                                                    }
                                                    GUILayout.EndHorizontal();
                                                }

                                            }
                                            #endregion

                                            #region Biome Filter
                                            else if (groupLBFilter.filterType == LBFilter.FilterType.Biome)
                                            {
                                                #if VEGETATION_STUDIO_PRO
                                                if (!landscape.useVegetationSystem)
                                                {
                                                    EditorGUILayout.HelpBox("Currently Biome filters only work when Vegetation Studio Pro is used in the landscape. Check the Terrain Settings on the Landscape tab.", MessageType.Error);
                                                }                              
                                                else
                                                {
                                                    GUILayout.BeginHorizontal();
                                                    EditorGUILayout.LabelField(groupsVSPBiomeContent, GUILayout.Width(124f));
                                                    groupLBFilter.lbBiome.biomeIndex = EditorGUILayout.Popup(groupLBFilter.lbBiome.biomeIndex, LBIntegration.VegetationStudioProGetPackageList(vsPro));
                                                    GUILayout.EndHorizontal();
                                                    GUILayout.BeginHorizontal();
                                                    EditorGUILayout.LabelField(groupsVSPBiomeMinBlendDistContent, GUILayout.Width(124f));
                                                    groupLBFilter.lbBiome.minBlendDist = EditorGUILayout.Slider(groupLBFilter.lbBiome.minBlendDist, 0f, 500f);
                                                    GUILayout.EndHorizontal();
                                                }
                                                #else
                                                EditorGUILayout.HelpBox("Currently Biome filters only work with Vegetation Studio Pro", MessageType.Error);
                                                #endif
                                            }
                                            #endregion

                                            // End Group-level filter
                                            GUILayout.EndVertical();
                                        }
                                        #endregion

                                        if (lbGroup.filterList.Count > 0)
                                        {
                                            GUILayout.BeginHorizontal();
                                            EditorGUILayout.LabelField(groupsFilterClearingRadiusContent, GUILayout.Width(128f));
                                            lbGroup.isClearingRadiusFiltered = EditorGUILayout.Toggle(lbGroup.isClearingRadiusFiltered);
                                            GUILayout.EndHorizontal();
                                        }

                                        #region Group-level Filter to Remove
                                        if (groupLBFilterToRemove != null)
                                        {
                                            int groupFilterPos = lbGroup.filterList.FindIndex(gpFilter => gpFilter == groupLBFilterToRemove);
                                            if (LBEditorHelper.PromptForDelete("Group-Level Filter", "", groupFilterPos, false))
                                            {
                                                lbGroup.filterList.Remove(groupLBFilterToRemove);
                                                groupLBFilterToRemove = null;
                                                isSceneDirtyRequired = true;
                                            }
                                        }
                                        #endregion
                                    }
                                }

                                #endregion

                                #region Group-level Zones
                                else if (lbGroup.showtabInEditor == 3)
                                {
                                    if (lbGroup.lbGroupType == LBGroup.LBGroupType.ProceduralClearing || lbGroup.lbGroupType == LBGroup.LBGroupType.ManualClearing || lbGroup.lbGroupType == LBGroup.LBGroupType.SubGroup)
                                    {
                                        EditorGUILayout.HelpBox("Zones may be used to restrict where items are placed, or not placed, within a group. Zones are defined at the Group-level here (or in the Group Designer), then applied as filters to group members.", MessageType.Info, true);

                                        if (lbGroup.zoneList == null) { lbGroup.zoneList = new List<LBGroupZone>(); }
                                        lbGroupZoneToRemove = null;
                                        insertZonePos = -1;

                                        EditorGUILayout.BeginHorizontal();
                                        arrayInt = (lbGroup.zoneList == null ? 0 : lbGroup.zoneList.Count);
                                        temp = arrayInt;

                                        // Expand or shrink all zones within the group
                                        EditorGUI.BeginChangeCheck();
                                        EditorGUIUtility.labelWidth = defaultEditorLabelWidth - 50f;
                                        lbGroup.isZoneListExpanded = EditorGUILayout.Foldout(lbGroup.isZoneListExpanded, "Group-level Zones");
                                        if (EditorGUI.EndChangeCheck())
                                        {
                                            lbGroup.GroupZoneListExpand(lbGroup.isZoneListExpanded);
                                        }

                                        if (lbGroup.editorSearchZoneFilter == null) { lbGroup.editorSearchZoneFilter = string.Empty; }

                                        // If the GroupDesigner is enabled, enable user to Display the zones from the editor
                                        if (isGroupDesignerInitialised && lbGroupDesigner != null)
                                        {
                                            searchTextFieldStyle.fixedWidth = 100f;
                                            lbGroup.editorSearchZoneFilter = GUILayout.TextField(lbGroup.editorSearchZoneFilter, searchTextFieldStyle);
                                            searchTextFieldStyle.fixedWidth = defaultSearchTextFieldWidth;

                                            // Sometimes the search text is reverse search almost seems invisible (small search icon and cancel cannot be seen)
                                            // Not sure how this occurs.
                                            if (GUILayout.Button("", searchCancelButtonStyle))
                                            {
                                                lbGroup.editorSearchZoneFilter = string.Empty;
                                                GUI.FocusControl(null);
                                            }

                                            if (lbGroupDesigner.showZones)
                                            {
                                                if (GUILayout.Button("Display", toggleCompactButtonStyleToggled, GUILayout.Width(60f)))
                                                {
                                                    lbGroupDesigner.showZones = false;
                                                    LBEditorHelper.RefreshSceneView();
                                                }
                                            }
                                            else if (GUILayout.Button("Display", toggleCompactButtonStyleNormal, GUILayout.Width(60f)))
                                            {
                                                lbGroupDesigner.showZones = true;
                                                LBEditorHelper.RefreshSceneView();
                                            }
                                        }
                                        else
                                        {
                                            lbGroup.editorSearchZoneFilter = GUILayout.TextField(lbGroup.editorSearchZoneFilter, searchTextFieldStyle);

                                            // Sometimes the search text is reverse search almost seems invisible (small search icon and cancel cannot be seen)
                                            // Not sure how this occurs.
                                            if (GUILayout.Button("", searchCancelButtonStyle))
                                            {
                                                lbGroup.editorSearchZoneFilter = string.Empty;
                                                GUI.FocusControl(null);
                                            }
                                        }

                                        if (GUILayout.Button("+", GUILayout.MaxWidth(30f))) { arrayInt++; }
                                        if (GUILayout.Button("-", GUILayout.MaxWidth(30f))) { arrayInt--; }
                                        if (arrayInt < 0) { arrayInt = 0; }
                                        EditorGUILayout.EndHorizontal();

                                        EditorGUIUtility.labelWidth = defaultEditorLabelWidth;

                                        // Add items to the list
                                        if (arrayInt > temp)
                                        {
                                            LBGroupZone lbGroupZone = new LBGroupZone();
                                            if (lbGroupZone != null)
                                            {
                                                lbGroupZone.zoneName = "zone" + arrayInt.ToString("000");
                                                lbGroupZone.width = 0.5f;
                                                lbGroupZone.length = 0.5f;
                                                lbGroup.zoneList.Add(lbGroupZone);
                                                if (isGroupDesignerInitialised)
                                                {
                                                    // Automatically show zones when a new one is added
                                                    lbGroupDesigner.showZones = true;
                                                    LBEditorHelper.RefreshSceneView();
                                                }
                                                else if (lbGroup.showGroupsInScene)
                                                {
                                                    LBGroupLocationItem.RefreshLocationZonesInScene(landscape, lbGroup, true);
                                                    LBEditorHelper.RefreshSceneView();
                                                }
                                                isSceneDirtyRequired = true;
                                            }
                                        }
                                        // Remove last item from the zone list for the current Group
                                        else if (arrayInt < temp && temp > 0)
                                        {
                                            lbGroupZoneToRemove = lbGroup.zoneList[temp - 1];
                                        }

                                        if (lbGroup.zoneList != null)
                                        {
                                            #region Group-Level Display Zones
                                            for (int zoneIdx = 0; zoneIdx < lbGroup.zoneList.Count; zoneIdx++)
                                            {
                                                lbGroupZone = lbGroup.zoneList[zoneIdx];

                                                // Check if the list of zones is being filtered. Ignore zones not in the filter
                                                if (lbGroupZone == null || !lbGroupZone.IsInSearchFilter(lbGroup.editorSearchZoneFilter)) { continue; }

                                                // Start the Group-level zone
                                                GUILayout.BeginVertical(EditorStyles.helpBox);
                                                GUILayout.BeginHorizontal();
                                                EditorGUI.BeginChangeCheck();
                                                lbGroupZone.zoneMode = (LBGroupZone.ZoneMode)EditorGUILayout.EnumPopup(lbGroupZone.zoneMode, GUILayout.Width(50f));
                                                if (EditorGUI.EndChangeCheck())
                                                {
                                                    // Update the designer if required
                                                    if (isGroupDesignerInitialised) { lbGroupDesigner.RefreshWorkspace(); }
                                                    isSceneDirtyRequired = true;
                                                }
                                                EditorGUI.BeginChangeCheck();
                                                lbGroupZone.zoneType = (LBGroupZone.LBGroupZoneType)EditorGUILayout.EnumPopup(lbGroupZone.zoneType, GUILayout.Width(80f));
                                                if (EditorGUI.EndChangeCheck())
                                                {
                                                    // If switching from Rectangle to circle
                                                    if (lbGroupZone.zoneType == LBGroupZone.LBGroupZoneType.circle)
                                                    {
                                                        lbGroupZone.width /= 2f;
                                                        lbGroupZone.length = lbGroupZone.width;
                                                    }
                                                    else
                                                    {
                                                        // Switching from circle to rectangle
                                                        lbGroupZone.width *= 2f;
                                                        lbGroupZone.length = lbGroupZone.width;
                                                    }

                                                    // Update the designer if required
                                                    if (isGroupDesignerInitialised) { lbGroupDesigner.RefreshWorkspace(); }
                                                    if (lbGroup.showGroupsInScene) { LBEditorHelper.RefreshSceneView(); }
                                                    isSceneDirtyRequired = true;
                                                }
                                                lbGroupZone.zoneName = EditorGUILayout.TextField(lbGroupZone.zoneName);
                                                if (GUILayout.Button("I", buttonCompact, GUILayout.MaxWidth(20f))) { insertZonePos = zoneIdx; }
                                                if (lbGroupZone.showInEditor) { if (GUILayout.Button("Hide", buttonCompact, GUILayout.Width(40f))) { GUI.FocusControl(null); lbGroupZone.showInEditor = false; } }
                                                else { if (GUILayout.Button("Show", buttonCompact, GUILayout.Width(40f))) { GUI.FocusControl(null); lbGroupZone.showInEditor = true; } }
                                                if (GUILayout.Button("X", buttonCompact, GUILayout.MaxWidth(20f))) { lbGroupZoneToRemove = lbGroupZone; }
                                                GUILayout.EndHorizontal();

                                                if (lbGroupZone.showInEditor)
                                                {
                                                    EditorGUI.BeginChangeCheck();
                                                    EditorGUILayout.BeginHorizontal();
                                                    EditorGUILayout.LabelField("Zone Centre Point", GUILayout.Width(135f));
                                                    EditorGUILayout.LabelField("X", GUILayout.Width(15f));
                                                    lbGroupZone.centrePointX = Mathf.Clamp(EditorGUILayout.FloatField(lbGroupZone.centrePointX * lbGroup.maxClearingRadius, GUILayout.Width(60f)) / lbGroup.maxClearingRadius, -1f, 1f);
                                                    EditorGUILayout.LabelField("Z", GUILayout.Width(15f));
                                                    lbGroupZone.centrePointZ = Mathf.Clamp(EditorGUILayout.FloatField(lbGroupZone.centrePointZ * lbGroup.maxClearingRadius, GUILayout.Width(60f)) / lbGroup.maxClearingRadius, -1f, 1f);
                                                    EditorGUILayout.EndHorizontal();
                                                    if (EditorGUI.EndChangeCheck())
                                                    {
                                                        // Update the designer if required
                                                        if (isGroupDesignerInitialised) { lbGroupDesigner.RefreshWorkspace(); }
                                                        isSceneDirtyRequired = true;
                                                    }

                                                    if (lbGroupZone.zoneType == LBGroupZone.LBGroupZoneType.circle)
                                                    {
                                                        GUILayout.BeginHorizontal();
                                                        EditorGUILayout.LabelField("Zone Radius", GUILayout.Width(135f));
                                                        EditorGUI.BeginChangeCheck();
                                                        lbGroupZone.length = EditorGUILayout.Slider(lbGroupZone.length * lbGroup.maxClearingRadius, 0.01f, lbGroup.maxClearingRadius) / lbGroup.maxClearingRadius;
                                                        GUILayout.EndHorizontal();

                                                        if (lbGroupZone.showInScene)
                                                        {
                                                            if (GUILayout.Button(groupsZoneShowInSceneContent, toggleTinyButtonStyleNormal, GUILayout.Width(135f)))
                                                            {
                                                                lbGroupZone.showInScene = false;
                                                            }
                                                        }
                                                        else if (GUILayout.Button(groupsZoneShowInSceneContent, toggleTinyButtonStyleToggled, GUILayout.Width(135f)))
                                                        {
                                                            lbGroupZone.showInScene = true;
                                                        }

                                                        if (EditorGUI.EndChangeCheck())
                                                        {
                                                            lbGroupZone.width = lbGroupZone.length;
                                                            if (isGroupDesignerInitialised) { lbGroupDesigner.AddPrefabBlock(200f); }
                                                            LBEditorHelper.RefreshSceneView();
                                                            // NOT it is too slow to update the GroupDesigner as user changes slider
                                                            isSceneDirtyRequired = true;
                                                        }
                                                    }
                                                    else
                                                    {
                                                        EditorGUI.BeginChangeCheck();
                                                        GUILayout.BeginHorizontal();
                                                        EditorGUILayout.LabelField("Zone Rectangle", GUILayout.Width(135f));
                                                        EditorGUILayout.LabelField("W", GUILayout.Width(25f));
                                                        lbGroupZone.width = EditorGUILayout.Slider(lbGroupZone.width * lbGroup.maxClearingRadius, 0.01f, lbGroup.maxClearingRadius * 2f) / lbGroup.maxClearingRadius;
                                                        GUILayout.EndHorizontal();
                                                        GUILayout.BeginHorizontal();

                                                        if (lbGroupZone.showInScene)
                                                        {
                                                            if (GUILayout.Button(groupsZoneShowInSceneContent, toggleTinyButtonStyleNormal, GUILayout.Width(135f)))
                                                            {
                                                                lbGroupZone.showInScene = false;
                                                            }
                                                        }
                                                        else if (GUILayout.Button(groupsZoneShowInSceneContent, toggleTinyButtonStyleToggled, GUILayout.Width(135f)))
                                                        {
                                                            lbGroupZone.showInScene = true;
                                                        }

                                                        EditorGUILayout.LabelField("L", GUILayout.Width(25f));
                                                        lbGroupZone.length = EditorGUILayout.Slider(lbGroupZone.length * lbGroup.maxClearingRadius, 0.01f, lbGroup.maxClearingRadius * 2f) / lbGroup.maxClearingRadius;
                                                        GUILayout.EndHorizontal();
                                                        if (EditorGUI.EndChangeCheck())
                                                        {
                                                            if (isGroupDesignerInitialised) { lbGroupDesigner.AddPrefabBlock(200f); }
                                                            LBEditorHelper.RefreshSceneView();
                                                            // NOT it is too slow to update the GroupDesigner as user changes slider
                                                            isSceneDirtyRequired = true;
                                                        }
                                                    }

                                                    EditorGUI.BeginChangeCheck();
                                                    EditorGUILayout.BeginHorizontal();
                                                    EditorGUILayout.LabelField(groupsZoneAutoScaleContent, GUILayout.Width(135f));
                                                    EditorGUILayout.LabelField("X", GUILayout.Width(15f));
                                                    lbGroupZone.isScaledPointX = EditorGUILayout.Toggle(lbGroupZone.isScaledPointX, GUILayout.Width(20f));
                                                    EditorGUILayout.LabelField("Z", GUILayout.Width(15f));
                                                    lbGroupZone.isScaledPointZ = EditorGUILayout.Toggle(lbGroupZone.isScaledPointZ, GUILayout.Width(20f));
                                                    if (lbGroupZone.zoneType == LBGroupZone.LBGroupZoneType.rectangle)
                                                    {
                                                        EditorGUILayout.LabelField("Width", GUILayout.Width(40f));
                                                        lbGroupZone.isScaledWidth = EditorGUILayout.Toggle(lbGroupZone.isScaledWidth, GUILayout.Width(20f));
                                                        EditorGUILayout.LabelField("Length", GUILayout.Width(50f));
                                                    }
                                                    else
                                                    {
                                                        EditorGUILayout.LabelField("Radius", GUILayout.Width(50f));
                                                    }
                                                    lbGroupZone.isScaledLength = EditorGUILayout.Toggle(lbGroupZone.isScaledLength, GUILayout.Width(20f));
                                                    EditorGUILayout.EndHorizontal();
                                                    if (EditorGUI.EndChangeCheck())
                                                    {
                                                        isSceneDirtyRequired = true;
                                                    }

                                                    #region Biomes
                                                    #if VEGETATION_STUDIO_PRO
                                                    if (!lbGroupZone.useBiome)
                                                    {
                                                        if (GUILayout.Button("Assign Biome", buttonCompact, GUILayout.Width(135f)))
                                                        {
                                                            if (lbGroupZone.lbBiome == null) { lbGroupZone.lbBiome = new LBBiome(); }
                                                            lbGroupZone.useBiome = true;
                                                            isSceneDirtyRequired = true;
                                                        }
                                                    }
                                                    else if (lbGroupZone.lbBiome != null)
                                                    {                                                        
                                                        if (!landscape.useVegetationSystem)
                                                        {
                                                            EditorGUILayout.HelpBox("Currently Biomes only work when Vegetation Studio Pro is used in the landscape. Check the Terrain Settings on the Landscape tab.", MessageType.Error);
                                                        }                              
                                                        else
                                                        {
                                                            EditorGUI.BeginChangeCheck();
                                                            GUILayout.BeginHorizontal();
                                                            EditorGUILayout.LabelField(groupsVSPBiomeContent, GUILayout.Width(135f));
                                                            lbGroupZone.lbBiome.biomeIndex = EditorGUILayout.Popup(lbGroupZone.lbBiome.biomeIndex, LBIntegration.VegetationStudioProGetPackageList(vsPro));
                                                            if (GUILayout.Button("X", buttonCompact, GUILayout.MaxWidth(20f)))
                                                            {
                                                                lbGroupZone.useBiome = false;
                                                                isSceneDirtyRequired = true;
                                                            }
                                                            GUILayout.EndHorizontal();
                                                            if (lbGroupZone.useBiome && lbGroupZone.lbBiome != null)
                                                            {
                                                                GUILayout.BeginHorizontal();
                                                                EditorGUILayout.LabelField(groupsVSPBiomeMinBlendDistContent, GUILayout.Width(135f));
                                                                lbGroupZone.lbBiome.minBlendDist = EditorGUILayout.Slider(lbGroupZone.lbBiome.minBlendDist, 0f, 500f);
                                                                GUILayout.EndHorizontal();
                                                            }
                                                            if (EditorGUI.EndChangeCheck()) { isSceneDirtyRequired = true; }
                                                        }
                                                    }
                                                    #endif
                                                    #endregion
                                                }

                                                // End of the Group-level zone
                                                GUILayout.EndVertical();
                                            }
                                            #endregion

                                            #region Group-level Zone to Insert, Remove
                                            if (lbGroupZoneToRemove != null)
                                            {
                                                int groupZonePos = lbGroup.zoneList.FindIndex(gpZone => gpZone == lbGroupZoneToRemove);
                                                if (groupZonePos >= 0 && LBEditorHelper.PromptForDelete("Group Zone", lbGroup.zoneList[groupZonePos].zoneName, groupZonePos, false))
                                                {
                                                    // Remove all the zone filters from the members for this zone
                                                    for (lbGroupMemberIdx = 0; lbGroupMemberIdx < lbGroup.groupMemberList.Count; lbGroupMemberIdx++)
                                                    {
                                                        lbGroup.groupMemberList[lbGroupMemberIdx].zoneGUIDList.RemoveAll(zone => zone == lbGroupZoneToRemove.GUID);
                                                    }

                                                    // Remove all the Tex zone filters
                                                    if (lbGroup.textureList != null)
                                                    {
                                                        for (int texIdx = 0; texIdx < lbGroup.textureList.Count; texIdx++)
                                                        {
                                                            lbGroup.textureList[texIdx].zoneGUIDList.RemoveAll(zone => zone == lbGroupZoneToRemove.GUID);
                                                        }
                                                    }

                                                    // Remove all the Grass zone filters
                                                    if (lbGroup.grassList != null)
                                                    {
                                                        for (int grIdx = 0; grIdx < lbGroup.grassList.Count; grIdx++)
                                                        {
                                                            lbGroup.grassList[grIdx].zoneGUIDList.RemoveAll(zone => zone == lbGroupZoneToRemove.GUID);
                                                        }
                                                    }

                                                    lbGroup.zoneList.Remove(lbGroupZoneToRemove);
                                                    lbGroupZoneToRemove = null;

                                                    // Update the designer if required
                                                    if (isGroupDesignerInitialised) { lbGroupDesigner.RefreshWorkspace(); }
                                                    else if (lbGroup.showGroupsInScene)
                                                    {
                                                        LBGroupLocationItem.RefreshLocationZonesInScene(landscape, lbGroup, true);
                                                        LBEditorHelper.RefreshSceneView();
                                                    }

                                                    isSceneDirtyRequired = true;
                                                }
                                            }
                                            // Does the user wish to insert a new (duplicate) zone into the list?
                                            else if (insertZonePos >= 0)
                                            {
                                                // Insert a duplicate above the selected zone
                                                lbGroup.zoneList.Insert(insertZonePos, new LBGroupZone(lbGroup.zoneList[insertZonePos]));
                                                // Give it a unique GUID
                                                lbGroup.zoneList[insertZonePos].GUID = System.Guid.NewGuid().ToString();
                                                lbGroup.zoneList[insertZonePos].showInScene = true;
                                                lbGroup.zoneList[insertZonePos].zoneName += " (dup)";
                                                lbGroup.zoneList[insertZonePos].showInEditor = true;
                                                lbGroup.zoneList[insertZonePos + 1].showInEditor = false;
                                                insertZonePos = -1;
                                                if (lbGroup.showGroupsInScene)
                                                {
                                                    LBGroupLocationItem.RefreshLocationZonesInScene(landscape, lbGroup, true);
                                                    LBEditorHelper.RefreshSceneView();
                                                }
                                                isSceneSaveRequired = true;
                                            }

                                            #endregion
                                        }
                                    }
                                    else { EditorGUILayout.LabelField("Zones do not apply to Uniform groups"); }
                                }
                                #endregion

                                #region Group-level Textures
                                else if (lbGroup.showtabInEditor == 4)
                                {
                                    EditorGUILayout.HelpBox("Group Textures are defined at the Group-Level. This will overwrite any ground textures in your terrain data not included in the Texturing tab. If you texture your terrains outside LB, consult Help for more details before proceeding.", MessageType.Warning, true);

                                    if (lbGroup.lbGroupType == LBGroup.LBGroupType.ProceduralClearing || lbGroup.lbGroupType == LBGroup.LBGroupType.ManualClearing || lbGroup.lbGroupType == LBGroup.LBGroupType.SubGroup)
                                    {
                                        #region Group-level Texture buttons
                                        if (lbGroup.textureList == null) { lbGroup.textureList = new List<LBGroupTexture>(); }
                                        lbGroupTextureToRemove = null;

                                        EditorGUILayout.BeginHorizontal();
                                        arrayInt = (lbGroup.textureList == null ? 0 : lbGroup.textureList.Count);
                                        temp = arrayInt;
                                        EditorGUILayout.LabelField("<color=" + txtColourName + ">Group-level Texturing</color>", labelFieldRichText);
                                        if (GUILayout.Button("+", GUILayout.MaxWidth(30f))) { arrayInt++; }
                                        if (GUILayout.Button("-", GUILayout.MaxWidth(30f))) { arrayInt--; }
                                        if (arrayInt < 0) { arrayInt = 0; }
                                        EditorGUILayout.EndHorizontal();

                                        // Add items to the list
                                        if (arrayInt > temp)
                                        {
                                            LBGroupTexture lbGroupTexture = new LBGroupTexture();
                                            if (lbGroupTexture != null)
                                            {
                                                lbGroupTexture.noiseTileSize = lbGroup.maxClearingRadius;
                                                lbGroup.textureList.Add(lbGroupTexture);
                                                isSceneDirtyRequired = true;
                                            }
                                        }
                                        // Remove last item from the texture list for the current Group
                                        else if (arrayInt < temp && temp > 0)
                                        {
                                            lbGroupTextureToRemove = lbGroup.textureList[temp - 1];
                                        }
                                        #endregion

                                        #region Show the list of Group Texture items
                                        if (lbGroup.textureList != null)
                                        {
                                            for (int texIdx = 0; texIdx < lbGroup.textureList.Count; texIdx++)
                                            {
                                                lbGroupTexture = lbGroup.textureList[texIdx];

                                                // Start the Group-level Texture
                                                GUILayout.BeginVertical(EditorStyles.helpBox);

                                                if (appliedTexturesList == null || appliedTexturesArray == null)
                                                {
                                                    EditorGUILayout.LabelField("No textures in this landscape. Check Texturing tab.");
                                                }
                                                else if (appliedTexturesList.Count == 0)
                                                {
                                                    EditorGUILayout.LabelField("No textures in this landscape. Check Texturing tab.");
                                                }
                                                else
                                                {
                                                    GUILayout.BeginHorizontal();
                                                    labelText = "<color=" + txtColourName + ">Texture " + (texIdx + 1).ToString("00") + "</color>";
                                                    EditorGUILayout.LabelField(labelText, labelFieldRichText, GUILayout.MaxWidth(70f));

                                                    // Find the matching LBTerrainTexture (if any)
                                                    int textureIndex = appliedTexturesList.FindIndex(tx => tx.GUID == lbGroupTexture.lbTerrainTextureGUID && !string.IsNullOrEmpty(tx.GUID));

                                                    string texStatus = "Check Texturing Tab";

                                                    EditorGUI.BeginChangeCheck();
                                                    textureIndex = EditorGUILayout.Popup(textureIndex, appliedTexturesArray);
                                                    if (EditorGUI.EndChangeCheck())
                                                    {
                                                        if (textureIndex < appliedTexturesList.Count)
                                                        {
                                                            LBTerrainTexture terrainTexture = appliedTexturesList[textureIndex];
                                                            // If this is a legacy LBTerrainTexture, update it now
                                                            if (string.IsNullOrEmpty(terrainTexture.GUID))
                                                            {
                                                                Debug.Log("Updating Texture " + terrainTexture.textureName + " to v2.0");
                                                                terrainTexture.GUID = System.Guid.NewGuid().ToString();
                                                            }

                                                            lbGroupTexture.lbTerrainTextureGUID = terrainTexture.GUID;
                                                            isSceneDirtyRequired = true;
                                                        }
                                                    }

                                                    if (lbGroupTexture.showInEditor) { if (GUILayout.Button("Hide", buttonCompact, GUILayout.Width(40f))) { GUI.FocusControl(null); lbGroupTexture.showInEditor = false; } }
                                                    else { if (GUILayout.Button("Show", buttonCompact, GUILayout.Width(40f))) { GUI.FocusControl(null); lbGroupTexture.showInEditor = true; } }
                                                    if (GUILayout.Button("X", buttonCompact, GUILayout.MaxWidth(20f))) { lbGroupTextureToRemove = lbGroupTexture; }

                                                    GUILayout.EndHorizontal();

                                                    if (lbGroupTexture.showInEditor)
                                                    {
                                                        lbGroupTexture.minBlendDist = EditorGUILayout.Slider(groupsTextureMinBlendDistContent, lbGroupTexture.minBlendDist * lbGroup.maxClearingRadius, -lbGroup.maxClearingRadius, lbGroup.maxClearingRadius) / lbGroup.maxClearingRadius;
                                                        lbGroupTexture.strength = EditorGUILayout.Slider(texturingStrengthContent, lbGroupTexture.strength, 0.01f, 1.0f);
                                                        lbGroupTexture.useNoise = EditorGUILayout.Toggle(texturingUseNoiseContent, lbGroupTexture.useNoise);
                                                        if (lbGroupTexture.useNoise)
                                                        {
                                                            lbGroupTexture.noiseTileSize = LBEditorHelper.LogarithmicSlider(texturingNoiseTileSizeContent, defaultEditorLabelWidth, lbGroupTexture.noiseTileSize, 1f, 1000f, false, 10);
                                                        }

                                                        GUILayout.BeginHorizontal();
                                                        EditorGUILayout.LabelField(groupsIsWholeGroupContent, GUILayout.MaxWidth(defaultEditorLabelWidth - 4f));
                                                        EditorGUI.BeginChangeCheck();
                                                        lbGroupTexture.isWholeGroup = EditorGUILayout.Toggle(lbGroupTexture.isWholeGroup, GUILayout.Width(25f));
                                                        if (EditorGUI.EndChangeCheck() && lbGroupTexture.isWholeGroup)
                                                        {
                                                            // Remove all Group Texture zone filters
                                                            lbGroupTexture.zoneGUIDList.Clear();
                                                            isSceneDirtyRequired = true;
                                                        }
                                                        if (textureIndex >= 0)
                                                        {
                                                            LBTerrainTexture terrainTexture = appliedTexturesList[textureIndex];
                                                            if (terrainTexture.isDisabled) { texStatus = "Disabled"; }
                                                            else if (terrainTexture.texture != null) { texStatus = "OK"; }
                                                        }
                                                        labelText = "Status: " + texStatus;
                                                        EditorGUILayout.LabelField(labelText, GUILayout.MaxWidth(190f));
                                                        
                                                        GUILayout.EndHorizontal();

                                                        #region Texture Zones
                                                        if (!lbGroupTexture.isWholeGroup)
                                                        {
                                                            lbGroupTexture.edgeBlendDist = EditorGUILayout.Slider(groupsTextureEdgeBlendDistContent, lbGroupTexture.edgeBlendDist, 0f, lbGroup.maxClearingRadius < 50f ? lbGroup.maxClearingRadius : 50f);

                                                            EditorGUILayout.HelpBox("Zones are defined at the Group-level on the Zones option tab, then applied as filters for the textures.", MessageType.Info, true);

                                                            #region Group-level Texture Zone buttons

                                                            if (lbGroupTexture.zoneGUIDList == null) { lbGroupTexture.zoneGUIDList = new List<string>(); }
                                                            lbGroupTextureZoneToRemove = string.Empty;

                                                            EditorGUILayout.BeginHorizontal();
                                                            arrayInt = (lbGroupTexture.zoneGUIDList == null ? 0 : lbGroupTexture.zoneGUIDList.Count);
                                                            temp = arrayInt;
                                                            EditorGUILayout.LabelField("<color=" + txtColourName + ">Texture Zones Filters</color>", labelFieldRichText);
                                                            if (GUILayout.Button("+", GUILayout.MaxWidth(30f))) { arrayInt++; }
                                                            if (GUILayout.Button("-", GUILayout.MaxWidth(30f))) { arrayInt--; }
                                                            if (arrayInt < 0) { arrayInt = 0; }
                                                            EditorGUILayout.EndHorizontal();

                                                            // Add items to the list
                                                            if (arrayInt > temp)
                                                            {
                                                                if (lbGroup.zoneList != null)
                                                                {
                                                                    if (lbGroup.zoneList.Count > 0)
                                                                    {
                                                                        lbGroupTexture.zoneGUIDList.Add(lbGroup.zoneList[0].GUID);
                                                                        isSceneDirtyRequired = true;
                                                                    }
                                                                }
                                                            }
                                                            // Remove last item from the zone GUID list for the current GroupMember
                                                            else if (arrayInt < temp && temp > 0)
                                                            {
                                                                lbGroupTextureZoneToRemove = lbGroupTexture.zoneGUIDList[temp - 1];
                                                            }
                                                            // NOTE: EditorGUILayout.Separator() can add extra unwanted width
                                                            EditorGUILayout.LabelField("", GUILayout.Height(5f));

                                                            #endregion

                                                            if (lbGroup.zoneList != null)
                                                            {
                                                                // Show all the zone filters that apply to this Group-Level Texture
                                                                for (int zoneIdx = 0; zoneIdx < lbGroupTexture.zoneGUIDList.Count; zoneIdx++)
                                                                {
                                                                    lbGroupZone = null;
                                                                    string zoneGUID = lbGroupTexture.zoneGUIDList[zoneIdx];
                                                                    int groupZoneIdx = lbGroup.zoneList.FindIndex(zone => zone.GUID == zoneGUID);
                                                                    if (groupZoneIdx >= 0 && groupZoneIdx < lbGroup.zoneList.Count)
                                                                    {
                                                                        lbGroupZone = lbGroup.zoneList[groupZoneIdx];
                                                                        EditorGUILayout.BeginHorizontal();
                                                                        EditorGUILayout.LabelField(lbGroupZone.zoneMode.ToString(), GUILayout.MaxWidth(30f));
                                                                        EditorGUILayout.LabelField(lbGroupZone.zoneType.ToString(), GUILayout.MaxWidth(65f));

                                                                        EditorGUI.BeginChangeCheck();
                                                                        groupZoneIdx = EditorGUILayout.Popup(groupZoneIdx, zoneNameList.ToArray());
                                                                        if (EditorGUI.EndChangeCheck() && groupZoneIdx < lbGroup.zoneList.Count)
                                                                        {
                                                                            lbGroupZone = lbGroup.zoneList[groupZoneIdx];
                                                                            if (lbGroupZone != null)
                                                                            {
                                                                                lbGroupTexture.zoneGUIDList[zoneIdx] = lbGroupZone.GUID;
                                                                            }
                                                                        }
                                                                        if (GUILayout.Button("X", buttonCompact, GUILayout.MaxWidth(20f))) { lbGroupTextureZoneToRemove = lbGroupTexture.zoneGUIDList[zoneIdx]; }
                                                                        EditorGUILayout.EndHorizontal();
                                                                    }
                                                                    else
                                                                    {
                                                                        EditorGUILayout.HelpBox("Zone is missing at the Group level", MessageType.Warning);
                                                                    }
                                                                }

                                                                // Remove / delete zone references
                                                                if (!string.IsNullOrEmpty(lbGroupTextureZoneToRemove))
                                                                {
                                                                    int groupTextureZonePos = lbGroupTexture.zoneGUIDList.FindIndex(gpTexZ => gpTexZ == lbGroupTextureZoneToRemove);

                                                                    if (LBEditorHelper.PromptForDelete("Group Texture Zone Filter", "", groupTextureZonePos, false))
                                                                    {
                                                                        lbGroupTexture.zoneGUIDList.Remove(lbGroupTextureZoneToRemove);
                                                                        lbGroupTextureZoneToRemove = string.Empty;
                                                                        isSceneDirtyRequired = true;
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        #endregion
                                                    }
                                                }

                                                // End of the Group-level Texture
                                                GUILayout.EndVertical();
                                            }

                                            if (lbGroupTextureToRemove != null)
                                            {
                                                int groupTexturePos = lbGroup.textureList.FindIndex(gpTex => gpTex == lbGroupTextureToRemove);
                                                if (LBEditorHelper.PromptForDelete("Group Texture", "", groupTexturePos, false))
                                                {
                                                    lbGroup.textureList.Remove(lbGroupTextureToRemove);
                                                    lbGroupTextureToRemove = null;
                                                    isSceneDirtyRequired = true;
                                                }
                                            }
                                        }
                                        #endregion
                                    }
                                    else { EditorGUILayout.LabelField("Texturing does not apply to Uniform groups"); }

                                }
                                #endregion

                                #region Group-level Grass
                                else if (lbGroup.showtabInEditor == 5)
                                {
                                    EditorGUILayout.HelpBox("Group grass is defined at the Group-Level. This will overwrite any Unity grass in your terrain data not included in the Grass tab. If you add terrain detail (grass) to your terrains outside LB, consult Help for more info before proceeding.", MessageType.Warning, true);

                                    if (lbGroup.lbGroupType == LBGroup.LBGroupType.ProceduralClearing || lbGroup.lbGroupType == LBGroup.LBGroupType.ManualClearing || lbGroup.lbGroupType == LBGroup.LBGroupType.SubGroup)
                                    {
                                        #region Group-level Grass buttons
                                        if (lbGroup.grassList == null) { lbGroup.grassList = new List<LBGroupGrass>(); }
                                        lbGroupGrassToRemove = null;

                                        EditorGUILayout.BeginHorizontal();
                                        arrayInt = (lbGroup.grassList == null ? 0 : lbGroup.grassList.Count);
                                        temp = arrayInt;
                                        EditorGUILayout.LabelField("<color=" + txtColourName + ">Group-level Grass</color>", labelFieldRichText);
                                        if (GUILayout.Button("+", GUILayout.MaxWidth(30f))) { arrayInt++; }
                                        if (GUILayout.Button("-", GUILayout.MaxWidth(30f))) { arrayInt--; }
                                        if (arrayInt < 0) { arrayInt = 0; }
                                        EditorGUILayout.EndHorizontal();

                                        // Add items to the list
                                        if (arrayInt > temp)
                                        {
                                            LBGroupGrass lbGroupGrass = new LBGroupGrass();
                                            if (lbGroupGrass != null)
                                            {
                                                lbGroup.grassList.Add(lbGroupGrass);
                                                isSceneDirtyRequired = true;
                                            }
                                        }
                                        // Remove last item from the grass list for the current Group
                                        else if (arrayInt < temp && temp > 0)
                                        {
                                            lbGroupGrassToRemove = lbGroup.grassList[temp - 1];
                                        }
                                        #endregion

                                        #region Show the list of Group Grass items
                                        if (lbGroup.grassList != null)
                                        {
                                            for (int grIdx = 0; grIdx < lbGroup.grassList.Count; grIdx++)
                                            {
                                                lbGroupGrass = lbGroup.grassList[grIdx];

                                                // Start the Group-level Grass
                                                GUILayout.BeginVertical(EditorStyles.helpBox);

                                                if (appliedGrassList == null || appliedGrassArray == null)
                                                {
                                                    EditorGUILayout.LabelField("No grass in this landscape. Check Grass tab.");
                                                }
                                                else if (appliedGrassList.Count == 0)
                                                {
                                                    EditorGUILayout.LabelField("No grass in this landscape. Check Grass tab.");
                                                }
                                                else
                                                {
                                                    GUILayout.BeginHorizontal();
                                                    labelText = "<color=" + txtColourName + ">Grass " + (grIdx + 1).ToString("00") + "</color>";
                                                    EditorGUILayout.LabelField(labelText, labelFieldRichText, GUILayout.MaxWidth(70f));

                                                    // Find the matching LBTerrainGrass (if any)
                                                    int grassIndex = appliedGrassList.FindIndex(tx => tx.GUID == lbGroupGrass.lbTerrainGrassGUID && !string.IsNullOrEmpty(tx.GUID));

                                                    string grassStatus = "Check Grass Tab";

                                                    EditorGUI.BeginChangeCheck();
                                                    grassIndex = EditorGUILayout.Popup(grassIndex, appliedGrassArray);
                                                    if (EditorGUI.EndChangeCheck())
                                                    {
                                                        if (grassIndex < appliedGrassList.Count)
                                                        {
                                                            LBTerrainGrass terrainGrass = appliedGrassList[grassIndex];
                                                            // If this is a legacy LBTerrainGrass, update it now
                                                            if (string.IsNullOrEmpty(terrainGrass.GUID))
                                                            {
                                                                Debug.Log("Updating Grass " + terrainGrass.textureName + " to v2.0");
                                                                terrainGrass.GUID = System.Guid.NewGuid().ToString();
                                                            }

                                                            lbGroupGrass.lbTerrainGrassGUID = terrainGrass.GUID;
                                                            isSceneDirtyRequired = true;
                                                        }
                                                    }
                                                    if (lbGroupGrass.showInEditor) { if (GUILayout.Button("Hide", buttonCompact, GUILayout.Width(40f))) { GUI.FocusControl(null); lbGroupGrass.showInEditor = false; } }
                                                    else { if (GUILayout.Button("Show", buttonCompact, GUILayout.Width(40f))) { GUI.FocusControl(null); lbGroupGrass.showInEditor = true; } }
                                                    if (GUILayout.Button("X", buttonCompact, GUILayout.MaxWidth(20f))) { lbGroupGrassToRemove = lbGroupGrass; }

                                                    GUILayout.EndHorizontal();

                                                    if (lbGroupGrass.showInEditor)
                                                    {
                                                        lbGroupGrass.minBlendDist = EditorGUILayout.Slider(groupsGrassMinBlendDistContent, lbGroupGrass.minBlendDist * lbGroup.maxClearingRadius, -lbGroup.maxClearingRadius, lbGroup.maxClearingRadius) / lbGroup.maxClearingRadius;
                                                        lbGroupGrass.minDensity = EditorGUILayout.IntSlider(grassMinDensityContent, lbGroupGrass.minDensity, 0, 15);
                                                        if (lbGroupGrass.maxDensity < lbGroupGrass.minDensity) { lbGroupGrass.maxDensity = lbGroupGrass.minDensity; }
                                                        lbGroupGrass.maxDensity = EditorGUILayout.IntSlider(grassDensityContent, lbGroupGrass.maxDensity, 1, 15);
                                                        lbGroupGrass.useNoise = EditorGUILayout.Toggle(grassUseNoiseContent, lbGroupGrass.useNoise);
                                                        if (lbGroupGrass.useNoise)
                                                        {
                                                            lbGroupGrass.noiseTileSize = LBEditorHelper.LogarithmicSlider(grassNoiseTileSizeContent, defaultEditorLabelWidth, lbGroupGrass.noiseTileSize, 1f, 1000f, false, 10);
                                                            lbGroupGrass.noiseOctaves = EditorGUILayout.IntSlider(grassNoiseOctavesContent, lbGroupGrass.noiseOctaves, 1, 8);
                                                            lbGroupGrass.grassPlacementCutoff = EditorGUILayout.Slider(grassNoisePlacementCutoffContent, lbGroupGrass.grassPlacementCutoff, 0.01f, 1f);
                                                        }

                                                        GUILayout.BeginHorizontal();
                                                        EditorGUILayout.LabelField(groupsIsWholeGroupContent, GUILayout.MaxWidth(defaultEditorLabelWidth - 4f));
                                                        EditorGUI.BeginChangeCheck();
                                                        lbGroupGrass.isWholeGroup = EditorGUILayout.Toggle(lbGroupGrass.isWholeGroup, GUILayout.Width(25f));
                                                        if (EditorGUI.EndChangeCheck() && lbGroupGrass.isWholeGroup)
                                                        {
                                                            // Remove all Group Texture zone filters
                                                            lbGroupGrass.zoneGUIDList.Clear();
                                                            isSceneDirtyRequired = true;
                                                        }
                                                        if (grassIndex >= 0)
                                                        {
                                                            LBTerrainGrass terrainGrass = appliedGrassList[grassIndex];
                                                            if (terrainGrass.isDisabled) { grassStatus = "Disabled"; }
                                                            else if (terrainGrass.texture != null) { grassStatus = "OK"; }
                                                        }
                                                        labelText = "Status: " + grassStatus;
                                                        EditorGUILayout.LabelField(labelText, GUILayout.MaxWidth(190f));
                                                        GUILayout.EndHorizontal();

                                                        #region Grass Zones
                                                        if (!lbGroupGrass.isWholeGroup)
                                                        {
                                                            lbGroupGrass.edgeBlendDist = EditorGUILayout.Slider(groupsGrassEdgeBlendDistContent, lbGroupGrass.edgeBlendDist, 0f, lbGroup.maxClearingRadius < 50f ? lbGroup.maxClearingRadius : 50f);

                                                            EditorGUILayout.HelpBox("Zones are defined at the Group-level on the Zones option tab, then applied as filters for the grass.", MessageType.Info, true);

                                                            #region Group-level Grass Zone buttons

                                                            if (lbGroupGrass.zoneGUIDList == null) { lbGroupGrass.zoneGUIDList = new List<string>(); }
                                                            lbGroupGrassZoneToRemove = string.Empty;

                                                            EditorGUILayout.BeginHorizontal();
                                                            arrayInt = (lbGroupGrass.zoneGUIDList == null ? 0 : lbGroupGrass.zoneGUIDList.Count);
                                                            temp = arrayInt;
                                                            EditorGUILayout.LabelField("<color=" + txtColourName + ">Grass Zones Filters</color>", labelFieldRichText);
                                                            if (GUILayout.Button("+", GUILayout.MaxWidth(30f))) { arrayInt++; }
                                                            if (GUILayout.Button("-", GUILayout.MaxWidth(30f))) { arrayInt--; }
                                                            if (arrayInt < 0) { arrayInt = 0; }
                                                            EditorGUILayout.EndHorizontal();

                                                            // Add items to the list
                                                            if (arrayInt > temp)
                                                            {
                                                                if (lbGroup.zoneList != null)
                                                                {
                                                                    if (lbGroup.zoneList.Count > 0)
                                                                    {
                                                                        lbGroupGrass.zoneGUIDList.Add(lbGroup.zoneList[0].GUID);
                                                                        isSceneDirtyRequired = true;
                                                                    }
                                                                }
                                                            }
                                                            // Remove last item from the zone GUID list for the current GroupMember
                                                            else if (arrayInt < temp && temp > 0)
                                                            {
                                                                lbGroupGrassZoneToRemove = lbGroupGrass.zoneGUIDList[temp - 1];
                                                            }
                                                            // NOTE: EditorGUILayout.Separator() can add extra unwanted width
                                                            EditorGUILayout.LabelField("", GUILayout.Height(5f));

                                                            #endregion

                                                            if (lbGroup.zoneList != null)
                                                            {
                                                                // Show all the zone filters that apply to this Group-Level Grass
                                                                for (int zoneIdx = 0; zoneIdx < lbGroupGrass.zoneGUIDList.Count; zoneIdx++)
                                                                {
                                                                    lbGroupZone = null;
                                                                    string zoneGUID = lbGroupGrass.zoneGUIDList[zoneIdx];
                                                                    int groupZoneIdx = lbGroup.zoneList.FindIndex(zone => zone.GUID == zoneGUID);
                                                                    if (groupZoneIdx >= 0 && groupZoneIdx < lbGroup.zoneList.Count)
                                                                    {
                                                                        lbGroupZone = lbGroup.zoneList[groupZoneIdx];
                                                                        EditorGUILayout.BeginHorizontal();
                                                                        EditorGUILayout.LabelField(lbGroupZone.zoneMode.ToString(), GUILayout.MaxWidth(30f));
                                                                        EditorGUILayout.LabelField(lbGroupZone.zoneType.ToString(), GUILayout.MaxWidth(65f));

                                                                        EditorGUI.BeginChangeCheck();
                                                                        groupZoneIdx = EditorGUILayout.Popup(groupZoneIdx, zoneNameList.ToArray());
                                                                        if (EditorGUI.EndChangeCheck() && groupZoneIdx < lbGroup.zoneList.Count)
                                                                        {
                                                                            lbGroupZone = lbGroup.zoneList[groupZoneIdx];
                                                                            if (lbGroupZone != null)
                                                                            {
                                                                                lbGroupGrass.zoneGUIDList[zoneIdx] = lbGroupZone.GUID;
                                                                            }
                                                                        }
                                                                        if (GUILayout.Button("X", buttonCompact, GUILayout.MaxWidth(20f))) { lbGroupGrassZoneToRemove = lbGroupGrass.zoneGUIDList[zoneIdx]; }
                                                                        EditorGUILayout.EndHorizontal();
                                                                    }
                                                                    else
                                                                    {
                                                                        EditorGUILayout.HelpBox("Zone is missing at the Group level", MessageType.Warning);
                                                                    }
                                                                }

                                                                // Remove / delete zone references
                                                                if (!string.IsNullOrEmpty(lbGroupGrassZoneToRemove))
                                                                {
                                                                    int groupGrassZonePos = lbGroupGrass.zoneGUIDList.FindIndex(gpTexZ => gpTexZ == lbGroupGrassZoneToRemove);

                                                                    if (LBEditorHelper.PromptForDelete("Group Grass Zone Filter", "", groupGrassZonePos, false))
                                                                    {
                                                                        lbGroupGrass.zoneGUIDList.Remove(lbGroupGrassZoneToRemove);
                                                                        lbGroupGrassZoneToRemove = string.Empty;
                                                                        isSceneDirtyRequired = true;
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        #endregion
                                                    }
                                                }

                                                // End of the Group-level Grass
                                                GUILayout.EndVertical();
                                            }

                                            if (lbGroupGrassToRemove != null)
                                            {
                                                int groupGrassPos = lbGroup.grassList.FindIndex(gpTex => gpTex == lbGroupGrassToRemove);
                                                if (LBEditorHelper.PromptForDelete("Group Grass", "", groupGrassPos, false))
                                                {
                                                    lbGroup.grassList.Remove(lbGroupGrassToRemove);
                                                    lbGroupGrassToRemove = null;
                                                    isSceneSaveRequired = true;
                                                }
                                            }
                                        }
                                        #endregion
                                    }
                                    else { EditorGUILayout.LabelField("Grass does not apply to Uniform groups"); }
                                }
                                #endregion

                                EditorGUILayout.Separator();
                            }
                            #endregion Group Options

                            #endregion Group-level properties

                            #region GroupMembers

                            #region GroupMember-level buttons
                            // This code simulates the unity default array functionality, which editorgui can't do
                            arrayInt = lbGroup.groupMemberList.Count;
                            GUILayout.BeginHorizontal();

                            // Expand or shrink all members within the group
                            EditorGUI.BeginChangeCheck();
                            EditorGUIUtility.fieldWidth = 15f;
                            lbGroup.isMemberListExpanded = EditorGUILayout.Foldout(lbGroup.isMemberListExpanded, "", foldoutStyleNoLabel);
                            EditorGUIUtility.fieldWidth = defaultEditorFieldWidth;
                            if (EditorGUI.EndChangeCheck())
                            {
                                lbGroup.GroupMemberListExpand(lbGroup.isMemberListExpanded);
                                // If we want to expand all the members, we should also show them.
                                if (lbGroup.isMemberListExpanded) { lbGroup.showGroupMembersInEditor = true; }
                            }

                            // Show or hide all members within the group
                            lbGroup.showGroupMembersInEditor = EditorGUILayout.Foldout(lbGroup.showGroupMembersInEditor, groupsMemberShowHideAllButtonContent);

                            // No group members to insert/move/remove/delete before members are displayed in the editor
                            groupMemberToRemove = null;
                            insertGroupMemberPos = -1;
                            groupMemberToMove = null;
                            moveGroupMemberPos = -1;

                            if (lbGroup.showGroupMembersInEditor)
                            {
                                if (lbGroup.editorSearchMemberFilter == null) { lbGroup.editorSearchMemberFilter = string.Empty; }
                                lbGroup.editorSearchMemberFilter = GUILayout.TextField(lbGroup.editorSearchMemberFilter, searchTextFieldStyle);

                                // Sometimes the search text is reverse search almost seems invisible (small search icon and cancel cannot be seen)
                                // Not sure how this occurs.
                                if (GUILayout.Button("", searchCancelButtonStyle))
                                {
                                    lbGroup.editorSearchMemberFilter = string.Empty;
                                    GUI.FocusControl(null);
                                }

                                if (GUILayout.Button("+", GUILayout.MaxWidth(30f))) { arrayInt++; }
                                if (GUILayout.Button("-", GUILayout.MaxWidth(30f))) { arrayInt--; }
                            }
                            if (arrayInt < 0) { arrayInt = 0; }
                            GUILayout.EndHorizontal();
                            // Add items to the list
                            if (arrayInt > lbGroup.groupMemberList.Count)
                            {
                                temp = arrayInt - lbGroup.groupMemberList.Count;
                                for (lbGroupMemberIdx = 0; lbGroupMemberIdx < temp; lbGroupMemberIdx++)
                                {
                                    lbGroup.groupMemberList.Add(new LBGroupMember());
                                    if (lbGroup.lbGroupType == LBGroup.LBGroupType.ProceduralClearing || lbGroup.lbGroupType == LBGroup.LBGroupType.ManualClearing || lbGroup.lbGroupType == LBGroup.LBGroupType.SubGroup)
                                    {
                                        lbGroup.groupMemberList[lbGroup.groupMemberList.Count - 1].isPlacedInCentre = true;
                                    }
                                }
                                // Show last member added
                                lbGroup.GroupMemberListExpand(false);
                                lbGroup.groupMemberList[lbGroup.groupMemberList.Count - 1].showInEditor = true;

                                // Always show members after adding a new one
                                lbGroup.showGroupMembersInEditor = true;
                            }
                            // Remove last from the GroupMember list for the current Group
                            else if (arrayInt < lbGroup.groupMemberList.Count)
                            {
                                groupMemberToRemove = lbGroup.groupMemberList[lbGroup.groupMemberList.Count - 1];
                            }
                            #endregion

                            if (lbGroup.showGroupMembersInEditor)
                            {
                                #region Initialise Group Members
                                if (lbGroup.groupMemberList == null) { lbGroup.groupMemberList = new List<LBGroupMember>(); }

                                // Populate list of Group Member type: Prefab
                                if (groupMemberNameTypePrefabList == null) { groupMemberNameTypePrefabList = new List<string>(); }
                                groupMemberNameTypePrefabList.Clear();
                                groupMemberNameTypePrefabList.AddRange(lbGroup.GetMemberNameList(LBGroupMember.LBMemberType.Prefab));

                                // Populate list of Group Member type: ObjPath
                                if (groupMemberNameTypeObjPathList == null) { groupMemberNameTypeObjPathList = new List<string>(); }
                                groupMemberNameTypeObjPathList.Clear();
                                groupMemberNameTypeObjPathList.AddRange(lbGroup.GetMemberNameList(LBGroupMember.LBMemberType.ObjPath));

                                grpCurrentEvt = Event.current;

                                #endregion

                                for (lbGroupMemberIdx = 0; lbGroupMemberIdx < lbGroup.groupMemberList.Count; lbGroupMemberIdx++)
                                {
                                    lbGroupMember = lbGroup.groupMemberList[lbGroupMemberIdx];

                                    #region GroupMember
                                    if (lbGroupMember != null)
                                    {
                                        // Check if the list of members is being filtered. Ignore members not in the filter
                                        if (!lbGroupMember.IsInSearchFilter(lbGroup.editorSearchMemberFilter)) { continue; }

                                        // Start the GroupMember
                                        GUILayout.BeginVertical(EditorStyles.helpBox);

                                        #region Member-Level Buttons
                                        GUILayout.BeginHorizontal();
                                        EditorGUI.BeginChangeCheck();
                                        lbGroupMember.isDisabled = !EditorGUILayout.Toggle(!lbGroupMember.isDisabled, GUILayout.Width(20f));
                                        if (EditorGUI.EndChangeCheck() && isGroupDesignerInitialised) { lbGroupDesigner.RefreshWorkspace(); }

                                        if (lbGroupMember.lbMemberType == LBGroupMember.LBMemberType.Prefab)
                                        {
                                            labelText2 = GetPrefabName(lbGroupMember.prefab, "group member", lbGroupMember.prefabName);
                                        }
                                        else { labelText2 = " (" + (string.IsNullOrEmpty(lbGroupMember.lbObjPath.pathName) ? "MISSING PATH NAME" : lbGroupMember.lbObjPath.pathName) + ")"; }
                                        labelText = "<color=" + txtColourName + "><b>Member " + (lbGroupMemberIdx + 1) + "</b>" + labelText2 + "</color>";

                                        EditorGUILayout.LabelField(labelText, labelFieldRichText);

                                        #region Member Type
                                        if (lbGroupMember.lbMemberType == LBGroupMember.LBMemberType.Prefab)
                                        {
                                            // Switch to Object Path member type
                                            if (GUILayout.Button(groupsMemberObjectPathButtonContent, toggleCompactButtonStyleNormal, GUILayout.Width(22f)))
                                            {
                                                lbGroupMember.lbMemberType = LBGroupMember.LBMemberType.ObjPath;
                                                if (lbGroupMember.lbObjPath == null)
                                                {
                                                    lbGroupMember.lbObjPath = new LBObjPath();
                                                    if (lbGroupMember.lbObjPath != null)
                                                    {
                                                        lbGroupMember.lbObjPath.pathName = lbGroup.groupName + " objpath " + (lbGroupMemberIdx + 1).ToString("00");
                                                        if (lbGroup.lbGroupType != LBGroup.LBGroupType.Uniform)
                                                        {
                                                            // Default to same height as Group Designer plane
                                                            lbObjPath.heightAboveTerrain = 0f;
                                                        }
                                                    }
                                                }
                                                else if (string.IsNullOrEmpty(lbGroupMember.lbObjPath.pathName))
                                                {
                                                    lbGroupMember.lbObjPath.pathName = lbGroup.groupName + " objpath " + (lbGroupMemberIdx + 1).ToString("00");
                                                }

                                                lbGroupMember.useNoise = false;
                                                // By default, all main objects should appear along the path (See Layout tab)
                                                lbGroupMember.noisePlacementCutoff = 1f;
                                            }
                                        }
                                        else
                                        {
                                            // Switching to prefab, if there are any path points prompt to change
                                            if (GUILayout.Button(groupsMemberPrefabButtonContent, toggleCompactButtonStyleToggled, GUILayout.Width(22f)))
                                            {
                                                // If ObjPath Designer is open, close it and clean up.
                                                if (lbGroupMember.showObjPathDesigner)
                                                {
                                                    lbGroupMember.showObjPathDesigner = false;
                                                    // Is pathonly needs to be OFF for a ObjPath member type, else it will not be processes.
                                                    lbGroupMember.isPathOnly = false;
                                                    if (lbObjPathDesigner != null)
                                                    {
                                                        LBObjPathDesigner.ShowDesigner(landscape, ref lbObjPathDesigner, lbGroup, lbGroupMember, null, false);
                                                        LBLandscapeTerrain.RemoveExistingPrefabs(landscape, true, LBPrefabItem.PrefabItemType.ObjPathDesignerPrefab, null);
                                                    }
                                                    isSceneSaveRequired = true;
                                                }

                                                bool isSwitchMemberType = true;
                                                if (lbGroupMember.lbObjPath != null && lbGroupMember.lbObjPath.pathPointList != null && lbGroupMember.lbObjPath.pathPointList.Count > 0)
                                                {
                                                    isSwitchMemberType = EditorUtility.DisplayDialog("Switch to Member Prefab type", "Switching to a prefab member type will REMOVE any existing Object Path configuation. There is NO UNDO. Are you sure?", "Ok, remove Object Path data", "Cancel");
                                                }

                                                if (isSwitchMemberType)
                                                {
                                                    lbGroupMember.lbMemberType = LBGroupMember.LBMemberType.Prefab;
                                                    lbGroupMember.lbObjPath = null;
                                                }
                                            }
                                        }
                                        #endregion

                                        #region MOVE or INSERT group member
                                        if (GUILayout.Button(groupsMoveGroupMemberDownButtonContent, buttonCompact, GUILayout.Width(20f)))
                                        {
                                            groupMemberToMove = new LBGroupMember(lbGroupMember);
                                            // Copy the randomiseRotationY from original as it gets set to true in Copy Constructor to solve some other issue...
                                            groupMemberToMove.randomiseRotationY = lbGroupMember.randomiseRotationY;
                                            moveGroupMemberPos = lbGroupMemberIdx;
                                        }
                                        if (GUILayout.Button(groupsInsertGroupMemberButtonContent, buttonCompact, GUILayout.Width(20f))) { insertGroupMemberPos = lbGroupMemberIdx; }
                                        #endregion

                                        if (lbGroupMember.showInEditor) { if (GUILayout.Button("Hide", buttonCompact, GUILayout.Width(40f))) { GUI.FocusControl(null); lbGroupMember.showInEditor = false; } }
                                        else { if (GUILayout.Button("Show", buttonCompact, GUILayout.Width(40f))) { GUI.FocusControl(null); lbGroupMember.showInEditor = true; } }
                                        if (GUILayout.Button("X", buttonCompact, GUILayout.MaxWidth(20f))) { groupMemberToRemove = lbGroupMember; }
                                        GUILayout.EndHorizontal();
                                        #endregion Member-level Buttons

                                        #region Group Member Settings
                                        if (lbGroupMember.showInEditor)
                                        {
                                            if (lbGroupMember.lbMemberType == LBGroupMember.LBMemberType.Prefab)
                                            {
                                                int prevTab = lbGroupMember.showtabInEditor;
                                                lbGroupMember.showtabInEditor = GUILayout.Toolbar(lbGroupMember.showtabInEditor, groupsMemberDesignerToolbarContent);
                                                
                                                // If tab changed, take focus off last control. This prevents issue of control showing previous control's value
                                                if (prevTab != lbGroupMember.showtabInEditor) { GUI.FocusControl(null); }

                                                #region Group Member Prefab General Tab
                                                if (lbGroupMember.showtabInEditor == (int)LBGroupMember.LBMemberEditorTab.General)
                                                {
                                                    #region Prefab Group Member settings

                                                    #region Group Member Prefab and Preview
                                                    EditorGUILayout.BeginHorizontal();
                                                    EditorGUIUtility.fieldWidth = 15f;
                                                    lbGroupMember.showPrefabPreview = EditorGUILayout.Foldout(lbGroupMember.showPrefabPreview, "", foldoutStyleNoLabel);
                                                    EditorGUIUtility.fieldWidth = defaultEditorFieldWidth;
                                                    EditorGUI.BeginChangeCheck();
                                                    EditorGUILayout.LabelField(groupsMemberPrefabContent, GUILayout.Width(defaultEditorLabelWidth - 25f));
                                                    lbGroupMember.prefab = (GameObject)EditorGUILayout.ObjectField(lbGroupMember.prefab, typeof(GameObject), false);
                                                    if (EditorGUI.EndChangeCheck())
                                                    {
                                                        // Make sure it was a prefab and not a simple gameobject like a fbx file etc.
                                                        if (lbGroupMember.prefab != null)
                                                        {
#if UNITY_2018_3_OR_NEWER
                                                            PrefabAssetType prefabAssetType = PrefabUtility.GetPrefabAssetType(lbGroupMember.prefab);

                                                            // NotAPrefab, Regular = User created prefab, Model = imported 3D model asset, Variant = Prefab Variant, MissingAsset (unknown prefab type)
                                                            if (prefabAssetType != PrefabAssetType.Regular && prefabAssetType != PrefabAssetType.Model && prefabAssetType != PrefabAssetType.Variant)
                                                            {
                                                                lbGroupMember.prefab = null;
                                                                Debug.Log("INFO: Landscape Builder - Only user defined, variant or imported 3D asset prefabs are permitted. Ensure you are adding a prefab.");

                                                            }
#else
                                                            PrefabType prefabType = PrefabUtility.GetPrefabType(lbGroupMember.prefab);

                                                            // Preb = User created prefab. ModelPrefab = imported 3D model asset
                                                            if (prefabType != PrefabType.Prefab && prefabType != PrefabType.ModelPrefab)
                                                            {
                                                                lbGroupMember.prefab = null;
                                                                Debug.Log("INFO: Landscape Builder - Only user defined or imported 3D asset prefabs are permitted. Ensure you are adding a prefab.");
                                                            }
#endif
                                                        }

                                                        if (lbGroupMember.prefab != null) { lbGroupMember.prefabName = lbGroupMember.prefab.name; }
                                                        else { lbGroupMember.prefabName = string.Empty; }

                                                        // Always want to update the Group Designer if it is open an a prefab has changed (or been set to null)
                                                        if (isGroupDesignerInitialised) { lbGroupDesigner.RefreshWorkspace(); }
                                                    }
                                                    EditorGUILayout.EndHorizontal();

                                                    // Using the foldout the user can expand a preview of the prefab.
                                                    if (lbGroupMember.prefab != null && lbGroupMember.showPrefabPreview)
                                                    {
                                                        // Attempt to get the asset preview first
                                                        Texture2D previewTex = AssetPreview.GetAssetPreview(lbGroupMember.prefab);

                                                        // Check to see if it is still loading (which is an asynch process)
                                                        if (AssetPreview.IsLoadingAssetPreview(lbGroupMember.prefab.GetInstanceID())) { GUILayout.Label("Loading..."); }
                                                        else if (previewTex != null) { GUILayout.Label(previewTex); }
                                                        //else { GUILayout.Label(AssetPreview.GetAssetPreview(lbGroupMember.prefab)); }
                                                    }
                                                    #endregion

                                                    if ((!lbGroupMember.isCombineMesh || !lbGroupMember.isRemoveEmptyGameObjects) && lbGroupMember.maxPrefabSqrKm > 10000f)
                                                    {
                                                        EditorGUILayout.HelpBox("This setting may create too many objects in your scene which may affect editor or in-game performance.", MessageType.Warning);
                                                    }

                                                    if (!lbGroupMember.isPathOnly)
                                                    {
                                                        if (lbGroup.lbGroupType == LBGroup.LBGroupType.Uniform)
                                                        {
                                                            lbGroupMember.maxPrefabSqrKm = (int)LBEditorHelper.LogarithmicSlider(groupsMemberMaxPrefabSqKmContent, defaultEditorLabelWidth, lbGroupMember.maxPrefabSqrKm, 1f, lbGroupMember.MaxPrefabSqrKmLimit, true, 10);
                                                        }
                                                        else if (!lbGroupMember.isPlacedInCentre)
                                                        {
                                                            EditorGUI.BeginChangeCheck();
                                                            lbGroupMember.maxPrefabSqrKm = (int)LBEditorHelper.LogarithmicSlider(groupsMemberMaxPrefabSqHectareContent, defaultEditorLabelWidth, lbGroupMember.maxPrefabSqrKm / 100f, 1f, lbGroupMember.MaxPrefabSqrKmLimit / 50f, true, 10) * 100;
                                                            lbGroupMember.maxPrefabPerGroup = (int)LBEditorHelper.LogarithmicSlider(groupsMemberMaxPerGroupContent, defaultEditorLabelWidth, lbGroupMember.maxPrefabPerGroup, 1f, 10000, true, 10);
                                                            if (EditorGUI.EndChangeCheck() && isGroupDesignerInitialised) { lbGroupDesigner.RefreshWorkspace(); }
                                                        }
                                                    }

                                                    EditorGUI.BeginChangeCheck();
                                                    lbGroupMember.isCombineMesh = EditorGUILayout.Toggle(groupsMemberIsCombineMeshContent, lbGroupMember.isCombineMesh);
                                                    if (EditorGUI.EndChangeCheck() && lbGroupMember.isCombineMesh) { lbGroupMember.isKeepPrefabConnection = false; }
                                                    if (lbGroupMember.isCombineMesh)
                                                    {
                                                        lbGroupMember.isRemoveAnimator = EditorGUILayout.Toggle(groupsMemberIsRemoveAnimatorContent, lbGroupMember.isRemoveAnimator);
                                                        lbGroupMember.isRemoveEmptyGameObjects = EditorGUILayout.Toggle(groupsMemberIsRemoveEmptyGameObjectContent, lbGroupMember.isRemoveEmptyGameObjects);
                                                    }
                                                    else
                                                    {
                                                        lbGroupMember.isKeepPrefabConnection = EditorGUILayout.Toggle(groupsMemberKeepPrefabConnectionContent, lbGroupMember.isKeepPrefabConnection);
                                                    }
                                                    if (lbGroupMember.isCreateCollider && !lbGroupMember.isCombineMesh && lbGroupMember.prefab != null && lbGroupMember.maxPrefabSqrKm > 100)
                                                    {
                                                        EditorGUILayout.HelpBox("Adding a mesh collider to every prefab (and all it's meshes) can be a big performance hit. Use for a small amount of prefabs in the scene or enable Combine Meshes.", MessageType.Warning, true);
                                                    }
                                                    lbGroupMember.isCreateCollider = EditorGUILayout.Toggle(groupsMemberAddMeshColliderContent, lbGroupMember.isCreateCollider);
                                                    #endregion

                                                    #region Group Member Override Group defaults
                                                    EditorGUI.BeginChangeCheck();
                                                    lbGroupMember.isGroupOverride = EditorGUILayout.Toggle(groupsMemberOverrideContent, lbGroupMember.isGroupOverride);
                                                    if (EditorGUI.EndChangeCheck())
                                                    {
                                                        if (lbGroupMember.isGroupOverride)
                                                        {
                                                            // Copy Group defaults to the member
                                                            lbGroupMember.minScale = lbGroup.minScale;
                                                            lbGroupMember.maxScale = lbGroup.maxScale;
                                                            lbGroupMember.minHeight = lbGroup.minHeight;
                                                            lbGroupMember.maxHeight = lbGroup.maxHeight;
                                                            lbGroupMember.minInclination = lbGroup.minInclination;
                                                            lbGroupMember.maxInclination = lbGroup.maxInclination;
                                                        }
                                                        if (isGroupDesignerInitialised) { lbGroupDesigner.UpdateGroupMember(lbGroupMember); }
                                                    }

                                                    if (lbGroupMember.isGroupOverride)
                                                    {
                                                        EditorGUI.BeginChangeCheck();
                                                        lbGroupMember.minScale = EditorGUILayout.Slider(groupsMemberMinScaleContent, lbGroupMember.minScale, 0.1f, 50f);
                                                        lbGroupMember.maxScale = EditorGUILayout.Slider(groupsMemberMaxScaleContent, lbGroupMember.maxScale, 0.1f, 50f);
                                                        if (lbGroupMember.maxScale < lbGroupMember.minScale) { lbGroupMember.maxScale = lbGroupMember.minScale; }
                                                        if (EditorGUI.EndChangeCheck() && isGroupDesignerInitialised) { lbGroupDesigner.UpdateGroupMember(lbGroupMember); }

                                                        lbGroupMember.minHeight = EditorGUILayout.Slider(groupsMemberMinHeightContent, lbGroupMember.minHeight * terrainHeight, 0f, terrainHeight) / terrainHeight;
                                                        lbGroupMember.maxHeight = EditorGUILayout.Slider(groupsMemberMaxHeightContent, lbGroupMember.maxHeight * terrainHeight, 0f, terrainHeight) / terrainHeight;
                                                        if (lbGroupMember.maxHeight < lbGroupMember.minHeight) { lbGroupMember.maxHeight = lbGroupMember.minHeight; }

                                                        lbGroupMember.minInclination = EditorGUILayout.Slider(groupsMemberMinInclinationContent, lbGroupMember.minInclination, 0f, 90f);
                                                        lbGroupMember.maxInclination = EditorGUILayout.Slider(groupsMemberMaxInclinationContent, lbGroupMember.maxInclination, 0f, 90f);
                                                        if (lbGroupMember.maxInclination < lbGroupMember.minInclination) { lbGroupMember.maxInclination = lbGroupMember.minInclination; }
                                                    }
                                                    #endregion

                                                    #region Group Member Noise

                                                    EditorGUI.BeginChangeCheck();
                                                    lbGroupMember.useNoise = EditorGUILayout.Toggle(groupsUseNoiseContent, lbGroupMember.useNoise);
                                                    if (lbGroupMember.useNoise)
                                                    {
                                                        lbGroupMember.noiseTileSize = LBEditorHelper.LogarithmicSlider(groupsNoiseTileSizeContent, defaultEditorLabelWidth, lbGroupMember.noiseTileSize, 1f, 10000f, true, 10);
                                                        lbGroupMember.noisePlacementCutoff = EditorGUILayout.Slider(groupsNoisePlacementCutoffContent, lbGroupMember.noisePlacementCutoff, 0.1f, 1f);
                                                    }
                                                    if (EditorGUI.EndChangeCheck())
                                                    {
                                                        if (isGroupDesignerInitialised) { lbGroupDesigner.RefreshWorkspace(); }
                                                    }

                                                    #endregion

                                                    #region Group Member Terrain

                                                    // Flatten is for individual members is not available if isTerrainFlattened is enabled for Clearings.
                                                    if (!((lbGroup.lbGroupType == LBGroup.LBGroupType.ProceduralClearing || lbGroup.lbGroupType == LBGroup.LBGroupType.ManualClearing || lbGroup.lbGroupType == LBGroup.LBGroupType.SubGroup) && lbGroup.isTerrainFlattened))
                                                    {
                                                        // Terrain Align and Terrain Flatten are mutually exclusive
                                                        if (!lbGroupMember.isTerrainFlattened)
                                                        {
                                                            EditorGUI.BeginChangeCheck();
                                                            lbGroupMember.isTerrainAligned = EditorGUILayout.Toggle(groupsMemberAlignWithTerrainContent, lbGroupMember.isTerrainAligned);
                                                            if (EditorGUI.EndChangeCheck())
                                                            {
                                                                // isTerrainAligned and usePathSlope are mutually exclusive
                                                                if (lbGroupMember.isTerrainAligned) { lbGroupMember.usePathSlope = false; }
                                                            }
                                                        }

                                                        // Member flatten terrain
                                                        EditorGUI.BeginChangeCheck();
                                                        lbGroupMember.isTerrainFlattened = EditorGUILayout.Toggle(groupsMemberIsTerrainFlattenContent, lbGroupMember.isTerrainFlattened);
                                                        if (EditorGUI.EndChangeCheck() && lbGroupMember.isTerrainAligned) { lbGroupMember.isTerrainAligned = false; }
                                                        if (lbGroupMember.isTerrainFlattened)
                                                        {
                                                            EditorGUI.BeginChangeCheck();
                                                            lbGroupMember.flattenDistance = EditorGUILayout.Slider(groupsMemberFlattenDistanceContent, lbGroupMember.flattenDistance, 0.1f, 100f);
                                                            lbGroupMember.flattenBlendRate = EditorGUILayout.Slider(groupsMemberFlattenBlendRateContent, lbGroupMember.flattenBlendRate, 0.01f, 1f);
                                                            lbGroupMember.flattenHeightOffset = EditorGUILayout.Slider(groupsMemberFlattenHeightOffsetContent, lbGroupMember.flattenHeightOffset, (terrainHeight * -0.25f), terrainHeight * 0.25f);
                                                            if (EditorGUI.EndChangeCheck())
                                                            {
                                                                if (isGroupDesignerEnabled) { SceneView.RepaintAll(); }
                                                            }

                                                            if (GUILayout.Button(groupsMemberFlattenCalcDistanceContent, GUILayout.Width(defaultEditorLabelWidth)))
                                                            {
                                                                if (lbGroupMember.prefab != null)
                                                                {
                                                                    GUI.FocusControl(null);
                                                                    Bounds prefabBounds = LBMeshOperations.GetBounds(lbGroupMember.prefab.transform, false, true);

                                                                    // Extents are always half the size, so multiple by 2. Then extend the flatten area to allow for blending with the surrounds
                                                                    lbGroupMember.flattenDistance = (prefabBounds.extents.x > prefabBounds.extents.z ? prefabBounds.extents.x : prefabBounds.extents.z) * 5.0f;
                                                                    lbGroupMember.flattenBlendRate = 0.5f;
                                                                }
                                                            }
                                                        }
                                                    }
                                                    #endregion
                                                }
                                                #endregion

                                                #region Group Member Prefab XYZ Settings Tab
                                                else if (lbGroupMember.showtabInEditor == (int)LBGroupMember.LBMemberEditorTab.XYZ)
                                                {
                                                    if (!lbGroupMember.isPathOnly && (lbGroup.lbGroupType == LBGroup.LBGroupType.ProceduralClearing || lbGroup.lbGroupType == LBGroup.LBGroupType.ManualClearing || lbGroup.lbGroupType == LBGroup.LBGroupType.SubGroup))
                                                    {
                                                        EditorGUI.BeginChangeCheck();
                                                        lbGroupMember.isPlacedInCentre = EditorGUILayout.Toggle(groupsMemberIsPlacedInCentreContent, lbGroupMember.isPlacedInCentre);
                                                        if (EditorGUI.EndChangeCheck())
                                                        {
                                                            if (!lbGroupMember.isPlacedInCentre)
                                                            {
                                                                // Reset offset when turning off isPlacedInCentre
                                                                lbGroupMember.minOffsetX = 0f;
                                                                lbGroupMember.minOffsetZ = 0f;
                                                            }

                                                            // Turning off/on isPlacedInCentre for a member could significantly change the layout, so refresh the entire workspace
                                                            if (isGroupDesignerInitialised) { lbGroupDesigner.RefreshWorkspace(); }
                                                        }
                                                    }

                                                    EditorGUI.BeginChangeCheck();

                                                    #region Group Member Offset

                                                    // Position offset of each instance
                                                    if (lbGroupMember.isPlacedInCentre && !lbGroupMember.isPathOnly)
                                                    {
                                                        EditorGUILayout.BeginHorizontal();
                                                        EditorGUILayout.LabelField(groupsMemberMinOffsetXZContent, GUILayout.Width(EditorGUIUtility.labelWidth));
                                                        EditorGUILayout.LabelField("X", GUILayout.Width(15f));
                                                        lbGroupMember.minOffsetX = EditorGUILayout.FloatField(lbGroupMember.minOffsetX, GUILayout.Width(60f));
                                                        EditorGUILayout.LabelField("Z", GUILayout.Width(15f));
                                                        lbGroupMember.minOffsetZ = EditorGUILayout.FloatField(lbGroupMember.minOffsetZ, GUILayout.Width(60f));
                                                        EditorGUILayout.EndHorizontal();
                                                    }

                                                    // Model offset
                                                    EditorGUILayout.BeginHorizontal();
                                                    EditorGUILayout.LabelField(groupsMemberModelOffsetXYZContent, GUILayout.Width(EditorGUIUtility.labelWidth));
                                                    EditorGUILayout.LabelField("X", GUILayout.Width(15f));
                                                    lbGroupMember.modelOffsetX = EditorGUILayout.FloatField(lbGroupMember.modelOffsetX, GUILayout.Width(45f));
                                                    EditorGUILayout.LabelField("Y", GUILayout.Width(15f));
                                                    lbGroupMember.modelOffsetY = EditorGUILayout.FloatField(lbGroupMember.modelOffsetY, GUILayout.Width(45f));
                                                    EditorGUILayout.LabelField("Z", GUILayout.Width(15f));
                                                    lbGroupMember.modelOffsetZ = EditorGUILayout.FloatField(lbGroupMember.modelOffsetZ, GUILayout.Width(45f));
                                                    EditorGUILayout.EndHorizontal();

                                                    lbGroupMember.randomiseOffsetY = EditorGUILayout.Toggle(groupsMemberRandomiseOffsetYContent, lbGroupMember.randomiseOffsetY);
                                                    if (lbGroupMember.randomiseOffsetY)
                                                    {
                                                        lbGroupMember.minOffsetY = LBEditorHelper.LogarithmicSlider(groupsMemberMinOffsetYContent, defaultEditorLabelWidth, lbGroupMember.minOffsetY, -terrainHeight * 0.25f, terrainHeight * 0.25f, false, 10);
                                                        lbGroupMember.maxOffsetY = LBEditorHelper.LogarithmicSlider(groupsMemberMaxOffsetYContent, defaultEditorLabelWidth, lbGroupMember.maxOffsetY, -terrainHeight * 0.25f, terrainHeight * 0.25f, false, 10);
                                                    }
                                                    else
                                                    {
                                                        lbGroupMember.minOffsetY = LBEditorHelper.LogarithmicSlider(groupsMemberMinOffsetYRandomiseOffContent, defaultEditorLabelWidth, lbGroupMember.minOffsetY, -terrainHeight * 0.25f, terrainHeight * 0.25f, false, 10);
                                                    }
                                                    if (lbGroupMember.maxOffsetY < lbGroupMember.minOffsetY) { lbGroupMember.maxOffsetY = lbGroupMember.minOffsetY; }

                                                    #endregion

                                                    #region Group Member Prefab Rotation
                                                    if (lbGroup.lbGroupType == LBGroup.LBGroupType.ProceduralClearing || lbGroup.lbGroupType == LBGroup.LBGroupType.ManualClearing || lbGroup.lbGroupType == LBGroup.LBGroupType.SubGroup)
                                                    {
                                                        lbGroupMember.rotationType = (LBGroupMember.LBRotationType)EditorGUILayout.EnumPopup(groupsMemberRotationTypeContent, lbGroupMember.rotationType);
                                                    }

                                                    lbGroupMember.randomiseRotationY = EditorGUILayout.Toggle(groupsMemberRandomiseRotationYContent, lbGroupMember.randomiseRotationY);
                                                    if (lbGroupMember.randomiseRotationY)
                                                    {
                                                        lbGroupMember.startRotationY = EditorGUILayout.Slider(groupsMemberStartRotationYContent, lbGroupMember.startRotationY, -359.9f, 359.9f);
                                                        lbGroupMember.endRotationY = EditorGUILayout.Slider(groupsMemberEndRotationYContent, lbGroupMember.endRotationY, -359.9f, 359.9f);
                                                    }
                                                    else
                                                    {
                                                        lbGroupMember.startRotationY = EditorGUILayout.Slider(groupsMemberFixedRotationYContent, lbGroupMember.startRotationY, -359.9f, 359.9f);
                                                    }

                                                    lbGroupMember.randomiseRotationXZ = EditorGUILayout.Toggle(groupsMemberRandomiseRotationXZContent, lbGroupMember.randomiseRotationXZ);
                                                    if (lbGroupMember.randomiseRotationXZ)
                                                    {
                                                        lbGroupMember.rotationX = EditorGUILayout.Slider(groupsMemberStartRotationXContent, lbGroupMember.rotationX, -359.9f, 359.9f);
                                                        lbGroupMember.endRotationX = EditorGUILayout.Slider(groupsMemberEndRotationXContent, lbGroupMember.endRotationX, -359.9f, 359.9f);
                                                        lbGroupMember.rotationZ = EditorGUILayout.Slider(groupsMemberStartRotationZContent, lbGroupMember.rotationZ, -359.9f, 359.9f);
                                                        lbGroupMember.endRotationZ = EditorGUILayout.Slider(groupsMemberEndRotationZContent, lbGroupMember.endRotationZ, -359.9f, 359.9f);
                                                    }
                                                    else
                                                    {
                                                        EditorGUILayout.BeginHorizontal();
                                                        EditorGUILayout.LabelField(groupsMemberOverrideRotationContent, GUILayout.Width(EditorGUIUtility.labelWidth));
                                                        EditorGUILayout.LabelField("X", GUILayout.Width(15f));
                                                        lbGroupMember.rotationX = EditorGUILayout.FloatField(lbGroupMember.rotationX, GUILayout.Width(60f));
                                                        EditorGUILayout.LabelField("Z", GUILayout.Width(15f));
                                                        lbGroupMember.rotationZ = EditorGUILayout.FloatField(lbGroupMember.rotationZ, GUILayout.Width(60f));
                                                        EditorGUILayout.EndHorizontal();
                                                    }
                                                    #endregion

                                                    // If the Group Member Offset or Rotation has changed and the Designer
                                                    // is displayed, update the settings in the Designer
                                                    if (EditorGUI.EndChangeCheck())
                                                    {
                                                        if (lbGroupMember.rotationType == LBGroupMember.LBRotationType.Face2GroupCentre && lbGroupMember.isPlacedInCentre)
                                                        {
                                                            lbGroupMember.rotationType = LBGroupMember.LBRotationType.WorldSpace;
                                                            Debug.Log("Face 2 Group Centre is not available when Place In Centre with Offset is set");
                                                            isSceneSaveRequired = true;
                                                        }

                                                        // Update Offset and/or Rotation in GroupDesigner
                                                        if (isGroupDesignerInitialised)
                                                        {
                                                            lbGroupDesigner.UpdateGroupMember(lbGroupMember);
                                                        }
                                                    }
                                                }
                                                #endregion

                                                #region Group Member Prefab Proximity Tab
                                                else if (lbGroupMember.showtabInEditor == (int)LBGroupMember.LBMemberEditorTab.Proximity)
                                                {
                                                    #region Group Member Proximity

                                                    EditorGUI.BeginChangeCheck();
                                                    lbGroupMember.proximityExtent = LBEditorHelper.LogarithmicSlider(groupsMemberProximityExtentContent, defaultEditorLabelWidth, lbGroupMember.proximityExtent, 0.01f, 10000f, false, 10);

                                                    // Don't force refresh unless AutoRefresh is enabled (else could be quite laggy).
                                                    if (EditorGUI.EndChangeCheck() && isGroupDesignerInitialised) { lbGroupDesigner.RefreshWorkspace(false); SceneView.RepaintAll();  }

                                                    EditorGUI.BeginChangeCheck();
                                                    lbGroupMember.isIgnoreProximityOfOthers = EditorGUILayout.Toggle(groupsMemberIsIgnoreProximityOfOthersContent, lbGroupMember.isIgnoreProximityOfOthers);
                                                    lbGroupMember.isProximityIgnoredByOthers = EditorGUILayout.Toggle(groupsMemberIsProximityIgnoredByOthersContent, lbGroupMember.isProximityIgnoredByOthers);
                                                    if (EditorGUI.EndChangeCheck() && isGroupDesignerInitialised) { lbGroupDesigner.RefreshWorkspace(false); SceneView.RepaintAll(); }

                                                    lbGroupMember.minGrassProximity = EditorGUILayout.Slider(groupsMinGrassProximityContent, lbGroupMember.minGrassProximity, 0f, 25f);
                                                    if (lbGroupMember.minGrassProximity > 0f)
                                                    {
                                                        lbGroupMember.removeGrassBlendDist = EditorGUILayout.Slider(groupsMemberRemoveGrassBlendDistContent, lbGroupMember.removeGrassBlendDist * lbGroupMember.minGrassProximity, 0f, lbGroupMember.minGrassProximity) / lbGroupMember.minGrassProximity;
                                                    }

                                                    lbGroupMember.isRemoveTree = EditorGUILayout.Toggle(groupsIsRemoveTreeContent, lbGroupMember.isRemoveTree);
                                                    lbGroupMember.minTreeProximity = EditorGUILayout.Slider(groupsMinTreeProximityContent, lbGroupMember.minTreeProximity, 0f, 100f);

                                                    if (GUILayout.Button(groupsMemberCalcProximityButtonContent, GUILayout.Width(defaultEditorLabelWidth)))
                                                    {
                                                        if (lbGroupMember.prefab != null)
                                                        {
                                                            GUI.FocusControl(null);
                                                            // Estimate the proximity of prefabs.
                                                            lbGroupMember.UpdateProximity(LBMeshOperations.GetBounds(lbGroupMember.prefab.transform, false, true));                                                          
                                                        }
                                                    }

                                                    #endregion

                                                }
                                                #endregion

                                                #region Group Member Prefab Zone Tab
                                                else if (lbGroupMember.showtabInEditor == (int)LBGroupMember.LBMemberEditorTab.Zone)
                                                {
                                                    EditorGUILayout.HelpBox("Zones may be used to restrict where items are placed, or not placed, within a clearing group. Zones are defined at the Group-level, then applied as filters here for clearing members.", MessageType.Info, true);

                                                    groupMemberZoneToRemove = string.Empty;

                                                    if (lbGroup.lbGroupType == LBGroup.LBGroupType.ProceduralClearing || lbGroup.lbGroupType == LBGroup.LBGroupType.ManualClearing || lbGroup.lbGroupType == LBGroup.LBGroupType.SubGroup)
                                                    {
                                                        if (lbGroupMember.zoneGUIDList == null) { lbGroupMember.zoneGUIDList = new List<string>(); }

                                                        arrayInt = (lbGroupMember.zoneGUIDList == null ? 0 : lbGroupMember.zoneGUIDList.Count);
                                                        temp = arrayInt;

                                                        if (arrayInt > 0 && lbGroupMember.isPlacedInCentre)
                                                        {
                                                            EditorGUILayout.HelpBox("Zones have no effect with prefabs that have Place In Centre (with or without an XZ offset)", MessageType.Warning, true);
                                                        }

                                                        EditorGUILayout.BeginHorizontal();
                                                        EditorGUILayout.LabelField("<color=" + txtColourName + ">Zones Filters</color>", labelFieldRichText);
                                                        if (GUILayout.Button("+", GUILayout.MaxWidth(30f))) { arrayInt++; }
                                                        if (GUILayout.Button("-", GUILayout.MaxWidth(30f))) { arrayInt--; }
                                                        if (arrayInt < 0) { arrayInt = 0; }
                                                        EditorGUILayout.EndHorizontal();

                                                        // Add items to the list
                                                        if (arrayInt > temp)
                                                        {
                                                            string zoneGUID = string.Empty;
                                                            if (lbGroup.zoneList != null)
                                                            {
                                                                if (lbGroup.zoneList.Count > 0)
                                                                {
                                                                    zoneGUID = lbGroup.zoneList[0].GUID;
                                                                    lbGroupMember.zoneGUIDList.Add(zoneGUID);
                                                                    // Update the designer if required
                                                                    if (isGroupDesignerInitialised) { lbGroupDesigner.RefreshWorkspace(); }
                                                                    isSceneDirtyRequired = true;
                                                                }
                                                            }
                                                        }
                                                        // Remove last item from the zone GUID list for the current GroupMember
                                                        else if (arrayInt < temp && temp > 0)
                                                        {
                                                            groupMemberZoneToRemove = lbGroupMember.zoneGUIDList[temp - 1];
                                                        }
                                                        EditorGUILayout.Separator();
                                                    }

                                                    if (lbGroup.zoneList != null)
                                                    {
                                                        // Show all the zone filters that apply to this group member
                                                        for (int zoneIdx = 0; zoneIdx < lbGroupMember.zoneGUIDList.Count; zoneIdx++)
                                                        {
                                                            lbGroupZone = null;
                                                            string zoneGUID = lbGroupMember.zoneGUIDList[zoneIdx];
                                                            int groupZoneIdx = lbGroup.zoneList.FindIndex(zone => zone.GUID == zoneGUID);
                                                            if (groupZoneIdx >= 0 && groupZoneIdx < lbGroup.zoneList.Count)
                                                            {
                                                                lbGroupZone = lbGroup.zoneList[groupZoneIdx];
                                                                EditorGUILayout.BeginHorizontal();
                                                                EditorGUILayout.LabelField(lbGroupZone.zoneMode.ToString(), GUILayout.MaxWidth(30f));
                                                                EditorGUILayout.LabelField(lbGroupZone.zoneType.ToString(), GUILayout.MaxWidth(65f));

                                                                EditorGUI.BeginChangeCheck();
                                                                groupZoneIdx = EditorGUILayout.Popup(groupZoneIdx, zoneNameList.ToArray());
                                                                if (EditorGUI.EndChangeCheck() && groupZoneIdx < lbGroup.zoneList.Count)
                                                                {
                                                                    lbGroupZone = lbGroup.zoneList[groupZoneIdx];
                                                                    if (lbGroupZone != null)
                                                                    {
                                                                        lbGroupMember.zoneGUIDList[zoneIdx] = lbGroupZone.GUID;
                                                                        // Update the designer if required
                                                                        if (isGroupDesignerInitialised) { lbGroupDesigner.RefreshWorkspace(); }
                                                                    }
                                                                }
                                                                if (GUILayout.Button("X", buttonCompact, GUILayout.MaxWidth(20f))) { groupMemberZoneToRemove = lbGroupMember.zoneGUIDList[zoneIdx]; }
                                                                EditorGUILayout.EndHorizontal();
                                                            }
                                                            else
                                                            {
                                                                EditorGUILayout.HelpBox("Zone is missing at the Group level", MessageType.Warning);
                                                            }
                                                        }

                                                        // Remove / delete zone references
                                                        if (!string.IsNullOrEmpty(groupMemberZoneToRemove))
                                                        {
                                                            int groupMemberZonePos = lbGroupMember.zoneGUIDList.FindIndex(gpTexZ => gpTexZ == groupMemberZoneToRemove);

                                                            if (LBEditorHelper.PromptForDelete("Group Member Zone Filter", "", groupMemberZonePos, false))
                                                            {
                                                                lbGroupMember.zoneGUIDList.Remove(groupMemberZoneToRemove);
                                                                groupMemberZoneToRemove = string.Empty;
                                                                // Update the designer if required
                                                                if (isGroupDesignerInitialised) { lbGroupDesigner.RefreshWorkspace(); }
                                                                isSceneDirtyRequired = true;
                                                            }
                                                        }
                                                    }

                                                    #region Group Member Zone Edge Fill (clearings only)
                                                    if (lbGroup.lbGroupType == LBGroup.LBGroupType.ProceduralClearing || lbGroup.lbGroupType == LBGroup.LBGroupType.ManualClearing || lbGroup.lbGroupType == LBGroup.LBGroupType.SubGroup)
                                                    {
                                                        EditorGUI.BeginChangeCheck();
                                                        EditorGUILayout.BeginHorizontal();
                                                        EditorGUILayout.LabelField(groupsMemberZoneEdgeFillContent, GUILayout.Width(EditorGUIUtility.labelWidth));
                                                        EditorGUILayout.LabelField("T", GUILayout.Width(15f));
                                                        lbGroupMember.isZoneEdgeFillTop = EditorGUILayout.Toggle(lbGroupMember.isZoneEdgeFillTop, GUILayout.Width(20f));
                                                        EditorGUILayout.LabelField("B", GUILayout.Width(15f));
                                                        lbGroupMember.isZoneEdgeFillBottom = EditorGUILayout.Toggle(lbGroupMember.isZoneEdgeFillBottom, GUILayout.Width(20f));
                                                        EditorGUILayout.LabelField("L", GUILayout.Width(15f));
                                                        lbGroupMember.isZoneEdgeFillLeft = EditorGUILayout.Toggle(lbGroupMember.isZoneEdgeFillLeft, GUILayout.Width(20f));
                                                        EditorGUILayout.LabelField("R", GUILayout.Width(15f));
                                                        lbGroupMember.isZoneEdgeFillRight = EditorGUILayout.Toggle(lbGroupMember.isZoneEdgeFillRight, GUILayout.Width(20f));
                                                        EditorGUILayout.EndHorizontal();
                                                        if (EditorGUI.EndChangeCheck())
                                                        {
                                                            if (isGroupDesignerInitialised) { lbGroupDesigner.RefreshWorkspace(); }
                                                        }

                                                        lbGroupMember.zoneEdgeFillDistance = EditorGUILayout.Slider(groupsMemberZoneEdgeFillDistContent, lbGroupMember.zoneEdgeFillDistance, 0f, lbGroup.maxClearingRadius);
                                                    }
                                                    #endregion
                                                }
                                                #endregion

                                                #region Group Member Prefab Path Tab
                                                else if (lbGroupMember.showtabInEditor == (int)LBGroupMember.LBMemberEditorTab.Path)
                                                {
                                                    EditorGUILayout.HelpBox("When a member prefab is placed in path, the following attributes apply. To create a path, add a new member and change the type to (O)bject Path", MessageType.Info, true);

                                                    EditorGUI.BeginChangeCheck();
                                                    //EditorGUILayout.LabelField("GUID: " + lbGroupMember.GUID);
                                                    lbGroupMember.isPathOnly = EditorGUILayout.Toggle(groupsMemberIsPathOnlyContent, lbGroupMember.isPathOnly);

                                                    if (lbGroupMember.isTerrainAligned && lbGroupMember.lbObjectOrientation == LBObjPath.LBObjectOrientation.PathSpace)
                                                    {
                                                        lbGroupMember.isLockTilt = EditorGUILayout.Toggle(groupsMemberIsLockTiltContent, lbGroupMember.isLockTilt);
                                                    }

                                                    lbGroupMember.usePathHeight = EditorGUILayout.Toggle(groupsMemberUsePathHeightContent, lbGroupMember.usePathHeight);
                                                    if (EditorGUI.EndChangeCheck())
                                                    {
                                                        if (isGroupDesignerInitialised) { lbGroupDesigner.RefreshWorkspace(); }
                                                    }

                                                    if (lbGroupMember.usePathHeight && lbGroup.lbGroupType != LBGroup.LBGroupType.Uniform)
                                                    {
                                                        lbGroupMember.useTerrainTrend = EditorGUILayout.Toggle(groupsMemberUseTerrainTrendContent, lbGroupMember.useTerrainTrend);
                                                    }

                                                    EditorGUI.BeginChangeCheck();
                                                    lbGroupMember.usePathSlope = EditorGUILayout.Toggle(groupsMemberUsePathSlopeContent, lbGroupMember.usePathSlope);
                                                    if (EditorGUI.EndChangeCheck())
                                                    {
                                                        // Turn off terrain aligned as usePathSlope and isTerrainAligned are mutually exclusive
                                                        if (lbGroupMember.isTerrainAligned) { lbGroupMember.isTerrainAligned = false; }
                                                        if (isGroupDesignerInitialised) { lbGroupDesigner.RefreshWorkspace(); }
                                                    }

                                                    EditorGUI.BeginChangeCheck();
                                                    lbGroupMember.lbObjectOrientation = (LBObjPath.LBObjectOrientation)EditorGUILayout.EnumPopup(groupsMemberPathObjOrientationContent, lbGroupMember.lbObjectOrientation);
                                                    if (EditorGUI.EndChangeCheck())
                                                    {
                                                        if (isGroupDesignerInitialised) { lbGroupDesigner.RefreshWorkspace(); }
                                                    }
                                                }
                                                #endregion
                                            }
                                            else
                                            {
                                                if (lbGroupMember.lbObjPath == null) { lbGroupMember.lbObjPath = new LBObjPath(); }
                                                lbObjPath = lbGroupMember.lbObjPath;

                                                #region Object Path Designer
                                                isObjPathDesignerInitialised = false;

                                                if (lbGroupMember.showObjPathDesigner)
                                                {
                                                    // Close Object Path Designer
                                                    GUILayout.BeginHorizontal();
                                                    if (GUILayout.Button(isGroupDesignerInitialised ? groupsMemberObjPathDesignerClearingButtonContent : groupsMemberObjPathDesignerButtonContent, toggleCompactButtonStyleToggled, GUILayout.Width(120f)))
                                                    {
                                                        LBObjPathDesigner.ShowDesigner(landscape, ref lbObjPathDesigner, lbGroup, lbGroupMember, null, false);
                                                        LBLandscapeTerrain.RemoveExistingPrefabs(landscape, true, LBPrefabItem.PrefabItemType.ObjPathDesignerPrefab, null);

                                                        // Restore the heightmap to how it was before entering ObjPath Editor mode
                                                        if (landscape.useGPUPath && lbObjPath.useWidth && lbGroup.lbGroupType == LBGroup.LBGroupType.Uniform)
                                                        {
                                                            EditorUtility.DisplayProgressBar("Restoring heightmap", "PLEASE WAIT", 0.1f);
                                                            landscape.RevertHeightmap1D("RP_" + lbGroupMember.GUID, true, true);

                                                            // In LB 2.2.0+ we also need to check subGroups for potential splatmap changes
                                                            if (LBGroup.IsApplyObjPathTexturesPresent(lbGroupList, lbGroup, lbObjPath))
                                                            //if (!string.IsNullOrEmpty(lbObjPath.coreTextureGUID) || !string.IsNullOrEmpty(lbObjPath.surroundTextureGUID))
                                                            {
                                                                EditorUtility.DisplayProgressBar("Restoring splatmaps", "PLEASE WAIT", 0.2f);
                                                                landscape.RevertTextures1D("RP_" + lbGroupMember.GUID, true);
                                                            }

                                                            if (lbObjPath.isRemoveExistingTrees)
                                                            {
                                                                EditorUtility.DisplayProgressBar("Restoring trees", "PLEASE WAIT", 0.3f);
                                                                landscape.RevertTrees1D("RP_" + lbGroupMember.GUID, true);
                                                            }

#if VEGETATION_STUDIO_PRO
                                                            if (landscape.useVegetationSystem)
                                                            {
                                                                LBIntegration.VegetationStudioProRefresh(true);
                                                            }
#endif

                                                            EditorUtility.ClearProgressBar();
                                                        }

                                                        if (isGroupDesignerInitialised && lbGroupDesigner != null)
                                                        {
                                                            lbGroupDesigner.isObjDesignerEnabled = false;
                                                            lbGroupDesigner.isShowPrefabWarning = true;
                                                            if (lbGroupDesigner.GetAutoRefresh) { lbGroupDesigner.RefreshWorkspace(true); }
                                                        }
                                                        // Save the scene when the designer is closed by the user
                                                        isSceneSaveRequired = true;
                                                    }
                                                    else if (lbObjPathDesigner != null)
                                                    {
                                                        isObjPathDesignerInitialised = lbObjPathDesigner.isInitialised;
                                                    }

                                                    if (GUILayout.Button(groupsMemberObjPathRefreshButtonContent, GUILayout.MaxWidth(60f)))
                                                    {
                                                        RefreshObjPath(lbGroup, lbGroupMember, lbGroupDesigner, isGroupDesignerInitialised);
                                                    }

                                                    GUILayout.EndHorizontal();
                                                }
                                                // There can only be one Object Path Designer enabled at any one time
                                                else if (lbGroup.lbGroupType == LBGroup.LBGroupType.Uniform && (!isGroupDesignerEnabled && !isObjPathDesignerEnabled))
                                                {
                                                    if (GUILayout.Button(groupsMemberObjPathDesignerButtonContent, toggleCompactButtonStyleNormal, GUILayout.Width(120f)))
                                                    {
                                                        lbGroupMember.showObjPathDesigner = LBObjPathDesigner.ShowDesigner(landscape, ref lbObjPathDesigner, lbGroup, lbGroupMember, null, true);
                                                    }
                                                }
                                                // This is a Procedural or Manual Clearing, the GroupDesigner IS enabled (for this group) AND the ObjPathDesigner is not currently in use
                                                else if (lbGroup.lbGroupType != LBGroup.LBGroupType.Uniform && isGroupDesignerEnabled && !isObjPathDesignerEnabled && lbGroup.showGroupDesigner)
                                                {
                                                    if (GUILayout.Button(groupsMemberObjPathDesignerClearingButtonContent, toggleCompactButtonStyleNormal, GUILayout.Width(120f)))
                                                    {
                                                        //Debug.Log("Enable ObjPathDesigner while in GroupDesigner");
                                                        lbGroupMember.showObjPathDesigner = LBObjPathDesigner.ShowDesigner(landscape, ref lbObjPathDesigner, lbGroup, lbGroupMember, lbGroupDesigner, true);
                                                    }
                                                }
                                                #endregion

                                                int prevTab = lbGroupMember.showtabInEditor;
                                                if (lbGroupMember.showtabInEditor > 3) { lbGroupMember.showtabInEditor = 0; }
                                                lbGroupMember.showtabInEditor = GUILayout.Toolbar(lbGroupMember.showtabInEditor, groupsMemberObjPathToolbarContent);

                                                // If tab changed, take focus off last control. This prevents issue of control showing previous control's value
                                                if (prevTab != lbGroupMember.showtabInEditor) { GUI.FocusControl(null); }

                                                #region Group Member Object Path General Tab
                                                if (lbGroupMember.showtabInEditor == (int)LBGroupMember.LBMemberEditorPathTab.General)
                                                {
                                                    #region Name and Path Length
                                                    EditorGUILayout.HelpBox("Path length: " + lbObjPath.splineLength.ToString("0.00") + "m", MessageType.Info);

                                                    EditorGUI.BeginChangeCheck();
                                                    lbObjPath.pathName = EditorGUILayout.TextField(groupsMemberPathNameContent, lbObjPath.pathName);

                                                    if (EditorGUI.EndChangeCheck())
                                                    {
                                                        // Should have a name
                                                        isSceneDirtyRequired = true;
                                                    }

                                                    if (string.IsNullOrEmpty(lbObjPath.pathName) || lbObjPath.pathName.ToLower() == "object path")
                                                    {
                                                        EditorGUILayout.HelpBox("Please use a unique Object Path Name for the project", MessageType.Warning);
                                                    }
                                                    #endregion

                                                    #region Use Width
                                                    bool prevUseWidth = lbObjPath.useWidth;
                                                    lbObjPath.useWidth = EditorGUILayout.Toggle(groupsMemberUseWidthContent, lbObjPath.useWidth);
                                                    if (lbObjPath.useWidth != prevUseWidth)
                                                    {
                                                        // Warn user about turning off UseWidth
                                                        if (prevUseWidth)
                                                        {
                                                            if (EditorUtility.DisplayDialog("Object Path Turn off width", "WARNING: Turning off Width will DELETE all width-related data.", "Do it!", "Cancel"))
                                                            {
                                                                lbObjPath.EnablePathWidth(false, true);

                                                                // If the topography was changed to enable editing of the ObjPath topography, restore the original topography
                                                                if (isObjPathDesignerInitialised && landscape.useGPUPath && lbGroup.lbGroupType == LBGroup.LBGroupType.Uniform)
                                                                {
                                                                    EditorUtility.DisplayProgressBar("Restoring heightmap", "PLEASE WAIT", 0.1f);
                                                                    landscape.RevertHeightmap1D("RP_" + lbGroupMember.GUID, true, true);

                                                                    // In LB 2.2.0+ we also need to check subGroups for potential splatmap changes
                                                                    if (LBGroup.IsApplyObjPathTexturesPresent(lbGroupList, lbGroup, lbObjPath))
                                                                    //if (!string.IsNullOrEmpty(lbObjPath.coreTextureGUID) || !string.IsNullOrEmpty(lbObjPath.surroundTextureGUID))
                                                                    {
                                                                        EditorUtility.DisplayProgressBar("Restoring splatmaps", "PLEASE WAIT", 0.2f);
                                                                        landscape.RevertTextures1D("RP_" + lbGroupMember.GUID, true);
                                                                    }

                                                                    if (lbObjPath.isRemoveExistingTrees)
                                                                    {
                                                                        EditorUtility.DisplayProgressBar("Restoring trees", "PLEASE WAIT", 0.3f);
                                                                        landscape.RevertTrees1D("RP_" + lbGroupMember.GUID, true);
                                                                    }

                                                                    EditorUtility.ClearProgressBar();
                                                                }
                                                            }
                                                            else
                                                            {
                                                                lbObjPath.useWidth = prevUseWidth;
                                                            }
                                                        }
                                                        else
                                                        {
                                                            lbObjPath.EnablePathWidth(true, true);

                                                            // If already in the ObjPathDesigner and the use enables useWidth, prepare the heightmap.
                                                            if (isObjPathDesignerInitialised && landscape.useGPUPath && lbGroup.lbGroupType == LBGroup.LBGroupType.Uniform)
                                                            {
                                                                // Create a restore point and apply current Topography tab settings
                                                                LBObjPathDesigner.InitialiseHeightmapForDesigner(landscape, lbGroupMember);

                                                                // Create a restore point and apply current Texturing tab settings
                                                                if (!string.IsNullOrEmpty(lbObjPath.coreTextureGUID) || !string.IsNullOrEmpty(lbObjPath.surroundTextureGUID))
                                                                {
                                                                    LBObjPathDesigner.InitialiseSplatMapsForDesigner(landscape, lbGroupMember);
                                                                }

                                                                // Create a restore point and apply current Trees tab settings
                                                                if (lbObjPath.isRemoveExistingTrees)
                                                                {
                                                                    LBObjPathDesigner.InitialiseTreesForDesigner(landscape, lbGroupMember);
                                                                }
                                                            }
                                                        }

                                                        // Unselect any objects to prevent AddPrefab() being called and deleting the selected object in the GroupDesigner
                                                        if (isGroupDesignerInitialised) { Selection.activeObject = null; }

                                                        isSceneDirtyRequired = true;
                                                    }

                                                    //if (lbObjPath.useWidth) { EditorGUILayout.HelpBox("WIP - Object Path Width is currently in technical preview.", MessageType.Warning);}
                                                    #endregion

                                                    #region Display Attributes
                                                    EditorGUI.BeginChangeCheck();
                                                    lbObjPath.showPathInScene = EditorGUILayout.Toggle(groupsMemberShowPathInSceneContent, lbObjPath.showPathInScene);
                                                    lbObjPath.showDistancesInScene = EditorGUILayout.Toggle(groupsMemberShowDistancesInSceneContent, lbObjPath.showDistancesInScene);
                                                    lbObjPath.showPointLabelsInScene = EditorGUILayout.Toggle(groupsMemberShowPointLabelsInSceneContent, lbObjPath.showPointLabelsInScene);
                                                    if (lbObjPath.useWidth)
                                                    {
                                                        lbObjPath.showSurroundingInScene = EditorGUILayout.Toggle(groupsMemberShowSurroundingInSceneContent, lbObjPath.showSurroundingInScene);
                                                    }
                                                    lbObjPath.pathPointColour = EditorGUILayout.ColorField(groupsMemberPathPointColourContent, lbObjPath.pathPointColour);
                                                    if (EditorGUI.EndChangeCheck())
                                                    {
                                                        // Unselect any objects to prevent AddPrefab() being called and deleting the selected object in the GroupDesigner
                                                        if (isGroupDesignerInitialised) { Selection.activeObject = null; }

                                                        if (isObjPathDesignerInitialised) { lbObjPathDesigner.RefreshPath(); }
                                                        isSceneDirtyRequired = true;
                                                    }
                                                    #endregion

                                                    #region Path Resolution
                                                    EditorGUI.BeginChangeCheck();
                                                    // Store the value as a float, but display as Integer in slider
                                                    pathResolutionInt = Mathf.RoundToInt(lbObjPath.pathResolution);
                                                    pathResolutionInt = EditorGUILayout.IntSlider(groupsMemberPathResolutionContent, pathResolutionInt, 1, 20);
                                                    lbObjPath.pathResolution = (float)pathResolutionInt;

                                                    if (EditorGUI.EndChangeCheck())
                                                    {
                                                        // Force refresh of spline cache
                                                        lbObjPath.isSplinesCached2 = false;
                                                        lbObjPath.RefreshObjPathPositions(lbObjPath.showSurroundingInScene, false);

                                                        // Unselect any objects to prevent AddPrefab() being called and deleting the selected object in the GroupDesigner
                                                        if (isGroupDesignerInitialised) { Selection.activeObject = null; }

                                                        if (isObjPathDesignerInitialised) { lbObjPathDesigner.RefreshPath(); }
                                                        isSceneDirtyRequired = true;
                                                    }
                                                    #endregion

                                                    #region Snap to Terrain
                                                    // Only useful when useWidth is enabled (always enabled when useWidth = false)
                                                    if (lbObjPath.useWidth)
                                                    {
                                                        EditorGUI.BeginChangeCheck();
                                                        GUILayout.BeginHorizontal();
                                                        EditorGUILayout.LabelField(groupsMemberPathSnapToTerrainContent, GUILayout.Width(EditorGUIUtility.labelWidth - 4f));
                                                        lbObjPath.snapToTerrain = EditorGUILayout.Toggle(lbObjPath.snapToTerrain, GUILayout.Width(15f));
                                                        // We don't need to call anything here because the button click will trigger the EditorGUI.EndChangeCheck below
                                                        bool resnap = GUILayout.Button(groupsMemberPathResnapToTerrainButtonContent, buttonCompact8, GUILayout.MaxWidth(50f));
                                                        GUILayout.EndHorizontal();
                                                        if (EditorGUI.EndChangeCheck())
                                                        {
                                                            // Unselect any objects to prevent AddPrefab() being called and deleting the selected object in the GroupDesigner
                                                            if (isGroupDesignerInitialised) { Selection.activeObject = null; }

                                                            if (lbObjPath.snapToTerrain || resnap)
                                                            {
                                                                lbObjPath.RefreshPathHeights(landscape, lbGroup.lbGroupType != LBGroup.LBGroupType.Uniform);

                                                                // Force refresh of spline cache
                                                                lbObjPath.isSplinesCached2 = false;
                                                                lbObjPath.RefreshObjPathPositions(lbObjPath.showSurroundingInScene, false);

                                                                if (isObjPathDesignerInitialised)
                                                                {
                                                                    lbObjPathDesigner.RefreshPath();
                                                                }
                                                            }
                                                            isSceneSaveRequired = true;
                                                        }
                                                    }
                                                    #endregion

                                                    #region Height Above Terrain
                                                    // Store the value as a float, but display as Integer in slider
                                                    heightAboveTerrainInt = Mathf.RoundToInt(lbObjPath.heightAboveTerrain);
                                                    EditorGUI.BeginChangeCheck();
                                                    heightAboveTerrainInt = EditorGUILayout.IntSlider(groupsMemberHeightOffsetContent, heightAboveTerrainInt, 0, 10);
                                                    if (EditorGUI.EndChangeCheck())
                                                    {
                                                        lbObjPath.heightAboveTerrain = (float)heightAboveTerrainInt;

                                                        // Unselect any objects to prevent AddPrefab() being called and deleting the selected object in the GroupDesigner
                                                        if (isGroupDesignerInitialised) { Selection.activeObject = null; }

                                                        if (!lbObjPath.useWidth || lbObjPath.snapToTerrain)
                                                        {
                                                            lbObjPath.RefreshPathHeights(landscape, lbGroup.lbGroupType != LBGroup.LBGroupType.Uniform);

                                                            // Force refresh of spline cache
                                                            lbObjPath.isSplinesCached2 = false;
                                                            lbObjPath.RefreshObjPathPositions(lbObjPath.showSurroundingInScene, false);

                                                            if (isObjPathDesignerInitialised)
                                                            {
                                                                lbObjPathDesigner.RefreshPath();
                                                            }
                                                        }

                                                        isSceneDirtyRequired = true;
                                                    }
                                                    #endregion

                                                    #region Point Display Scale

                                                    pointDisplayScaleInt = lbObjPath.GetPointDisplayScaleAsInt();
                                                    EditorGUI.BeginChangeCheck();
                                                    pointDisplayScaleInt = EditorGUILayout.IntSlider(groupsMemberPointDisplayScaleContent, pointDisplayScaleInt, 1, 5);
                                                    if (EditorGUI.EndChangeCheck())
                                                    {
                                                        lbObjPath.SetPointDisplayScale(pointDisplayScaleInt);

                                                        // Unselect any objects to prevent AddPrefab() being called and deleting the selected object in the GroupDesigner
                                                        if (isGroupDesignerInitialised) { Selection.activeObject = null; }

                                                        if (isObjPathDesignerInitialised) { SceneView.RepaintAll(); }
                                                        isSceneDirtyRequired = true;
                                                    }

                                                    #endregion

                                                    #region Find Options
                                                    if (lbGroup.lbGroupType == LBGroup.LBGroupType.Uniform)
                                                    {
                                                        lbObjPath.zoomOnFind = EditorGUILayout.Toggle(groupsMemberZoomOnFindContent, lbObjPath.zoomOnFind);
                                                        if (lbObjPath.zoomOnFind)
                                                        {
                                                            // Store the value as a float, but display as Integer in slider
                                                            findZoomDistanceInt = Mathf.RoundToInt(lbObjPath.findZoomDistance);
                                                            findZoomDistanceInt = EditorGUILayout.IntSlider(groupsMemberFindZoomDistanceContent, findZoomDistanceInt, 2, 1000);
                                                            lbObjPath.findZoomDistance = (float)findZoomDistanceInt;
                                                        }
                                                    }
                                                    #endregion

                                                    #region Remove Grass and/or Trees
                                                    if (lbObjPath.useWidth)
                                                    {
                                                        // Currently only implemented with Vegetation Studio Pro using Vegetation Mask Areas
                                                        if (landscape.useVegetationSystem && isVegetationStudioProInstalled)
                                                        {
                                                            lbObjPath.isRemoveExistingGrass = EditorGUILayout.Toggle(groupsMemberObjPathRemoveGrassContent, lbObjPath.isRemoveExistingGrass);
                                                        }

                                                        EditorGUI.BeginChangeCheck();
                                                        lbObjPath.isRemoveExistingTrees = EditorGUILayout.Toggle(groupsMemberObjPathRemoveTreesContent, lbObjPath.isRemoveExistingTrees);
                                                        if (EditorGUI.EndChangeCheck())
                                                        {
                                                            // Object Designer for a uniform group
                                                            if (isObjPathDesignerInitialised && !isGroupDesignerInitialised)
                                                            {
                                                                if (lbObjPath.isRemoveExistingTrees)
                                                                {
                                                                    // If RemoveExistingTrees wasn't previously used while in the Object Designer for a uniform group, create a restore point
                                                                    LBObjPathDesigner.InitialiseTreesForDesigner(landscape, lbGroupMember);
                                                                }
                                                                else
                                                                {
                                                                    // Remove existing trees is being turned off, so revert to the original trees
                                                                    EditorUtility.DisplayProgressBar("Restoring trees", "PLEASE WAIT", 0.2f);
                                                                    landscape.RevertTrees1D("RP_" + lbGroupMember.GUID, true);
                                                                    EditorUtility.ClearProgressBar();
                                                                }
                                                            }
                                                        }

                                                        if (lbObjPath.isRemoveExistingTrees)
                                                        {
                                                            if (!landscape.useGPUPath)
                                                            {
                                                                EditorGUILayout.HelpBox("Object Path Remove Trees requires GPU Acceleration - Path to be enabled on the Advanced tab", MessageType.Error);
                                                            }

                                                            lbObjPath.treeDistFromEdge = EditorGUILayout.Slider(groupsMemberObjPathTreeDistFromEdgeContent, lbObjPath.treeDistFromEdge, 0.0f, lbObjPath.edgeBlendWidth);
                                                        }
                                                    }

                                                    #endregion

                                                    #region Object Path Biomes
                                                    #if VEGETATION_STUDIO_PRO
                                                    if (lbObjPath.useWidth)
                                                    {
                                                        // Currently only 1 biome is used with object paths, but there is provision for multiple.
                                                        if (!lbObjPath.useBiomes)
                                                        {
                                                            if (GUILayout.Button("Assign Biome", buttonCompact, GUILayout.Width(135f)))
                                                            {
                                                                if (lbObjPath.lbBiomeList == null) { lbObjPath.lbBiomeList = new List<LBBiome>(); }

                                                                int numBiomes = lbObjPath.lbBiomeList == null ? 0 : lbObjPath.lbBiomeList.Count;

                                                                if (numBiomes == 0 && lbObjPath.lbBiomeList != null) { lbObjPath.lbBiomeList.Add(new LBBiome()); numBiomes++; }
                                                                lbObjPath.useBiomes = numBiomes > 0;

                                                                isSceneDirtyRequired = true;
                                                            }
                                                        }
                                                        else
                                                        {
                                                            int numBiomes = lbObjPath.lbBiomeList == null ? 0 : lbObjPath.lbBiomeList.Count;

                                                            if (numBiomes > 0)
                                                            {
                                                                if (!landscape.useVegetationSystem)
                                                                {
                                                                    EditorGUILayout.HelpBox("Currently Biomes only work when Vegetation Studio Pro is used in the landscape. Check the Terrain Settings on the Landscape tab.", MessageType.Error);
                                                                }
                                                                else
                                                                {
                                                                    LBBiome lbBiome = lbObjPath.lbBiomeList[0];

                                                                    EditorGUI.BeginChangeCheck();
                                                                    GUILayout.BeginHorizontal();
                                                                    EditorGUILayout.LabelField(groupsVSPBiomeContent, GUILayout.Width(defaultEditorLabelWidth));
                                                                    lbBiome.biomeIndex = EditorGUILayout.Popup(lbBiome.biomeIndex, LBIntegration.VegetationStudioProGetPackageList(vsPro));
                                                                    if (GUILayout.Button("X", buttonCompact, GUILayout.MaxWidth(20f)))
                                                                    {
                                                                        lbObjPath.useBiomes = false;
                                                                        lbBiome = null;
                                                                        lbObjPath.lbBiomeList.Clear();
                                                                        isSceneDirtyRequired = true;
                                                                    }
                                                                    GUILayout.EndHorizontal();
                                                                    if (lbObjPath.useBiomes && lbBiome != null)
                                                                    {
                                                                        GUILayout.BeginHorizontal();
                                                                        EditorGUILayout.LabelField(groupsVSPBiomeMinBlendDistContent, GUILayout.Width(defaultEditorLabelWidth));
                                                                        lbBiome.minBlendDist = EditorGUILayout.Slider(lbBiome.minBlendDist, 0f, 500f);
                                                                        GUILayout.EndHorizontal();
                                                                    }
                                                                    if (EditorGUI.EndChangeCheck()) { isSceneDirtyRequired = true; }
                                                                }
                                                            }
                                                        }
                                                    }
                                                    #endif
                                                    #endregion Biomes

                                                }
                                                #endregion

                                                #region Group Member Object Path Objects Tab
                                                else if (lbGroupMember.showtabInEditor == (int)LBGroupMember.LBMemberEditorPathTab.Objects)
                                                {
                                                    EditorGUILayout.HelpBox("Series Start/End Members are optional. Layout determines how the Main Member Objects are distributed along the path. Don't forget to check the member proximity settings.", MessageType.Info);

#region Default Series
                                                    // The default series variable are embedded in the LBObjPath
                                                    // These pre-date the LBObjPathSeries class.

                                                    // Start the Default Series
                                                    GUILayout.BeginVertical(EditorStyles.helpBox);

                                                    GUILayout.BeginHorizontal();
                                                    EditorGUILayout.LabelField(groupsMemberObjDefaultSeriesContent, labelFieldRichText);
                                                    if (lbObjPath.showDefaultSeriesInEditor) { if (GUILayout.Button("Hide", buttonCompact, GUILayout.Width(40f))) { GUI.FocusControl(null); lbObjPath.showDefaultSeriesInEditor = false; } }
                                                    else { if (GUILayout.Button("Show", buttonCompact, GUILayout.Width(40f))) { GUI.FocusControl(null); lbObjPath.showDefaultSeriesInEditor = true; } }
                                                    GUILayout.EndHorizontal();

                                                    if (lbObjPath.showDefaultSeriesInEditor)
                                                    {                                                     
#region Prefab Start settings
                                                        if (lbObjPath.startObjPrefab == null) { lbObjPath.startObjPrefab = new LBObjPrefab(); }

                                                        // Find the matching LBGroupMember (if any)
                                                        groupMemberLookupIndex2 = lbGroup.groupMemberList.FindIndex(gmbr => gmbr.GUID == lbObjPath.startObjPrefab.groupMemberGUID && !string.IsNullOrEmpty(gmbr.GUID));
                                                        // Now find it in the smaller list of MemberType: Prefab
                                                        groupMemberLookupIndex = groupMemberNameTypePrefabList.FindIndex(nm => nm.StartsWith("Member " + (groupMemberLookupIndex2 + 1).ToString("00")));

                                                        GUILayout.BeginHorizontal();
                                                        if (GUILayout.Button(groupsMemberPathShowMemberButtonContent, buttonCompact, GUILayout.MaxWidth(20f)))
                                                        {
                                                            if (groupMemberLookupIndex >= 0)
                                                            {
                                                                GUI.FocusControl(null);
                                                                lbObjPath.showSeriesListInEditor = false;
                                                                lbGroup.GroupMemberListExpand(false);
                                                                // Keep the Object Path member open
                                                                lbGroupMember.showInEditor = true;
                                                                lbGroup.groupMemberList[groupMemberLookupIndex2].showInEditor = true;
                                                            }
                                                        }
                                                        EditorGUILayout.LabelField(groupsMemberStartPrefabContent, GUILayout.Width(defaultEditorLabelWidth - 58f));
                                                        if (groupMemberNameTypePrefabList.Count < 1) { EditorGUILayout.LabelField("No Members with prefabs"); }
                                                        else
                                                        {
                                                            EditorGUI.BeginChangeCheck();
                                                            groupMemberLookupIndex = EditorGUILayout.Popup(groupMemberLookupIndex, groupMemberNameTypePrefabList.ToArray());
                                                            if (EditorGUI.EndChangeCheck())
                                                            {
                                                                // Lookup the GUID for the selected Group Member
                                                                if (groupMemberLookupIndex < groupMemberNameTypePrefabList.Count)
                                                                {
                                                                    // Find this member name in the full groupMemberList
                                                                    groupMemberLookupName = groupMemberNameTypePrefabList[groupMemberLookupIndex];
                                                                    if (groupMemberLookupName.Length > 8) { groupMemberLookupIndex = Convert.ToInt32(groupMemberLookupName.Substring(7, 2)) - 1; }

                                                                    //Debug.Log("Selected Group Member " + (groupMemberLookupIndex + 1).ToString() + " GUID:" + lbGroup.groupMemberList[groupMemberLookupIndex].GUID);

                                                                    lbObjPath.startObjPrefab.groupMemberGUID = lbGroup.groupMemberList[groupMemberLookupIndex].GUID;
                                                                    isSceneDirtyRequired = true;
                                                                }
                                                            }
                                                        }
                                                        if (GUILayout.Button("X", buttonCompact, GUILayout.MaxWidth(20f))) { lbObjPath.startObjPrefab.groupMemberGUID = string.Empty; isSceneDirtyRequired = true; }
                                                        GUILayout.EndHorizontal();
#endregion

#region Prefab End settings
                                                        if (lbObjPath.endObjPrefab == null) { lbObjPath.endObjPrefab = new LBObjPrefab(); }

                                                        // Find the matching LBGroupMember (if any)
                                                        groupMemberLookupIndex2 = lbGroup.groupMemberList.FindIndex(gmbr => gmbr.GUID == lbObjPath.endObjPrefab.groupMemberGUID && !string.IsNullOrEmpty(gmbr.GUID));
                                                        // Now find it in the smaller list of MemberType: Prefab
                                                        groupMemberLookupIndex = groupMemberNameTypePrefabList.FindIndex(nm => nm.StartsWith("Member " + (groupMemberLookupIndex2 + 1).ToString("00")));

                                                        GUILayout.BeginHorizontal();
                                                        if (GUILayout.Button(groupsMemberPathShowMemberButtonContent, buttonCompact, GUILayout.MaxWidth(20f)))
                                                        {
                                                            if (groupMemberLookupIndex >= 0)
                                                            {
                                                                GUI.FocusControl(null);
                                                                lbObjPath.showSeriesListInEditor = false;
                                                                lbGroup.GroupMemberListExpand(false);
                                                                // Keep the Object Path member open
                                                                lbGroupMember.showInEditor = true;
                                                                lbGroup.groupMemberList[groupMemberLookupIndex2].showInEditor = true;
                                                            }
                                                        }
                                                        EditorGUILayout.LabelField(groupsMemberEndPrefabContent, GUILayout.Width(defaultEditorLabelWidth - 58f));
                                                        if (groupMemberNameTypePrefabList.Count < 1) { EditorGUILayout.LabelField("No Members with prefabs"); }
                                                        else
                                                        {
                                                            EditorGUI.BeginChangeCheck();
                                                            groupMemberLookupIndex = EditorGUILayout.Popup(groupMemberLookupIndex, groupMemberNameTypePrefabList.ToArray());
                                                            if (EditorGUI.EndChangeCheck())
                                                            {
                                                                // Lookup the GUID for the selected Group Member
                                                                if (groupMemberLookupIndex < groupMemberNameTypePrefabList.Count)
                                                                {
                                                                    // Find this member name in the full groupMemberList
                                                                    groupMemberLookupName = groupMemberNameTypePrefabList[groupMemberLookupIndex];
                                                                    if (groupMemberLookupName.Length > 8) { groupMemberLookupIndex = Convert.ToInt32(groupMemberLookupName.Substring(7, 2)) - 1; }

                                                                    lbObjPath.endObjPrefab.groupMemberGUID = lbGroup.groupMemberList[groupMemberLookupIndex].GUID;
                                                                    isSceneDirtyRequired = true;
                                                                }
                                                            }
                                                        }
                                                        if (GUILayout.Button("X", buttonCompact, GUILayout.MaxWidth(20f))) { lbObjPath.endObjPrefab.groupMemberGUID = string.Empty; isSceneDirtyRequired = true; }
                                                        GUILayout.EndHorizontal();
#endregion

#region Main Prefab List settings
                                                        if (lbObjPath.mainObjPrefabList == null) { lbObjPath.mainObjPrefabList = new List<LBObjPrefab>(); }
                                                        numMainPrefabsInList = (lbObjPath.mainObjPrefabList == null ? 0 : lbObjPath.mainObjPrefabList.Count);

                                                        // reset delete/insert for Main Obj Prefabs
                                                        deleteObjPrefabPos = -1;
                                                        objPrefabToRemove = null;
                                                        insertObjPathPrefabPos = -1;

#region Append or Reduce Number Main Prefabs

                                                        GUILayout.BeginHorizontal();
                                                        EditorGUILayout.LabelField("Main Members: " + numMainPrefabsInList.ToString("00"));
                                                        if (GUILayout.Button("+", GUILayout.MaxWidth(30f)))
                                                        {
                                                            if (lbObjPath.mainObjPrefabList != null)
                                                            {
                                                                lbObjPath.mainObjPrefabList.Add(new LBObjPrefab());
                                                                numMainPrefabsInList++;
                                                            }
                                                        }
                                                        // Remove the last prefab in the list of main prefabs
                                                        if (GUILayout.Button("-", GUILayout.MaxWidth(30f)))
                                                        {
                                                            if (numMainPrefabsInList > 0)
                                                            {
                                                                deleteObjPrefabPos = numMainPrefabsInList - 1;
                                                                objPrefabToRemove = lbObjPath.mainObjPrefabList[deleteObjPrefabPos];
                                                            }
                                                        }
                                                        GUILayout.EndHorizontal();
#endregion

#region Display Main ObjPrefab list

                                                        for (int i = 0; i < numMainPrefabsInList; i++)
                                                        {
                                                            lbObjPrefab = lbObjPath.mainObjPrefabList[i];
                                                            if (lbObjPrefab != null)
                                                            {
                                                                // Find the matching LBGroupMember (if any)
                                                                groupMemberLookupIndex2 = lbGroup.groupMemberList.FindIndex(gmbr => gmbr.GUID == lbObjPrefab.groupMemberGUID && !string.IsNullOrEmpty(gmbr.GUID));
                                                                // Now find it in the smaller list of MemberType: Prefab
                                                                groupMemberLookupIndex = groupMemberNameTypePrefabList.FindIndex(nm => nm.StartsWith("Member " + (groupMemberLookupIndex2 + 1).ToString("00")));

                                                                GUILayout.BeginHorizontal();
                                                                //if (GUILayout.Button("I", buttonCompact, GUILayout.MaxWidth(20f))) { insertObjPathPrefabPos = i; }

                                                                if (GUILayout.Button(groupsMemberPathShowMemberButtonContent, buttonCompact, GUILayout.MaxWidth(20f)))
                                                                {
                                                                    if (groupMemberLookupIndex >= 0)
                                                                    {
                                                                        GUI.FocusControl(null);
                                                                        lbObjPath.showSeriesListInEditor = false;
                                                                        lbGroup.GroupMemberListExpand(false);
                                                                        // Keep the Object Path member open
                                                                        lbGroupMember.showInEditor = true;
                                                                        lbGroup.groupMemberList[groupMemberLookupIndex2].showInEditor = true;
                                                                    }
                                                                }
                                                                EditorGUILayout.LabelField("Prefab " + (i + 1).ToString("00"), GUILayout.Width(defaultEditorLabelWidth - 58f));
                                                                if (groupMemberNameTypePrefabList.Count < 1) { EditorGUILayout.LabelField("No Members with prefabs"); }
                                                                else
                                                                {
                                                                    EditorGUI.BeginChangeCheck();
                                                                    groupMemberLookupIndex = EditorGUILayout.Popup(groupMemberLookupIndex, groupMemberNameTypePrefabList.ToArray());
                                                                    if (EditorGUI.EndChangeCheck())
                                                                    {
                                                                        // Lookup the GUID for the selected Group Member
                                                                        if (groupMemberLookupIndex < groupMemberNameTypePrefabList.Count)
                                                                        {
                                                                            // Find this member name in the full groupMemberList
                                                                            groupMemberLookupName = groupMemberNameTypePrefabList[groupMemberLookupIndex];
                                                                            if (groupMemberLookupName.Length > 8) { groupMemberLookupIndex = Convert.ToInt32(groupMemberLookupName.Substring(7, 2)) - 1; }

                                                                            lbObjPrefab.groupMemberGUID = lbGroup.groupMemberList[groupMemberLookupIndex].GUID;
                                                                            isSceneDirtyRequired = true;

                                                                            // Unselect any objects to prevent AddPrefab() being called and deleting the selected object in the GroupDesigner
                                                                            if (isGroupDesignerInitialised) { Selection.activeObject = null; }

                                                                            // Always want to update the Group Designer if it is open an a prefab has changed (or been set to null)
                                                                            //if (isGroupDesignerInitialised) { lbGroupDesigner.RefreshWorkspace(); }
                                                                            //if (isObjPathDesignerInitialised) { }
                                                                        }
                                                                    }
                                                                }

                                                                if (GUILayout.Button("X", buttonCompact, GUILayout.MaxWidth(20f))) { deleteObjPrefabPos = i; objPrefabToRemove = lbObjPrefab; }
                                                                GUILayout.EndHorizontal();
                                                            }
                                                        }

#endregion

#region Insert/Delete Main ObjPrefab
                                                        if (insertObjPathPrefabPos >= 0)
                                                        {

                                                        }
                                                        // Don't permit insert and delete in same frame
                                                        else if (deleteObjPrefabPos >= 0 && objPrefabToRemove != null)
                                                        {
                                                            lbObjPath.mainObjPrefabList.Remove(objPrefabToRemove);
                                                            objPrefabToRemove = null;
                                                            isSceneDirtyRequired = true;
                                                        }
#endregion

#endregion

#region Layout
                                                        EditorGUI.BeginChangeCheck();
                                                        lbObjPath.layoutMethod = (LBObjPath.LayoutMethod)EditorGUILayout.EnumPopup(groupsMemberObjTypeLayoutMethodContent, lbObjPath.layoutMethod);
                                                        lbObjPath.selectionMethod = (LBObjPath.SelectionMethod)EditorGUILayout.EnumPopup(groupsMemberObjSelectionMethodContent, lbObjPath.selectionMethod);

                                                        if (lbObjPath.layoutMethod == LBObjPath.LayoutMethod.Spacing)
                                                        {
                                                            lbObjPath.spacingDistance = EditorGUILayout.Slider(groupsMemberObjSpacingDistContent, lbObjPath.spacingDistance, 0.01f, 100f);
                                                            lbObjPath.isLastObjSnappedToEnd = EditorGUILayout.Toggle(groupsMemberObjIsLastObjSnappedToEndContent, lbObjPath.isLastObjSnappedToEnd);
                                                        }
                                                        else if (lbObjPath.layoutMethod == LBObjPath.LayoutMethod.QtyPer100m)
                                                        {
                                                            lbObjPath.maxMainPrefabs = EditorGUILayout.IntSlider(groupsMemberObjMaxMainPrefabsContent, lbObjPath.maxMainPrefabs, 1, 100);
                                                            lbObjPath.isLastObjSnappedToEnd = EditorGUILayout.Toggle(groupsMemberObjIsLastObjSnappedToEndContent, lbObjPath.isLastObjSnappedToEnd);
                                                        }
                                                        else if (lbObjPath.layoutMethod == LBObjPath.LayoutMethod.ExactQty)
                                                        {
                                                            // Must have at least 2 path points
                                                            lbObjPath.maxMainPrefabs = EditorGUILayout.IntSlider(groupsMemberObjPrefabsOnPathContent, lbObjPath.maxMainPrefabs, 2, 1000);
                                                            lbObjPath.isLastObjSnappedToEnd = false;
                                                        }

                                                        // Check to see if Randomise per Group Region is available
                                                        if (lbGroupMember.noisePlacementCutoff < 1f || lbObjPath.selectionMethod == LBObjPath.SelectionMethod.Random || lbObjPath.selectionMethod == LBObjPath.SelectionMethod.RandomLessRepeats || lbObjPath.selectionMethod == LBObjPath.SelectionMethod.RandomUnique)
                                                        {
                                                            lbObjPath.isRandomisePerGroupRegion = EditorGUILayout.Toggle(groupsMemberObjPathRanPerGroupRegionContent, lbObjPath.isRandomisePerGroupRegion);
                                                        }

                                                        // Used in ObjPaths to determine how likely main objects will be placed
                                                        lbGroupMember.noisePlacementCutoff = EditorGUILayout.Slider(groupsMemberObjPlacementCutoffContent, lbGroupMember.noisePlacementCutoff, 0.01f, 1f);

                                                        if (EditorGUI.EndChangeCheck())
                                                        {
                                                            isSceneDirtyRequired = true;

                                                            // Unselect any objects to prevent AddPrefab() being called and deleting the selected object in the GroupDesigner
                                                            if (isGroupDesignerInitialised) { Selection.activeObject = null; }
                                                        }

#endregion

                                                    }
                                                    GUILayout.EndVertical();
#endregion Default Series

#region Series List
                                                    if (lbObjPath.useWidth)
                                                    {
                                                        GUILayout.BeginVertical(EditorStyles.helpBox);

                                                        GUILayout.BeginHorizontal();
                                                        EditorGUILayout.LabelField(groupsMemberObjSeriesListContent, labelFieldRichText);
                                                        if (lbObjPath.showSeriesListInEditor) { if (GUILayout.Button("Hide", buttonCompact, GUILayout.Width(40f))) { GUI.FocusControl(null); lbObjPath.showSeriesListInEditor = false; } }
                                                        else { if (GUILayout.Button("Show", buttonCompact, GUILayout.Width(40f))) { GUI.FocusControl(null); lbObjPath.showSeriesListInEditor = true; } }
                                                        GUILayout.EndHorizontal();

                                                        if (lbObjPath.lbObjPathSeriesList == null) { lbObjPath.lbObjPathSeriesList = new List<LBObjPathSeries>(); }

                                                        if (lbObjPath.showSeriesListInEditor)
                                                        {
                                                            lbObjPath.isSeriesListOverride = EditorGUILayout.Toggle(groupsMemberObjPathSeriesOverrideContent, lbObjPath.isSeriesListOverride);

#region Override Width-based Series List
                                                            if (lbObjPath.isSeriesListOverride)
                                                            {
                                                                EditorGUILayout.HelpBox("WIP - Series Override is currently in technical preview", MessageType.Warning);

                                                                // Find the matching LBGroupMember (if any). It must be an Object Path
                                                                groupMemberLookupIndex2 = lbGroup.groupMemberList.FindIndex(gmbr => gmbr.GUID == lbObjPath.seriesListGroupMemberGUID && !string.IsNullOrEmpty(gmbr.GUID) && gmbr.lbMemberType == LBGroupMember.LBMemberType.ObjPath);
                                                                // Now find it in the smaller list of MemberType: ObjPath
                                                                groupMemberLookupIndex = groupMemberNameTypeObjPathList.FindIndex(nm => nm.StartsWith("Member " + (groupMemberLookupIndex2 + 1).ToString("00")));
                                                                
                                                                GUILayout.BeginHorizontal();
                                                                if (GUILayout.Button(groupsMemberPathShowMemberButtonContent, buttonCompact, GUILayout.MaxWidth(20f)))
                                                                {
                                                                    if (groupMemberLookupIndex >= 0)
                                                                    {
                                                                        GUI.FocusControl(null);
                                                                        lbGroup.GroupMemberListExpand(false);
                                                                        // Keep the Object Path member open
                                                                        lbGroupMember.showInEditor = true;
                                                                        lbGroup.groupMemberList[groupMemberLookupIndex2].showInEditor = true;
                                                                        // Show the Objects tab
                                                                        lbGroup.groupMemberList[groupMemberLookupIndex2].showtabInEditor = 1;
                                                                    }
                                                                }

                                                                EditorGUILayout.LabelField(groupsMemberObjPathSeriesOverrideMemberContent, GUILayout.Width(defaultEditorLabelWidth - 58f));
                                                                if (groupMemberNameTypeObjPathList.Count < 2) { EditorGUILayout.LabelField("No other Object Path Members in this Group"); }
                                                                else
                                                                {
                                                                    EditorGUI.BeginChangeCheck();
                                                                    groupMemberLookupIndex = EditorGUILayout.Popup(groupMemberLookupIndex, groupMemberNameTypeObjPathList.ToArray());
                                                                    if (EditorGUI.EndChangeCheck())
                                                                    {
                                                                        // Lookup the GUID for the selected Group Member
                                                                        if (groupMemberLookupIndex < groupMemberNameTypeObjPathList.Count)
                                                                        {
                                                                            // Find this member name in the full groupMemberList
                                                                            groupMemberLookupName = groupMemberNameTypeObjPathList[groupMemberLookupIndex];
                                                                            if (groupMemberLookupName.Length > 8) { groupMemberLookupIndex = Convert.ToInt32(groupMemberLookupName.Substring(7, 2)) - 1; }

                                                                            lbObjPath.seriesListGroupMemberGUID = lbGroup.groupMemberList[groupMemberLookupIndex].GUID;
                                                                            isSceneDirtyRequired = true;
                                                                        }
                                                                    }
                                                                }
                                                                if (GUILayout.Button("X", buttonCompact, GUILayout.MaxWidth(20f)))
                                                                {
                                                                    lbObjPath.seriesListGroupMemberGUID = string.Empty;
                                                                    isSceneDirtyRequired = true;
                                                                }

                                                                GUILayout.EndHorizontal();

                                                            }
#endregion

#region This Member Width-based Series List
                                                            else
                                                            {
                                                                numObjPathSeriesInList = lbObjPath.lbObjPathSeriesList == null ? 0 : lbObjPath.lbObjPathSeriesList.Count;

                                                                // reset delete/insert for ObjPathSeries
                                                                deleteObjPathSeriesPos = -1;
                                                                objPathSeriesToRemove = null;
                                                                objPathSeriesToMove = null;
                                                                insertObjPathSeriesPos = -1;
                                                                moveObjPathSeriesPos = -1;

#region Append or Reduce Number of Series
                                                                GUILayout.BeginHorizontal();
                                                                EditorGUILayout.LabelField("Series: " + numObjPathSeriesInList.ToString("00"));
                                                                if (GUILayout.Button("+", GUILayout.MaxWidth(30f)))
                                                                {
                                                                    if (lbObjPath.lbObjPathSeriesList != null)
                                                                    {
                                                                        GUI.FocusControl(null);
                                                                        lbObjPath.lbObjPathSeriesList.Add(new LBObjPathSeries());
                                                                        numObjPathSeriesInList++;
                                                                    }
                                                                }
                                                                // Remove the last series in the list of ObjPathSeries
                                                                if (GUILayout.Button("-", GUILayout.MaxWidth(30f)))
                                                                {
                                                                    if (numObjPathSeriesInList > 0)
                                                                    {
                                                                        deleteObjPathSeriesPos = numObjPathSeriesInList - 1;
                                                                        objPathSeriesToRemove = lbObjPath.lbObjPathSeriesList[deleteObjPathSeriesPos];
                                                                    }
                                                                }
                                                                GUILayout.EndHorizontal();

#endregion Append or Reduce Number of Series

#region Display Series List
                                                                for (int sIdx = 0; sIdx < numObjPathSeriesInList; sIdx++)
                                                                {
                                                                    objPathSeries = lbObjPath.lbObjPathSeriesList[sIdx];

                                                                    if (objPathSeries != null)
                                                                    {
                                                                        GUILayout.Box(GUIContent.none, line1Style, GUILayout.ExpandWidth(true), GUILayout.Height(1f));

                                                                        GUILayout.BeginHorizontal();
                                                                        labelText2 = " (" + (string.IsNullOrEmpty(objPathSeries.seriesName) ? "MISSING SERIES NAME" : objPathSeries.seriesName) + ")";
                                                                        labelText = "<color=" + txtColourName + "><b>Series " + (sIdx + 1) + "</b>" + labelText2 + "</color>";
                                                                        EditorGUILayout.LabelField(labelText, labelFieldRichText);

#region MOVE or INSERT ObjPathSeries Buttons
                                                                        if (GUILayout.Button(groupsMemberObjSeriesDownButtonContent, buttonCompact, GUILayout.Width(20f)))
                                                                        {
                                                                            objPathSeriesToMove = new LBObjPathSeries(objPathSeries);
                                                                            moveObjPathSeriesPos = sIdx;
                                                                        }
                                                                        if (GUILayout.Button(groupsMemberObjSeriesButtonContent, buttonCompact, GUILayout.Width(20f))) { insertObjPathSeriesPos = sIdx; }
#endregion

#region Show/Hide/Delete Buttons
                                                                        if (objPathSeries.showInEditor) { if (GUILayout.Button("Hide", buttonCompact, GUILayout.Width(40f))) { GUI.FocusControl(null); objPathSeries.showInEditor = false; } }
                                                                        else { if (GUILayout.Button("Show", buttonCompact, GUILayout.Width(40f))) { GUI.FocusControl(null); objPathSeries.showInEditor = true; } }
                                                                        if (GUILayout.Button("X", buttonCompact, GUILayout.MaxWidth(20f))) { objPathSeriesToRemove = objPathSeries; deleteObjPathSeriesPos = sIdx; }
#endregion

                                                                        GUILayout.EndHorizontal();

                                                                        if (objPathSeries.showInEditor)
                                                                        {
#region Series Name
                                                                            EditorGUI.BeginChangeCheck();
                                                                            objPathSeries.seriesName = EditorGUILayout.TextField(groupsMemberObjSeriesNameContent, objPathSeries.seriesName);

                                                                            if (EditorGUI.EndChangeCheck())
                                                                            {
                                                                                // Should have a name
                                                                                isSceneDirtyRequired = true;
                                                                            }

                                                                            if (string.IsNullOrEmpty(objPathSeries.seriesName) || objPathSeries.seriesName.ToLower() == "(new) series")
                                                                            {
                                                                                EditorGUILayout.HelpBox("Please use a unique Series Name for the Object Path", MessageType.Warning);
                                                                            }
#endregion

                                                                            // We don't support SubGroups within SubGroups
                                                                            if (lbGroup.lbGroupType == LBGroup.LBGroupType.SubGroup)
                                                                            {
                                                                                // Turn them off if someone has then set then changes the group type
                                                                                if (objPathSeries.useSubGroups)
                                                                                {
                                                                                    objPathSeries.useSubGroups = false;
                                                                                    isSceneDirtyRequired = true;
                                                                                }
                                                                            }
                                                                            else
                                                                            {
                                                                                EditorGUI.BeginChangeCheck();
                                                                                objPathSeries.useSubGroups = EditorGUILayout.Toggle(groupsMemberObjSeriesUseSubGroupsContent, objPathSeries.useSubGroups);
                                                                                if (EditorGUI.EndChangeCheck()) { isSceneDirtyRequired = true; }
                                                                            }

#region Verify Start/End/Main Prefab/SubGroup variables are initialised

                                                                            // SubGroups
                                                                            if (objPathSeries.startObjSubGroup == null) { objPathSeries.startObjSubGroup = new LBObjSubGroup(); }
                                                                            if (objPathSeries.endObjSubGroup == null) { objPathSeries.endObjSubGroup = new LBObjSubGroup(); }
                                                                            if (objPathSeries.mainObjSubGroupList == null) { objPathSeries.mainObjSubGroupList = new List<LBObjSubGroup>(); }

                                                                            // Prefabs
                                                                            if (objPathSeries.startObjPrefab == null) { objPathSeries.startObjPrefab = new LBObjPrefab(); }
                                                                            if (objPathSeries.endObjPrefab == null) { objPathSeries.endObjPrefab = new LBObjPrefab(); }
                                                                            if (objPathSeries.mainObjPrefabList == null) { objPathSeries.mainObjPrefabList = new List<LBObjPrefab>(); }

#endregion

                                                                            if (objPathSeries.useSubGroups)
                                                                            {
                                                                                EditorGUILayout.HelpBox("The SubGroup feature is currently in technical preview", MessageType.Warning);

#region Series SubGroup Start settings
                                                                                GUILayout.BeginHorizontal();

                                                                                EditorGUILayout.LabelField(groupsMemberStartSubGroupContent, GUILayout.Width(defaultEditorLabelWidth - 4f));
                                                                                if (subGroupNameList.Count < 1) { EditorGUILayout.LabelField("No SubGroups"); }
                                                                                else
                                                                                {
                                                                                    // Find the SubGroup in the list of SubGroup GUIDs.
                                                                                    groupLookupIndex = subGroupGUIDList.FindIndex(ggd => ggd == objPathSeries.startObjSubGroup.subGroupGUID && !string.IsNullOrEmpty(ggd));
                                                                                    // Display the SubGroup from the list of matching SubGroup names
                                                                                    EditorGUI.BeginChangeCheck();
                                                                                    groupLookupIndex = EditorGUILayout.Popup(groupLookupIndex, subGroupNameList.ToArray());
                                                                                    if (EditorGUI.EndChangeCheck())
                                                                                    {
                                                                                        if (groupLookupIndex < 0) { objPathSeries.startObjSubGroup.subGroupGUID = string.Empty; }
                                                                                        else { objPathSeries.startObjSubGroup.subGroupGUID = subGroupGUIDList[groupLookupIndex]; }
                                                                                        isSceneDirtyRequired = true;
                                                                                    }
                                                                                }
                                                                                if (GUILayout.Button("X", buttonCompact, GUILayout.MaxWidth(20f)))
                                                                                {
                                                                                    objPathSeries.startObjSubGroup.subGroupGUID = string.Empty;
                                                                                    objPathSeries.startMemberOffset = 0f;
                                                                                    isSceneDirtyRequired = true;
                                                                                }
                                                                                GUILayout.EndHorizontal();
#endregion

#region Series Subgroup End settings
                                                                                GUILayout.BeginHorizontal();

                                                                                EditorGUILayout.LabelField(groupsMemberEndSubGroupContent, GUILayout.Width(defaultEditorLabelWidth - 4f));
                                                                                if (subGroupNameList.Count < 1) { EditorGUILayout.LabelField("No SubGroups"); }
                                                                                else
                                                                                {
                                                                                    // Find the SubGroup in the list of SubGroup GUIDs.
                                                                                    groupLookupIndex = subGroupGUIDList.FindIndex(ggd => ggd == objPathSeries.endObjSubGroup.subGroupGUID && !string.IsNullOrEmpty(ggd));
                                                                                    // Display the SubGroup from the list of matching SubGroup names
                                                                                    EditorGUI.BeginChangeCheck();
                                                                                    groupLookupIndex = EditorGUILayout.Popup(groupLookupIndex, subGroupNameList.ToArray());
                                                                                    if (EditorGUI.EndChangeCheck())
                                                                                    {
                                                                                        if (groupLookupIndex < 0) { objPathSeries.endObjSubGroup.subGroupGUID = string.Empty; }
                                                                                        else { objPathSeries.endObjSubGroup.subGroupGUID = subGroupGUIDList[groupLookupIndex]; }
                                                                                        isSceneDirtyRequired = true;
                                                                                    }
                                                                                }
                                                                                if (GUILayout.Button("X", buttonCompact, GUILayout.MaxWidth(20f)))
                                                                                {
                                                                                    objPathSeries.endObjSubGroup.subGroupGUID = string.Empty;
                                                                                    objPathSeries.endMemberOffset = 0f;
                                                                                    isSceneDirtyRequired = true;
                                                                                }
                                                                                GUILayout.EndHorizontal();
#endregion

#region Series Main SubGroup List settings
                                                                                numMainSubGroupsInList = objPathSeries.mainObjSubGroupList == null ? 0 : objPathSeries.mainObjSubGroupList.Count;

                                                                                // reset delete/insert for Main Obj SubGroups
                                                                                deleteObjSubGroupPos = -1;
                                                                                objSubGroupToRemove = null;
                                                                                insertObjPathSubGroupPos = -1;

#region Series Append or Reduce Number Main SubGroups
                                                                                GUILayout.BeginHorizontal();
                                                                                EditorGUILayout.LabelField(new GUIContent("Main SubGroups: " + numMainSubGroupsInList.ToString("00"), "A list of subgroups to place along the Object Path. Use the Selection Method to determine which items are placed along the path."));
                                                                                if (GUILayout.Button("+", GUILayout.MaxWidth(30f)))
                                                                                {
                                                                                    if (objPathSeries.mainObjSubGroupList != null)
                                                                                    {
                                                                                        objPathSeries.mainObjSubGroupList.Add(new LBObjSubGroup());
                                                                                        numMainSubGroupsInList++;
                                                                                    }
                                                                                }
                                                                                // Remove the last SubGroup in the list of main subgroups
                                                                                if (GUILayout.Button("-", GUILayout.MaxWidth(30f)))
                                                                                {
                                                                                    if (numMainSubGroupsInList > 0)
                                                                                    {
                                                                                        deleteObjSubGroupPos = numMainSubGroupsInList - 1;
                                                                                        objSubGroupToRemove = objPathSeries.mainObjSubGroupList[deleteObjSubGroupPos];
                                                                                    }
                                                                                }
                                                                                GUILayout.EndHorizontal();
#endregion

#region Series Display Main SubGroup List
                                                                                for (int i = 0; i < numMainSubGroupsInList; i++)
                                                                                {
                                                                                    lbObjSubGroup = objPathSeries.mainObjSubGroupList[i];
                                                                                    if (lbObjSubGroup != null)
                                                                                    {
                                                                                        // Find the SubGroup in the list of SubGroup GUIDs.
                                                                                        groupLookupIndex = subGroupGUIDList.FindIndex(ggd => ggd == lbObjSubGroup.subGroupGUID && !string.IsNullOrEmpty(ggd));

                                                                                        GUILayout.BeginHorizontal();
#if UNITY_2019_3_OR_NEWER
                                                                                        EditorGUILayout.LabelField(" SubGroup " + (i + 1).ToString("00"), GUILayout.Width(defaultEditorLabelWidth - 1f));
#else
                                                                                        EditorGUILayout.LabelField(" SubGroup " + (i + 1).ToString("00"), GUILayout.Width(defaultEditorLabelWidth - 4f));
#endif
                                                                                        if (subGroupNameList.Count < 1) { EditorGUILayout.LabelField("No SubGroups"); }
                                                                                        else
                                                                                        {
                                                                                            // Display the SubGroup from the list of matching SubGroup names
                                                                                            EditorGUI.BeginChangeCheck();
                                                                                            groupLookupIndex = EditorGUILayout.Popup(groupLookupIndex, subGroupNameList.ToArray());
                                                                                            if (EditorGUI.EndChangeCheck())
                                                                                            {
                                                                                                // Lookup the GUID for the selected SubGroup
                                                                                                if (groupLookupIndex < 0) { lbObjSubGroup.subGroupGUID = string.Empty; }
                                                                                                else { lbObjSubGroup.subGroupGUID = subGroupGUIDList[groupLookupIndex]; }

                                                                                                isSceneDirtyRequired = true;

                                                                                                // Unselect any objects to prevent AddPrefab() being called and deleting the selected object in the GroupDesigner
                                                                                                if (isGroupDesignerInitialised) { Selection.activeObject = null; }
                                                                                            }
                                                                                        }
                                                                                        if (GUILayout.Button("X", buttonCompact, GUILayout.MaxWidth(20f))) { deleteObjSubGroupPos = i; objSubGroupToRemove = lbObjSubGroup; }
                                                                                        GUILayout.EndHorizontal();
                                                                                    }
                                                                                }
#endregion

#region Insert/Delete Main SubGroups
                                                                                if (insertObjPathSubGroupPos >= 0)
                                                                                {

                                                                                }
                                                                                // Don't permit insert and delete in same frame
                                                                                else if (deleteObjSubGroupPos >= 0 && objSubGroupToRemove != null)
                                                                                {
                                                                                    objPathSeries.mainObjSubGroupList.Remove(objSubGroupToRemove);
                                                                                    objSubGroupToRemove = null;
                                                                                    isSceneDirtyRequired = true;
                                                                                }
#endregion

#endregion
                                                                            }
                                                                            else
                                                                            {
#region Series Prefab Start settings
                                                                                // Find the matching LBGroupMember (if any)
                                                                                groupMemberLookupIndex2 = lbGroup.groupMemberList.FindIndex(gmbr => gmbr.GUID == objPathSeries.startObjPrefab.groupMemberGUID && !string.IsNullOrEmpty(gmbr.GUID));
                                                                                // Now find it in the smaller list of MemberType: Prefab
                                                                                groupMemberLookupIndex = groupMemberNameTypePrefabList.FindIndex(nm => nm.StartsWith("Member " + (groupMemberLookupIndex2 + 1).ToString("00")));

                                                                                GUILayout.BeginHorizontal();
                                                                                if (GUILayout.Button(groupsMemberPathShowMemberButtonContent, buttonCompact, GUILayout.MaxWidth(20f)))
                                                                                {
                                                                                    if (groupMemberLookupIndex >= 0)
                                                                                    {
                                                                                        GUI.FocusControl(null);
                                                                                        lbObjPath.showDefaultSeriesInEditor = false;
                                                                                        lbGroup.GroupMemberListExpand(false);
                                                                                        // Keep the Object Path member open
                                                                                        lbGroupMember.showInEditor = true;
                                                                                        lbGroup.groupMemberList[groupMemberLookupIndex2].showInEditor = true;
                                                                                    }
                                                                                }
                                                                                EditorGUILayout.LabelField(groupsMemberStartPrefabContent, GUILayout.Width(defaultEditorLabelWidth - 58f));
                                                                                if (groupMemberNameTypePrefabList.Count < 1) { EditorGUILayout.LabelField("No Members with prefabs"); }
                                                                                else
                                                                                {
                                                                                    EditorGUI.BeginChangeCheck();
                                                                                    groupMemberLookupIndex = EditorGUILayout.Popup(groupMemberLookupIndex, groupMemberNameTypePrefabList.ToArray());
                                                                                    if (EditorGUI.EndChangeCheck())
                                                                                    {
                                                                                        // Lookup the GUID for the selected Group Member
                                                                                        if (groupMemberLookupIndex < groupMemberNameTypePrefabList.Count)
                                                                                        {
                                                                                            // Find this member name in the full groupMemberList
                                                                                            groupMemberLookupName = groupMemberNameTypePrefabList[groupMemberLookupIndex];
                                                                                            if (groupMemberLookupName.Length > 8) { groupMemberLookupIndex = Convert.ToInt32(groupMemberLookupName.Substring(7, 2)) - 1; }

                                                                                            //Debug.Log("Selected Group Member " + (groupMemberLookupIndex + 1).ToString() + " GUID:" + lbGroup.groupMemberList[groupMemberLookupIndex].GUID);

                                                                                            objPathSeries.startObjPrefab.groupMemberGUID = lbGroup.groupMemberList[groupMemberLookupIndex].GUID;
                                                                                            isSceneDirtyRequired = true;
                                                                                        }
                                                                                    }
                                                                                }
                                                                                if (GUILayout.Button("X", buttonCompact, GUILayout.MaxWidth(20f)))
                                                                                {
                                                                                    objPathSeries.startObjPrefab.groupMemberGUID = string.Empty;
                                                                                    objPathSeries.startMemberOffset = 0f;
                                                                                    isSceneDirtyRequired = true;
                                                                                }
                                                                                GUILayout.EndHorizontal();

                                                                                if (groupMemberNameTypePrefabList.Count > 0 && groupMemberLookupIndex >= 0)
                                                                                {
                                                                                    float objPathMemberSpacingDistance = 50f;
                                                                                    if (objPathSeries.layoutMethod == LBObjPath.LayoutMethod.Spacing)
                                                                                    {
                                                                                        objPathMemberSpacingDistance = objPathSeries.spacingDistance;
                                                                                    }
                                                                                    else if (objPathSeries.layoutMethod == LBObjPath.LayoutMethod.QtyPer100m)
                                                                                    {
                                                                                        // For QtyPer100m, we need to use maxMainPrefabs - 1 to allow for the first point at 0 distance.
                                                                                        objPathMemberSpacingDistance = objPathSeries.maxMainPrefabs < 2 ? 100f : 100f / ((float)objPathSeries.maxMainPrefabs - 1f);
                                                                                    }

                                                                                    objPathSeries.startMemberOffset = EditorGUILayout.Slider(groupsMemberObjPathStartMemberOffsetContent, objPathSeries.startMemberOffset, -objPathMemberSpacingDistance, objPathMemberSpacingDistance);
                                                                                }

#endregion

#region Series Prefab End settings
                                                                                // Find the matching LBGroupMember (if any)
                                                                                groupMemberLookupIndex2 = lbGroup.groupMemberList.FindIndex(gmbr => gmbr.GUID == objPathSeries.endObjPrefab.groupMemberGUID && !string.IsNullOrEmpty(gmbr.GUID));
                                                                                // Now find it in the smaller list of MemberType: Prefab
                                                                                groupMemberLookupIndex = groupMemberNameTypePrefabList.FindIndex(nm => nm.StartsWith("Member " + (groupMemberLookupIndex2 + 1).ToString("00")));

                                                                                GUILayout.BeginHorizontal();
                                                                                if (GUILayout.Button(groupsMemberPathShowMemberButtonContent, buttonCompact, GUILayout.MaxWidth(20f)))
                                                                                {
                                                                                    if (groupMemberLookupIndex >= 0)
                                                                                    {
                                                                                        GUI.FocusControl(null);
                                                                                        lbObjPath.showDefaultSeriesInEditor = false;
                                                                                        lbGroup.GroupMemberListExpand(false);
                                                                                        // Keep the Object Path member open
                                                                                        lbGroupMember.showInEditor = true;
                                                                                        lbGroup.groupMemberList[groupMemberLookupIndex2].showInEditor = true;
                                                                                    }
                                                                                }
                                                                                EditorGUILayout.LabelField(groupsMemberEndPrefabContent, GUILayout.Width(defaultEditorLabelWidth - 58f));
                                                                                if (groupMemberNameTypePrefabList.Count < 1) { EditorGUILayout.LabelField("No Members with prefabs"); }
                                                                                else
                                                                                {
                                                                                    EditorGUI.BeginChangeCheck();
                                                                                    groupMemberLookupIndex = EditorGUILayout.Popup(groupMemberLookupIndex, groupMemberNameTypePrefabList.ToArray());
                                                                                    if (EditorGUI.EndChangeCheck())
                                                                                    {
                                                                                        // Lookup the GUID for the selected Group Member
                                                                                        if (groupMemberLookupIndex < groupMemberNameTypePrefabList.Count)
                                                                                        {
                                                                                            // Find this member name in the full groupMemberList
                                                                                            groupMemberLookupName = groupMemberNameTypePrefabList[groupMemberLookupIndex];
                                                                                            if (groupMemberLookupName.Length > 8) { groupMemberLookupIndex = Convert.ToInt32(groupMemberLookupName.Substring(7, 2)) - 1; }

                                                                                            objPathSeries.endObjPrefab.groupMemberGUID = lbGroup.groupMemberList[groupMemberLookupIndex].GUID;
                                                                                            isSceneDirtyRequired = true;
                                                                                        }
                                                                                    }
                                                                                }
                                                                                if (GUILayout.Button("X", buttonCompact, GUILayout.MaxWidth(20f)))
                                                                                {
                                                                                    objPathSeries.endObjPrefab.groupMemberGUID = string.Empty;
                                                                                    objPathSeries.endMemberOffset = 0f;
                                                                                    isSceneDirtyRequired = true;
                                                                                }
                                                                                GUILayout.EndHorizontal();

                                                                                if (groupMemberNameTypePrefabList.Count > 0 && groupMemberLookupIndex >= 0)
                                                                                {
                                                                                    float objPathMemberSpacingDistance = 50f;
                                                                                    if (objPathSeries.layoutMethod == LBObjPath.LayoutMethod.Spacing)
                                                                                    {
                                                                                        objPathMemberSpacingDistance = objPathSeries.spacingDistance;
                                                                                    }
                                                                                    else if (objPathSeries.layoutMethod == LBObjPath.LayoutMethod.QtyPer100m)
                                                                                    {
                                                                                        // For QtyPer100m, we need to use maxMainPrefabs - 1 to allow for the first point at 0 distance.
                                                                                        objPathMemberSpacingDistance = objPathSeries.maxMainPrefabs < 2 ? 100f : 100f / ((float)objPathSeries.maxMainPrefabs - 1f);
                                                                                    }

                                                                                    objPathSeries.endMemberOffset = EditorGUILayout.Slider(groupsMemberObjPathEndMemberOffsetContent, objPathSeries.endMemberOffset, -objPathMemberSpacingDistance, objPathMemberSpacingDistance);
                                                                                }
#endregion

#region Series Main Prefab List settings
                                                                                numMainPrefabsInList = (objPathSeries.mainObjPrefabList == null ? 0 : objPathSeries.mainObjPrefabList.Count);

                                                                                // reset delete/insert for Main Obj Prefabs
                                                                                deleteObjPrefabPos = -1;
                                                                                objPrefabToRemove = null;
                                                                                insertObjPathPrefabPos = -1;

#region Series Append or Reduce Number Main Prefabs

                                                                                GUILayout.BeginHorizontal();
                                                                                EditorGUILayout.LabelField(new GUIContent("Main Members: " + numMainPrefabsInList.ToString("00"), "A list of prefabs to place along the Object Path. Use the Selection Method to determine which items are placed along the path."));
                                                                                if (GUILayout.Button("+", GUILayout.MaxWidth(30f)))
                                                                                {
                                                                                    if (objPathSeries.mainObjPrefabList != null)
                                                                                    {
                                                                                        objPathSeries.mainObjPrefabList.Add(new LBObjPrefab());
                                                                                        numMainPrefabsInList++;
                                                                                    }
                                                                                }
                                                                                // Remove the last prefab in the list of main prefabs
                                                                                if (GUILayout.Button("-", GUILayout.MaxWidth(30f)))
                                                                                {
                                                                                    if (numMainPrefabsInList > 0)
                                                                                    {
                                                                                        deleteObjPrefabPos = numMainPrefabsInList - 1;
                                                                                        objPrefabToRemove = objPathSeries.mainObjPrefabList[deleteObjPrefabPos];
                                                                                    }
                                                                                }
                                                                                GUILayout.EndHorizontal();
#endregion

#region Series Display Main ObjPrefab list

                                                                                for (int i = 0; i < numMainPrefabsInList; i++)
                                                                                {
                                                                                    lbObjPrefab = objPathSeries.mainObjPrefabList[i];
                                                                                    if (lbObjPrefab != null)
                                                                                    {
                                                                                        // Find the matching LBGroupMember (if any)
                                                                                        groupMemberLookupIndex2 = lbGroup.groupMemberList.FindIndex(gmbr => gmbr.GUID == lbObjPrefab.groupMemberGUID && !string.IsNullOrEmpty(gmbr.GUID));
                                                                                        // Now find it in the smaller list of MemberType: Prefab
                                                                                        groupMemberLookupIndex = groupMemberNameTypePrefabList.FindIndex(nm => nm.StartsWith("Member " + (groupMemberLookupIndex2 + 1).ToString("00")));

                                                                                        GUILayout.BeginHorizontal();
                                                                                        //if (GUILayout.Button("I", buttonCompact, GUILayout.MaxWidth(20f))) { insertObjPathPrefabPos = i; }

                                                                                        if (GUILayout.Button(groupsMemberPathShowMemberButtonContent, buttonCompact, GUILayout.MaxWidth(20f)))
                                                                                        {
                                                                                            if (groupMemberLookupIndex >= 0)
                                                                                            {
                                                                                                GUI.FocusControl(null);
                                                                                                lbObjPath.showDefaultSeriesInEditor = false;
                                                                                                lbGroup.GroupMemberListExpand(false);
                                                                                                // Keep the Object Path member open
                                                                                                lbGroupMember.showInEditor = true;
                                                                                                lbGroup.groupMemberList[groupMemberLookupIndex2].showInEditor = true;
                                                                                            }
                                                                                        }
                                                                                        EditorGUILayout.LabelField("Prefab " + (i + 1).ToString("00"), GUILayout.Width(defaultEditorLabelWidth - 58f));
                                                                                        if (groupMemberNameTypePrefabList.Count < 1) { EditorGUILayout.LabelField("No Members with prefabs"); }
                                                                                        else
                                                                                        {
                                                                                            EditorGUI.BeginChangeCheck();
                                                                                            groupMemberLookupIndex = EditorGUILayout.Popup(groupMemberLookupIndex, groupMemberNameTypePrefabList.ToArray());
                                                                                            if (EditorGUI.EndChangeCheck())
                                                                                            {
                                                                                                // Lookup the GUID for the selected Group Member
                                                                                                if (groupMemberLookupIndex < groupMemberNameTypePrefabList.Count)
                                                                                                {
                                                                                                    // Find this member name in the full groupMemberList
                                                                                                    groupMemberLookupName = groupMemberNameTypePrefabList[groupMemberLookupIndex];
                                                                                                    if (groupMemberLookupName.Length > 8) { groupMemberLookupIndex = Convert.ToInt32(groupMemberLookupName.Substring(7, 2)) - 1; }

                                                                                                    lbObjPrefab.groupMemberGUID = lbGroup.groupMemberList[groupMemberLookupIndex].GUID;
                                                                                                    isSceneDirtyRequired = true;

                                                                                                    // Unselect any objects to prevent AddPrefab() being called and deleting the selected object in the GroupDesigner
                                                                                                    if (isGroupDesignerInitialised) { Selection.activeObject = null; }

                                                                                                    // Always want to update the Group Designer if it is open an a prefab has changed (or been set to null)
                                                                                                    //if (isGroupDesignerInitialised) { lbGroupDesigner.RefreshWorkspace(); }
                                                                                                    //if (isObjPathDesignerInitialised) { }
                                                                                                }
                                                                                            }
                                                                                        }

                                                                                        if (GUILayout.Button("X", buttonCompact, GUILayout.MaxWidth(20f))) { deleteObjPrefabPos = i; objPrefabToRemove = lbObjPrefab; }
                                                                                        GUILayout.EndHorizontal();
                                                                                    }
                                                                                }

#endregion

#region Insert/Delete Main ObjPrefab
                                                                                if (insertObjPathPrefabPos >= 0)
                                                                                {

                                                                                }
                                                                                // Don't permit insert and delete in same frame
                                                                                else if (deleteObjPrefabPos >= 0 && objPrefabToRemove != null)
                                                                                {
                                                                                    objPathSeries.mainObjPrefabList.Remove(objPrefabToRemove);
                                                                                    objPrefabToRemove = null;
                                                                                    isSceneDirtyRequired = true;
                                                                                }
#endregion

#endregion
                                                                            }

#region Layout
                                                                            EditorGUI.BeginChangeCheck();
                                                                            objPathSeries.layoutMethod = (LBObjPath.LayoutMethod)EditorGUILayout.EnumPopup(groupsMemberObjTypeLayoutMethodContent, objPathSeries.layoutMethod);

                                                                            if (EditorGUI.EndChangeCheck())
                                                                            {
                                                                                if (objPathSeries.layoutMethod == LBObjPath.LayoutMethod.ExactQty)
                                                                                {
                                                                                    Debug.Log("INFO: Exact Qty is not currently available in a Width-based Series");
                                                                                    objPathSeries.layoutMethod = LBObjPath.LayoutMethod.Spacing;
                                                                                }

                                                                                isSceneDirtyRequired = true;

                                                                                // Unselect any objects to prevent AddPrefab() being called and deleting the selected object in the GroupDesigner
                                                                                if (isGroupDesignerInitialised) { Selection.activeObject = null; }
                                                                            }

                                                                            EditorGUI.BeginChangeCheck();
                                                                            objPathSeries.selectionMethod = (LBObjPath.SelectionMethod)EditorGUILayout.EnumPopup(groupsMemberObjSelectionMethodContent, objPathSeries.selectionMethod);

                                                                            if (objPathSeries.layoutMethod == LBObjPath.LayoutMethod.Spacing)
                                                                            {
                                                                                objPathSeries.spacingDistance = EditorGUILayout.Slider(groupsMemberObjSpacingDistContent, objPathSeries.spacingDistance, 0.01f, objPathSeries.useSubGroups ? 250f : 100f);
                                                                                objPathSeries.isLastObjSnappedToEnd = EditorGUILayout.Toggle(groupsMemberObjIsLastObjSnappedToEndContent, objPathSeries.isLastObjSnappedToEnd);
                                                                            }
                                                                            else if (objPathSeries.layoutMethod == LBObjPath.LayoutMethod.QtyPer100m)
                                                                            {
                                                                                objPathSeries.maxMainPrefabs = EditorGUILayout.IntSlider(groupsMemberObjMaxMainPrefabsContent, objPathSeries.maxMainPrefabs, 1, 100);
                                                                                objPathSeries.isLastObjSnappedToEnd = EditorGUILayout.Toggle(groupsMemberObjIsLastObjSnappedToEndContent, objPathSeries.isLastObjSnappedToEnd);
                                                                            }
                                                                            else if (objPathSeries.layoutMethod == LBObjPath.LayoutMethod.ExactQty)
                                                                            {
                                                                                // Must have at least 2 path points
                                                                                objPathSeries.maxMainPrefabs = EditorGUILayout.IntSlider(groupsMemberObjPrefabsOnPathContent, objPathSeries.maxMainPrefabs, 2, 1000);
                                                                                objPathSeries.isLastObjSnappedToEnd = false;
                                                                            }

                                                                            // Check to see if Randomise per Group Region is available
                                                                            if (objPathSeries.sparcePlacementCutoff < 1f || objPathSeries.selectionMethod == LBObjPath.SelectionMethod.Random || objPathSeries.selectionMethod == LBObjPath.SelectionMethod.RandomLessRepeats || objPathSeries.selectionMethod == LBObjPath.SelectionMethod.RandomUnique)
                                                                            {
                                                                                objPathSeries.isRandomisePerGroupRegion = EditorGUILayout.Toggle(groupsMemberObjPathRanPerGroupRegionContent, objPathSeries.isRandomisePerGroupRegion);
                                                                            }

                                                                            // Used in ObjPaths to determine how likely main objects will be placed
                                                                            objPathSeries.sparcePlacementCutoff = EditorGUILayout.Slider(groupsMemberObjPlacementCutoffContent, objPathSeries.sparcePlacementCutoff, 0.01f, 1f);

                                                                            // We don't keep the updated minPathWidth and the surrounds (edgeBlendWidth) may be very small
                                                                            //float prefabOffsetZLimit = objPathSeries.pathSpline == LBObjPath.PathSpline.Centre ? 50f : lbObjPath.edgeBlendWidth;
                                                                            float prefabOffsetZLimit = 100f;

                                                                            objPathSeries.pathSpline = (LBObjPath.PathSpline)EditorGUILayout.EnumPopup(groupsMemberObjPathSplineContent, objPathSeries.pathSpline);
                                                                            objPathSeries.use3DDistance = EditorGUILayout.Toggle(groupsMemberObjPathUse3DDistanceContent, objPathSeries.use3DDistance);
                                                                            objPathSeries.useNonOffsetDistance = EditorGUILayout.Toggle(groupsMemberObjPathUseNonOffsetDistanceContent, objPathSeries.useNonOffsetDistance);
                                                                            objPathSeries.prefabOffsetZ = EditorGUILayout.Slider(groupsMemberObjPathPrefabOffsetZContent, objPathSeries.prefabOffsetZ, -prefabOffsetZLimit, prefabOffsetZLimit);
                                                                            objPathSeries.prefabStartOffset = EditorGUILayout.Slider(groupsMemberObjPathPrefabStartOffsetContent, objPathSeries.prefabStartOffset, 0f, lbObjPath.splineLength);
                                                                            objPathSeries.prefabEndOffset = EditorGUILayout.Slider(groupsMemberObjPathPrefabEndOffsetContent, objPathSeries.prefabEndOffset, 0f, lbObjPath.splineLength);

                                                                            if (EditorGUI.EndChangeCheck())
                                                                            {
                                                                                isSceneDirtyRequired = true;

                                                                                // Unselect any objects to prevent AddPrefab() being called and deleting the selected object in the GroupDesigner
                                                                                if (isGroupDesignerInitialised) { Selection.activeObject = null; }
                                                                            }

#endregion
                                                                        }
                                                                    }
                                                                }

#endregion Display Series List

#region Insert/Move/Delete Series
                                                                if (insertObjPathSeriesPos >= 0)
                                                                {
                                                                    GUI.FocusControl(null);

                                                                    // Unselect any objects to prevent AddPrefab() being called
                                                                    if (isGroupDesignerInitialised) { Selection.activeObject = null; }

                                                                    objPathSeriesInserted = new LBObjPathSeries(lbObjPath.lbObjPathSeriesList[insertObjPathSeriesPos]);

                                                                    if (objPathSeriesInserted != null)
                                                                    {
                                                                        objPathSeriesInserted.seriesName += " (dup)";

                                                                        // Insert a duplicate above the selected Series
                                                                        lbObjPath.lbObjPathSeriesList.Insert(insertObjPathSeriesPos, objPathSeriesInserted);
                                                                        // Show the new duplicate, and hide the original
                                                                        lbObjPath.lbObjPathSeriesList[insertObjPathSeriesPos].showInEditor = true;
                                                                        lbObjPath.lbObjPathSeriesList[insertObjPathSeriesPos].seriesGUID = System.Guid.NewGuid().ToString();
                                                                        lbObjPath.lbObjPathSeriesList[insertObjPathSeriesPos + 1].showInEditor = false;

                                                                        // Update the designer if required
                                                                        if (isGroupDesignerInitialised)
                                                                        {
                                                                            // Give Unity a chance to update the Series list before updating the designer.
                                                                            Repaint();
                                                                            lbGroupDesigner.RefreshWorkspace();
                                                                            isSceneDirtyRequired = true;
                                                                        }
                                                                        else { isSceneSaveRequired = true; }
                                                                    }

                                                                    insertObjPathSeriesPos = -1;
                                                                }
                                                                // Don't permit insert, move and delete in same frame
                                                                else if (moveObjPathSeriesPos >= 0 && objPathSeriesToMove != null)
                                                                {
                                                                    GUI.FocusControl(null);
                                                                    // Does the user wish to move a Series downward in the list within the ObjPath?

                                                                    // Attempt to move this Series down one in the list
                                                                    if (numObjPathSeriesInList > 1)
                                                                    {
                                                                        // Unselect any objects to prevent AddPrefab() being called
                                                                        if (isGroupDesignerInitialised) { Selection.activeObject = null; }

                                                                        // If this is the last in the list we want to put it at the top
                                                                        if (moveObjPathSeriesPos == lbObjPath.lbObjPathSeriesList.Count - 1)
                                                                        {
                                                                            lbObjPath.lbObjPathSeriesList.Insert(0, objPathSeriesToMove);
                                                                            lbObjPath.lbObjPathSeriesList.RemoveAt(lbObjPath.lbObjPathSeriesList.Count - 1);
                                                                        }
                                                                        else
                                                                        {
                                                                            // Move down one in the list
                                                                            lbObjPath.lbObjPathSeriesList.RemoveAt(moveObjPathSeriesPos);
                                                                            lbObjPath.lbObjPathSeriesList.Insert(moveObjPathSeriesPos + 1, objPathSeriesToMove);
                                                                        }

                                                                        if (isGroupDesignerInitialised)
                                                                        {
                                                                            lbGroupDesigner.RefreshWorkspace();
                                                                            isSceneDirtyRequired = true;
                                                                        }
                                                                        else { isSceneSaveRequired = true; }
                                                                    }
                                                                    objPathSeriesToMove = null;
                                                                    moveObjPathSeriesPos = -1;
                                                                }
                                                                // Don't permit insert, move and delete in same frame
                                                                else if (deleteObjPathSeriesPos >= 0 && objPathSeriesToRemove != null)
                                                                {
                                                                    if (LBEditorHelper.PromptForDelete("Object Path Series", "", deleteObjPathSeriesPos, false))
                                                                    {
                                                                        GUI.FocusControl(null);
                                                                        lbObjPath.lbObjPathSeriesList.Remove(objPathSeriesToRemove);
                                                                        objPathSeriesToRemove = null;
                                                                        isSceneDirtyRequired = true;
                                                                    }
                                                                }

#endregion Insert/Delete Series
                                                            }
#endregion
                                                        }
                                                        GUILayout.EndVertical();
                                                    }
                                                    else
                                                    {
                                                        EditorGUILayout.HelpBox("To enable a width-based series, on this member's General tab, turn on 'Path has Width'", MessageType.Info);
                                                    }

#endregion
                                                }
                                                #endregion

                                                #region Group Member Object Path Points Tab
                                                else if (lbGroupMember.showtabInEditor == (int)LBGroupMember.LBMemberEditorPathTab.Points)
                                                {
                                                    numPointsInList = (lbObjPath.positionList == null ? 0 : lbObjPath.positionList.Count);

                                                    labelText = "Click F(ind) to select a path point in the scene view. Hold the ctrl key down to move all the points at the same time. ";
                                                    labelText += "Left mouse click and '+' key in the scene to append a new point to the path.";
                                                    EditorGUILayout.HelpBox(labelText, MessageType.Info);

                                                    #region Path Point List Buttons
                                                    EditorGUIUtility.labelWidth = 55f;
                                                    GUILayout.BeginHorizontal();
                                                    EditorGUILayout.LabelField("Path Points: " + numPointsInList.ToString("00"));

                                                    #region Set Path Width
                                                    if (lbObjPath.useWidth)
                                                    {
                                                        if (lbObjPath.isGetPointWidthMode)
                                                        {
                                                            if (GUILayout.Button(groupsMemberObjSetWidthButtonContent, toggleCompactButtonStyleToggled, GUILayout.MaxWidth(25f)))
                                                            {
                                                                GUI.FocusControl(null);
                                                                lbObjPath.isGetPointWidthMode = false;
                                                            }
                                                        }
                                                        else
                                                        {
                                                            if (GUILayout.Button(groupsMemberObjSetWidthButtonContent, toggleCompactButtonStyleNormal, GUILayout.MaxWidth(25f)))
                                                            {
                                                                GUI.FocusControl(null);
                                                                lbObjPath.minPathWidth = lbObjPath.GetMinWidth();
                                                                lbObjPath.isGetPointWidthMode = true;
                                                            }
                                                        }
                                                    }
                                                    #endregion

                                                    #region Copy Group Member to LB Copy Buffer
                                                    if (GUILayout.Button(groupsMemberObjCopyButtonContent, GUILayout.MaxWidth(30f)))
                                                    {
                                                        grpMbrCopy = new LBGroupMember(lbGroupMember);
                                                        grpMbrCopyGroupName = lbGroup.groupName;
                                                        grpMbrCopyGroupType = lbGroup.lbGroupType;
                                                    }
                                                    #endregion

                                                    #region Get Points from MapPath Toggle Button
                                                    if (lbObjPath.isGetPointsMode)
                                                    {
                                                        if (GUILayout.Button(groupsMemberObjGetPointsButtonContent, toggleCompactButtonStyleToggled, GUILayout.MaxWidth(40f)))
                                                        {
                                                            GUI.FocusControl(null);
                                                            lbObjPath.isGetPointsMode = false;
                                                        }
                                                    }
                                                    else
                                                    {
                                                        if (GUILayout.Button(groupsMemberObjGetPointsButtonContent, toggleCompactButtonStyleNormal, GUILayout.MaxWidth(40f)))
                                                        {
                                                            GUI.FocusControl(null);
                                                            lbObjPath.isGetPointsMode = true;
                                                        }
                                                    }
                                                    #endregion

                                                    #region Change Point Spacing Toggle Button
                                                    if (lbObjPath.showTargetSpacingInEditor)
                                                    {
                                                        if (GUILayout.Button(groupsMemberObjPointSpacingButtonContent, toggleCompactButtonStyleToggled, GUILayout.MaxWidth(40f)))
                                                        {
                                                            GUI.FocusControl(null);
                                                            lbObjPath.showTargetSpacingInEditor = false;
                                                        }
                                                    }
                                                    else
                                                    {
                                                        if (GUILayout.Button(groupsMemberObjPointSpacingButtonContent, toggleCompactButtonStyleNormal, GUILayout.MaxWidth(40f)))
                                                        {
                                                            GUI.FocusControl(null);
                                                            lbObjPath.showTargetSpacingInEditor = true;
                                                        }
                                                    }
                                                    #endregion

                                                    #region Reverse Points
                                                    if (GUILayout.Button(groupsMemberObjReverseButtonContent, GUILayout.MaxWidth(40f)))
                                                    {
                                                        GUI.FocusControl(null);
                                                        lbObjPath.Reverse(isObjPathDesignerInitialised && lbObjPath.showSurroundingInScene);
                                                        SceneView.RepaintAll();
                                                        isSceneDirtyRequired = true;
                                                    }
                                                    #endregion

                                                    #region Reset Rotation
                                                    if (GUILayout.Button(groupsMemberObjResetRotationButtonContent, GUILayout.MaxWidth(80f)))
                                                    {
                                                        if (EditorUtility.DisplayDialog("Reset Rotation", "Do you wish to reset the rotation on all path point in " + lbObjPath.pathName + "?", "Ok, do it!", "Cancel"))
                                                        {
                                                            // In case use has a RotationZ control in LB Window selected
                                                            GUI.FocusControl(null);
                                                            for (int pt = 0; pt < numPointsInList; pt++)
                                                            {
                                                                lbObjPath.pathPointList[pt].rotationZ = 0f;
                                                            }
                                                        }
                                                    }
                                                    #endregion

                                                    #region AddRemove Buttons
                                                    if (GUILayout.Button("+", GUILayout.MaxWidth(30f)))
                                                    {
                                                        LBObjPathDesigner.AppendPathPoint(landscape, lbGroup, lbGroupMember, lbObjPath, null, Vector3.zero);
                                                        numPointsInList = lbObjPath.positionList.Count;
                                                        SceneView.RepaintAll();
                                                        isSceneDirtyRequired = true;
                                                    }

                                                    // Remove the last point in the path
                                                    if (GUILayout.Button("-", GUILayout.MaxWidth(30f)))
                                                    {
                                                        int itemToRemove = numPointsInList - 1;

                                                        if (numPointsInList > 0)
                                                        {
                                                            // It might be in the selected list, so remove that first
                                                            lbObjPath.selectedList.Remove(itemToRemove);

                                                            // Remove the point from position and LBPathPoint lists.
                                                            objPathPointToRemove = lbObjPath.pathPointList[itemToRemove];
                                                            lbObjPath.pathPointList.Remove(objPathPointToRemove);
                                                            objPathPointToRemove = null;
                                                            lbObjPath.positionList.RemoveAt(itemToRemove);
                                                            if (lbObjPath.useWidth) { lbObjPath.widthList.RemoveAt(itemToRemove); }
                                                            // Force spline cache update
                                                            lbObjPath.isSplinesCached2 = false;
                                                            // Update splines
                                                            lbObjPath.RefreshObjPathPositions(lbObjPath.showSurroundingInScene, false);

                                                            numPointsInList = lbObjPath.positionList.Count;
                                                            if (isObjPathDesignerInitialised) { lbObjPathDesigner.RefreshPath(); }
                                                            isSceneDirtyRequired = true;
                                                        }
                                                    }
                                                    #endregion

                                                    GUILayout.EndHorizontal();
                                                    EditorGUIUtility.labelWidth = defaultEditorLabelWidth;
                                                    #endregion

                                                    #region Add or Set Width
                                                    if (lbObjPath.isGetPointWidthMode)
                                                    {
                                                        GUILayout.BeginHorizontal();
                                                        lbObjPath.minPathWidth = EditorGUILayout.Slider(groupsMemberObjPathSetWidthContent, lbObjPath.minPathWidth, 0.5f, 100f);
                                                        if (GUILayout.Button("Change", GUILayout.Width(65f)))
                                                        {
                                                            lbObjPath.SetPathWidths(lbObjPath.minPathWidth);
                                                            lbObjPath.RefreshObjPathPositions(lbObjPath.showSurroundingInScene, false);
                                                            if (isObjPathDesignerInitialised) { lbObjPathDesigner.RefreshPath(); }
                                                            isSceneSaveRequired = true;
                                                            lbObjPath.isGetPointWidthMode = false;
                                                        }
                                                        GUILayout.EndHorizontal();

                                                        GUILayout.BeginHorizontal();
                                                        lbObjPath.addPathWidth = EditorGUILayout.Slider(groupsMemberObjPathAddWidthContent, lbObjPath.addPathWidth, -50f, 50f);
                                                        if (GUILayout.Button("Change", GUILayout.Width(65f)))
                                                        {
                                                            lbObjPath.AddPathWidths(lbObjPath.addPathWidth, 0.5f, 100f);
                                                            lbObjPath.minPathWidth = lbObjPath.GetMinWidth();
                                                            lbObjPath.RefreshObjPathPositions(lbObjPath.showSurroundingInScene, false);
                                                            if (isObjPathDesignerInitialised) { lbObjPathDesigner.RefreshPath(); }
                                                            isSceneSaveRequired = true;
                                                            lbObjPath.isGetPointWidthMode = false;
                                                        }
                                                        GUILayout.EndHorizontal();
                                                    }
                                                    #endregion

                                                    #region Change Position Spacing Distribution
                                                    if (lbObjPath.showTargetSpacingInEditor)
                                                    {
                                                        if (lbObjPath.useWidth)
                                                        {
                                                            EditorGUILayout.HelpBox("Changing the path spline point spacing will reset path widths on each point to the minimum width. It may also change the shape of the path. There is NO UNDO button.", MessageType.Info);
                                                        }
                                                        else
                                                        {
                                                            EditorGUILayout.HelpBox("Changing the path spline point spacing may change the shape of the path. There is NO UNDO button.", MessageType.Info);
                                                        }
                                                        GUILayout.BeginHorizontal();
                                                        lbObjPath.positionSpacingTarget = EditorGUILayout.Slider(groupsMemberObjPointSpacingDistContent, lbObjPath.positionSpacingTarget, 2, 200);
                                                        if (GUILayout.Button("Change", GUILayout.Width(65f)))
                                                        {
                                                            lbObjPath.ChangePositionSpacing();

                                                            // Update the number in the list for the editor code below
                                                            numPointsInList = (lbObjPath.positionList == null ? 0 : lbObjPath.positionList.Count);

                                                            if (isObjPathDesignerInitialised) { lbObjPathDesigner.RefreshPath(); }
                                                            isSceneDirtyRequired = true;
                                                        }
                                                        GUILayout.EndHorizontal();
                                                    }
                                                    #endregion

                                                    #region Get Points from MapPath OR LB Copy Buffer
                                                    // The button is toggled on/off above
                                                    if (lbObjPath.isGetPointsMode)
                                                    {
                                                        labelText = "Select or drag a MapPath from the current Landscape into the slot to import points from an existing MapPath. All existing points will be deleted.";
                                                        EditorGUILayout.HelpBox(labelText, MessageType.Info);
                                                        // Allow user to drag in or select a Map Path from the scene view
                                                        lbMapPathToImport = (LBMapPath)EditorGUILayout.ObjectField("Source Map Path", lbMapPathToImport, typeof(LBMapPath), true);
                                                        if (lbMapPathToImport != null)
                                                        {
                                                            string msg = "Group Object Path - " + lbMapPathToImport.name + " doesn't have any points to import.";
                                                            if (lbMapPathToImport.lbPath == null) { Debug.LogWarning(msg); }
                                                            else if (lbMapPathToImport.lbPath.positionList == null) { Debug.LogWarning(msg); }
                                                            else if (lbMapPathToImport.lbPath.positionList.Count < 1) { Debug.LogWarning(msg); }
                                                            else if (lbMapPathToImport.transform.parent == null || lbMapPathToImport.transform.parent != landscapeGameObject.transform)
                                                            {
                                                                Debug.LogWarning("Group Object Path - " + lbMapPathToImport.name + " is not part of the current landscape. Please select a MapPath that is a child of the current Landscape.");
                                                            }
                                                            else
                                                            {
                                                                // Check if there are any existing points in path
                                                                bool isContinueToAddPoints = true;

                                                                if (lbObjPath.positionList.Count > 0)
                                                                {
                                                                    isContinueToAddPoints = EditorUtility.DisplayDialog("Overwrite existing path points?", "This action will clear all current path points\n\nWARNING: There is NO UNDO.", "Overwrite", "Cancel");
                                                                }

                                                                if (isContinueToAddPoints)
                                                                {
                                                                    bool currentShowPathInScene = lbObjPath.showPathInScene;
                                                                    int numPointsToImport = lbMapPathToImport.lbPath.positionList == null ? 0 : lbMapPathToImport.lbPath.positionList.Count;

                                                                    // Clear out the old points data
                                                                    lbObjPath.showPathInScene = false;
                                                                    lbObjPath.selectedList.Clear();
                                                                    lbObjPath.positionList.Clear();
                                                                    lbObjPath.pathPointList.Clear();
                                                                    if (lbObjPath.widthList != null) { lbObjPath.widthList.Clear(); }
                                                                    else { lbObjPath.widthList = new List<float>(numPointsToImport); }

                                                                    // Copy over the data (don't need a deep copy here as they are Vector3 and floats
                                                                    lbObjPath.positionList.AddRange(lbMapPathToImport.lbPath.positionList);
                                                                    lbObjPath.positionListLeftEdge.AddRange(lbMapPathToImport.lbPath.positionListLeftEdge);
                                                                    lbObjPath.positionListRightEdge.AddRange(lbMapPathToImport.lbPath.positionListRightEdge);
                                                                    lbObjPath.widthList.AddRange(lbMapPathToImport.lbPath.widthList);

                                                                    lbObjPath.useWidth = true;
                                                                    // Snap to terrain should off by default so we preserve the height of points being imported
                                                                    lbObjPath.snapToTerrain = false;
                                                                    for (int pIdx = 0; pIdx < numPointsToImport; pIdx++)
                                                                    {
                                                                        lbObjPath.pathPointList.Add(new LBPathPoint());
                                                                    }

                                                                    // Adjust user-defined path positions to the correct terrain offset
                                                                    // based on current ObjPath settings
                                                                    lbObjPath.RefreshPathHeights(landscape, false);

                                                                    // Refresh everything
                                                                    lbObjPath.isSplinesCached2 = false;
                                                                    lbObjPath.RefreshObjPathPositions(lbObjPath.showSurroundingInScene, false);

                                                                    lbObjPath.isGetPointsMode = false;
                                                                    lbObjPath.showPathInScene = currentShowPathInScene;

                                                                    // Update the number in the list for the editor code below
                                                                    numPointsInList = (lbObjPath.positionList == null ? 0 : lbObjPath.positionList.Count);
                                                                }
                                                            }
                                                            lbMapPathToImport = null;
                                                        }

                                                        // Can only copy points from Uniform Group to Uniform Group OR non-Uniform to non-Uniform (clearings and subgroups)
                                                        if (grpMbrCopy != null && grpMbrCopy.lbMemberType == LBGroupMember.LBMemberType.ObjPath &&
                                                           (
                                                            (grpMbrCopyGroupType == LBGroup.LBGroupType.Uniform && lbGroup.lbGroupType == LBGroup.LBGroupType.Uniform) ||
                                                            (grpMbrCopyGroupType != LBGroup.LBGroupType.Uniform && lbGroup.lbGroupType != LBGroup.LBGroupType.Uniform)
                                                           ))
                                                        {
                                                            GUILayout.BeginHorizontal();
                                                            if (GUILayout.Button(groupsMemberObjPasteButtonContent, GUILayout.MaxWidth(60f)))
                                                            {
                                                                if (grpMbrCopy.lbObjPath == null || grpMbrCopy.lbObjPath.positionList == null || grpMbrCopy.lbObjPath.positionList.Count < 1)
                                                                {
                                                                    Debug.LogWarning("There are no path points to copy from " + grpMbrCopyGroupName + "." + grpMbrCopy.lbObjPath.pathName);
                                                                }
                                                                else
                                                                {
                                                                    // Check if there are any existing points in path
                                                                    bool isContinueToAddPoints = true;

                                                                    if (lbObjPath.positionList.Count > 0)
                                                                    {
                                                                        isContinueToAddPoints = EditorUtility.DisplayDialog("Overwrite existing path points?", "This action will clear all current path points\n\nWARNING: There is NO UNDO.", "Overwrite", "Cancel");
                                                                    }
                                                                    if (isContinueToAddPoints)
                                                                    {
                                                                        bool currentShowPathInScene = lbObjPath.showPathInScene;
                                                                        int numPointsToImport = grpMbrCopy.lbObjPath.positionList == null ? 0 : grpMbrCopy.lbObjPath.positionList.Count;

                                                                        // Clear out the old points data
                                                                        lbObjPath.showPathInScene = false;
                                                                        lbObjPath.selectedList.Clear();
                                                                        lbObjPath.positionList.Clear();
                                                                        lbObjPath.pathPointList.Clear();
                                                                        if (lbObjPath.widthList != null) { lbObjPath.widthList.Clear(); }
                                                                        else { lbObjPath.widthList = new List<float>(numPointsToImport); }

                                                                        // Copy over the data (don't need a deep copy here as they are Vector3 and floats
                                                                        lbObjPath.positionList.AddRange(grpMbrCopy.lbObjPath.positionList);
                                                                        lbObjPath.positionListLeftEdge.AddRange(grpMbrCopy.lbObjPath.positionListLeftEdge);
                                                                        lbObjPath.positionListRightEdge.AddRange(grpMbrCopy.lbObjPath.positionListRightEdge);
                                                                        lbObjPath.widthList.AddRange(grpMbrCopy.lbObjPath.widthList);

                                                                        lbObjPath.useWidth = grpMbrCopy.lbObjPath.useWidth;
                                                                        // Snap to terrain should off by default so we preserve the height of points being imported
                                                                        lbObjPath.snapToTerrain = false;
                                                                        for (int pIdx = 0; pIdx < numPointsToImport; pIdx++)
                                                                        {
                                                                            lbObjPath.pathPointList.Add(new LBPathPoint(grpMbrCopy.lbObjPath.pathPointList[pIdx]));
                                                                        }

                                                                        // Refresh everything
                                                                        lbObjPath.isSplinesCached2 = false;
                                                                        lbObjPath.RefreshObjPathPositions(lbObjPath.showSurroundingInScene, false);

                                                                        lbObjPath.isGetPointsMode = false;
                                                                        lbObjPath.showPathInScene = currentShowPathInScene;

                                                                        // Update the number in the list for the editor code below
                                                                        numPointsInList = (lbObjPath.positionList == null ? 0 : lbObjPath.positionList.Count);
                                                                    }
                                                                }
                                                            }
                                                            EditorGUILayout.LabelField("from: " + grpMbrCopyGroupName + "." + grpMbrCopy.lbObjPath.pathName);
                                                            GUILayout.EndHorizontal();
                                                        }
                                                        else
                                                        {
                                                            EditorGUILayout.LabelField("No Object Path data in LB Copy Buffer");
                                                        }
                                                        EditorGUILayout.Space();
                                                    }

                                                    #endregion

                                                    #region Display list of points in path

                                                    // Reset find/insert/delete point positions
                                                    insertObjPathPointPos = -1;
                                                    findObjPathPointPos = -1;
                                                    deleteObjPathPointPos = -1;
                                                    objPathPointToRemove = null;

                                                    EditorGUI.BeginChangeCheck();
                                                    for (int i = 0; i < numPointsInList; i++)
                                                    {
                                                        lbPathPoint = lbObjPath.pathPointList[i];
                                                        // If for some reason the LBPathPoint is null, skip this point
                                                        if (lbPathPoint == null) { continue; }

                                                        // Display each position in the list
                                                        GUILayout.BeginHorizontal();
                                                        // A Foldout with no label must have a style fixedWidth of low non-zero value, and have a small (global) fieldWidth.
                                                        EditorGUIUtility.fieldWidth = 15f;
                                                        lbPathPoint.showInEditor = EditorGUILayout.Foldout(lbPathPoint.showInEditor, "", foldoutStyleNoLabel);
                                                        EditorGUIUtility.fieldWidth = defaultEditorFieldWidth;
                                                        if (GUILayout.Button("F", buttonCompact, GUILayout.MaxWidth(20f))) { findObjPathPointPos = i; }
                                                        if (GUILayout.Button("I", buttonCompact, GUILayout.MaxWidth(20f))) { insertObjPathPointPos = i; }
                                                        isObjPathPointSelected = lbObjPath.selectedList.Exists(pt => pt == i);
                                                        labelText = "<color=" + txtColourName + ">" + (isObjPathPointSelected ? "<b>" : "") + "Pt " + (i + 1).ToString("000") + (isObjPathPointSelected ? "</b>" : "") + "</color>";
                                                        EditorGUILayout.LabelField(labelText, labelFieldRichText, GUILayout.MaxWidth(48f));
                                                        lbObjPath.positionList[i] = EditorGUILayout.Vector3Field("", lbObjPath.positionList[i]);
                                                        if (GUILayout.Button("X", buttonCompact, GUILayout.MaxWidth(20f))) { deleteObjPathPointPos = i; objPathPointToRemove = lbPathPoint; }
                                                        GUILayout.EndHorizontal();

                                                        // Display LBPathPoint detail
                                                        if (lbPathPoint.showInEditor)
                                                        {
                                                            currentBgndColor = GUI.backgroundColor;
                                                            GUI.backgroundColor = GUI.backgroundColor * (EditorGUIUtility.isProSkin ? 0.7f : 1.3f);
                                                            GUILayout.BeginVertical(EditorStyles.helpBox);
                                                            GUI.backgroundColor = currentBgndColor;
                                                            lbPathPoint.rotationZ = EditorGUILayout.Slider(groupsMemberObjRotationZContent, lbPathPoint.rotationZ, -359.9f, 359.9f);
                                                            if (lbObjPath.useWidth && lbObjPath.widthList != null)
                                                            {
                                                                // TODO - fix expanded width when scroll bar is on.
                                                                lbObjPath.widthList[i] = LBEditorHelper.LogarithmicSlider(groupsMemberObjPathWidthContent, defaultEditorLabelWidth, lbObjPath.widthList[i], 0.01f, 100f, false, 10);
                                                            }
                                                            GUILayout.EndVertical();
                                                        }
                                                    }
                                                    if (EditorGUI.EndChangeCheck())
                                                    {
                                                        if (isObjPathDesignerInitialised) { lbObjPathDesigner.RefreshPath(); }
                                                        isSceneDirtyRequired = true;
                                                    }
                                                    #endregion

                                                    #region Find Position in Scene
                                                    if (findObjPathPointPos >= 0)
                                                    {
                                                        // Only change scene view camera and zoom if zoom is enabled and NOT in Group Designer
                                                        if (lbObjPath.zoomOnFind && lbGroup.lbGroupType == LBGroup.LBGroupType.Uniform)
                                                        {
                                                            // Move the scene view camera to the selected point
                                                            LBEditorHelper.PositionSceneView(lbObjPath.positionList[findObjPathPointPos], lbObjPath.findZoomDistance, this.GetType());
                                                        }
                                                        lbObjPath.selectedList.Clear();
                                                        lbObjPath.selectedList.Add(findObjPathPointPos);

                                                        // Only show the details for the selected point
                                                        lbGroupMember.ObjPathPointsExpand(false);
                                                        lbObjPath.pathPointList[findObjPathPointPos].showInEditor = true;
                                                    }
                                                    #endregion

                                                    #region Insert or Delete Positions
                                                    if (insertObjPathPointPos >= 0)
                                                    {
                                                        lbObjPath.isRefreshing = true;
                                                        // Insert a duplicate above the selected point
                                                        lbObjPath.pathPointList.Insert(insertObjPathPointPos, new LBPathPoint(lbObjPath.pathPointList[insertObjPathPointPos]));
                                                        lbObjPath.positionList.Insert(insertObjPathPointPos, lbObjPath.positionList[insertObjPathPointPos]);
                                                        if (lbObjPath.useWidth)
                                                        {
                                                            lbObjPath.widthList.Insert(insertObjPathPointPos, lbObjPath.widthList[insertObjPathPointPos]);
                                                            lbObjPath.positionListLeftEdge.Insert(insertObjPathPointPos, lbObjPath.positionListLeftEdge[insertObjPathPointPos]);
                                                            lbObjPath.positionListRightEdge.Insert(insertObjPathPointPos, lbObjPath.positionListRightEdge[insertObjPathPointPos]);
                                                        }

                                                        // Show the new duplicate, and hide the original
                                                        lbObjPath.pathPointList[insertObjPathPointPos].showInEditor = true;
                                                        lbObjPath.pathPointList[insertObjPathPointPos + 1].showInEditor = false;

                                                        // Only change scene view camera and zoom if NOT in Group Designer
                                                        if (lbGroup.lbGroupType == LBGroup.LBGroupType.Uniform)
                                                        {
                                                            LBEditorHelper.PositionSceneView(lbObjPath.positionList[insertObjPathPointPos], lbObjPath.findZoomDistance, this.GetType());
                                                        }
                                                        lbObjPath.selectedList.Clear();
                                                        lbObjPath.selectedList.Add(insertObjPathPointPos);
                                                        // Force spline cache update
                                                        lbObjPath.isRefreshing = false;
                                                        lbObjPath.isSplinesCached2 = false;
                                                        // Update splines
                                                        lbObjPath.RefreshObjPathPositions(lbObjPath.showSurroundingInScene, false);
                                                        if (isObjPathDesignerInitialised) { lbObjPathDesigner.RefreshPath(); }
                                                        isSceneDirtyRequired = true;
                                                    }
                                                    // Don't permit deletes in the same frame as an insert
                                                    else if (deleteObjPathPointPos >= 0 && objPathPointToRemove != null)
                                                    {
                                                        lbObjPath.isRefreshing = true;
                                                        // It might be in the selected list, so remove that first
                                                        lbObjPath.selectedList.Remove(deleteObjPathPointPos);

                                                        lbObjPath.pathPointList.Remove(objPathPointToRemove);
                                                        objPathPointToRemove = null;

                                                        lbObjPath.positionList.RemoveAt(deleteObjPathPointPos);
                                                        if (lbObjPath.useWidth)
                                                        {
                                                            lbObjPath.widthList.RemoveAt(deleteObjPathPointPos);
                                                            lbObjPath.positionListLeftEdge.RemoveAt(deleteObjPathPointPos);
                                                            lbObjPath.positionListRightEdge.RemoveAt(deleteObjPathPointPos);
                                                        }
                                                        // Force spline cache update
                                                        lbObjPath.isRefreshing = false;
                                                        lbObjPath.isSplinesCached2 = false;
                                                        // Update splines
                                                        lbObjPath.RefreshObjPathPositions(lbObjPath.showSurroundingInScene, false);
                                                        if (isObjPathDesignerInitialised) { lbObjPathDesigner.RefreshPath(); }
                                                        isSceneDirtyRequired = true;
                                                    }
                                                    #endregion
                                                }
                                                #endregion

                                                #region Group Member Object Path Surface Tab
                                                else if (lbGroupMember.showtabInEditor == (int)LBGroupMember.LBMemberEditorPathTab.Surface)
                                                {
                                                    EditorGUILayout.HelpBox("When Path Has Width on the Member General tab is enabled, Surface determines how the landscape surface or ground is affected along the length of the Object Path", MessageType.Info);
                                                    EditorGUILayout.HelpBox("This feature is currently in technical preview", MessageType.Warning);

                                                    if (lbObjPath.useWidth)
                                                    {
                                                        if (lbGroupMember.isTerrainFlattened && !landscape.useGPUPath)
                                                        {
                                                            EditorGUILayout.HelpBox("Object Path Flatten requires GPU Acceleration - Path to be enabled on the Advanced tab", MessageType.Error);
                                                        }

#region Object Path Flatten
                                                        EditorGUI.BeginChangeCheck();
                                                        lbGroupMember.isTerrainFlattened = EditorGUILayout.Toggle(groupsMemberObjPathIsTerrainFlattenContent, lbGroupMember.isTerrainFlattened);
                                                        if (EditorGUI.EndChangeCheck())
                                                        {
                                                            if (!lbGroupMember.isTerrainFlattened)
                                                            {
                                                                lbObjPath.showSurroundingInScene = false;
                                                            }
                                                        }

                                                        // Path edge blend width is the surround distance. This is the distance over which the path is blended
                                                        // with the surrounding topography or terrain textures. It is outside the width of the Object Path.
                                                        lbObjPath.edgeBlendWidth = EditorGUILayout.Slider(groupsMemberObjPathFlattenDistanceContent, lbObjPath.edgeBlendWidth, 0.1f, 100f);

                                                        // When the path is a complete circuit, the ends will not be blended (currently Closed Circuit is not an option here)
                                                        // Blend ends can apply to Texturing, Flatten, and/or Surface depending on which ones are enabled.
                                                        if (!lbObjPath.closedCircuit)
                                                        {
                                                            EditorGUI.BeginChangeCheck();
                                                            lbObjPath.blendStart = EditorGUILayout.Toggle(groupsMemberObjPathBlendStartContent, lbObjPath.blendStart);
                                                            lbObjPath.blendEnd = EditorGUILayout.Toggle(groupsMemberObjPathBlendEndContent, lbObjPath.blendEnd);
                                                            if (EditorGUI.EndChangeCheck() && isObjPathDesignerInitialised && lbObjPath.showSurroundingInScene)
                                                            {
                                                                SceneView.RepaintAll();
                                                            }
                                                        }

                                                        if (lbGroupMember.isTerrainFlattened)
                                                        {
                                                            // ObjPath Profile Height Presets
                                                            newObjPathProfileHeightCurvePreset = (LBCurve.ObjPathHeightCurvePreset)EditorGUILayout.EnumPopup(groupsMemberObjPathProfileHeightCurvePresetContent, lbObjPath.profileHeightCurvePreset);
                                                            if (newObjPathProfileHeightCurvePreset != lbObjPath.profileHeightCurvePreset)
                                                            {
                                                                lbObjPath.profileHeightCurve = LBCurve.SetCurveFromPreset(newObjPathProfileHeightCurvePreset);
                                                                lbObjPath.profileHeightCurvePreset = newObjPathProfileHeightCurvePreset;
                                                            }

                                                            EditorGUILayout.BeginHorizontal();
                                                            GUILayout.Label(groupsMemberObjPathProfileHeightCurveContent, GUILayout.Width(EditorGUIUtility.labelWidth - 28f));
                                                            AddScriptCurveButton(lbObjPath.profileHeightCurve, "group" + (index + 1).ToString() + "gmbr" + (lbGroupMemberIdx + 1).ToString() + "profileHeightCurve");
                                                            lbObjPath.profileHeightCurve = EditorGUILayout.CurveField(lbObjPath.profileHeightCurve, GUILayout.Height(30f));
                                                            EditorGUILayout.EndHorizontal();

                                                            float addTerrainHeight = lbObjPath.addTerrainHeight * terrainHeight;
                                                            EditorGUI.BeginChangeCheck();
                                                            addTerrainHeight = EditorGUILayout.Slider(groupsMemberObjPathAddTerrainHeightContent, addTerrainHeight, 0f, terrainHeight / 10f);
                                                            if (EditorGUI.EndChangeCheck() && terrainHeight > 0f)
                                                            {
                                                                lbObjPath.addTerrainHeight = addTerrainHeight / terrainHeight;
                                                            }

                                                            // Stored as a float for later flexibility. Currently on/off
                                                            lbObjPath.surroundSmoothing = EditorGUILayout.Toggle(groupsMemberObjPathSmoothSurroundingContent, lbObjPath.surroundSmoothing > 0f) ? 0.1f : 0f;

                                                            EditorGUILayout.BeginHorizontal();
                                                            GUILayout.Label(groupsMemberObjPathSurroundBlendCurveContent, GUILayout.Width(EditorGUIUtility.labelWidth - 54f));
                                                            //EditorGUILayout.BeginVertical(GUILayout.Width(20f));
                                                            if (GUILayout.Button(smallResetButtonContent, buttonCompact, GUILayout.MaxWidth(20f))) { lbObjPath.surroundBlendCurve = LBObjPath.GetDefaultBlendCurve; }
                                                            AddScriptCurveButton(lbObjPath.surroundBlendCurve, "group" + (index + 1).ToString() + "gmbr" + (lbGroupMemberIdx + 1).ToString() + "surroundBlendCurve");
                                                            //EditorGUILayout.EndVertical();
                                                            lbObjPath.surroundBlendCurve = EditorGUILayout.CurveField(lbObjPath.surroundBlendCurve, GUILayout.Height(30f));
                                                            EditorGUILayout.EndHorizontal();
                                                        }

#endregion Object Path Flatten

#region Surface Mesh
                                                        EditorGUI.BeginChangeCheck();
                                                        lbObjPath.useSurfaceMesh = EditorGUILayout.Toggle(groupsMemberObjPathUseMeshSurfaceContent, lbObjPath.useSurfaceMesh);
                                                        if (EditorGUI.EndChangeCheck())
                                                        {
                                                            if (lbObjPath.useSurfaceMesh && lbGroup.lbGroupType != LBGroup.LBGroupType.Uniform)
                                                            {
                                                                // Clearings always need to snap to terrain because path spline heights
                                                                // are only set in the compute shader.
                                                                lbObjPath.meshEdgeSnapToTerrain = true;
                                                            }
                                                        }
                                                        if (lbObjPath.useSurfaceMesh)
                                                        {
                                                            lbObjPath.meshYOffset = EditorGUILayout.Slider(groupsMemberObjPathMeshYOffsetContent, lbObjPath.meshYOffset, -100f, 100f);

                                                            // Make sure minPathWidth is updated
                                                            if (lbObjPath.minPathWidth == 0f) { lbObjPath.minPathWidth = lbObjPath.GetMinWidth(); }

                                                            EditorGUI.BeginChangeCheck();
                                                            lbObjPath.leftBorderWidth = EditorGUILayout.Slider(groupsMemberObjPathFlattenMeshIndentContent, lbObjPath.leftBorderWidth, 0f, lbObjPath.minPathWidth * 0.8f);
                                                            if (EditorGUI.EndChangeCheck())
                                                            {
                                                                lbObjPath.rightBorderWidth = lbObjPath.leftBorderWidth;
                                                            }

                                                            lbObjPath.meshEdgeSnapToTerrain = EditorGUILayout.Toggle(groupsMemberObjPathMeshEdgeSnapToTerrain, lbObjPath.meshEdgeSnapToTerrain);

                                                            if (lbObjPath.meshEdgeSnapToTerrain)
                                                            {
                                                                lbObjPath.meshSnapType = (LBPath.MeshSnapType)EditorGUILayout.EnumPopup(groupsMemberObjPathMeshSnapTypeContent, lbObjPath.meshSnapType);
                                                            }
                                                            lbObjPath.isCreateSurfaceMeshCollider = EditorGUILayout.Toggle(groupsMemberObjPathIsCreateSurfaceMeshColliderContent, lbObjPath.isCreateSurfaceMeshCollider);

                                                            lbObjPath.meshIsDoubleSided = EditorGUILayout.Toggle(groupsMemberObjPathMeshIsDoubleSidedContent, lbObjPath.meshIsDoubleSided);

                                                            lbObjPath.isMeshLandscapeUV = EditorGUILayout.Toggle(groupsMemberObjPathMeshLandscapeUVContent, lbObjPath.isMeshLandscapeUV);
                                                            lbObjPath.isSwitchMeshUVs = EditorGUILayout.Toggle(groupsMemberObjPathMeshSwitchUVContent, lbObjPath.isSwitchMeshUVs);
                                                            EditorGUILayout.BeginHorizontal();
                                                            GUILayout.Label(groupsMemberObjPathMeshUVTilingContent, GUILayout.Width(EditorGUIUtility.labelWidth - 3f));
                                                            lbObjPath.meshUVTileScale = EditorGUILayout.Vector2Field("", lbObjPath.meshUVTileScale);
                                                            EditorGUILayout.EndHorizontal();
                                                            lbObjPath.surfaceMeshMaterial = (Material)EditorGUILayout.ObjectField(groupsMemberObjPathMeshMaterialContent, lbObjPath.surfaceMeshMaterial, typeof(Material), true);

                                                            lbObjPath.baseMeshThickness = EditorGUILayout.Slider(groupsMemberObjPathMeshBaseThicknessContent, lbObjPath.baseMeshThickness, 0f, 5.0f);
                                                            // Only show base mesh details if it is enabled
                                                            if (lbObjPath.baseMeshThickness > 0f)
                                                            {
                                                                lbObjPath.baseMeshUseIndent = EditorGUILayout.Toggle(groupsMemberObjPathMeshBaseUseIndentContent, lbObjPath.baseMeshUseIndent);
                                                                lbObjPath.isCreateBaseMeshCollider = EditorGUILayout.Toggle(groupsMemberObjPathMeshBaseCreateColliderContent, lbObjPath.isCreateBaseMeshCollider);
                                                                lbObjPath.isSwitchBaseMeshUVs = EditorGUILayout.Toggle(groupsMemberObjPathMeshBaseSwitchUVContent, lbObjPath.isSwitchBaseMeshUVs);
                                                                EditorGUILayout.BeginHorizontal();
                                                                GUILayout.Label(groupsMemberObjPathMeshBaseUVTilingContent, GUILayout.Width(EditorGUIUtility.labelWidth - 3f));
                                                                lbObjPath.baseMeshUVTileScale = EditorGUILayout.Vector2Field("", lbObjPath.baseMeshUVTileScale);
                                                                EditorGUILayout.EndHorizontal();
                                                                lbObjPath.baseMeshMaterial = (Material)EditorGUILayout.ObjectField(groupsMemberObjPathMeshBaseMaterialContent, lbObjPath.baseMeshMaterial, typeof(Material), true);
                                                            }
                                                        }
#endregion

#region Object Path Texture Terrain

                                                        if (appliedTexturesList == null || appliedTexturesArray == null)
                                                        {
                                                            EditorGUILayout.LabelField("No textures in this landscape. Check Texturing tab.");
                                                        }
                                                        else if (appliedTexturesList.Count == 0)
                                                        {
                                                            EditorGUILayout.LabelField("No textures in this landscape. Check Texturing tab.");
                                                        }
                                                        else
                                                        {
                                                            if ((!string.IsNullOrEmpty(lbObjPath.coreTextureGUID) || !string.IsNullOrEmpty(lbObjPath.coreTextureGUID)) && !landscape.useGPUPath)
                                                            {
                                                                EditorGUILayout.HelpBox("Object Path texturing requires GPU Acceleration - Path on the Advanced tab", MessageType.Error);
                                                            }

#region Core Texture
                                                            GUILayout.BeginHorizontal();
                                                            EditorGUILayout.LabelField(groupsMemberObjPathCoreTextureContent, GUILayout.Width(defaultEditorLabelWidth-4f));

                                                            // Find the matching LBTerrainTexture (if any)
                                                            int textureIndex = appliedTexturesList.FindIndex(tx => tx.GUID == lbObjPath.coreTextureGUID && !string.IsNullOrEmpty(tx.GUID));

                                                            EditorGUI.BeginChangeCheck();
                                                            textureIndex = EditorGUILayout.Popup(textureIndex, appliedTexturesArray);
                                                            if (EditorGUI.EndChangeCheck())
                                                            {
                                                                if (textureIndex < appliedTexturesList.Count)
                                                                {
                                                                    LBTerrainTexture terrainTexture = appliedTexturesList[textureIndex];
                                                                    // If this is a legacy LBTerrainTexture, update it now
                                                                    if (string.IsNullOrEmpty(terrainTexture.GUID))
                                                                    {
                                                                        Debug.Log("Updating Texture " + terrainTexture.textureName + " to v2.x");
                                                                        terrainTexture.GUID = System.Guid.NewGuid().ToString();
                                                                    }

                                                                    // If texturing wasn't previously used while in the Object Designer for a uniform group, create a restore point
                                                                    if (isObjPathDesignerInitialised && !isGroupDesignerInitialised)
                                                                    {
                                                                        if (textureIndex < 0)
                                                                        {
                                                                            // Surround Texturing is also not used, so get the restore point
                                                                            if (string.IsNullOrEmpty(lbObjPath.surroundTextureGUID))
                                                                            {
                                                                                EditorUtility.DisplayProgressBar("Restoring splatmaps", "PLEASE WAIT", 0.2f);
                                                                                landscape.RevertTextures1D("RP_" + lbGroupMember.GUID, true);
                                                                                EditorUtility.ClearProgressBar();
                                                                            }
                                                                        }
                                                                        else
                                                                        {
                                                                            // Previously Texturing the path was not in use, so create a Texturing restore point
                                                                            // In LB 2.2.0+ we also need to consider subgroup texturing along the path
                                                                            if (!LBGroup.IsApplyObjPathTexturesPresent(lbGroupList, lbGroup, lbObjPath))
                                                                            {
                                                                                LBObjPathDesigner.InitialiseSplatMapsForDesigner(landscape, lbGroupMember);
                                                                            }
                                                                        }
                                                                    }

                                                                    lbObjPath.coreTextureGUID = terrainTexture.GUID;
                                                                    isSceneDirtyRequired = true;
                                                                }
                                                            }

                                                            // Button to remove Object Path core Texturing
                                                            if (GUILayout.Button("X", buttonCompact, GUILayout.MaxWidth(20f)))
                                                            {
                                                                lbObjPath.coreTextureGUID = string.Empty;
                                                                // Surround Texturing is also not used, so get the restore point
                                                                if (!isGroupDesignerInitialised && string.IsNullOrEmpty(lbObjPath.surroundTextureGUID))
                                                                {
                                                                    EditorUtility.DisplayProgressBar("Restoring splatmaps", "PLEASE WAIT", 0.2f);
                                                                    landscape.RevertTextures1D("RP_" + lbGroupMember.GUID, true);
                                                                    EditorUtility.ClearProgressBar();
                                                                }
                                                            }

                                                            GUILayout.EndHorizontal();

                                                            // LogarithmicSlider cannot have a minValue of 0.0f
                                                            //lbObjPath.coreTextureNoiseTileSize = LBEditorHelper.LogarithmicSlider(groupsMemberObjPathTexNoiseTileSizeContent, defaultEditorLabelWidth, lbObjPath.coreTextureNoiseTileSize, 0f, 1000f, false, 10);
                                                            lbObjPath.coreTextureNoiseTileSize = EditorGUILayout.Slider(groupsMemberObjPathTexNoiseTileSizeContent, lbObjPath.coreTextureNoiseTileSize, 0f, 100f);
                                                            lbObjPath.coreTextureStrength = EditorGUILayout.Slider(groupsMemberObjPathCoreStrengthContent, lbObjPath.coreTextureStrength, 0.01f, 1.0f);
#endregion Core Texture

#region Surround Texture
                                                            GUILayout.BeginHorizontal();
                                                            EditorGUILayout.LabelField(groupsMemberObjPathSurroundTextureContent, GUILayout.Width(defaultEditorLabelWidth - 4f));

                                                            // Find the matching LBTerrainTexture (if any)
                                                            textureIndex = appliedTexturesList.FindIndex(tx => tx.GUID == lbObjPath.surroundTextureGUID && !string.IsNullOrEmpty(tx.GUID));

                                                            EditorGUI.BeginChangeCheck();
                                                            textureIndex = EditorGUILayout.Popup(textureIndex, appliedTexturesArray);
                                                            if (EditorGUI.EndChangeCheck())
                                                            {
                                                                if (textureIndex < appliedTexturesList.Count)
                                                                {
                                                                    LBTerrainTexture terrainTexture = appliedTexturesList[textureIndex];
                                                                    // If this is a legacy LBTerrainTexture, update it now
                                                                    if (string.IsNullOrEmpty(terrainTexture.GUID))
                                                                    {
                                                                        Debug.Log("Updating Texture " + terrainTexture.textureName + " to v2.x");
                                                                        terrainTexture.GUID = System.Guid.NewGuid().ToString();
                                                                    }

                                                                    // If texturing wasn't previously used while in the Object Designer for a uniform group, create a restore point
                                                                    if (isObjPathDesignerInitialised && !isGroupDesignerInitialised)
                                                                    {
                                                                        if (textureIndex < 0)
                                                                        {
                                                                            // Surround Texturing is also not used, so get the restore point
                                                                            if (string.IsNullOrEmpty(lbObjPath.surroundTextureGUID))
                                                                            {
                                                                                EditorUtility.DisplayProgressBar("Restoring splatmaps", "PLEASE WAIT", 0.2f);
                                                                                landscape.RevertTextures1D("RP_" + lbGroupMember.GUID, true);
                                                                                EditorUtility.ClearProgressBar();
                                                                            }
                                                                        }
                                                                        else
                                                                        {
                                                                            // Previously Texturing the path was not in use, so create a Texturing restore point
                                                                            // In LB 2.2.0+ we also need to consider subgroup texturing along the path
                                                                            if (!LBGroup.IsApplyObjPathTexturesPresent(lbGroupList, lbGroup, lbObjPath))
                                                                            {
                                                                                LBObjPathDesigner.InitialiseSplatMapsForDesigner(landscape, lbGroupMember);
                                                                            }
                                                                        }
                                                                    }

                                                                    lbObjPath.surroundTextureGUID = terrainTexture.GUID;
                                                                    isSceneDirtyRequired = true;
                                                                }
                                                            }

                                                            // Button to remove Object Path surround Texturing
                                                            if (GUILayout.Button("X", buttonCompact, GUILayout.MaxWidth(20f)))
                                                            {
                                                                lbObjPath.surroundTextureGUID = string.Empty;
                                                                // Core Texturing is also not used, so get the restore point
                                                                if (!isGroupDesignerInitialised && string.IsNullOrEmpty(lbObjPath.coreTextureGUID))
                                                                {
                                                                    EditorUtility.DisplayProgressBar("Restoring splatmaps", "PLEASE WAIT", 0.2f);
                                                                    landscape.RevertTextures1D("RP_" + lbGroupMember.GUID, true);
                                                                    EditorUtility.ClearProgressBar();
                                                                }
                                                            }

                                                            GUILayout.EndHorizontal();
                                                            lbObjPath.surroundTextureNoiseTileSize = EditorGUILayout.Slider(groupsMemberObjPathTexNoiseTileSizeContent, lbObjPath.surroundTextureNoiseTileSize, 0f, 100f);
                                                            lbObjPath.surroundTextureStrength = EditorGUILayout.Slider(groupsMemberObjPathSurroundStrengthContent, lbObjPath.surroundTextureStrength, 0.01f, 1.0f);
#endregion Surround Texture

                                                        }
#endregion Object Path Texture Terrain
                                                    }
                                                }
                                                #endregion
                                            }
                                        }

                                        #endregion Group Member Settings

                                        GUILayout.EndHorizontal(); // End GroupMember

                                        // Is the Mouse over this GroupMember? (Used for context GenericMenu)
                                        if (grpCurrentEvt != null && grpCurrentEvt.type == EventType.Repaint && GUILayoutUtility.GetLastRect().Contains(grpCurrentEvt.mousePosition))
                                        {
                                            lastMouseOverGroupPos = index;
                                            lastMouseOverGroupMemberPos = lbGroupMemberIdx;
                                            //Debug.Log("Hover Group " + (lastMouseOverGroupPos + 1) + " mbr " + (lastMouseOverGroupMemberPos + 1));
                                        }
                                    }
                                    #endregion
                                }

                                #region Move, Insert or Remove Group Member

                                // More than one group member "could" be removed in same frame but very unlikely so just use the last one
                                if (groupMemberToRemove != null)
                                {
                                    int groupMemberPos = lbGroup.groupMemberList.FindIndex(gmbr => gmbr == groupMemberToRemove);
                                    if (LBEditorHelper.PromptForDelete("Group Member", "", groupMemberPos, false))
                                    {
                                        // Unselect any objects to prevent AddPrefab() being called
                                        if (isGroupDesignerInitialised) { Selection.activeObject = null; }

                                        // Is the Object Path Designer open?
                                        if (isObjPathDesignerInitialised && lbObjPathDesigner != null)
                                        {
                                            // Is this member being edited by the Object Path Designer?
                                            if (lbObjPathDesigner.lbGroupMember != null && lbObjPathDesigner.lbGroupMember.GUID == groupMemberToRemove.GUID)
                                            {
                                                LBLandscapeTerrain.RemoveExistingPrefabs(landscape, true, LBPrefabItem.PrefabItemType.ObjPathDesignerPrefab, groupMemberToRemove.GUID);
                                                // Close the Object Path Designer
                                                LBObjPathDesigner.ShowDesigner(landscape, ref lbObjPathDesigner, lbGroup, groupMemberToRemove, null, false);

                                                // Restore the heightmap to how it was before entering ObjPath Editor mode
                                                if (landscape.useGPUPath && groupMemberToRemove.lbObjPath.useWidth && lbGroup.lbGroupType == LBGroup.LBGroupType.Uniform)
                                                {
                                                    EditorUtility.DisplayProgressBar("Restoring heightmap", "PLEASE WAIT", 0.1f);
                                                    landscape.RevertHeightmap1D("RP_" + groupMemberToRemove.GUID, true, true);

                                                    if (LBGroup.IsApplyObjPathTexturesPresent(lbGroupList, lbGroup, groupMemberToRemove.lbObjPath))
                                                    //if (!string.IsNullOrEmpty(groupMemberToRemove.lbObjPath.coreTextureGUID) || !string.IsNullOrEmpty(groupMemberToRemove.lbObjPath.surroundTextureGUID))
                                                    {
                                                        EditorUtility.DisplayProgressBar("Restoring splatmaps", "PLEASE WAIT", 0.15f);
                                                        landscape.RevertTextures1D("RP_" + groupMemberToRemove.GUID, true);
                                                    }

                                                    if (groupMemberToRemove.lbObjPath.isRemoveExistingTrees)
                                                    {
                                                        EditorUtility.DisplayProgressBar("Restoring Unity terrain trees", "PLEASE WAIT", 0.2f);
                                                        landscape.RevertTrees1D("RP_" + groupMemberToRemove.GUID, true);
                                                    }

                                                    EditorUtility.ClearProgressBar();
                                                }
                                            }
                                        }

                                        lbGroup.groupMemberList.Remove(groupMemberToRemove);
                                        groupMemberToRemove = null;

                                        // Reset mouse over
                                        lastMouseOverGroupPos = -1;
                                        lastMouseOverGroupMemberPos = -1;

                                        // Update the designer if required
                                        if (isGroupDesignerInitialised) { lbGroupDesigner.RefreshWorkspace(false); isSceneDirtyRequired = true; }
                                        else { isSceneDirtyRequired = true; }
                                    }
                                }
                                // Does the user wish to insert a new (duplicate) group member into the list within the Group?
                                else if (insertGroupMemberPos >= 0)
                                {
                                    // Unselect any objects to prevent AddPrefab() being called
                                    if (isGroupDesignerInitialised) { Selection.activeObject = null; }

                                    groupMemberInserted = new LBGroupMember(lbGroup.groupMemberList[insertGroupMemberPos]);

                                    if (groupMemberInserted != null)
                                    {
                                        if (groupMemberInserted.lbMemberType == LBGroupMember.LBMemberType.ObjPath && groupMemberInserted.lbObjPath != null)
                                        {
                                            groupMemberInserted.showObjPathDesigner = false;
                                            groupMemberInserted.lbObjPath.ResetPathPointGUIDs();
                                            groupMemberInserted.lbObjPath.pathName += " (dup)";
                                        }

                                        // Insert a duplicate above the selected group member
                                        lbGroup.groupMemberList.Insert(insertGroupMemberPos, groupMemberInserted);
                                        // Show the new duplicate, and hide the original
                                        lbGroup.groupMemberList[insertGroupMemberPos].showInEditor = true;
                                        lbGroup.groupMemberList[insertGroupMemberPos].GUID = System.Guid.NewGuid().ToString();
                                        lbGroup.groupMemberList[insertGroupMemberPos + 1].showInEditor = false;

                                        // Copy the randomiseRotationY from original as it gets set to true in Copy Constructor to solve some other issue...
                                        lbGroup.groupMemberList[insertGroupMemberPos].randomiseRotationY = lbGroup.groupMemberList[insertGroupMemberPos + 1].randomiseRotationY;

                                        // Reset mouse over
                                        lastMouseOverGroupPos = -1;
                                        lastMouseOverGroupMemberPos = -1;

                                        // Update the designer if required
                                        if (isGroupDesignerInitialised)
                                        {
                                            // Give Unity a chance to update the member list before updating the designer.
                                            Repaint();
                                            lbGroupDesigner.RefreshWorkspace(false);
                                            isSceneDirtyRequired = true;
                                        }
                                        else { isSceneSaveRequired = true; }
                                    }
                                }
                                // Does the user wish to move a Group Member within the Group?
                                else if (moveGroupMemberPos >= 0)
                                {
                                    // Reset mouse over
                                    lastMouseOverGroupPos = -1;
                                    lastMouseOverGroupMemberPos = -1;

                                    // Does the user wish to move a Group Member downward in the list within the Group?
                                    if (groupMemberToMove != null)
                                    {
                                        // Attempt to move this Group Member down one in the list
                                        if (lbGroup.groupMemberList.Count > 1)
                                        {
                                            // Unselect any objects to prevent AddPrefab() being called
                                            if (isGroupDesignerInitialised) { Selection.activeObject = null; }

                                            // If this is the last in the list we want to put it at the top
                                            if (moveGroupMemberPos == lbGroup.groupMemberList.Count - 1)
                                            {
                                                lbGroup.groupMemberList.Insert(0, groupMemberToMove);
                                                lbGroup.groupMemberList.RemoveAt(lbGroup.groupMemberList.Count - 1);
                                            }
                                            else
                                            {
                                                // Move down one in the list
                                                lbGroup.groupMemberList.RemoveAt(moveGroupMemberPos);
                                                lbGroup.groupMemberList.Insert(moveGroupMemberPos + 1, groupMemberToMove);
                                            }

                                            if (isGroupDesignerInitialised)
                                            {
                                                lbGroupDesigner.RefreshWorkspace(false);
                                                isSceneDirtyRequired = true;
                                            }
                                            else { isSceneSaveRequired = true; }
                                        }
                                        groupMemberToMove = null;
                                    }
                                }

                                #endregion

                            }

                            #endregion
                        }

                        GUILayout.EndVertical(); // End of a group

                        // Is the Mouse over this Group? (Used for context GenericMenu)
                        if (lastMouseOverGroupPos != index && grpCurrentEvt != null && grpCurrentEvt.type == EventType.Repaint && GUILayoutUtility.GetLastRect().Contains(grpCurrentEvt.mousePosition))
                        {
                            lastMouseOverGroupPos = index;
                            lastMouseOverGroupMemberPos = -1;
                            //Debug.Log("Hover Group " + (lastMouseOverGroupPos + 1));
                        }

                        #endregion
                    }

                    EditorGUILayout.Space();

                    #region Move, Insert or Remove Group
                    // More than one group "could" be removed in same frame but very unlikely so just use the last one
                    if (groupToRemove != null)
                    {
                        int groupPos = lbGroupList.FindIndex(tx => tx == groupToRemove);
                        labelText = "Group " + (groupPos + 1).ToString() + " will be deleted\n\nThis action will remove the group from the list and cannot be undone.";
                        if (LBEditorHelper.PromptForDelete("Group", lbGroupList[groupPos].groupName, groupPos, false))
                        {
                            // Unselect any objects to prevent AddPrefab() being called
                            if (isGroupDesignerInitialised) { Selection.activeObject = null; }

                            // Is the Object Path Designer open?
                            if (isObjPathDesignerInitialised && lbObjPathDesigner != null && lbObjPathDesigner.lbGroupMember != null)
                            {
                                LBGroupMember lbGroupMemberEditing = lbGroup.groupMemberList.Find(gm => gm.GUID == lbObjPathDesigner.lbGroupMember.GUID);

                                // Is there a member being edited by the Object Path Designer?
                                if (lbGroupMemberEditing != null)
                                {
                                    LBLandscapeTerrain.RemoveExistingPrefabs(landscape, true, LBPrefabItem.PrefabItemType.ObjPathDesignerPrefab, lbGroupMemberEditing.GUID);
                                    // Close the Object Path Designer
                                    LBObjPathDesigner.ShowDesigner(landscape, ref lbObjPathDesigner, lbGroup, lbGroupMemberEditing, null, false);
                                    lbGroupMemberEditing = null;
                                }
                            }

                            // If required, close the designer before deleting the group
                            if (isGroupDesignerInitialised) { LBGroupDesigner.ShowGroupDesigner(landscape, ref lbGroupDesigner, groupToRemove, false); }
                            else if (lbGroup.lbGroupType == LBGroup.LBGroupType.ManualClearing && groupToRemove.showGroupsInScene)
                            {
                                LBGroupLocationItem.RemoveLocationsFromScene(landscape, true);
                                groupToRemove.showGroupsInScene = false;
                                lbGroupShowLocations = null;
                                landscape.LockTerrains(false);
                            }

                            // If required, close the editing of manual group positions in the scene
                            if (groupToRemove.showGroupsInScene && groupToRemove.lbGroupType == LBGroup.LBGroupType.ManualClearing)
                            {
                                LBGroupLocationItem.RemoveLocationsFromScene(landscape, true);
                                groupToRemove.showGroupsInScene = false;
                                lbGroupShowLocations = null;
                                landscape.LockTerrains(false);
                            }

                            lbGroupList.Remove(groupToRemove);
                            groupToRemove = null;
                            RefreshSubGroupLists();
                            isSceneSaveRequired = true;
                        }
                    }
                    // Does the user wish to insert a new (duplicate) group into the list?
                    else if (insertGroupPos >= 0)
                    {
                        // Insert a duplicate above the selected group
                        lbGroupList.Insert(insertGroupPos, new LBGroup(lbGroupList[insertGroupPos]));
                        // Show the new duplicate, and hide the original
                        lbGroupList[insertGroupPos].showInEditor = true;
                        // The Group Designer many be enabled for the original group, make sure we don't duplicate that.
                        lbGroupList[insertGroupPos].showGroupDesigner = false;
                        lbGroupList[insertGroupPos].groupName += " (dup)";
                        // Assign a unique identifier
                        lbGroupList[insertGroupPos].GUID = System.Guid.NewGuid().ToString();

                        lbGroupList[insertGroupPos + 1].showInEditor = false;
                        // If this is a manual procedural group, ensure the showGroupsInScene isn't enabled on the duplicate
                        lbGroupList[insertGroupPos].showGroupsInScene = false;

                        RefreshSubGroupLists();
                        isSceneSaveRequired = true;
                    }
                    // Does the user wish to move a Group downward in the list (or move from last position to top)?
                    else if (moveGroupPos >= 0 && groupToMove != null)
                    {
                        // Unselect any objects to prevent AddPrefab() being called
                        if (isGroupDesignerInitialised) { Selection.activeObject = null; }

                        // Attempt to move this Layer down one in the list
                        if (lbGroupList.Count > 1)
                        {
                            // If this is the last in the list we want to put it at the top
                            if (moveGroupPos == lbGroupList.Count - 1)
                            {
                                lbGroupList.Insert(0, groupToMove);
                                lbGroupList.RemoveAt(lbGroupList.Count - 1);
                            }
                            else
                            {
                                // Move down one in the list
                                lbGroupList.RemoveAt(moveGroupPos);
                                lbGroupList.Insert(moveGroupPos + 1, groupToMove);
                            }
                            RefreshSubGroupLists();
                            isSceneSaveRequired = true;
                        }
                        groupToMove = null;
                    }
                    #endregion

                    EditorGUILayout.EndScrollView();

                    #region Group-Level Context Menu

                    // Place context menu outside the list of groups. We track which group and member the mouse is over while iterating through the groups and members.
                    // However, because we can only get the GUILayout control rectangle during a Paint event, we can't reliably get the correct member AND check for
                    // the ContextClick event at the same time.

                    if (grpCurrentEvt != null && lbGroupList != null)
                    {
                        if (grpCurrentEvt.type == EventType.ContextClick)
                        {
                            GenericMenu menu = new GenericMenu();
                            if (!isGroupDesignerEnabled && !isObjPathDesignerEnabled)
                            {
                                menu.AddItem(new GUIContent("Apply Groups"), false, () => { ApplyGroups(); });
                                if (landscape.isUndoTopographyDisabled) { menu.AddDisabledItem(new GUIContent("Undo Flatten Terrain")); }
                                else { menu.AddItem(new GUIContent("Undo Flatten Terrain"), false, () => { UndoHeightmap(); }); }
                                menu.AddItem(new GUIContent("Undo Tex"), false, () => { UndoTexturing(); });
                                menu.AddItem(new GUIContent("Undo Trees"), false, () => { UndoTrees(); });
                                menu.AddItem(new GUIContent("Undo Grass"), false, () => { UndoGrass(); });
                                menu.AddSeparator("");
                            }
                            // If the mouse was last over a group, show Group-context menu items
                            if (lastMouseOverGroupPos >= 0)
                            {
                                //Debug.Log("Context Menu Group " + (lastMouseOverGroupPos + 1) + " mbr " + (lastMouseOverGroupMemberPos + 1));
                                menu.AddItem(new GUIContent("Enable Group " + (lastMouseOverGroupPos + 1) + " Members"), false, () => { LBGroup.EnableGroupMembers(lbGroupList, lastMouseOverGroupPos, true, lbGroup.editorSearchMemberFilter); RefreshSubGroupLists(); });
                                menu.AddItem(new GUIContent("Diable Group " + (lastMouseOverGroupPos + 1) + " Members"), false, () => { LBGroup.EnableGroupMembers(lbGroupList, lastMouseOverGroupPos, false, lbGroup.editorSearchMemberFilter); RefreshSubGroupLists(); });
                                menu.AddSeparator("");

                                // If mouse was last over a group member, show context menu items
                                if (lastMouseOverGroupMemberPos >= 0)
                                {
                                    if (isGroupDesignerEnabled)
                                    {
                                        menu.AddItem(new GUIContent("Refresh Group Designer"), false, () => { lbGroupDesigner.RefreshWorkspace(true); });
                                    }

                                    if (isGroupDesignerEnabled && !isObjPathDesignerEnabled && lbGroupList[lastMouseOverGroupPos].showGroupDesigner)
                                    {
                                        //menu.AddSeparator("");
                                        menu.AddItem(new GUIContent("Select in Group Designer"), false, () =>
                                        {
                                            LBGroupDesignerItem lbGroupDesignerItemToSelect = lbGroupDesigner.GetGroupDesignerItem(lbGroupList[lastMouseOverGroupPos].groupMemberList[lastMouseOverGroupMemberPos]);
                                            if (lbGroupDesignerItemToSelect != null) { Selection.activeTransform = lbGroupDesignerItemToSelect.transform; }
                                        });
                                        menu.AddSeparator("");
                                    }

                                    if (isObjPathDesignerEnabled)
                                    {
                                        menu.AddItem(new GUIContent("Refresh Object Path"), false, () =>
                                        {
                                            RefreshObjPath(lbObjPathDesigner.lbGroup, lbObjPathDesigner.lbGroupMember, lbGroupDesigner, isGroupDesignerInitialised);
                                        });
                                        menu.AddSeparator("");
                                    }

                                    menu.AddItem(new GUIContent("Move Member " + (lastMouseOverGroupMemberPos + 1) + " to Top"), false, () =>
                                    {
                                        // Unselect any objects to prevent AddPrefab() being called
                                        if (isGroupDesignerInitialised) { Selection.activeObject = null; }

                                        LBGroup.MoveGroupMemberToTop(lbGroupList, lastMouseOverGroupPos, lastMouseOverGroupMemberPos);

                                        // Reset mouseover
                                        lastMouseOverGroupPos = -1;
                                        lastMouseOverGroupMemberPos = -1;

                                        RefreshSubGroupLists();

                                        if (isGroupDesignerInitialised)
                                        {
                                            lbGroupDesigner.RefreshWorkspace(false);
                                            isSceneDirtyRequired = true;
                                        }
                                        else { isSceneSaveRequired = true; }
                                    });
                                    menu.AddItem(new GUIContent("Move Member " + (lastMouseOverGroupMemberPos + 1) + " to End"), false, () =>
                                    {
                                        // Unselect any objects to prevent AddPrefab() being called
                                        if (isGroupDesignerInitialised) { Selection.activeObject = null; }

                                        LBGroup.MoveGroupMemberToEnd(lbGroupList, lastMouseOverGroupPos, lastMouseOverGroupMemberPos);

                                        // Reset mouseover
                                        lastMouseOverGroupPos = -1;
                                        lastMouseOverGroupMemberPos = -1;

                                        RefreshSubGroupLists();

                                        if (isGroupDesignerInitialised)
                                        {
                                            lbGroupDesigner.RefreshWorkspace(false);
                                            isSceneDirtyRequired = true;
                                        }
                                        else { isSceneSaveRequired = true; }
                                    });
                                    menu.AddSeparator("");
                                }
                            }
                            menu.AddItem(new GUIContent("Cancel"), false, () => { });
                            menu.ShowAsContext();
                            grpCurrentEvt.Use();
                        }
                    }

                    #endregion

                    if (!isGroupDesignerEnabled && !isObjPathDesignerEnabled)
                    {
                        if (landscape.isUndoTopographyDisabled)
                        {
                            EditorGUILayout.HelpBox("Override Undo Topography is enabled. NO UNDO.", MessageType.Warning, true);
                        }

                        if (GUILayout.Button("Populate Landscape With Groups")) { ApplyGroups(); }

                        EditorGUILayout.BeginHorizontal();
                        if (landscape.isUndoTopographyDisabled) { GUILayout.Button("*NO* Undo Terrain"); }
                        else { if (GUILayout.Button("Undo Flatten Terrain")) { UndoHeightmap(); } }
                        if (GUILayout.Button("Undo Tex")) { UndoTexturing(); }
                        if (GUILayout.Button("Undo Trees")) { UndoTrees(); }
                        if (GUILayout.Button("Undo Grass")) { UndoGrass(); }
                        EditorGUILayout.EndHorizontal();
                    }
                }
                else
                {
                    EditorGUILayout.HelpBox("No landscape to modify - you can add or find one in the landscape tab.", MessageType.Info, true);
                }

                #endregion
            }
            else if (selectedTabInt == 3)
            {
                // Texturing tab
                #region TexturingTab
                if (landscapeGameObject != null && landscape != null && isDefaultResourcesValid)
                {
                    DrawTexturingHeaderTex();
                    if (terrainTexturesList == null) { terrainTexturesList = new List<LBTerrainTexture>(); }

                    selectedTexturingPreset = EditorGUILayout.Popup("Texturing Preset", selectedTexturingPreset, texturingPresetNames.ToArray());
                    if (GUILayout.Button("Assign Textures from Preset"))
                    {
                        if (EditorUtility.DisplayDialog("Assign Textures from Preset?", "This action will clear all current textures and cannot be undone.", "Assign", "Cancel"))
                        {
                            SetFromTexturingPreset(selectedTexturingPreset);
                            if (disableAllTerrains) { LBLandscape.SetDisableAllTextures(disableAllTerrains = false); }
                        }
                        GetDRPresetNames();
                    }

                    // This code simulates the unity default array functionality, which editorgui can't do
                    arrayInt = terrainTexturesList.Count;
                    GUILayout.BeginHorizontal();

                    // A Foldout with no label must have a style fixedWidth of low non-zero value, and have a small (global) fieldWidth.
                    EditorGUIUtility.fieldWidth = 15f;
                    EditorGUI.BeginChangeCheck();
                    isTextureListExpanded = EditorGUILayout.Foldout(isTextureListExpanded, "", foldoutStyleNoLabel);
                    EditorGUIUtility.fieldWidth = defaultEditorFieldWidth;
                    if (EditorGUI.EndChangeCheck()) { TextureListExpand(isTextureListExpanded); }

                    if (GUILayout.Button("Add Texture")) { arrayInt++; }
                    if (GUILayout.Button("Remove Texture")) { if (arrayInt > 0) { if (LBEditorHelper.PromptForDelete("Texture", "", arrayInt - 1, false)) { arrayInt--; } } }
                    if (GUILayout.Button(texturingImportContent)) { LBImport.ImportTextures(landscape, true); arrayInt = terrainTexturesList.Count; }
                    if (arrayInt < 0) { arrayInt = 0; }
                    GUILayout.EndHorizontal();

                    // Disable All Textures ON/OFF
                    if (terrainTexturesList.Count > 0)
                    {
                        EditorGUILayout.Space();
                        EditorGUILayout.Space();

                        EditorGUIUtility.labelWidth = 125f;
                        prevToggleValue = disableAllTerrains;
                        disableAllTerrains = EditorGUILayout.Toggle(texturingDisableAllContent, disableAllTerrains);
                        EditorGUIUtility.labelWidth = defaultEditorLabelWidth;

                        if (prevToggleValue != disableAllTerrains)
                        {
                            // User has toggled value update each texture
                            foreach (LBTerrainTexture terrainTexture in terrainTexturesList)
                            {
                                terrainTexture.isDisabled = disableAllTerrains;
                            }

                            // Save the user choice to disk
                            LBLandscape.SetDisableAllTextures(disableAllTerrains);
                        }
                    }

                    if (landscape.useGPUTexturing)
                    {
                        Vector4 minmaxLBMapSize = LBTerrainTexture.GetMinMaxMapSize(terrainTexturesList);
                        if (minmaxLBMapSize.w >= 0 && (minmaxLBMapSize.x != minmaxLBMapSize.z || minmaxLBMapSize.y != minmaxLBMapSize.w))
                        {
                            EditorGUILayout.HelpBox("When GPU acceleration is enabled, different Map sizes may produce inconsistent results Min " + minmaxLBMapSize.x + "x" + minmaxLBMapSize.y + " Max " + minmaxLBMapSize.y + "z" + minmaxLBMapSize.w, MessageType.Info, true);
                        }
                    }

                    scrollPosition = EditorGUILayout.BeginScrollView(scrollPosition);
                    // Add items to the list
                    if (arrayInt > terrainTexturesList.Count)
                    {
                        temp = arrayInt - terrainTexturesList.Count;
                        for (index = 0; index < temp; index++)
                        {                           
                            terrainTexturesList.Add(new LBTerrainTexture());
                            if (disableAllTerrains) { LBLandscape.SetDisableAllTextures(disableAllTerrains = false); }
                        }
                    }
                    // Remove items from the list
                    else if (arrayInt < terrainTexturesList.Count)
                    {
                        temp = terrainTexturesList.Count - arrayInt;
                        for (index = 0; index < temp; index++)
                        {
                            terrainTexturesList.RemoveAt(terrainTexturesList.Count - 1);
                        }
                    }

                    // If the texture filter area highlighter is required this value will be set to true at some point before the end of 
                    // this block of code. If it is not set to true we will need to make sure the texture filter area highlighter is removed.
                    areaHighlighterRequired = false;

                    // No textures need inserting/removing at start of loop
                    textureToRemove = null;
                    insertTexturePos = -1;

                    txtCurrentEvt = Event.current;

                    #region Loop through Textures
                    for (index = 0; index < terrainTexturesList.Count; index++)
                    {
                        // Show the elements of the list
                        GUILayout.BeginVertical(EditorStyles.helpBox);
                        GUILayout.BeginHorizontal();
                        EditorGUI.BeginChangeCheck();
                        terrainTexturesList[index].isDisabled = !EditorGUILayout.Toggle(!terrainTexturesList[index].isDisabled, GUILayout.Width(20f));
                        if (EditorGUI.EndChangeCheck() && disableAllTerrains && !terrainTexturesList[index].isDisabled)
                        {
                            disableAllTerrains = false;
                        }

                        // GetTextureName() will return either the name of the texture or the last known name of the texture if the Texture2D image is missing.
                        if (terrainTexturesList[index].showTexture) { labelText = "<color=" + txtColourName + "><b>Texture " + (index + 1) + " </b></color>"; }
                        else { labelText = "<color=" + txtColourName + "><b>Texture " + (index + 1) + "</b> " + GetTextureName(terrainTexturesList[index].texture, terrainTexturesList[index].textureName) + "</color>"; }

                        EditorGUILayout.LabelField(labelText, labelFieldRichText);
                        if (GUILayout.Button(texturingScriptContent, buttonCompact, GUILayout.MaxWidth(20f))) { Debug.Log(terrainTexturesList[index].ScriptTexture(index, "\n")); }
                        if (GUILayout.Button(new GUIContent("I", "Insert new Texture above this Texture"), buttonCompact, GUILayout.Width(20f))) { insertTexturePos = index; }
                        if (terrainTexturesList[index].showTexture) { if (GUILayout.Button("Hide", buttonCompact, GUILayout.MaxWidth(40f))) { GUI.FocusControl(null); terrainTexturesList[index].showTexture = false; } }
                        else { if (GUILayout.Button("Show", buttonCompact, GUILayout.MaxWidth(40f))) { GUI.FocusControl(null); terrainTexturesList[index].showTexture = true; } }
                        if (GUILayout.Button("X", buttonCompact, GUILayout.MaxWidth(20f))) { textureToRemove = terrainTexturesList[index]; }
                        GUILayout.EndHorizontal();

                        if (terrainTexturesList[index].showTexture)
                        {
                            EditorGUIUtility.labelWidth = 250f;

                            // Support added LB 2.2.2
                            //if (landscape.useGPUTexturing && terrainTexturesList[index].texturingMode == LBTerrainTexture.TexturingMode.Imported)
                            //{
                            //    EditorGUILayout.HelpBox("Imported Textures are not currently supported with GPU acceleration.", MessageType.Warning);
                            //}

                            #region Texture2D and name
                            EditorGUI.BeginChangeCheck();
                            // GetTextureName() will return either the name of the texture or the last known name of the texture if the Texture2D image is missing.
                            terrainTexturesList[index].texture = (Texture2D)EditorGUILayout.ObjectField("Texture" + GetTextureName(terrainTexturesList[index].texture, terrainTexturesList[index].textureName), terrainTexturesList[index].texture, typeof(Texture2D), false);
                            // If the texture changes, update the TintedTexture too
                            if (EditorGUI.EndChangeCheck())
                            {
                                if (terrainTexturesList[index].isTinted)
                                {
                                    // Validate that the texture can be tinted
                                    LBTextureOperations.SetTextureAttributes(terrainTexturesList[index].texture, TextureImporterCompression.Uncompressed, FilterMode.Trilinear, true, 0, true);

                                    // Set the initial tint of the changed texture
                                    terrainTexturesList[index].tintedTexture = LBTextureOperations.TintTexture(terrainTexturesList[index].texture, terrainTexturesList[index].tintColour, terrainTexturesList[index].tintStrength);
                                }
                                // Ensure isRotated is disabled
                                terrainTexturesList[index].isRotated = false;

                                if (terrainTexturesList[index].texture == null) { terrainTexturesList[index].textureName = string.Empty; }
                                else { terrainTexturesList[index].textureName = terrainTexturesList[index].texture.name; }
                            }
                            #endregion

                            #region Normalmap
                            EditorGUI.BeginChangeCheck();
                            // GetTextureName() will return either the name of the normalmap or the last known name of the normalmap if the Texture2D image is missing.
                            terrainTexturesList[index].normalMap = (Texture2D)EditorGUILayout.ObjectField("Normal Map" + GetTextureName(terrainTexturesList[index].normalMap, terrainTexturesList[index].normalMapName), terrainTexturesList[index].normalMap, typeof(Texture2D), false);
                            if (EditorGUI.EndChangeCheck())
                            {
                                // Disable Texture rotation if there is a normalmap
                                if (terrainTexturesList[index].normalMap != null && terrainTexturesList[index].isRotated)
                                {
                                    terrainTexturesList[index].rotatedTexture = null;
                                    terrainTexturesList[index].isRotated = false;
                                }

                                if (terrainTexturesList[index].normalMap == null) { terrainTexturesList[index].normalMapName = string.Empty; }
                                else { terrainTexturesList[index].normalMapName = terrainTexturesList[index].normalMap.name; }
                            }
                            #endregion

                            #region Heightmap
                            if (landscape.showTextureHeightmap)
                            {
                                terrainTexturesList[index].heightMap = (Texture2D)EditorGUILayout.ObjectField(new GUIContent("Height Map" + GetTextureName(terrainTexturesList[index].heightMap), "Heightmap data for this Texture. You can use an Occlusion (AO) Map if you don't have a heightmap."), terrainTexturesList[index].heightMap, typeof(Texture2D), false);
                            }
                            #endregion

                            EditorGUIUtility.labelWidth = defaultEditorLabelWidth;

                            terrainTexturesList[index].tileSize = (Vector2)EditorGUILayout.Vector2Field("Tiling", terrainTexturesList[index].tileSize);
                            terrainTexturesList[index].metallic = EditorGUILayout.Slider("Metallic", terrainTexturesList[index].metallic, 0f, 1f);
                            terrainTexturesList[index].smoothness = EditorGUILayout.Slider("Smoothness", terrainTexturesList[index].smoothness, 0f, 1f);

                            #region Tinting
                            EditorGUI.BeginChangeCheck();
                            terrainTexturesList[index].isTinted = EditorGUILayout.Toggle(texturingIsTintedContent, terrainTexturesList[index].isTinted);
                            if (EditorGUI.EndChangeCheck())
                            {
                                // Update the tinted texture or set it to null
                                if (terrainTexturesList[index].isTinted)
                                {
                                    // Validate that the texture can be tinted
                                    LBTextureOperations.SetTextureAttributes(terrainTexturesList[index].texture, TextureImporterCompression.Uncompressed, FilterMode.Trilinear, true, 0, true);

                                    // Set the initial tint
                                    terrainTexturesList[index].tintedTexture = LBTextureOperations.TintTexture(terrainTexturesList[index].texture, terrainTexturesList[index].tintColour, terrainTexturesList[index].tintStrength);
                                }
                                else { terrainTexturesList[index].tintedTexture = null; }
                            }
                            if (terrainTexturesList[index].isTinted)
                            {
                                EditorGUI.BeginChangeCheck();
                                terrainTexturesList[index].tintColour = EditorGUILayout.ColorField(texturingTintColourContent, terrainTexturesList[index].tintColour);
                                terrainTexturesList[index].tintStrength = EditorGUILayout.Slider(texturingTintStrengthContent, terrainTexturesList[index].tintStrength, 0.1f, 1f);
                                if (EditorGUI.EndChangeCheck())
                                {
                                    terrainTexturesList[index].tintedTexture = LBTextureOperations.TintTexture(terrainTexturesList[index].texture, terrainTexturesList[index].tintColour, terrainTexturesList[index].tintStrength);
                                }

                                // NOTE: A GUIContext on a LabelField displays an incorrect colour representation of the texture.
                                // Instead, display an ObjectField that doesn't get set to anything if the user clicks Select or drags in another texture.
                                EditorGUILayout.ObjectField("Tinted Texture", terrainTexturesList[index].tintedTexture, typeof(Texture2D), false);
                            }
                            #endregion

                            #region Rotation
                            // Rotate a texture (that doesn't have a normalmap) by number of degrees (multiples of +/- 90 only).
                            EditorGUI.BeginChangeCheck();
                            terrainTexturesList[index].isRotated = EditorGUILayout.Toggle(texturingIsRotatedContent, terrainTexturesList[index].isRotated);
                            if (EditorGUI.EndChangeCheck())
                            {
                                // Update the rotated texture or set it to null
                                if (terrainTexturesList[index].isRotated && terrainTexturesList[index].normalMap == null)
                                {
                                    // Validate that the texture can be tinted
                                    LBTextureOperations.SetTextureAttributes(terrainTexturesList[index].texture, TextureImporterCompression.Uncompressed, FilterMode.Trilinear, true, 0, true);

                                    // Set the initial rotation
                                    terrainTexturesList[index].rotatedTexture = LBTextureOperations.RotateTexture(terrainTexturesList[index].texture, terrainTexturesList[index].rotationAngle);
                                }
                                else { terrainTexturesList[index].rotatedTexture = null; terrainTexturesList[index].isRotated = false; }
                            }
                            if (terrainTexturesList[index].isRotated)
                            {
                                // Default to 90
                                if (terrainTexturesList[index].rotationAngle == 0f) { terrainTexturesList[index].rotationAngle = 90f; }
                                EditorGUI.BeginChangeCheck();
                                // Limit to +/- 90, 180, 270
                                terrainTexturesList[index].rotationAngle = (float)EditorGUILayout.IntPopup("Rotation Angle", (int)terrainTexturesList[index].rotationAngle, possibleRotationAngleStrings, possibleRotationAngles);

                                if (EditorGUI.EndChangeCheck())
                                {
                                    terrainTexturesList[index].rotatedTexture = LBTextureOperations.RotateTexture(terrainTexturesList[index].texture, terrainTexturesList[index].rotationAngle);
                                }

                                // NOTE: A GUIContext on a LabelField displays an incorrect colour representation of the texture.
                                // Instead, display an ObjectField that doesn't get set to anything if the user clicks Select or drags in another texture.
                                EditorGUILayout.ObjectField("Rotated Texture", terrainTexturesList[index].rotatedTexture, typeof(Texture2D), false);
                            }
                            #endregion

                            terrainTexturesList[index].texturingMode = (LBTerrainTexture.TexturingMode)EditorGUILayout.EnumPopup("Texturing Mode", terrainTexturesList[index].texturingMode);

                            #region Terrain Height for Textures
                            if (terrainTexturesList[index].texturingMode == LBTerrainTexture.TexturingMode.Height ||
                                terrainTexturesList[index].texturingMode == LBTerrainTexture.TexturingMode.HeightAndInclination ||
                                terrainTexturesList[index].texturingMode == LBTerrainTexture.TexturingMode.HeightInclinationCurvature ||
                                terrainTexturesList[index].texturingMode == LBTerrainTexture.TexturingMode.HeightInclinationMap)
                            {
                                terrainTexturesList[index].minHeight = EditorGUILayout.Slider(texturingMinHeightContent, terrainTexturesList[index].minHeight * terrainHeight, 0f, terrainHeight) / terrainHeight;
                                terrainTexturesList[index].maxHeight = EditorGUILayout.Slider(texturingMaxHeightContent, terrainTexturesList[index].maxHeight * terrainHeight, 0f, terrainHeight) / terrainHeight;
                                if (terrainTexturesList[index].maxHeight < terrainTexturesList[index].minHeight)
                                {
                                    terrainTexturesList[index].maxHeight = terrainTexturesList[index].minHeight;
                                }
                            }
                            #endregion

                            #region Terrain Inclination for Textures
                            if (terrainTexturesList[index].texturingMode == LBTerrainTexture.TexturingMode.Inclination ||
                                terrainTexturesList[index].texturingMode == LBTerrainTexture.TexturingMode.HeightAndInclination ||
                                terrainTexturesList[index].texturingMode == LBTerrainTexture.TexturingMode.HeightInclinationCurvature ||
                                terrainTexturesList[index].texturingMode == LBTerrainTexture.TexturingMode.HeightInclinationMap)
                            {
                                terrainTexturesList[index].minInclination = EditorGUILayout.Slider(texturingMinInclinationContent, terrainTexturesList[index].minInclination, 0f, 90f);
                                terrainTexturesList[index].maxInclination = EditorGUILayout.Slider(texturingMaxInclinationContent, terrainTexturesList[index].maxInclination, 0f, 90f);
                                if (terrainTexturesList[index].maxInclination < terrainTexturesList[index].minInclination)
                                {
                                    terrainTexturesList[index].maxInclination = terrainTexturesList[index].minInclination;
                                }
                            }
                            #endregion

                            #region Terrain Curvature for Textures
                            if (terrainTexturesList[index].texturingMode == LBTerrainTexture.TexturingMode.HeightInclinationCurvature)
                            {
                                // CurvatureType only has 2 values. Convert from Enum to Int so can be compared with 0 (Concave) to produce a bool.
                                terrainTexturesList[index].isCurvatureConcave = ((int)(CurvatureType)EditorGUILayout.EnumPopup(texturingCurvatureTypeContent, (CurvatureType)(terrainTexturesList[index].isCurvatureConcave ? 0 : 1), GUILayout.ExpandWidth(true)) == 0);
                                terrainTexturesList[index].curvatureMinHeightDiff = EditorGUILayout.Slider(texturingCurvatureMinHeightDiffContent, terrainTexturesList[index].curvatureMinHeightDiff, 0.01f, 10f);
                                terrainTexturesList[index].curvatureDistance = EditorGUILayout.Slider(texturingCurvatureDistanceContent, terrainTexturesList[index].curvatureDistance, 0f, 50f);
                            }
                            #endregion

                            #region Terrain Inclination for Map
                            if (terrainTexturesList[index].texturingMode == LBTerrainTexture.TexturingMode.Map ||
                                terrainTexturesList[index].texturingMode == LBTerrainTexture.TexturingMode.HeightInclinationMap)
                            {
                                if (landscape.useGPUTexturing && !terrainTexturesList[index].mapIsPath)
                                {
                                    EditorGUILayout.HelpBox("In this version GPU acceleration only supports grayscale maps. Selecting Map Is From Path will enable this.", MessageType.Warning);
                                }

                                EditorGUI.BeginChangeCheck();
                                GUILayout.BeginHorizontal();
                                labelText = "Map" + GetTextureName(terrainTexturesList[index].map) + (terrainTexturesList[index].map != null ? "\n\n" + terrainTexturesList[index].map.width + "x" + terrainTexturesList[index].map.height : "\n");
                                GUILayout.Label(labelText, GUILayout.MaxWidth(defaultEditorLabelWidth), GUILayout.MaxHeight(60f));
                                terrainTexturesList[index].map = (Texture2D)EditorGUILayout.ObjectField("", terrainTexturesList[index].map, typeof(Texture2D), false);
                                GUILayout.EndHorizontal();
                                if (EditorGUI.EndChangeCheck())
                                {
                                    if (terrainTexturesList[index].map != null) { LBTextureOperations.EnableReadable(terrainTexturesList[index].map, true, true); }
                                }

                                if (!terrainTexturesList[index].mapIsPath)
                                {
                                    terrainTexturesList[index].mapColour = EditorGUILayout.ColorField("Colour", terrainTexturesList[index].mapColour);
                                }

                                EditorGUI.BeginChangeCheck();
                                terrainTexturesList[index].mapIsPath = EditorGUILayout.Toggle(texturingMapIsPathContent, terrainTexturesList[index].mapIsPath);
                                if (EditorGUI.EndChangeCheck())
                                {
                                    // Map Path and tolerance are mutually exclusive
                                    terrainTexturesList[index].useAdvancedMapTolerance = false;

                                    if (terrainTexturesList[index].mapIsPath)
                                    {
                                        // Use the default LBPath curve when in Map mode
                                        terrainTexturesList[index].mapToleranceBlendCurve = LBPath.GetDefaultBlendCurve;
                                        terrainTexturesList[index].mapColour = UnityEngine.Color.white;
                                    }
                                    // Use the default curve when switching back to standard tolerance mode
                                    else { terrainTexturesList[index].mapToleranceBlendCurve = LBMap.GetDefaultToleranceBlendCurve; }
                                }

                                EditorGUI.BeginChangeCheck();
                                terrainTexturesList[index].useAdvancedMapTolerance = EditorGUILayout.Toggle(texturingUseAdvMapToleranceContent, terrainTexturesList[index].useAdvancedMapTolerance);
                                if (EditorGUI.EndChangeCheck() && !terrainTexturesList[index].useAdvancedMapTolerance)
                                {
                                    // Always use the default blend curve when in "standard" map tolerance mode
                                    terrainTexturesList[index].mapToleranceBlendCurve = LBMap.GetDefaultToleranceBlendCurve;
                                }
                                // Advanced matching to the Map on colour channels gives more control
                                if (terrainTexturesList[index].useAdvancedMapTolerance)
                                {
                                    if (landscape.useGPUTexturing)
                                    {
                                        EditorGUILayout.HelpBox("Map Advanced is not supported with GPU acceleration. If you need more control with blending, import the map into a Stencil Layer and add a Stencil Layer Filter to this Texture", MessageType.Warning);
                                    }

                                    // Map Path and tolerance are mutually exclusive
                                    terrainTexturesList[index].mapIsPath = false;

                                    terrainTexturesList[index].mapToleranceRed = EditorGUILayout.IntSlider(new GUIContent("Tolerance Red", "Red channel tolerance on the map to allow for blended edges"), terrainTexturesList[index].mapToleranceRed, 0, 255);
                                    terrainTexturesList[index].mapToleranceGreen = EditorGUILayout.IntSlider(new GUIContent("Tolerance Green", "Green channel tolerance on the map to allow for blended edges"), terrainTexturesList[index].mapToleranceGreen, 0, 255);
                                    terrainTexturesList[index].mapToleranceBlue = EditorGUILayout.IntSlider(new GUIContent("Tolerance Blue", "Blue channel tolerance on the map to allow for blended edges"), terrainTexturesList[index].mapToleranceBlue, 0, 255);
                                    terrainTexturesList[index].mapToleranceAlpha = EditorGUILayout.IntSlider(new GUIContent("Tolerance Alpha", "Alpha channel tolerance on the map to allow for blended edges"), terrainTexturesList[index].mapToleranceAlpha, 0, 255);
                                    terrainTexturesList[index].mapWeightRed = EditorGUILayout.Slider(new GUIContent("Weight Red", "The amount of influence the Red channel has on tolerance"), terrainTexturesList[index].mapWeightRed, 0f, 1f);
                                    terrainTexturesList[index].mapWeightGreen = EditorGUILayout.Slider(new GUIContent("Weight Green", "The amount of influence the Green channel has on tolerance"), terrainTexturesList[index].mapWeightGreen, 0f, 1f);
                                    terrainTexturesList[index].mapWeightBlue = EditorGUILayout.Slider(new GUIContent("Weight Blue", "The amount of influence the Blue channel has on tolerance"), terrainTexturesList[index].mapWeightBlue, 0f, 1f);
                                    terrainTexturesList[index].mapWeightAlpha = EditorGUILayout.Slider(new GUIContent("Weight Alpha", "The amount of influence the Alpha channel has on tolerance"), terrainTexturesList[index].mapWeightAlpha, 0f, 1f);

                                    // Show the elements of the list
                                    LBCurve.BlendCurvePreset newCurvePreset;
                                    newCurvePreset = (LBCurve.BlendCurvePreset)EditorGUILayout.EnumPopup("Preset", terrainTexturesList[index].mapToleranceBlendCurvePreset);
                                    if (newCurvePreset != terrainTexturesList[index].mapToleranceBlendCurvePreset)
                                    {
                                        terrainTexturesList[index].mapToleranceBlendCurve = LBCurve.SetCurveFromPreset((LBCurve.CurvePreset)newCurvePreset);
                                        terrainTexturesList[index].mapToleranceBlendCurvePreset = newCurvePreset;
                                    }
                                    EditorGUILayout.BeginHorizontal();
                                    GUILayout.Label(new GUIContent("Blend Modifier", "The blend curve used when the Colour does not exactly match the pixel in the Map texture and tolerances are greater than 0"), GUILayout.Width(EditorGUIUtility.labelWidth - 28f));
                                    AddScriptCurveButton(terrainTexturesList[index].mapToleranceBlendCurve, "mapToleranceBlendCurve");
                                    terrainTexturesList[index].mapToleranceBlendCurve = EditorGUILayout.CurveField(terrainTexturesList[index].mapToleranceBlendCurve, GUILayout.Height(30f));
                                    EditorGUILayout.EndHorizontal();
                                }
                                else if (!terrainTexturesList[index].mapIsPath)
                                {
                                    terrainTexturesList[index].mapTolerance = EditorGUILayout.IntSlider(texturingMapToleranceContent, terrainTexturesList[index].mapTolerance, 0, 20);
                                }

                                terrainTexturesList[index].mapInverse = EditorGUILayout.Toggle(texturingMapInverseContent, terrainTexturesList[index].mapInverse);
                            }
                            #endregion

                            #region Noise
                            terrainTexturesList[index].useNoise = EditorGUILayout.Toggle(texturingUseNoiseContent, terrainTexturesList[index].useNoise);
                            if (terrainTexturesList[index].useNoise)
                            {
                                terrainTexturesList[index].isMinimalBlendingEnabled = EditorGUILayout.Toggle(texturingIsMinimalBlendContent, terrainTexturesList[index].isMinimalBlendingEnabled);
                                terrainTexturesList[index].noiseTileSize = EditorGUILayout.Slider(texturingNoiseTileSizeContent, terrainTexturesList[index].noiseTileSize, 10f, 1000f);
                            }
                            else
                            {
                                // Minimal Blending is always disabled when Noise is disabled.
                                terrainTexturesList[index].isMinimalBlendingEnabled = false;
                            }
                            #endregion

                            terrainTexturesList[index].strength = EditorGUILayout.Slider(texturingStrengthContent, terrainTexturesList[index].strength, 0f, 2f);

                            #region Texture filters
                            GUILayout.BeginHorizontal();
                            if (GUILayout.Button(texturingAddFilterContent, GUILayout.Width(100f)))
                            {
                                // Create a new default Area filter
                                LBTextureFilter newLBTextureFilter = new LBTextureFilter(LBTextureFilter.FilterType.Area, LBTextureFilter.FilterMode.OR);
                                if (newLBTextureFilter != null)
                                {
                                    // If this is the first filter, create an empty List of LBFilters.
                                    if (terrainTexturesList[index].filterList == null)
                                    {
                                        terrainTexturesList[index].filterList = new List<LBTextureFilter>();
                                    }
                                    terrainTexturesList[index].filterList.Add(newLBTextureFilter);
                                    isSceneSaveRequired = true;
                                }
                            }
                            if (terrainTexturesList[index].filterList != null)
                            {
                                if (terrainTexturesList[index].filterList.Count > 0)
                                {
                                    if (GUILayout.Button("Remove Filter", GUILayout.Width(100f)))
                                    {
                                        // Remove the last one from the list
                                        terrainTexturesList[index].filterList.RemoveAt(terrainTexturesList[index].filterList.Count - 1);
                                        isSceneSaveRequired = true;
                                    }
                                }
                            }
                            GUILayout.EndHorizontal();

                            // Display the Texture filters
                            if (terrainTexturesList[index].filterList != null)
                            {
                                //if (landscape.useGPUTexturing)
                                //{
                                //    EditorGUILayout.HelpBox("Stencil layer resolutions of 1K, 2K, 4K and 8K are currently supported with GPU acceleration.", MessageType.Info);
                                //}

                                for (int filterIndex = 0; filterIndex < terrainTexturesList[index].filterList.Count; filterIndex++)
                                {
                                    textureLBTextureFilter = terrainTexturesList[index].filterList[filterIndex];

                                    if (textureLBTextureFilter != null)
                                    {
                                        EditorGUILayout.Space();

                                        GUILayout.BeginHorizontal();
                                        labelText = "<color=" + txtColourName + "><i>Filter " + (filterIndex + 1).ToString("00") + " </i></color>";
                                        EditorGUILayout.LabelField(labelText, labelFieldRichText, GUILayout.MaxWidth(50f));

                                        EditorGUI.BeginChangeCheck();
                                        textureLBTextureFilter.filterType = (LBTextureFilter.FilterType)EditorGUILayout.EnumPopup(textureLBTextureFilter.filterType, GUILayout.Width(90f));
                                        if (EditorGUI.EndChangeCheck())
                                        {
                                            if (textureLBTextureFilter.filterType == LBTextureFilter.FilterType.StencilLayer)
                                            {
                                                // Only AND or NOT are supported for StencilLayer filters, so default to AND
                                                textureLBTextureFilter.filterMode = LBTextureFilter.FilterMode.AND;
                                                isSceneSaveRequired = true;
                                            }
                                        }

                                        EditorGUI.BeginChangeCheck();
                                        textureLBTextureFilter.filterMode = (LBTextureFilter.FilterMode)EditorGUILayout.EnumPopup(textureLBTextureFilter.filterMode, GUILayout.MaxWidth(50f));
                                        if (EditorGUI.EndChangeCheck() && textureLBTextureFilter.filterType == LBTextureFilter.FilterType.StencilLayer)
                                        {
                                            if (textureLBTextureFilter.filterMode == LBTextureFilter.FilterMode.OR)
                                            {
                                                // Only AND or NOT are supported for StencilLayer filters
                                                textureLBTextureFilter.filterMode = LBTextureFilter.FilterMode.AND;
                                                isSceneSaveRequired = true;
                                                Debug.Log("INFO: Sorry, only AND/NOT filters are supported for Texturing Stencil Layer filters");
                                            }
                                        }

                                        // Provide a quick way of editing the selected Stencil
                                        if (textureLBTextureFilter.filterType == LBTextureFilter.FilterType.StencilLayer)
                                        {
                                            if (GUILayout.Button(commonStencilEditButtonContent, buttonCompactNoOffset, GUILayout.MaxWidth(40f)))
                                            {
                                                if (textureLBTextureFilter.lbStencil != null)
                                                {
                                                    Transform stencilTransform = textureLBTextureFilter.lbStencil.transform;
                                                    if (stencilTransform != null)
                                                    {
                                                        Selection.activeTransform = stencilTransform;
                                                        #if UNITY_2018_2_OR_NEWER
                                                        LBEditorHelper.CallMenu("Window/General/Inspector");
                                                        #else
                                                        LBEditorHelper.CallMenu("Window/Inspector");
                                                        #endif
                                                        //textureLBTextureFilter.lbStencil.showStencilInScene = true;
                                                    }
                                                }
                                            }
                                        }

                                        GUILayout.EndHorizontal();

                                        // Each filter can be a different type.
                                        if (textureLBTextureFilter.filterType == LBTextureFilter.FilterType.Area)
                                        {
                                            // Is the texture area highlighter required?
                                            areaHighlighterRequired = (areaHighlighterRequired || textureLBTextureFilter.showAreaHighlighter);

                                            if (textureLBTextureFilter.showAreaHighlighter)
                                            {
                                                GUILayout.BeginHorizontal();
                                                if (GUILayout.Button("Disable Area Picker", buttonCompact, GUILayout.MaxWidth(125f)))
                                                {
                                                    textureLBTextureFilter.showAreaHighlighter = false;
                                                    areaHighlighterRequired = false;
                                                }
                                                if (GUILayout.Button("Move Area to View", buttonCompact, GUILayout.MaxWidth(125f)))
                                                {
                                                    textureFilterAreaHighlighter.MoveToSceneView();
                                                }
                                                GUILayout.EndHorizontal();
                                            }
                                            else if (!textureFilterAreaHighlighterEnabled)
                                            {
                                                if (GUILayout.Button("Enable Area Picker", buttonCompact, GUILayout.MaxWidth(125f)))
                                                {
                                                    textureLBTextureFilter.showAreaHighlighter = true;
                                                    areaHighlighterRequired = true;
                                                }
                                            }

                                            if (textureFilterAreaHighlighter != null && textureLBTextureFilter.showAreaHighlighter && textureFilterAreaHighlighter.AreaRectSet())
                                            {
                                                textureLBTextureFilter.areaRect = textureFilterAreaHighlighter.GetAreaRect();
                                            }
                                            textureLBTextureFilter.areaRect = EditorGUILayout.RectField(texturingAreaRectContent, textureLBTextureFilter.areaRect);
                                            if (textureFilterAreaHighlighter != null && textureLBTextureFilter.showAreaHighlighter)
                                            {
                                                textureFilterAreaHighlighter.AssignAreaRect(textureLBTextureFilter.areaRect, landscape.transform.position, terrainHeight);
                                            }
                                            EditorGUILayout.HelpBox("To filter with an irregular shape, create a Stencil Layer filter", MessageType.Info, true);
                                        }
                                        else if (textureLBTextureFilter.filterType == LBTextureFilter.FilterType.StencilLayer)
                                        {
                                            // If there is a Stencil selected, populate the temporary class instance
                                            if (textureLBTextureFilter.lbStencilGUID != null && textureLBTextureFilter.lbStencil == null)
                                            {
                                                textureLBTextureFilter.lbStencil = LBStencil.GetStencilInLandscape(landscape, textureLBTextureFilter.lbStencilGUID, true);
                                            }

                                            EditorGUI.BeginChangeCheck();
                                            textureLBTextureFilter.lbStencil = (LBStencil)EditorGUILayout.ObjectField(texturingFilterStencilContent, textureLBTextureFilter.lbStencil, typeof(LBStencil), true);
                                            if (EditorGUI.EndChangeCheck())
                                            {
                                                textureLBTextureFilter.lbStencilGUID = textureLBTextureFilter.lbStencil.GUID;
                                                textureLBTextureFilter.lbStencilLayerGUID = string.Empty;
                                                // When user selects a different stencil, default to the first stencil layer
                                                if (textureLBTextureFilter.lbStencil.stencilLayerList != null)
                                                {
                                                    if (textureLBTextureFilter.lbStencil.stencilLayerList.Count > 0)
                                                    {
                                                        textureLBTextureFilter.lbStencilLayerGUID = textureLBTextureFilter.lbStencil.stencilLayerList[0].GUID;
                                                    }
                                                }
                                            }

                                            // Get list of LBStencilLayers for the current LBStencil
                                            if (textureLBTextureFilter.lbStencil != null)
                                            {
                                                // Get a list of the Layer Names and their GUIDs
                                                List<string> texturingFilterStencilLayerGUIDList = new List<string>();
                                                List<string> texturingFilterStencilLayerNameList = new List<string>();
                                                int texturingFilterStencilLayerIndex = 0;

                                                if (textureLBTextureFilter.lbStencil.stencilLayerList != null)
                                                {
                                                    foreach (LBStencilLayer lbStencilLayer in textureLBTextureFilter.lbStencil.stencilLayerList)
                                                    {
                                                        if (!string.IsNullOrEmpty(lbStencilLayer.GUID))
                                                        {
                                                            texturingFilterStencilLayerGUIDList.Add(lbStencilLayer.GUID);
                                                            texturingFilterStencilLayerNameList.Add(lbStencilLayer.LayerName);
                                                        }
                                                    }

                                                    // Find the stencil layer that was last selected in the tree filter
                                                    texturingFilterStencilLayerIndex = texturingFilterStencilLayerGUIDList.FindIndex(sl => sl == textureLBTextureFilter.lbStencilLayerGUID);
                                                }

                                                // Display the list of Stencil Layers for the selected Stencil.
                                                EditorGUI.BeginChangeCheck();
                                                texturingFilterStencilLayerIndex = EditorGUILayout.Popup("Stencil Layer", texturingFilterStencilLayerIndex, texturingFilterStencilLayerNameList.ToArray());

                                                if (EditorGUI.EndChangeCheck() && texturingFilterStencilLayerGUIDList.Count > texturingFilterStencilLayerIndex && texturingFilterStencilLayerIndex >= 0)
                                                {
                                                    // Update the stencil layer for this tree filter
                                                    textureLBTextureFilter.lbStencilLayerGUID = texturingFilterStencilLayerGUIDList[texturingFilterStencilLayerIndex];
                                                }
                                            }
                                        }
                                    }
                                }
                            }  // end Texture filters
                            #endregion

                            // Is the Mouse over this Texture? (Used for context GenericMenu)
                            if (txtCurrentEvt != null && txtCurrentEvt.type == EventType.Repaint && GUILayoutUtility.GetLastRect().Contains(txtCurrentEvt.mousePosition))
                            {
                                lastMouseOverTxtPos = index;
                                //Debug.Log("Hover Texture " + (lastMouseOverTxtPos + 1));
                            }

                        }
                        GUILayout.EndVertical();
                    }
                    #endregion

                    #region Insert/Delete Texture
                    // More than one texture "could" be removed in same frame but very unlikely so just use the last one
                    if (textureToRemove != null)
                    {
                        int texturePos = terrainTexturesList.FindIndex(tx => tx == textureToRemove);
                        labelText = "Texture " + (texturePos + 1).ToString() + " " + GetTextureName(textureToRemove.texture) + " will be deleted ";
                        labelText += "\n\nThis action will remove the texture from the list and cannot be undone.";
                        if (LBEditorHelper.PromptForDelete("Delete Texture?", labelText))
                        {
                            terrainTexturesList.Remove(textureToRemove);
                        }
                    }
                    // Does the user wish to insert a new (duplicate) texture into the list?
                    else if (insertTexturePos >= 0)
                    {
                        // Insert a duplicate above the selected Texture
                        terrainTexturesList.Insert(insertTexturePos, new LBTerrainTexture(terrainTexturesList[insertTexturePos]));

                        // Create a new GUID for the duplicated Texture Type
                        terrainTexturesList[insertTexturePos].GUID = System.Guid.NewGuid().ToString();

                        // Show the new duplicate, and hide the original
                        terrainTexturesList[insertTexturePos].showTexture = true;
                        terrainTexturesList[insertTexturePos + 1].showTexture = false;
                        isSceneSaveRequired = true;
                    }
                    #endregion

                    #region Area Highlighter
                    // Enable or disable the texture Filter Area Highlighter
                    if (areaHighlighterRequired && textureFilterAreaHighlighter == null)
                    {
                        textureFilterAreaHighlighter = GameObject.FindObjectOfType<LBAreaHighlight>();
                        if (textureFilterAreaHighlighter == null)
                        {
                            textureFilterAreaHighlighter = LBAreaHighlight.CreateAreaHighLighter();
                            // Set to enabled so that we know when we need to repaint the editor in OnInspectorUpdate()
                            textureFilterAreaHighlighterEnabled = true;
                        }
                    }
                    else if (!areaHighlighterRequired && textureFilterAreaHighlighter != null)
                    {
                        DestroyImmediate(textureFilterAreaHighlighter.gameObject);
                        textureFilterAreaHighlighterEnabled = false;
                    }
                    #endregion

                    EditorGUILayout.EndScrollView();

                    #region MegaSplat Texturing
                    #if __MEGASPLAT__
                    if (isMegaSplatInstalled)
                    {
                        GUILayout.BeginVertical(EditorStyles.helpBox);

                        labelText = "<color=" + txtColourName + "><b>MegaSplat Texturing</b></color>";
                        EditorGUILayout.LabelField(labelText, labelFieldRichText);

                        GUILayout.Space(5);
                        GUILayout.BeginHorizontal();
                        GUILayout.Label("Texture Array Config", GUILayout.Width(EditorGUIUtility.labelWidth));

                        if (GUILayout.Button(new GUIContent("Create / Select", "Create a new Texture Array Config if required"), GUILayout.Width(100f)))
                        {
                            if (terrainCustomMaterial != null && landscape.terrainCustomMaterial == null) { landscape.terrainCustomMaterial = terrainCustomMaterial; }

                            LBIntegration.MegaSplatCreateTextureArray(landscape, terrainMaterialType, true);
                        }

                        if (GUILayout.Button(new GUIContent("Copy Textures", "Copy Textures to MegaSplat Texture Array"), GUILayout.MaxWidth(100f)))
                        {
                            if (terrainCustomMaterial != null && landscape.terrainCustomMaterial == null) { landscape.terrainCustomMaterial = terrainCustomMaterial; }

                            LBEditorIntegration.MegaSplatCopyTextures(landscape, terrainMaterialType, true);
                        }

                        GUILayout.EndHorizontal();

                        // Temp stores another Tex2DArray which can be copied
                        // Really we'd like to use the Tex Array Config but we can't cast the ObjectField to the TextureArrayConfig type
                        GUILayout.BeginHorizontal();
                        GUILayout.Label(new GUIContent("Copy from Existing", "Copy an existing Texture2D Array Config"), GUILayout.Width(EditorGUIUtility.labelWidth));

                        EditorGUI.BeginChangeCheck();
                        megaSplatT2Array2Copy = (Texture2DArray)EditorGUILayout.ObjectField(megaSplatT2Array2Copy, typeof(Texture2DArray), false);
                        bool isReplaceTextureArray = EditorGUI.EndChangeCheck();

                        // End Horizontal, Vertical must come before call to MegaSplatCreateTextureArray(), else an GUILayout error occurs
                        GUILayout.EndHorizontal();
                        GUILayout.EndVertical();  // end helpBox style

                        if (isReplaceTextureArray)
                        {
                            if (megaSplatT2Array2Copy != null)
                            {
                                if (terrainCustomMaterial != null && landscape.terrainCustomMaterial == null) { landscape.terrainCustomMaterial = terrainCustomMaterial; }
                                if (LBIntegration.MegaSplatReplaceTextureArray(landscape, megaSplatT2Array2Copy, true))
                                {
                                    // Only create the config if the selected TextureArray has a matching Config file (that we could guess it's name from the array file)
                                    LBIntegration.MegaSplatCreateTextureArray(landscape, terrainMaterialType, true);
                                }
                            }
                        }

                        // Add some space to separate the MegaSplat buttons from the Texture Landscape button
                        GUILayout.Space(10);
                    }
                    
                    #endif
                    #endregion

                    #region RTP Help Msgbox
                    if (terrainMaterialType == LBLandscape.TerrainMaterialType.ReliefTerrainPack)
                    {
                        EditorGUILayout.HelpBox("Texturing will update and/or replace Textures, normal maps and height map textures in RTP. When switching from 5+ textures to 4, you may need to manually disable '8 LAYERS in first pass' in RTP LOD Manager and Recompile Shaders.", MessageType.Info, true);
                    }
                    #endregion

                    // Do not permit texture generation or other operations from the Texturing tab, when a Group Object Path is being edited
                    if (!IsObjPathDesignerOpen(true))
                    {
                        #region Texture-Level Context Menu

                        // Place context menu outside the list of textures. We track which texture the mouse is over while iterating through the textures.
                        // However, because we can only get the GUILayout control rectangle during a Paint event, we can't reliably get the correct texture AND check for
                        // the ContextClick event at the same time.

                        if (txtCurrentEvt != null && terrainTexturesList != null)
                        {
                            if (txtCurrentEvt.type == EventType.ContextClick)
                            {
                                GenericMenu menu = new GenericMenu();
                                menu.AddItem(new GUIContent("Apply Textures"), false, () => { TextureLandscape(); });
                                menu.AddItem(new GUIContent("Undo Textures"), false, () => { UndoTexturing(); });
                                menu.AddSeparator("");
                                // If the mouse was last over a texture, show Texture-context menu items
                                if (lastMouseOverTxtPos >= 0)
                                {
                                    //menu.AddItem(new GUIContent("Do something Texture " + (lastMouseOverTxtPos + 1)), false, () => { LBTerrainTexture.xxx(terrainTexturesList, lastMouseOverTxtPos); });
                                    //menu.AddSeparator("");
                                }
                                menu.AddItem(new GUIContent("Cancel"), false, () => { });
                                menu.ShowAsContext();
                                txtCurrentEvt.Use();
                            }
                        }

                        #endregion

                        #region Texture Landscape and Undo Buttons
                        if (GUILayout.Button("Texture Landscape"))
                        {
                            TextureLandscape();
                        }

                        if (GUILayout.Button("Undo Texture Modification"))
                        {
                            landscape.RevertToLastSave(LBLandscape.UndoType.Textures);

                            if (autoSaveEnabled) { sceneSaved = EditorSceneManager.SaveScene(EditorSceneManager.GetActiveScene()); }
                            else { EditorSceneManager.MarkSceneDirty(EditorSceneManager.GetActiveScene()); }
                        }

                        #endregion Texture Landscape and Undo Buttons
                    }
                }
                else if (!isDefaultResourcesValid)
                {

                }
                else
                {
                    EditorGUILayout.HelpBox("No landscape to modify - you can add or find one in the landscape tab.", MessageType.Info, true);
                }
                #endregion
            }
            else if (selectedTabInt == 4)
            {
                // Trees tab
                #region TreesTab
                if (landscapeGameObject != null && landscape != null && isDefaultResourcesValid)
                {
                    DrawTreeHeaderTex();

                    if (terrainTreesList == null) { terrainTreesList = new List<LBTerrainTree>(); }

                    #region Tree Presets
                    selectedTreePreset = EditorGUILayout.Popup("Trees Preset", selectedTreePreset, treePresetNames.ToArray());
                    if (GUILayout.Button("Assign Trees from Preset"))
                    {
                        if (EditorUtility.DisplayDialog("Assign Trees from Preset?", "This action will clear all current trees and cannot be undone.", "Assign", "Cancel"))
                        {
                            SetFromTreePreset(selectedTreePreset);
                        }
                        GetDRPresetNames();
                    }
                    #endregion

                    GUILayout.BeginHorizontal();
                    landscape.treesHaveColliders = EditorGUILayout.Toggle(new GUIContent("Trees Have Colliders", "Whether the defined trees have colliders"), landscape.treesHaveColliders, GUILayout.MaxWidth(180f));
                    landscape.treePlacementSpeed = (LBTerrainTree.TreePlacementSpeed)EditorGUILayout.EnumPopup(landscape.treePlacementSpeed, GUILayout.MaxWidth(120f));
                    GUILayout.EndHorizontal();
                    if (landscape.treesHaveColliders)
                    {
                        maxTreeAmount = Mathf.RoundToInt(64000f / ((landscape.size.x / 1000f) * (landscape.size.y / 1000f)));
                    }
                    else
                    {
                        maxTreeAmount = 10000;
                    }

                    // This code simulates the unity default array functionality, which editorgui can't do
                    arrayInt = terrainTreesList.Count;
                    GUILayout.BeginHorizontal();

                    // A Foldout with no label must have a style fixedWidth of low non-zero value, and have a small (global) fieldWidth.
                    EditorGUIUtility.fieldWidth = 15f;
                    EditorGUI.BeginChangeCheck();
                    isTreeListExpanded = EditorGUILayout.Foldout(isTreeListExpanded, "", foldoutStyleNoLabel);
                    EditorGUIUtility.fieldWidth = defaultEditorFieldWidth;
                    if (EditorGUI.EndChangeCheck()) { TreeListExpand(isTreeListExpanded); }

                    #region Add Remove Import Tree Buttons
                    if (GUILayout.Button("Add Tree Type")) { arrayInt++; }
                    if (GUILayout.Button("Remove Tree Type")) { if (arrayInt > 0) { if (LBEditorHelper.PromptForDelete("Tree Type", "", arrayInt - 1, false)) { arrayInt--; } } }
                    if (GUILayout.Button(treeImportContent)) { LBImport.ImportTrees(landscape, true); arrayInt = terrainTreesList.Count; }
                    if (arrayInt < 0) { arrayInt = 0; }
                    GUILayout.EndHorizontal();
                    scrollPosition = EditorGUILayout.BeginScrollView(scrollPosition);
                    // Add items to the list
                    if (arrayInt > terrainTreesList.Count)
                    {
                        temp = arrayInt - terrainTreesList.Count;
                        for (index = 0; index < temp; index++)
                        {
                            terrainTreesList.Add(new LBTerrainTree());
                        }
                    }
                    // Remove items from the list
                    else if (arrayInt < terrainTreesList.Count)
                    {
                        temp = terrainTreesList.Count - arrayInt;
                        for (index = 0; index < temp; index++)
                        {
                            terrainTreesList.RemoveAt(terrainTreesList.Count - 1);
                        }
                    }
                    #endregion

                    #region Calculate the collective tree count
                    int collectiveTreeCount = 0;
                    for (index = 0; index < terrainTreesList.Count; index++) { if (!terrainTreesList[index].isDisabled) { collectiveTreeCount += terrainTreesList[index].maxTreesPerSqrKm; } }
                    if (collectiveTreeCount > maxTreeAmount)
                    {
                        // Show warning if max trees per sqr km may cause scene collider limit to be exceeded
                        EditorGUILayout.HelpBox("With your current max trees per sqr km settings (combined max trees of " + collectiveTreeCount +
                                                "), it is possible that the number of trees in the scene may exceed the max scene colliders" +
                                                " limit (65k), meaning that you will encounter collider issues. Using a maximum" +
                                                " combined max trees per sqr km of " + maxTreeAmount + " will greatly reduce the chances of" +
                                                " encountering this issue.", MessageType.Warning);
                    }
                    #endregion

                    // If the tree area filter highlighter is required this value will be set to true at some point before the end of 
                    // this block of code. If it is not set to true we will need to make sure the tree area filter highlighter is removed.
                    areaHighlighterRequired = false;

                    // No trees to insert/remove at start of list
                    treeToRemove = null;
                    insertTreePos = -1;

                    #region List Tree types
                    for (index = 0; index < terrainTreesList.Count; index++)
                    {
                        // Show the elements of the list
                        GUILayout.BeginVertical(EditorStyles.helpBox);
                        GUILayout.BeginHorizontal();
                        terrainTreesList[index].isDisabled = !EditorGUILayout.Toggle(!terrainTreesList[index].isDisabled, GUILayout.Width(20f));

                        labelText2 = GetPrefabName(terrainTreesList[index].prefab, "tree", terrainTreesList[index].prefabName);

                        if (terrainTreesList[index].showTree) { labelText = "<color=" + txtColourName + "><b>Tree Type " + (index + 1) + " </b></color>"; }
                        else { labelText = "<color=" + txtColourName + "><b>Tree Type " + (index + 1) + "</b> " + labelText2 + "</color>"; }

                        EditorGUILayout.LabelField(labelText, labelFieldRichText);
                        if (GUILayout.Button(treeScriptContent, buttonCompact, GUILayout.Width(20f))) { Debug.Log(terrainTreesList[index].ScriptTree(index, "\n")); }
                        if (GUILayout.Button(treeInsertAboveContent, buttonCompact, GUILayout.Width(20f))) { insertTreePos = index; }
                        if (terrainTreesList[index].showTree) { if (GUILayout.Button("Hide", buttonCompact, GUILayout.MaxWidth(40f))) { GUI.FocusControl(null); terrainTreesList[index].showTree = false; } }
                        else { if (GUILayout.Button("Show", buttonCompact, GUILayout.MaxWidth(40f))) { GUI.FocusControl(null); terrainTreesList[index].showTree = true; } }
                        if (GUILayout.Button("X", buttonCompact, GUILayout.MaxWidth(20f))) { treeToRemove = terrainTreesList[index]; }
                        GUILayout.EndHorizontal();

                        if (terrainTreesList[index].showTree)
                        {
                            isTreeImported = (terrainTreesList[index].treePlacingMode == LBTerrainTree.TreePlacingMode.Imported);

                            #region Tree Prefab and Preview
                            EditorGUILayout.BeginHorizontal();
                            EditorGUIUtility.fieldWidth = 15f;
                            terrainTreesList[index].showPrefabPreview = EditorGUILayout.Foldout(terrainTreesList[index].showPrefabPreview, "", foldoutStyleNoLabel);
                            EditorGUIUtility.fieldWidth = defaultEditorFieldWidth;

                            EditorGUI.BeginChangeCheck();
                            EditorGUILayout.LabelField(treePrefabContent, GUILayout.Width(defaultEditorLabelWidth - 25f));
                            terrainTreesList[index].prefab = (GameObject)EditorGUILayout.ObjectField(terrainTreesList[index].prefab, typeof(GameObject), false);
                            if (EditorGUI.EndChangeCheck())
                            {
                                if (terrainTreesList[index].prefab == null) { terrainTreesList[index].prefabName = string.Empty; }
                                else { terrainTreesList[index].prefabName = terrainTreesList[index].prefab.name; }
                            }
                            EditorGUILayout.EndHorizontal();

                            // Using the foldout the user can expand a preview of the prefab.
                            if (terrainTreesList[index].prefab != null && terrainTreesList[index].showPrefabPreview)
                            {
                                // Attempt to get the asset preview first
                                Texture2D previewTex = AssetPreview.GetAssetPreview(terrainTreesList[index].prefab);

                                // Check to see if it is still loading (which is an asynch process)
                                if (AssetPreview.IsLoadingAssetPreview(terrainTreesList[index].prefab.GetInstanceID())) { GUILayout.Label("Loading..."); }
                                else if (previewTex != null) { GUILayout.Label(previewTex); }
                            }

                            if (terrainTreesList[index].prefab == null && !string.IsNullOrEmpty(terrainTreesList[index].prefabName))
                            {
                                EditorGUILayout.LabelField("[Missing] Tree Prefab " + labelText2, labelFieldRichText);
                            }
                            #endregion

                            #region Tree settings for non-Imported Trees
                            if (!isTreeImported)
                            {
                                terrainTreesList[index].maxTreesPerSqrKm = EditorGUILayout.IntSlider(treeMaxTreePerSqKmContent, terrainTreesList[index].maxTreesPerSqrKm, 1, maxTreeAmount);
                                terrainTreesList[index].bendFactor = EditorGUILayout.Slider(treeBendFactorContent, terrainTreesList[index].bendFactor, 0f, 1f);
                                terrainTreesList[index].minScale = EditorGUILayout.Slider(treeMinScaleContent, terrainTreesList[index].minScale, 0.1f, 10f);
                                terrainTreesList[index].maxScale = EditorGUILayout.Slider(treeMaxScaleContent, terrainTreesList[index].maxScale, 0.1f, 10f);
                                //	GUILayout.BeginHorizontal();
                                //	EditorGUILayout.MinMaxSlider(new GUIContent("Min-Max Scale", ""), ref terrainTreesList[index].minScale, ref terrainTreesList[index].maxScale, 0.1f, 10f);
                                //	terrainTreesList[index].minScale = EditorGUILayout.FloatField(terrainTreesList[index].minScale);
                                //	terrainTreesList[index].maxScale = EditorGUILayout.FloatField(terrainTreesList[index].maxScale);
                                //	GUILayout.EndHorizontal();
                                terrainTreesList[index].minProximity = EditorGUILayout.Slider(treeMinProximityContent, terrainTreesList[index].minProximity, 0f, 100f);

                                terrainTreesList[index].offsetY = EditorGUILayout.Slider(treeOffsetYContent, terrainTreesList[index].offsetY, -2f, 0f);
                                if (terrainTreesList[index].maxScale < terrainTreesList[index].minScale)
                                {
                                    terrainTreesList[index].maxScale = terrainTreesList[index].minScale;
                                }
                                terrainTreesList[index].treeScalingMode = (LBTerrainTree.TreeScalingMode)EditorGUILayout.EnumPopup("Tree Scaling Mode", terrainTreesList[index].treeScalingMode);
                                if (terrainTreesList[index].treeScalingMode == LBTerrainTree.TreeScalingMode.RandomScaling)
                                {
                                    terrainTreesList[index].lockWidthToHeight = EditorGUILayout.Toggle(treeLockWidthToHeightContent, terrainTreesList[index].lockWidthToHeight);
                                }
                            }
                            #endregion

                            terrainTreesList[index].treePlacingMode = (LBTerrainTree.TreePlacingMode)EditorGUILayout.EnumPopup("Tree Placing Mode", terrainTreesList[index].treePlacingMode);

                            #region Terrain Height for Trees
                            if (terrainTreesList[index].treePlacingMode == LBTerrainTree.TreePlacingMode.Height ||
                                terrainTreesList[index].treePlacingMode == LBTerrainTree.TreePlacingMode.HeightAndInclination ||
                                terrainTreesList[index].treePlacingMode == LBTerrainTree.TreePlacingMode.HeightInclinationMap ||
                                terrainTreesList[index].treePlacingMode == LBTerrainTree.TreePlacingMode.HeightInclinationCurvature)
                            {
                                terrainTreesList[index].minHeight = EditorGUILayout.Slider(treeMinHeightContent, terrainTreesList[index].minHeight * terrainHeight, 0f, terrainHeight) / terrainHeight;
                                terrainTreesList[index].maxHeight = EditorGUILayout.Slider(treeMaxHeightContent, terrainTreesList[index].maxHeight * terrainHeight, 0f, terrainHeight) / terrainHeight;
                                if (terrainTreesList[index].maxHeight < terrainTreesList[index].minHeight)
                                {
                                    terrainTreesList[index].maxHeight = terrainTreesList[index].minHeight;
                                }
                            }
                            #endregion

                            #region Terrain Inclination for Trees
                            if (terrainTreesList[index].treePlacingMode == LBTerrainTree.TreePlacingMode.Inclination ||
                                terrainTreesList[index].treePlacingMode == LBTerrainTree.TreePlacingMode.HeightAndInclination ||
                                terrainTreesList[index].treePlacingMode == LBTerrainTree.TreePlacingMode.HeightInclinationMap ||
                                terrainTreesList[index].treePlacingMode == LBTerrainTree.TreePlacingMode.HeightInclinationCurvature)
                            {
                                terrainTreesList[index].minInclination = EditorGUILayout.Slider(treeMinInclinationContent, terrainTreesList[index].minInclination, 0f, 90f);
                                terrainTreesList[index].maxInclination = EditorGUILayout.Slider(treeMaxInclinationContent, terrainTreesList[index].maxInclination, 0f, 90f);
                                if (terrainTreesList[index].maxInclination < terrainTreesList[index].minInclination)
                                {
                                    terrainTreesList[index].maxInclination = terrainTreesList[index].minInclination;
                                }
                            }
                            #endregion

                            #region Terrain Curvature for Trees
                            if (terrainTreesList[index].treePlacingMode == LBTerrainTree.TreePlacingMode.HeightInclinationCurvature)
                            {
                                // CurvatureType only has 2 values. Convert from Enum to Int so can be compared with 0 (Concave) to produce a bool.
                                terrainTreesList[index].isCurvatureConcave = ((int)(CurvatureType)EditorGUILayout.EnumPopup(treeCurvatureTypeContent, (CurvatureType)(terrainTreesList[index].isCurvatureConcave ? 0 : 1), GUILayout.ExpandWidth(true)) == 0);
                                terrainTreesList[index].curvatureMinHeightDiff = EditorGUILayout.Slider(treeCurvatureMinHeightDiffContent, terrainTreesList[index].curvatureMinHeightDiff, 0.01f, 10f);
                                terrainTreesList[index].curvatureDistance = EditorGUILayout.Slider(treeCurvatureDistanceContent, terrainTreesList[index].curvatureDistance, 0f, 50f);
                            }
                            #endregion

                            #region Terrain Map for Trees
                            if (terrainTreesList[index].treePlacingMode == LBTerrainTree.TreePlacingMode.Map ||
                                terrainTreesList[index].treePlacingMode == LBTerrainTree.TreePlacingMode.HeightInclinationMap)
                            {
                                EditorGUI.BeginChangeCheck();
                                terrainTreesList[index].map = (Texture2D)EditorGUILayout.ObjectField("Map" + GetTextureName(terrainTreesList[index].map), terrainTreesList[index].map, typeof(Texture2D), false);
                                if (EditorGUI.EndChangeCheck())
                                {
                                    if (terrainTreesList[index].map != null) { LBTextureOperations.EnableReadable(terrainTreesList[index].map, true, true); }
                                }

                                if (!terrainTreesList[index].mapIsPath)
                                {
                                    terrainTreesList[index].mapColour = EditorGUILayout.ColorField("Colour", terrainTreesList[index].mapColour);
                                    terrainTreesList[index].mapTolerance = EditorGUILayout.IntSlider(treeMapToleranceContent, terrainTreesList[index].mapTolerance, 0, 20);
                                }

                                EditorGUI.BeginChangeCheck();
                                terrainTreesList[index].mapIsPath = EditorGUILayout.Toggle(treeMapIsPathContent, terrainTreesList[index].mapIsPath);
                                if (EditorGUI.EndChangeCheck())
                                {
                                    if (terrainTreesList[index].mapIsPath)
                                    {
                                        // Use the default LBPath curve when in Map mode
                                        terrainTreesList[index].mapToleranceBlendCurve = LBPath.GetDefaultBlendCurve;
                                        terrainTreesList[index].mapColour = UnityEngine.Color.white;
                                    }
                                    // Use the default curve when switching back to standard tolerance mode
                                    else { terrainTreesList[index].mapToleranceBlendCurve = LBMap.GetDefaultToleranceBlendCurve; }
                                }
                                terrainTreesList[index].mapInverse = EditorGUILayout.Toggle(treeMapInverseContent, terrainTreesList[index].mapInverse);
                            }

                            if (!isTreeImported)
                            {
                                terrainTreesList[index].useNoise = EditorGUILayout.Toggle(treeUseNoiseContent, terrainTreesList[index].useNoise);
                                if (terrainTreesList[index].useNoise)
                                {
                                    terrainTreesList[index].noiseTileSize = EditorGUILayout.Slider(treeNoiseTileSizeContent, terrainTreesList[index].noiseTileSize, 10f, 10000f);
                                    terrainTreesList[index].treePlacementCutoff = EditorGUILayout.Slider(treePlacementCutoffContent, terrainTreesList[index].treePlacementCutoff, 0.1f, 1f);
                                }
                            }
                            #endregion

                            #region Tinted
                            terrainTreesList[index].isTinted = EditorGUILayout.Toggle(treeIsTintedContent, terrainTreesList[index].isTinted);
                            if (terrainTreesList[index].isTinted)
                            {
                                terrainTreesList[index].maxTintStrength = EditorGUILayout.Slider(treeMaxTintStrengthContent, terrainTreesList[index].maxTintStrength, 0.01f, 0.3f);
                                terrainTreesList[index].tintColour = EditorGUILayout.ColorField("Tint Colour", terrainTreesList[index].tintColour);
                            }
                            #endregion

                            #region Tree Filters
                            // Tree filters
                            if (!isTreeImported)
                            {
                                GUILayout.BeginHorizontal();
                                if (GUILayout.Button(treeAddFilterContent, GUILayout.Width(100f)))
                                {
                                    // Create a new default filter
                                    LBFilter newLBFilter = new LBFilter(LBFilter.FilterType.Texture, LBFilter.FilterMode.AND);
                                    if (newLBFilter != null)
                                    {
                                        newLBFilter.terrainTexture = new LBTerrainTexture();
                                        // If this is the first filter, create an empty List of LBFilters.
                                        if (terrainTreesList[index].filterList == null)
                                        {
                                            terrainTreesList[index].filterList = new List<LBFilter>();
                                        }
                                        terrainTreesList[index].filterList.Add(newLBFilter);
                                        isSceneSaveRequired = true;
                                    }
                                }
                                if (terrainTreesList[index].filterList != null)
                                {
                                    if (terrainTreesList[index].filterList.Count > 0)
                                    {
                                        if (GUILayout.Button("Remove Filter", GUILayout.Width(100f)))
                                        {
                                            // Remove the last one from the list
                                            terrainTreesList[index].filterList.RemoveAt(terrainTreesList[index].filterList.Count - 1);
                                            isSceneSaveRequired = true;
                                        }
                                    }
                                }
                                GUILayout.EndHorizontal();
                            }

                            // Display the Tree filters
                            if (terrainTreesList[index].filterList != null)
                            {
                                for (int filterIndex = 0; filterIndex < terrainTreesList[index].filterList.Count; filterIndex++)
                                {
                                    treeLBFilter = terrainTreesList[index].filterList[filterIndex];

                                    EditorGUILayout.Space();
                                    GUILayout.BeginHorizontal();
                                    labelText = "<color=" + txtColourName + "><i>Filter " + (filterIndex + 1).ToString("00") + " </i></color>";
                                    EditorGUILayout.LabelField(labelText, labelFieldRichText, GUILayout.MaxWidth(50f));

                                    EditorGUI.BeginChangeCheck();
                                    LBFilter.FilterTypesForTrees filterTypeForTrees = (LBFilter.FilterTypesForTrees)EditorGUILayout.EnumPopup((LBFilter.FilterTypesForTrees)treeLBFilter.filterType, GUILayout.Width(90f));
                                    if (EditorGUI.EndChangeCheck())
                                    {
                                        treeLBFilter.filterType = (LBFilter.FilterType)filterTypeForTrees;
                                    }

                                    // Each filter can be a different type.
                                    // v1.2.1 only supports FilterType.Texture
                                    // v1.3.0 supports Texture and Area filters
                                    if (treeLBFilter.filterType == LBFilter.FilterType.Texture)
                                    {
                                        // A Texture Filter has only one texture per filter (this makes coding simplier and reduced
                                        // the need for more buttons to add and remove textures from a single filter.
                                        treeLBFilter.filterMode = (LBFilter.FilterMode)EditorGUILayout.EnumPopup((LBFilter.FilterModeAndNot)treeLBFilter.filterMode, GUILayout.Width(65f));
                                        GUILayout.EndHorizontal();

                                        GUILayout.BeginHorizontal();
                                        labelText = "<color=" + txtColourName + ">Texture</color>";
                                        EditorGUILayout.LabelField(labelText, labelFieldRichText, GUILayout.MaxWidth(50f));

                                        if (TerrainTexturesAvailableList == null || TerrainTexturesAvailableArray == null)
                                        {
                                            EditorGUILayout.LabelField("No textures in this landscape");
                                        }
                                        else if (TerrainTexturesAvailableList.Count == 0)
                                        {
                                            EditorGUILayout.LabelField("No textures in this landscape");
                                        }
                                        else
                                        {
                                            if (treeLBFilter.terrainTexture == null) { Debug.LogError("treeLBFilter.terrainTexture is null"); }

                                            // We can't simply find the matching LBTerrainTexture with FindIndex(ftx => ftx == treeLBFilter.terrainTexture)
                                            // because a splatprototype only contains texture, normalmap, metallic, smoothness and tileSize fields
                                            int textureIndex = TerrainTexturesAvailableList.FindIndex(ftx => ftx.texture == treeLBFilter.terrainTexture.texture &&
                                                                                                             ftx.normalMap == treeLBFilter.terrainTexture.normalMap &&
                                                                                                             ftx.metallic == treeLBFilter.terrainTexture.metallic &&
                                                                                                             ftx.smoothness == treeLBFilter.terrainTexture.smoothness &&
                                                                                                             ftx.tileSize == treeLBFilter.terrainTexture.tileSize);
                                            EditorGUI.BeginChangeCheck();
                                            textureIndex = EditorGUILayout.Popup(textureIndex, TerrainTexturesAvailableArray);
                                            if (EditorGUI.EndChangeCheck())
                                            {
                                                if (textureIndex < TerrainTexturesAvailableList.Count)
                                                {
                                                    treeLBFilter.terrainTexture = TerrainTexturesAvailableList[textureIndex];
                                                    isSceneSaveRequired = true;
                                                }
                                            }
                                        }
                                        GUILayout.EndHorizontal();
                                    }
                                    else if (treeLBFilter.filterType == LBFilter.FilterType.Area)
                                    {
                                        treeLBFilter.filterMode = (LBFilter.FilterMode)EditorGUILayout.EnumPopup(treeLBFilter.filterMode, GUILayout.Width(65f));
                                        GUILayout.EndHorizontal();

                                        // Is the area highlighter required?
                                        areaHighlighterRequired = (areaHighlighterRequired || treeLBFilter.showAreaHighlighter);

                                        if (treeLBFilter.showAreaHighlighter)
                                        {
                                            GUILayout.BeginHorizontal();
                                            if (GUILayout.Button("Disable Area Picker", buttonCompact, GUILayout.MaxWidth(125f)))
                                            {
                                                treeLBFilter.showAreaHighlighter = false;
                                                areaHighlighterRequired = false;
                                            }
                                            if (GUILayout.Button("Move Area to View", buttonCompact, GUILayout.MaxWidth(125f)))
                                            {
                                                treeAreaHighlighter.MoveToSceneView();
                                            }
                                            GUILayout.EndHorizontal();
                                        }
                                        // Only permit area picker to be enabled if no other tree area filters have the picker enabled.
                                        else if (!treeAreaHighlighterEnabled)
                                        {
                                            if (GUILayout.Button("Enable Area Picker", buttonCompact, GUILayout.MaxWidth(125f)))
                                            {
                                                treeLBFilter.showAreaHighlighter = true;
                                                areaHighlighterRequired = true;
                                            }
                                        }

                                        if (treeAreaHighlighter != null && treeLBFilter.showAreaHighlighter && treeAreaHighlighter.AreaRectSet())
                                        {
                                            treeLBFilter.areaRect = treeAreaHighlighter.GetAreaRect();
                                        }
                                        treeLBFilter.areaRect = EditorGUILayout.RectField(treeFilterAreaRectContent, treeLBFilter.areaRect);
                                        if (treeAreaHighlighter != null && treeLBFilter.showAreaHighlighter)
                                        {
                                            treeAreaHighlighter.AssignAreaRect(treeLBFilter.areaRect, landscape.transform.position, terrainHeight);
                                        }
                                        EditorGUILayout.HelpBox("To filter with an irregular shape, create a Stencil Layer filter", MessageType.Info, true);
                                    }
                                    else if (treeLBFilter.filterType == LBFilter.FilterType.StencilLayer)
                                    {
                                        treeLBFilter.filterMode = (LBFilter.FilterMode)EditorGUILayout.EnumPopup((LBFilter.FilterModeAndNot)treeLBFilter.filterMode, GUILayout.Width(65f));

                                        // Provide a quick way of editing the selected Stencil
                                        if (treeLBFilter.filterType == LBFilter.FilterType.StencilLayer)
                                        {
                                            if (GUILayout.Button(commonStencilEditButtonContent, buttonCompactNoOffset, GUILayout.MaxWidth(40f)))
                                            {
                                                if (treeLBFilter.lbStencil != null)
                                                {
                                                    Transform stencilTransform = treeLBFilter.lbStencil.transform;
                                                    if (stencilTransform != null)
                                                    {
                                                        Selection.activeTransform = stencilTransform;
                                                        #if UNITY_2018_2_OR_NEWER
                                                        LBEditorHelper.CallMenu("Window/General/Inspector");
                                                        #else
                                                        LBEditorHelper.CallMenu("Window/Inspector");
                                                        #endif
                                                        //textureLBTextureFilter.lbStencil.showStencilInScene = true;
                                                    }
                                                }
                                            }
                                        }

                                        GUILayout.EndHorizontal();

                                        // If there is a Stencil selected, populate the temporary class instance
                                        if (treeLBFilter.lbStencilGUID != null && treeLBFilter.lbStencil == null)
                                        {
                                            treeLBFilter.lbStencil = LBStencil.GetStencilInLandscape(landscape, treeLBFilter.lbStencilGUID, true);
                                        }

                                        EditorGUI.BeginChangeCheck();
                                        treeLBFilter.lbStencil = (LBStencil)EditorGUILayout.ObjectField(treeFilterStencilContent, treeLBFilter.lbStencil, typeof(LBStencil), true);
                                        if (EditorGUI.EndChangeCheck())
                                        {
                                            treeLBFilter.lbStencilGUID = treeLBFilter.lbStencil.GUID;
                                            treeLBFilter.lbStencilLayerGUID = string.Empty;
                                            // When user selects a different stencil, default to the first stencil layer
                                            if (treeLBFilter.lbStencil.stencilLayerList != null)
                                            {
                                                if (treeLBFilter.lbStencil.stencilLayerList.Count > 0)
                                                {
                                                    treeLBFilter.lbStencilLayerGUID = treeLBFilter.lbStencil.stencilLayerList[0].GUID;
                                                }
                                            }
                                        }

                                        // Get list of LBStencilLayers for the current LBStencil
                                        if (treeLBFilter.lbStencil != null)
                                        {
                                            // Get a list of the Layer Names and their GUIDs
                                            List<string> treeFilterStencilLayerGUIDList = new List<string>();
                                            List<string> treeFilterStencilLayerNameList = new List<string>();
                                            int treeFilterStencilLayerIndex = 0;

                                            if (treeLBFilter.lbStencil.stencilLayerList != null)
                                            {
                                                foreach (LBStencilLayer lbStencilLayer in treeLBFilter.lbStencil.stencilLayerList)
                                                {
                                                    if (!string.IsNullOrEmpty(lbStencilLayer.GUID))
                                                    {
                                                        treeFilterStencilLayerGUIDList.Add(lbStencilLayer.GUID);
                                                        treeFilterStencilLayerNameList.Add(lbStencilLayer.LayerName);
                                                    }
                                                }

                                                // Find the stencil layer that was last selected in the tree filter
                                                treeFilterStencilLayerIndex = treeFilterStencilLayerGUIDList.FindIndex(sl => sl == treeLBFilter.lbStencilLayerGUID);
                                            }

                                            // Display the list of Stencil Layers for the selected Stencil.
                                            EditorGUI.BeginChangeCheck();
                                            treeFilterStencilLayerIndex = EditorGUILayout.Popup("Stencil Layer", treeFilterStencilLayerIndex, treeFilterStencilLayerNameList.ToArray());

                                            if (EditorGUI.EndChangeCheck() && treeFilterStencilLayerGUIDList.Count > treeFilterStencilLayerIndex && treeFilterStencilLayerIndex >= 0)
                                            {
                                                // Update the stencil layer for this tree filter
                                                treeLBFilter.lbStencilLayerGUID = treeFilterStencilLayerGUIDList[treeFilterStencilLayerIndex];
                                            }
                                        }
                                    }
                                    else { GUILayout.EndHorizontal(); }
                                }
                            }  // end Tree filters
                            #endregion
                        }
                        GUILayout.EndVertical();
                    }
                    #endregion

                    EditorGUILayout.EndScrollView();

                    #region Delete Insert Trees
                    // More than one tree "could" be removed in same frame but very unlikely so just use the last one
                    if (treeToRemove != null)
                    {
                        int treePos = terrainTreesList.FindIndex(tx => tx == treeToRemove);
                        labelText = "Tree Type " + (treePos + 1).ToString() + " (";
                        if (treeToRemove.prefab != null) { labelText += treeToRemove.prefab.name; }
                        else { labelText += "No tree prefab"; }
                        labelText += ") will be deleted \n\nThis action will remove the tree type from the list and cannot be undone.";
                        if (LBEditorHelper.PromptForDelete("Delete Tree?", labelText))
                        {
                            terrainTreesList.Remove(treeToRemove);
                        }
                    }
                    // Does the user wish to insert a new (duplicate) tree into the list?
                    else if (insertTreePos >= 0)
                    {
                        // Insert a duplicate above the selected Tree
                        terrainTreesList.Insert(insertTreePos, new LBTerrainTree(terrainTreesList[insertTreePos]));
                        // Create a new GUID for the duplicated Tree Type
                        terrainTreesList[insertTreePos].GUID = System.Guid.NewGuid().ToString();
                        // Show the new duplicate, and hide the original
                        terrainTreesList[insertTreePos].showTree = true;
                        terrainTreesList[insertTreePos + 1].showTree = false;
                        isSceneSaveRequired = true;
                    }
                    #endregion

                    #region Enable or disable the tree Area filter Highlighter
                    if (areaHighlighterRequired && treeAreaHighlighter == null)
                    {
                        treeAreaHighlighter = GameObject.FindObjectOfType<LBAreaHighlight>();
                        if (treeAreaHighlighter == null)
                        {
                            treeAreaHighlighter = LBAreaHighlight.CreateAreaHighLighter();
                            // Set to enabled so that we know when we need to repaint the editor in OnInspectorUpdate()
                            treeAreaHighlighterEnabled = true;
                        }
                    }
                    else if (!areaHighlighterRequired && treeAreaHighlighter != null)
                    {
                        DestroyImmediate(treeAreaHighlighter.gameObject);
                        treeAreaHighlighterEnabled = false;
                    }
                    #endregion

                    #region Apply or Undo Trees Buttons

                    // Do not permit tree population from the Trees tab, when a Group Object Path is being edited
                    if (!IsObjPathDesignerOpen(true))
                    {
                        if (GUILayout.Button("Populate Landscape With Trees"))
                        {
                            // Turn highlighter off before applying trees or a layout error occurs
                            DisableTreeAreaHighlighter();

                            ApplyTrees();
                        }

                        if (GUILayout.Button("Undo Trees Modification"))
                        {
                            landscape.RevertToLastSave(LBLandscape.UndoType.Trees);

                            isSceneSaveRequired = true;
                        }
                    }
                    #endregion
                }
                else if (!isDefaultResourcesValid)
                {

                }
                else
                {
                    EditorGUILayout.HelpBox("No landscape to modify - you can add or find one in the landscape tab.", MessageType.Info, true);
                }
                #endregion
            }
            else if (selectedTabInt == 5)
            {
                // Grass tab
                #region GrassTab
                if (landscapeGameObject != null && landscape != null && isDefaultResourcesValid)
                {
                    DrawGrassHeaderTex();

                    if (terrainGrassList == null) { terrainGrassList = new List<LBTerrainGrass>(); }

                    #region Grass Presets
                    selectedGrassPreset = EditorGUILayout.Popup("Grass Preset", selectedGrassPreset, grassPresetNames.ToArray());
                    if (GUILayout.Button("Assign Grass from Preset"))
                    {
                        if (EditorUtility.DisplayDialog("Assign Grass from Preset?", "This action will clear all current grass and cannot be undone.", "Assign", "Cancel"))
                        {
                            SetFromGrassPreset(selectedGrassPreset);
                        }
                        GetDRPresetNames();
                    }
                    #endregion

                    #region Add Remove Import Grass Types
                    // This code simulates the unity default array functionality, which editorgui can't do
                    arrayInt = terrainGrassList.Count;
                    GUILayout.BeginHorizontal();

                    // A Foldout with no label must have a style fixedWidth of low non-zero value, and have a small (global) fieldWidth.
                    EditorGUIUtility.fieldWidth = 15f;
                    EditorGUI.BeginChangeCheck();
                    isGrassListExpanded = EditorGUILayout.Foldout(isGrassListExpanded, "", foldoutStyleNoLabel);
                    EditorGUIUtility.fieldWidth = defaultEditorFieldWidth;
                    if (EditorGUI.EndChangeCheck()) { GrassListExpand(isGrassListExpanded); }

                    if (GUILayout.Button("Add Grass Type")) { arrayInt++; }
                    if (GUILayout.Button("Remove Grass Type")) { if (arrayInt > 0) { if (LBEditorHelper.PromptForDelete("Grass Type", "", arrayInt - 1, false)) { arrayInt--; } } }
                    if (GUILayout.Button(grassImportContent)) { LBImport.ImportGrass(landscape, true); arrayInt = terrainGrassList.Count; }
                    if (arrayInt < 0) { arrayInt = 0; }
                    GUILayout.EndHorizontal();
                    scrollPosition = EditorGUILayout.BeginScrollView(scrollPosition);
                    // Add items to the list
                    if (arrayInt > terrainGrassList.Count)
                    {
                        temp = arrayInt - terrainGrassList.Count;
                        for (index = 0; index < temp; index++)
                        {
                            terrainGrassList.Add(new LBTerrainGrass());
                        }
                    }
                    // Remove items from the list
                    else if (arrayInt < terrainGrassList.Count)
                    {
                        temp = terrainGrassList.Count - arrayInt;
                        for (index = 0; index < temp; index++)
                        {
                            terrainGrassList.RemoveAt(terrainGrassList.Count - 1);
                        }
                    }
                    #endregion

                    #region Calculate the collective grass density
                    int collectiveGrassDensity = 0;
                    for (index = 0; index < terrainGrassList.Count; index++) { collectiveGrassDensity += terrainGrassList[index].density; }
                    int possibleTotalGrassDensity = collectiveGrassDensity * Mathf.RoundToInt((terrainWidth / 1000f) * (terrainWidth / 1000f));
                    int possiblePatchVertices = possibleTotalGrassDensity * 32 * 16;
                    if (possiblePatchVertices > 60000f)
                    {
                        // Show warning if grass density settings may cause detail object vertices per patch limit to be exceeded
                        int maxPossibleDensity = Mathf.FloorToInt(60000f / 32f / 16f / Mathf.RoundToInt((terrainWidth / 1000f) * (terrainWidth / 1000f)));
                        EditorGUILayout.HelpBox("With your current grass density settings (combined density of " + collectiveGrassDensity +
                                                "), it is possible that some grass patches may exceed the detail object vertices per patch" +
                                                " limit (65k), meaning that some grass billboards won't be rendered. Using a maximum" +
                                                " combined density of " + maxPossibleDensity + " will greatly reduce the chances of" +
                                                " encountering this issue.", MessageType.Warning);
                    }
                    #endregion

                    // If the grass area filter highlighter is required this value will be set to true at some point before the end of 
                    // this block of code. If it is not set to true we will need to make sure the grass area filter highlighter is removed.
                    areaHighlighterRequired = false;

                    // No grass to insert/remove/delete at the start of the list.
                    grassToRemove = null;
                    insertGrassPos = -1;

                    #region List Grasses
                    for (index = 0; index < terrainGrassList.Count; index++)
                    {
                        // Show the elements of the list
                        GUILayout.BeginVertical(EditorStyles.helpBox);

                        #region Grass Buttons
                        GUILayout.BeginHorizontal();
                        terrainGrassList[index].isDisabled = !EditorGUILayout.Toggle(!terrainGrassList[index].isDisabled, GUILayout.Width(20f));

                        labelText = "<color=" + txtColourName + "><b>Grass Type " + (index + 1) + " </b>";

                        // GetPrefabName() will return either the name of the prefab or the last known name of the prefab if the prefab is missing.
                        if (terrainGrassList[index].showGrass) { labelText += "</color>"; }
                        else if (terrainGrassList[index].useMeshPrefab)
                        {
                            labelText += GetPrefabName(terrainGrassList[index].meshPrefab, "grass", terrainGrassList[index].meshPrefabName) + "</color>";
                        }
                        else { labelText += GetTextureName(terrainGrassList[index].texture, terrainGrassList[index].textureName) + "</color>"; }

                        // The width = view width - E button - L button - Hide button - X button (100)
                        EditorGUILayout.LabelField(labelText, labelFieldRichText, GUILayout.MaxWidth(EditorGUIUtility.currentViewWidth - 100f));

                        if (terrainGrassList[index].showGrass)
                        {
                            if (GUILayout.Button(grassScriptContent, buttonCompact, GUILayout.Width(20f))) { Debug.Log(terrainGrassList[index].ScriptGrass(index, "\n")); }
                            if (GUILayout.Button(new GUIContent("E", "Open Grass Editor for default grass configurations"), buttonCompact, GUILayout.Width(20f)))
                            {
                                // If the GrassEditor is open, set the focus, else open a new floating one.
                                LandscapeBuilderGrassEditor grassEditor = (LandscapeBuilderGrassEditor)EditorWindow.GetWindow(typeof(LandscapeBuilderGrassEditor), false, "Grass Editor", true);
                                if (grassEditor != null)
                                {
                                    // Pass handle to this window so Grass Editor can tell us when the GrassConfigList needs refreshing
                                    grassEditor.lbWindow = this;

                                    // Pass the current Texture to the GrassEditor
                                    grassEditor.lbTerrainGrassSelected = terrainGrassList[index];
                                    // Load the grass list and set it to filter by User Defined
                                    grassEditor.isRemoteLoading = true;
                                }
                            }

                            // In LB v2.0 allow users to select user-defined grasses, even if HQ Photo+Rustic are not installed.
                            //if (isHQPhotoPackVol1Installed || isHQPhotoPackVol2Installed || isRusticGrassInstalled)
                            {
                                // If user has selected a grass from the HQ or Rustic Grass list (or a User-defined grass), pre-populate the LBTerrainGrass class instance
                                // For some reason, lbGrassConfigSelected is never null, even on startup.
                                if (isGrassConfigSelected && lbGrassConfigSelected != null)
                                {
                                    // Is the class instance the same as the instance which was used to select the grass?
                                    // == will check for the exact class instance. If we need to just check the contents of the
                                    // class instance the we should use Equals()
                                    if (lbTerrainGrassToConfigure == terrainGrassList[index])
                                    {
                                        // If user was modifying this Grass by unselecting all of the controls, it will update correctly in GUI.
                                        GUI.FocusControl(null);

                                        // Update the Grass settings with the pre-configured settings
                                        terrainGrassList[index].detailRenderMode = lbGrassConfigSelected.detailRenderMode;
                                        terrainGrassList[index].grassPatchFadingMode = (LBTerrainGrass.GrassPatchFadingMode)lbGrassConfigSelected.grassPatchFadingMode;
                                        terrainGrassList[index].healthyColour = lbGrassConfigSelected.healthyColour;
                                        terrainGrassList[index].dryColour = lbGrassConfigSelected.dryColour;
                                        terrainGrassList[index].minHeight = lbGrassConfigSelected.minHeight;
                                        terrainGrassList[index].maxHeight = lbGrassConfigSelected.maxHeight;
                                        terrainGrassList[index].minWidth = lbGrassConfigSelected.minWidth;
                                        terrainGrassList[index].maxWidth = lbGrassConfigSelected.maxWidth;
                                        terrainGrassList[index].useMeshPrefab = false;
                                        terrainGrassList[index].meshPrefab = null;

                                        // Reload the texture. Setting it to lbGrassConfigSelected.texture2D doesn't work.
                                        terrainGrassList[index].texture = (Texture2D)AssetDatabase.LoadAssetAtPath(lbGrassConfigSelected.grassTexturePath, typeof(Texture2D));

                                        // Reset values so we don't check again
                                        isGrassConfigSelected = false;
                                        lbGrassConfigSelected = null;
                                        isSceneSaveRequired = true;
                                    }
                                }
                            }

                            if (GUILayout.Button(new GUIContent("L", "Select from list of preconfigured\ngrass types"), buttonCompact, GUILayout.Width(20f)))
                            {
                                lbGrassConfigSelected = null;

                                if (isGrassConfigListDirty)
                                {
                                    EditorUtility.DisplayProgressBar("Refreshing grass configurations", "Please Wait", 0.5f);
                                    RefreshGrassConfigList();
                                    EditorUtility.ClearProgressBar();
                                }

                                // Open a new editor window containing a list of the LBGrassConfig instances
                                Rect winRect = new Rect(200f, 150f, 600f, 400f);
                                LandscapeBuilderGrassSelector grassSelector = (LandscapeBuilderGrassSelector)EditorWindow.GetWindow(typeof(LandscapeBuilderGrassSelector), true, "Grass Selector", true);
                                if (grassSelector != null)
                                {
                                    grassSelector.minSize = new Vector2(600f, 400f);
                                    grassSelector.position = winRect;
                                    grassSelector.Initialize(this, grassConfigList);
                                    lbTerrainGrassToConfigure = terrainGrassList[index];
                                }
                                #if UNITY_EDITOR_OSX
                                return;
                                #endif
                            }
                            if (GUILayout.Button(new GUIContent("I", "Insert new Grass above this Grass"), buttonCompact, GUILayout.Width(20f))) { insertGrassPos = index; }
                            if (GUILayout.Button("Hide", buttonCompact, GUILayout.Width(40f))) { GUI.FocusControl(null); terrainGrassList[index].showGrass = false; }
                        }
                        else
                        {
                            if (GUILayout.Button(new GUIContent("I", "Insert new Grass above this Grass"), buttonCompact, GUILayout.Width(20f))) { insertGrassPos = index; }
                            if (GUILayout.Button("Show", buttonCompact, GUILayout.MaxWidth(40f))) { GUI.FocusControl(null); terrainGrassList[index].showGrass = true; }
                        }
                        if (GUILayout.Button("X", buttonCompact, GUILayout.MaxWidth(20f))) { grassToRemove = terrainGrassList[index]; }
                        GUILayout.EndHorizontal();
                        #endregion

                        if (terrainGrassList[index].showGrass)
                        {
                            isGrassImported = (terrainGrassList[index].grassPlacingMode == LBTerrainGrass.GrassPlacingMode.Imported);
                            isGrassForGroupsOnly = (terrainGrassList[index].grassPlacingMode == LBTerrainGrass.GrassPlacingMode.GroupsOnly);

                            if (landscape.useGPUGrass && isGrassImported)
                            {
                                EditorGUILayout.HelpBox("Imported Grass is not currently supported with GPU acceleration.", MessageType.Warning);
                            }

                            terrainGrassList[index].useMeshPrefab = EditorGUILayout.Toggle(grassUseMeshPrefabContent, terrainGrassList[index].useMeshPrefab);

                            if (terrainGrassList[index].useMeshPrefab)
                            {
                                #region Prefab and Preview Prefab
                                EditorGUILayout.BeginHorizontal();
                                EditorGUIUtility.fieldWidth = 15f;
                                terrainGrassList[index].showPrefabPreview = EditorGUILayout.Foldout(terrainGrassList[index].showPrefabPreview, "", foldoutStyleNoLabel);
                                EditorGUIUtility.fieldWidth = defaultEditorFieldWidth;
                                EditorGUI.BeginChangeCheck();
                                EditorGUILayout.LabelField(grassMeshPrefabContent, GUILayout.Width(defaultEditorLabelWidth - 25f));
                                terrainGrassList[index].meshPrefab = (GameObject)EditorGUILayout.ObjectField(terrainGrassList[index].meshPrefab, typeof(GameObject), false);
                                //terrainGrassList[index].meshPrefab = (GameObject)EditorGUILayout.ObjectField(grassMeshPrefabContent, terrainGrassList[index].meshPrefab, typeof(GameObject), false);
                                if (EditorGUI.EndChangeCheck())
                                {
                                    #if UNITY_2018_3_OR_NEWER
                                    PrefabAssetType prefabAssetType = PrefabUtility.GetPrefabAssetType(terrainGrassList[index].meshPrefab);

                                    // NotAPrefab, Regular = User created prefab, Model = imported 3D model asset, Variant = Prefab Variant, MissingAsset (unknown prefab type)
                                    if (prefabAssetType != PrefabAssetType.Regular && prefabAssetType != PrefabAssetType.Model && prefabAssetType != PrefabAssetType.Variant)
                                    {
                                        terrainGrassList[index].meshPrefab = null;
                                        Debug.Log("INFO: Landscape Builder - Only user defined, variant or imported 3D asset prefabs are permitted as an alternative to a grass texture. Ensure you are adding a prefab.");
                                    }
                                    #else
                                    PrefabType prefabType = PrefabUtility.GetPrefabType(terrainGrassList[index].meshPrefab);

                                    //Debug.Log("Grass prefabtype: " + prefabType);

                                    // Preb = User created prefab. ModelPrefab = imported 3D model asset
                                    // Make sure it was a prefab and not a simple gameobject like a fbx file etc.
                                    if (terrainGrassList[index].meshPrefab != null && prefabType != PrefabType.Prefab && prefabType != PrefabType.ModelPrefab)
                                    {
                                        terrainGrassList[index].meshPrefab = null;
                                        Debug.Log("Landscape Builder - Only prefabs are permitted as an alternative to a grass texture. Ensure you are adding a prefab.");
                                    }
                                    #endif

                                    if (terrainGrassList[index].meshPrefab == null) { terrainGrassList[index].meshPrefabName = string.Empty; }
                                    else { terrainGrassList[index].meshPrefabName = terrainGrassList[index].meshPrefab.name; }
                                }
                                EditorGUILayout.EndHorizontal();

                                // Using the foldout the user can expand a preview of the prefab.
                                if (terrainGrassList[index].meshPrefab != null && terrainGrassList[index].showPrefabPreview)
                                {
                                    // Attempt to get the asset preview first
                                    Texture2D previewTex = AssetPreview.GetAssetPreview(terrainGrassList[index].meshPrefab);

                                    // Check to see if it is still loading (which is an asynch process)
                                    if (AssetPreview.IsLoadingAssetPreview(terrainGrassList[index].meshPrefab.GetInstanceID())) { GUILayout.Label("Loading..."); }
                                    else if (previewTex != null) { GUILayout.Label(previewTex); }
                                }

                                #endregion
                            }
                            else
                            {
                                EditorGUI.BeginChangeCheck();
                                EditorGUIUtility.labelWidth = 250f;
                                // GetTextureName() will return either the name of the texture or the last known name of the texture if the Texture2D image is missing.
                                terrainGrassList[index].texture = (Texture2D)EditorGUILayout.ObjectField("Texture" + GetTextureName(terrainGrassList[index].texture, terrainGrassList[index].textureName), terrainGrassList[index].texture, typeof(Texture2D), false);
                                if (EditorGUI.EndChangeCheck())
                                {
                                    if (terrainGrassList[index].texture == null) { terrainGrassList[index].textureName = string.Empty; }
                                    else { terrainGrassList[index].textureName = terrainGrassList[index].texture.name; }
                                }
                                EditorGUIUtility.labelWidth = defaultEditorLabelWidth;
                            }
                            terrainGrassList[index].detailRenderMode = (DetailRenderMode)EditorGUILayout.EnumPopup("Grass Rendering Mode", terrainGrassList[index].detailRenderMode);
                            if (!terrainGrassList[index].useMeshPrefab && terrainGrassList[index].detailRenderMode == DetailRenderMode.VertexLit)
                            {
                                terrainGrassList[index].detailRenderMode = DetailRenderMode.Grass;
                                Debug.Log("Vertex-Lit is only available when Use Mesh Prefabs is enabled.");
                            }
                            else if (terrainGrassList[index].useMeshPrefab && terrainGrassList[index].detailRenderMode == DetailRenderMode.GrassBillboard)
                            {
                                terrainGrassList[index].detailRenderMode = DetailRenderMode.Grass;
                                Debug.Log("GrassBillboard is not available when using detail mesh prefabs.");
                            }
                            terrainGrassList[index].grassPatchFadingMode = (LBTerrainGrass.GrassPatchFadingMode)EditorGUILayout.EnumPopup("Grass Patch Fading Mode", terrainGrassList[index].grassPatchFadingMode);
                            terrainGrassList[index].healthyColour = EditorGUILayout.ColorField(grassHealthyColourContent, terrainGrassList[index].healthyColour);
                            terrainGrassList[index].dryColour = EditorGUILayout.ColorField(grassDryColourContent, terrainGrassList[index].dryColour);

                            if (!isGrassImported)
                            {

                                terrainGrassList[index].minHeight = EditorGUILayout.Slider(grassMinHeightContent, terrainGrassList[index].minHeight, 0.1f, 8f);
                                terrainGrassList[index].maxHeight = EditorGUILayout.Slider(grassMaxHeightContent, terrainGrassList[index].maxHeight, 0.1f, 8f);
                                if (terrainGrassList[index].maxHeight < terrainGrassList[index].minHeight)
                                {
                                    terrainGrassList[index].maxHeight = terrainGrassList[index].minHeight;
                                }
                                terrainGrassList[index].minWidth = EditorGUILayout.Slider(grassMinWidthContent, terrainGrassList[index].minWidth, 0.1f, 8f);
                                terrainGrassList[index].maxWidth = EditorGUILayout.Slider(grassMaxWidthContent, terrainGrassList[index].maxWidth, 0.1f, 8f);
                                if (terrainGrassList[index].maxWidth < terrainGrassList[index].minWidth)
                                {
                                    terrainGrassList[index].maxWidth = terrainGrassList[index].minWidth;
                                }
                            }
                            else
                            {
                                // Read-only values for Imported
                                EditorGUILayout.BeginHorizontal();
                                GUILayout.Label(grassMinHeightContent, GUILayout.Width(EditorGUIUtility.labelWidth));
                                GUILayout.Label(terrainGrassList[index].minHeight.ToString("#0.00"));
                                EditorGUILayout.EndHorizontal();
                                EditorGUILayout.BeginHorizontal();
                                GUILayout.Label(grassMaxHeightContent, GUILayout.Width(EditorGUIUtility.labelWidth));
                                GUILayout.Label(terrainGrassList[index].maxHeight.ToString("#0.00"));
                                EditorGUILayout.EndHorizontal();
                                EditorGUILayout.BeginHorizontal();
                                GUILayout.Label(grassMinWidthContent, GUILayout.Width(EditorGUIUtility.labelWidth));
                                GUILayout.Label(terrainGrassList[index].minWidth.ToString("#0.00"));
                                EditorGUILayout.EndHorizontal();
                                EditorGUILayout.BeginHorizontal();
                                GUILayout.Label(grassMaxWidthContent, GUILayout.Width(EditorGUIUtility.labelWidth));
                                GUILayout.Label(terrainGrassList[index].maxWidth.ToString("#0.00"));
                                EditorGUILayout.EndHorizontal();
                            }
                            // Min/Max Density gets set in the Groups tab. So for Grass only used for Groups, these don't apply
                            if (!isGrassForGroupsOnly)
                            {
                                terrainGrassList[index].minDensity = EditorGUILayout.IntSlider(grassMinDensityContent, terrainGrassList[index].minDensity, 0, 15);
                                if (terrainGrassList[index].density < terrainGrassList[index].minDensity) { terrainGrassList[index].density = terrainGrassList[index].minDensity; }
                                terrainGrassList[index].density = EditorGUILayout.IntSlider(grassDensityContent, terrainGrassList[index].density, 1, 15);
                            }
                            terrainGrassList[index].grassPlacingMode = (LBTerrainGrass.GrassPlacingMode)EditorGUILayout.EnumPopup("Grass Populating Mode", terrainGrassList[index].grassPlacingMode);

                            #region Terrain Height for Grass
                            if (terrainGrassList[index].grassPlacingMode == LBTerrainGrass.GrassPlacingMode.Height ||
                                terrainGrassList[index].grassPlacingMode == LBTerrainGrass.GrassPlacingMode.HeightAndInclination ||
                                terrainGrassList[index].grassPlacingMode == LBTerrainGrass.GrassPlacingMode.HeightInclinationCurvature ||
                                terrainGrassList[index].grassPlacingMode == LBTerrainGrass.GrassPlacingMode.HeightInclinationMap)
                            {
                                terrainGrassList[index].minPopulatedHeight = EditorGUILayout.Slider(new GUIContent("Min Height", "Minimum height in metres that the grass can be placed at"), terrainGrassList[index].minPopulatedHeight * terrainHeight, 0f, terrainHeight) / terrainHeight;
                                terrainGrassList[index].maxPopulatedHeight = EditorGUILayout.Slider(new GUIContent("Max Height", "Maximum height in metres that the grass can be placed at"), terrainGrassList[index].maxPopulatedHeight * terrainHeight, 0f, terrainHeight) / terrainHeight;
                                if (terrainGrassList[index].maxPopulatedHeight < terrainGrassList[index].minPopulatedHeight)
                                {
                                    terrainGrassList[index].maxPopulatedHeight = terrainGrassList[index].minPopulatedHeight;
                                }
                            }
                            #endregion

                            #region Terrain Inclination for Grass
                            if (terrainGrassList[index].grassPlacingMode == LBTerrainGrass.GrassPlacingMode.Inclination ||
                                terrainGrassList[index].grassPlacingMode == LBTerrainGrass.GrassPlacingMode.HeightAndInclination ||
                                terrainGrassList[index].grassPlacingMode == LBTerrainGrass.GrassPlacingMode.HeightInclinationCurvature ||
                                terrainGrassList[index].grassPlacingMode == LBTerrainGrass.GrassPlacingMode.HeightInclinationMap)
                            {
                                terrainGrassList[index].minInclination = EditorGUILayout.Slider(grassMinInclination, terrainGrassList[index].minInclination, 0f, 90f);
                                terrainGrassList[index].maxInclination = EditorGUILayout.Slider(grassMaxInclination, terrainGrassList[index].maxInclination, 0f, 90f);
                                if (terrainGrassList[index].maxInclination < terrainGrassList[index].minInclination)
                                {
                                    terrainGrassList[index].maxInclination = terrainGrassList[index].minInclination;
                                }
                            }
                            #endregion

                            #region Terrain Curvature for Grass
                            if (terrainGrassList[index].grassPlacingMode == LBTerrainGrass.GrassPlacingMode.HeightInclinationCurvature)
                            {
                                // CurvatureType only has 2 values. Convert from Enum to Int so can be compared with 0 (Concave) to produce a bool.
                                terrainGrassList[index].isCurvatureConcave = ((int)(CurvatureType)EditorGUILayout.EnumPopup(grassCurvatureTypeContent, (CurvatureType)(terrainGrassList[index].isCurvatureConcave ? 0 : 1), GUILayout.ExpandWidth(true)) == 0);
                                terrainGrassList[index].curvatureMinHeightDiff = EditorGUILayout.Slider(grassCurvatureMinHeightDiffContent, terrainGrassList[index].curvatureMinHeightDiff, 0.01f, 10f);
                                terrainGrassList[index].curvatureDistance = EditorGUILayout.Slider(grassCurvatureDistanceContent, terrainGrassList[index].curvatureDistance, 0f, 50f);
                            }
                            #endregion

                            #region Terrain Map for Grass
                            if (terrainGrassList[index].grassPlacingMode == LBTerrainGrass.GrassPlacingMode.Map ||
                                terrainGrassList[index].grassPlacingMode == LBTerrainGrass.GrassPlacingMode.HeightInclinationMap)
                            {

                                if (landscape.useGPUGrass && !terrainGrassList[index].mapIsPath)
                                {
                                    EditorGUILayout.HelpBox("In this version GPU acceleration only supports grayscale maps. Selecting Map Is From Path will enable this.", MessageType.Warning);
                                }

                                EditorGUI.BeginChangeCheck();
                                terrainGrassList[index].map = (Texture2D)EditorGUILayout.ObjectField("Map" + GetTextureName(terrainGrassList[index].map), terrainGrassList[index].map, typeof(Texture2D), false);
                                if (EditorGUI.EndChangeCheck())
                                {
                                    if (terrainGrassList[index].map != null) { LBTextureOperations.EnableReadable(terrainGrassList[index].map, true, true); }
                                }

                                if (!terrainGrassList[index].mapIsPath)
                                {
                                    terrainGrassList[index].mapColour = EditorGUILayout.ColorField("Colour", terrainGrassList[index].mapColour);
                                    terrainGrassList[index].mapTolerance = EditorGUILayout.IntSlider(new GUIContent("Tolerance", "Colour tolerance on the map to allow for blended edges"), terrainGrassList[index].mapTolerance, 0, 20);
                                }

                                EditorGUI.BeginChangeCheck();
                                terrainGrassList[index].mapIsPath = EditorGUILayout.Toggle(new GUIContent("Is Map from Path?", "Was this map created from a Map Path?"), terrainGrassList[index].mapIsPath);
                                if (EditorGUI.EndChangeCheck())
                                {
                                    if (terrainGrassList[index].mapIsPath)
                                    {
                                        // Use the default LBPath curve when in Map mode
                                        terrainGrassList[index].mapToleranceBlendCurve = LBPath.GetDefaultBlendCurve;
                                        terrainGrassList[index].mapColour = UnityEngine.Color.white;
                                    }
                                    // Use the default curve when switching back to standard tolerance mode
                                    else { terrainGrassList[index].mapToleranceBlendCurve = LBMap.GetDefaultToleranceBlendCurve; }
                                }

                                terrainGrassList[index].mapInverse = EditorGUILayout.Toggle(new GUIContent("Inverse", "Grass will not appear in the map areas"), terrainGrassList[index].mapInverse);
                            }
                            #endregion

                            if (isGrassForGroupsOnly)
                            {
                                EditorGUILayout.HelpBox("Groups Only is useful when you wish to only apply grass within a Group. It still needs to be enabled on this tab and applied to the landscape to show up in the Groups tab.", MessageType.Info);
                            }

                            // Noise doesn't apply to import grass (non-LB generated grass), or grass only in Groups (which has it's own noise)
                            if (!isGrassImported && !isGrassForGroupsOnly)
                            {
                                terrainGrassList[index].useNoise = EditorGUILayout.Toggle(grassUseNoiseContent, terrainGrassList[index].useNoise);
                                if (terrainGrassList[index].useNoise)
                                {
                                    terrainGrassList[index].noiseTileSize = EditorGUILayout.Slider(grassNoiseTileSizeContent, terrainGrassList[index].noiseTileSize, 1f, 250f);
                                    terrainGrassList[index].noiseOctaves = EditorGUILayout.IntSlider(grassNoiseOctavesContent, terrainGrassList[index].noiseOctaves, 1, 8);
                                    terrainGrassList[index].grassPlacementCutoff = EditorGUILayout.Slider(grassNoisePlacementCutoffContent, terrainGrassList[index].grassPlacementCutoff, 0.01f, 1f);
                                }
                            }

                            #region Grass filters
                            // Grass Filters don't apply to grass only used in Groups
                            if (!isGrassForGroupsOnly)
                            {
                                // Grass filters
                                GUILayout.BeginHorizontal();
                                if (GUILayout.Button(grassAddFilterContent, GUILayout.Width(100f)))
                                {
                                    // Create a new default filter
                                    LBFilter newLBFilter = new LBFilter(LBFilter.FilterType.Texture, LBFilter.FilterMode.AND);
                                    if (newLBFilter != null)
                                    {
                                        newLBFilter.terrainTexture = new LBTerrainTexture();

                                        // If this is the first filter, create an empty List of LBFilters.
                                        if (terrainGrassList[index].filterList == null)
                                        {
                                            terrainGrassList[index].filterList = new List<LBFilter>();
                                        }

                                        terrainGrassList[index].filterList.Add(newLBFilter);
                                        isSceneSaveRequired = true;
                                    }
                                }
                                if (terrainGrassList[index].filterList != null)
                                {
                                    if (terrainGrassList[index].filterList.Count > 0)
                                    {
                                        if (GUILayout.Button("Remove Filter", GUILayout.Width(100f)))
                                        {
                                            // Remove the last one from the list
                                            terrainGrassList[index].filterList.RemoveAt(terrainGrassList[index].filterList.Count - 1);
                                            isSceneSaveRequired = true;
                                        }
                                    }
                                }
                                GUILayout.EndHorizontal();

                                if (terrainGrassList[index].filterList != null)
                                {
                                    // Display the Grass filters
                                    for (int filterIndex = 0; filterIndex < terrainGrassList[index].filterList.Count; filterIndex++)
                                    {
                                        grassLBFilter = terrainGrassList[index].filterList[filterIndex];

                                        #if VEGETATION_STUDIO_PRO
                                        if (landscape.useGPUGrass && grassLBFilter.filterType == LBFilter.FilterType.Texture && !landscape.useVegetationSystem)
                                        {
                                            EditorGUILayout.HelpBox("Texture filters are not currently supported with GPU acceleration unless the Vegetation Studio Pro is enabled in Terrain Settings.", MessageType.Info);
                                        }
                                        #else
                                        if (landscape.useGPUGrass && grassLBFilter.filterType == LBFilter.FilterType.Texture)
                                        {
                                            EditorGUILayout.HelpBox("Texture filters are not currently supported with GPU acceleration unless the 3rd party Vegetation Studio Pro is used.", MessageType.Info);
                                        }
                                        #endif

                                        // NOTE: EditorGUILayout.Space() or Separator() causes an horizontal expansion as a side effect...
                                        GUILayout.Space(10f);
                                        GUILayout.BeginHorizontal();
                                        labelText = "<color=" + txtColourName + "><i>Filter " + (filterIndex + 1).ToString("00") + " </i></color>";
                                        EditorGUILayout.LabelField(labelText, labelFieldRichText, GUILayout.Width(50f));
                                        //grassLBFilter.filterType = (LBFilter.FilterType)EditorGUILayout.EnumPopup(grassLBFilter.filterType, GUILayout.Width(65f));

                                        EditorGUI.BeginChangeCheck();
                                        // Store as standard LBFilter but only display limited list
                                        LBFilter.FilterTypesForGrass filterTypeForGrass = (LBFilter.FilterTypesForGrass)EditorGUILayout.EnumPopup((LBFilter.FilterTypesForGrass)grassLBFilter.filterType, GUILayout.Width(90f));
                                        if (EditorGUI.EndChangeCheck())
                                        {
                                            grassLBFilter.filterType = (LBFilter.FilterType)filterTypeForGrass;

                                            // StencilLayer filters only support AND/NOT
                                            if (grassLBFilter.filterType == LBFilter.FilterType.StencilLayer && grassLBFilter.filterMode == LBFilter.FilterMode.OR)
                                            {
                                                grassLBFilter.filterMode = LBFilter.FilterMode.AND;
                                                isSceneSaveRequired = true;
                                            }
                                        }

                                        // Each filter can be a different type.
                                        #region Texture Filter
                                        if (grassLBFilter.filterType == LBFilter.FilterType.Texture)
                                        {
                                            // A Texture Filter has only one texture per filter (this makes coding simplier and reduced
                                            // the need for more buttons to add and remove textures from a single filter.
                                            grassLBFilter.filterMode = (LBFilter.FilterMode)EditorGUILayout.EnumPopup((LBFilter.FilterModeAndNot)grassLBFilter.filterMode, GUILayout.MaxWidth(65f));
                                            GUILayout.EndHorizontal();

                                            GUILayout.BeginHorizontal();
                                            labelText = "<color=" + txtColourName + ">Texture</color>";
                                            EditorGUILayout.LabelField(labelText, labelFieldRichText, GUILayout.Width(50f));

                                            if (TerrainTexturesAvailableList == null || TerrainTexturesAvailableArray == null)
                                            {
                                                EditorGUILayout.LabelField("No textures in this landscape");
                                            }
                                            else if (TerrainTexturesAvailableList.Count == 0)
                                            {
                                                EditorGUILayout.LabelField("No textures in this landscape");
                                            }
                                            else
                                            {
                                                if (grassLBFilter.terrainTexture == null) { Debug.LogError("grassLBFilter.terrainTexture is null"); }

                                                // We can't simply find the matching LBTerrainTexture with FindIndex(ftx => ftx == grassLBFilter.terrainTexture)
                                                // because a splatprototype only contains texture, normalmap, metallic, smoothness and tileSize fields
                                                int textureIndex = TerrainTexturesAvailableList.FindIndex(ftx => ftx.texture == grassLBFilter.terrainTexture.texture &&
                                                                                                                 ftx.normalMap == grassLBFilter.terrainTexture.normalMap &&
                                                                                                                 ftx.metallic == grassLBFilter.terrainTexture.metallic &&
                                                                                                                 ftx.smoothness == grassLBFilter.terrainTexture.smoothness &&
                                                                                                                 ftx.tileSize == grassLBFilter.terrainTexture.tileSize);
                                                EditorGUI.BeginChangeCheck();
                                                textureIndex = EditorGUILayout.Popup(textureIndex, TerrainTexturesAvailableArray);
                                                if (EditorGUI.EndChangeCheck())
                                                {
                                                    if (textureIndex < TerrainTexturesAvailableList.Count)
                                                    {
                                                        grassLBFilter.terrainTexture = TerrainTexturesAvailableList[textureIndex];
                                                        isSceneSaveRequired = true;
                                                    }
                                                }
                                            }
                                            GUILayout.EndHorizontal();
                                        }
                                        #endregion

                                        #region Area Filter
                                        else if (grassLBFilter.filterType == LBFilter.FilterType.Area)
                                        {
                                            grassLBFilter.filterMode = (LBFilter.FilterMode)EditorGUILayout.EnumPopup(grassLBFilter.filterMode, GUILayout.Width(65f));
                                            GUILayout.EndHorizontal();

                                            // Is the area highlighter required?
                                            areaHighlighterRequired = (areaHighlighterRequired || grassLBFilter.showAreaHighlighter);

                                            if (grassLBFilter.showAreaHighlighter)
                                            {
                                                GUILayout.BeginHorizontal();
                                                if (GUILayout.Button("Disable Area Picker", buttonCompact, GUILayout.MaxWidth(125f)))
                                                {
                                                    grassLBFilter.showAreaHighlighter = false;
                                                    areaHighlighterRequired = false;
                                                }
                                                if (GUILayout.Button("Move Area to View", buttonCompact, GUILayout.MaxWidth(125f)))
                                                {
                                                    grassAreaHighlighter.MoveToSceneView();
                                                }
                                                GUILayout.EndHorizontal();
                                            }
                                            // Only permit area picker to be enabled if no other grass area filters have the picker enabled.
                                            else if (!grassAreaHighlighterEnabled)
                                            {
                                                if (GUILayout.Button("Enable Area Picker", buttonCompact, GUILayout.MaxWidth(125f)))
                                                {
                                                    grassLBFilter.showAreaHighlighter = true;
                                                    areaHighlighterRequired = true;
                                                }
                                            }

                                            if (grassAreaHighlighter != null && grassLBFilter.showAreaHighlighter && grassAreaHighlighter.AreaRectSet())
                                            {
                                                grassLBFilter.areaRect = grassAreaHighlighter.GetAreaRect();
                                            }
                                            grassLBFilter.areaRect = EditorGUILayout.RectField(new GUIContent("       Area Rectangle", "The area in the landscape that this grass type will be applied to"), grassLBFilter.areaRect);
                                            if (grassAreaHighlighter != null && grassLBFilter.showAreaHighlighter)
                                            {
                                                grassAreaHighlighter.AssignAreaRect(grassLBFilter.areaRect, landscape.transform.position, terrainHeight);
                                            }
                                            EditorGUILayout.HelpBox("To filter with an irregular shape, create a Stencil Layer filter", MessageType.Info, true);
                                        }
                                        #endregion

                                        #region Stencil Layer Filter
                                        else if (grassLBFilter.filterType == LBFilter.FilterType.StencilLayer)
                                        {
                                            grassLBFilter.filterMode = (LBFilter.FilterMode)EditorGUILayout.EnumPopup((LBFilter.FilterModeAndNot)grassLBFilter.filterMode, GUILayout.Width(65f));

                                            // Provide a quick way of editing the selected Stencil
                                            if (grassLBFilter.filterType == LBFilter.FilterType.StencilLayer)
                                            {
                                                //if (GUILayout.Button(commonStencilEditButtonContent, buttonCompact, GUILayout.Width(40f)))
                                                if (GUILayout.Button(commonStencilEditButtonContent, buttonCompactNoOffset, GUILayout.Width(40f)))
                                                {
                                                    if (grassLBFilter.lbStencil != null)
                                                    {
                                                        Transform stencilTransform = grassLBFilter.lbStencil.transform;
                                                        if (stencilTransform != null)
                                                        {
                                                            Selection.activeTransform = stencilTransform;
                                                            #if UNITY_2018_2_OR_NEWER
                                                            LBEditorHelper.CallMenu("Window/General/Inspector");
                                                            #else
                                                            LBEditorHelper.CallMenu("Window/Inspector");
                                                            #endif
                                                        }
                                                    }
                                                }
                                            }

                                            GUILayout.EndHorizontal();

                                            // If there is a Stencil selected, populate the temporary class instance
                                            if (grassLBFilter.lbStencilGUID != null && grassLBFilter.lbStencil == null)
                                            {
                                                grassLBFilter.lbStencil = LBStencil.GetStencilInLandscape(landscape, grassLBFilter.lbStencilGUID, true);
                                            }

                                            EditorGUI.BeginChangeCheck();
                                            grassLBFilter.lbStencil = (LBStencil)EditorGUILayout.ObjectField(grassFilterStencilContent, grassLBFilter.lbStencil, typeof(LBStencil), true);
                                            if (EditorGUI.EndChangeCheck())
                                            {
                                                grassLBFilter.lbStencilGUID = grassLBFilter.lbStencil.GUID;
                                                grassLBFilter.lbStencilLayerGUID = string.Empty;
                                                // When user selects a different stencil, default to the first stencil layer
                                                if (grassLBFilter.lbStencil.stencilLayerList != null)
                                                {
                                                    if (grassLBFilter.lbStencil.stencilLayerList.Count > 0)
                                                    {
                                                        grassLBFilter.lbStencilLayerGUID = grassLBFilter.lbStencil.stencilLayerList[0].GUID;
                                                    }
                                                }
                                            }

                                            // Get list of LBStencilLayers for the current LBStencil
                                            if (grassLBFilter.lbStencil != null)
                                            {
                                                // Get a list of the Layer Names and their GUIDs
                                                List<string> grassFilterStencilLayerGUIDList = new List<string>();
                                                List<string> grassFilterStencilLayerNameList = new List<string>();
                                                int grassFilterStencilLayerIndex = 0;

                                                if (grassLBFilter.lbStencil.stencilLayerList != null)
                                                {
                                                    foreach (LBStencilLayer lbStencilLayer in grassLBFilter.lbStencil.stencilLayerList)
                                                    {
                                                        if (!string.IsNullOrEmpty(lbStencilLayer.GUID))
                                                        {
                                                            grassFilterStencilLayerGUIDList.Add(lbStencilLayer.GUID);
                                                            grassFilterStencilLayerNameList.Add(lbStencilLayer.LayerName);
                                                        }
                                                    }

                                                    // Find the stencil layer that was last selected in the grass filter
                                                    grassFilterStencilLayerIndex = grassFilterStencilLayerGUIDList.FindIndex(sl => sl == grassLBFilter.lbStencilLayerGUID);
                                                }

                                                // Display the list of Stencil Layers for the selected Stencil.
                                                EditorGUI.BeginChangeCheck();
                                                grassFilterStencilLayerIndex = EditorGUILayout.Popup("Stencil Layer", grassFilterStencilLayerIndex, grassFilterStencilLayerNameList.ToArray());

                                                if (EditorGUI.EndChangeCheck() && grassFilterStencilLayerGUIDList.Count > grassFilterStencilLayerIndex && grassFilterStencilLayerIndex >= 0)
                                                {
                                                    // Update the stencil layer for this grass filter
                                                    grassLBFilter.lbStencilLayerGUID = grassFilterStencilLayerGUIDList[grassFilterStencilLayerIndex];
                                                }
                                            }
                                        }
                                        #endregion

                                        else { GUILayout.EndHorizontal(); }
                                    }
                                }  // end Grass filters
                            }
                            #endregion
                        }
                        GUILayout.EndVertical();
                    }
                    #endregion

                    EditorGUILayout.EndScrollView();

                    #region Delete / Insert Grass
                    // More than one grass "could" be removed in same frame but very unlikely so just use the last one
                    if (grassToRemove != null)
                    {
                        int grassPos = terrainGrassList.FindIndex(tx => tx == grassToRemove);
                        labelText = "Grass " + (grassPos + 1).ToString() + " " + GetTextureName(grassToRemove.texture) + " will be deleted ";
                        labelText += "\n\nThis action will remove the grass from the list and cannot be undone.";
                        if (LBEditorHelper.PromptForDelete("Delete Grass?", labelText))
                        {
                            terrainGrassList.Remove(grassToRemove);
                        }
                    }
                    // Does the user wish to insert a new (duplicate) Grass into the list?
                    else if (insertGrassPos >= 0)
                    {
                        // Insert a duplicate above the selected Grass
                        terrainGrassList.Insert(insertGrassPos, new LBTerrainGrass(terrainGrassList[insertGrassPos]));
                        // Create a new GUID for the duplicated Grass Type
                        terrainGrassList[insertGrassPos].GUID = System.Guid.NewGuid().ToString();
                        // Show the new duplicate, and hide the original
                        terrainGrassList[insertGrassPos].showGrass = true;
                        terrainGrassList[insertGrassPos + 1].showGrass = false;
                        isSceneSaveRequired = true;
                    }
                    #endregion

                    // Enable or disable the grass Area filter Highlighter
                    if (areaHighlighterRequired && grassAreaHighlighter == null)
                    {
                        grassAreaHighlighter = GameObject.FindObjectOfType<LBAreaHighlight>();
                        if (grassAreaHighlighter == null)
                        {
                            grassAreaHighlighter = LBAreaHighlight.CreateAreaHighLighter();
                            // Set to enabled so that we know when we need to repaint the editor in OnInspectorUpdate()
                            grassAreaHighlighterEnabled = true;
                        }
                    }
                    else if (!areaHighlighterRequired && grassAreaHighlighter != null)
                    {
                        DestroyImmediate(grassAreaHighlighter.gameObject);
                        grassAreaHighlighterEnabled = false;
                    }

                    #region Apply Grass and Undo Buttons

                    // Do not permit application of grass from the Grass tab, when a Group Object Path is being edited
                    if (!IsObjPathDesignerOpen(true))
                    {
                        if (GUILayout.Button("Populate Landscape With Grass"))
                        {
                            // Turn highlighter off before applying grass or a layout error occurs
                            DisableGrassAreaHighlighter();

                            ApplyGrass();
                        }

                        if (GUILayout.Button("Undo Grass Modification"))
                        {
                            landscape.RevertToLastSave(LBLandscape.UndoType.Grass);
                            isSceneSaveRequired = true;
                        }
                    }

                    #endregion Apply Grass and Undo Buttons
                }
                else if (!isDefaultResourcesValid)
                {

                }
                else
                {
                    EditorGUILayout.HelpBox("No landscape to modify - you can add or find one in the landscape tab.", MessageType.Info, true);
                }
                #endregion
            }
            else if (selectedTabInt == 6)
            {
                // Mesh tab
                #region MeshTab
                if (landscapeGameObject != null && landscape != null)
                {
                    EditorGUILayout.LabelField("<b>PLEASE USE GROUPS (Mesh tab is for backward compatibility only)</b>\n\nProcedurally populate your landscape with" +
                                             " your own custom meshes or prefabs according to rules you define. Where possible, use Uniform Groups instead on the Groups tab.", helpBoxRichText);

                    if (landscapeMeshList == null) { landscapeMeshList = new List<LBLandscapeMesh>(); }

                    landscape.meshPlacementSpeed = (LBLandscapeMesh.MeshPlacementSpeed)EditorGUILayout.EnumPopup(meshPlacementSpeedContent, landscape.meshPlacementSpeed, GUILayout.MaxWidth(300f));

                    // This code simulates the unity default array functionality, which editorgui can't do
                    arrayInt = landscapeMeshList.Count;
                    GUILayout.BeginHorizontal();

                    // A Foldout with no label must have a style fixedWidth of low non-zero value, and have a small (global) fieldWidth.
                    EditorGUIUtility.fieldWidth = 15f;
                    EditorGUI.BeginChangeCheck();
                    isMeshPrefabListExpanded = EditorGUILayout.Foldout(isMeshPrefabListExpanded, "", foldoutStyleNoLabel);
                    EditorGUIUtility.fieldWidth = defaultEditorFieldWidth;
                    if (EditorGUI.EndChangeCheck()) { MeshPrefabListExpand(isMeshPrefabListExpanded); }

                    if (GUILayout.Button("Add Mesh")) { arrayInt++; }
                    if (GUILayout.Button("Remove Mesh")) { if (arrayInt > 0) { if (LBEditorHelper.PromptForDelete("Mesh/Prefab", "", arrayInt - 1, false)) { arrayInt--; } } }
                    if (GUILayout.Button(meshConvertToGroupsContent)) { LBUpdate.ConvertMeshesToGroups(landscape); selectedTabInt = 2; }
                    if (arrayInt < 0) { arrayInt = 0; }
                    GUILayout.EndHorizontal();
                    scrollPosition = EditorGUILayout.BeginScrollView(scrollPosition);
                    // Add items to the list
                    if (arrayInt > landscapeMeshList.Count)
                    {
                        temp = arrayInt - landscapeMeshList.Count;
                        for (index = 0; index < temp; index++)
                        {
                            landscapeMeshList.Add(new LBLandscapeMesh());
                        }
                    }
                    // Remove items from the list
                    else if (arrayInt < landscapeMeshList.Count)
                    {
                        temp = landscapeMeshList.Count - arrayInt;
                        for (index = 0; index < temp; index++)
                        {
                            landscapeMeshList.RemoveAt(landscapeMeshList.Count - 1);
                        }
                    }

                    // If the mesh area filter highlighter is required this value will be set to true at some point before the end of 
                    // this block of code. If it is not set to true we will need to make sure the mesh area filter highlighter is removed.
                    areaHighlighterRequired = false;

                    // No mesh to remove/delete at the start of loop
                    meshToRemove = null;
                    meshToMove = null;
                    moveMeshPos = -1;
                    insertMeshPos = -1;

                    for (index = 0; index < landscapeMeshList.Count; index++)
                    {
                        // Show the elements of the list
                        GUILayout.BeginVertical(EditorStyles.helpBox);

                        GUILayout.BeginHorizontal();
                        landscapeMeshList[index].isDisabled = !EditorGUILayout.Toggle(!landscapeMeshList[index].isDisabled, GUILayout.Width(20f));

                        if (landscapeMeshList[index].usePrefab)
                        {
                            labelText2 = GetPrefabName(landscapeMeshList[index].prefab, "mesh", landscapeMeshList[index].prefabName);
                        }
                        else if (landscapeMeshList[index].mesh != null) { labelText2 = " (" + landscapeMeshList[index].mesh.name + ")"; }
                        else { labelText2 = " (No mesh)"; }

                        if (landscapeMeshList[index].showMesh) { labelText = "<color=" + txtColourName + "><b>Mesh " + (index + 1) + " </b></color>"; }
                        else { labelText = "<color=" + txtColourName + "><b>Mesh " + (index + 1) + "</b>" + labelText2 + "</color>"; }

                        EditorGUILayout.LabelField(labelText, labelFieldRichText);

                        if (GUILayout.Button(new GUIContent("V", "Move Mesh or Prefab down. If this is the last Mesh, make it the first."), buttonCompact, GUILayout.Width(20f)))
                        {
                            meshToMove = new LBLandscapeMesh(landscapeMeshList[index]);
                            moveMeshPos = index;
                        }

                        if (GUILayout.Button(meshInsertAboveContent, buttonCompact, GUILayout.Width(20f))) { insertMeshPos = index; }
                        if (landscapeMeshList[index].showMesh) { if (GUILayout.Button("Hide", buttonCompact, GUILayout.MaxWidth(40f))) { GUI.FocusControl(null); landscapeMeshList[index].showMesh = false; } }
                        else { if (GUILayout.Button("Show", buttonCompact, GUILayout.MaxWidth(40f))) { GUI.FocusControl(null); landscapeMeshList[index].showMesh = true; } }
                        if (GUILayout.Button("X", buttonCompact, GUILayout.MaxWidth(20f))) { meshToRemove = landscapeMeshList[index]; }
                        GUILayout.EndHorizontal();

                        if (landscapeMeshList[index].showMesh)
                        {
                            EditorGUI.BeginChangeCheck();
                            landscapeMeshList[index].usePrefab = EditorGUILayout.Toggle(meshUsePrefabContent, landscapeMeshList[index].usePrefab);
                            if (EditorGUI.EndChangeCheck())
                            {
                                if (!landscapeMeshList[index].usePrefab) { landscapeMeshList[index].isCombineMesh = true; }
                            }
                            if (landscapeMeshList[index].usePrefab)
                            {
                                EditorGUI.BeginChangeCheck();
                                landscapeMeshList[index].prefab = (GameObject)EditorGUILayout.ObjectField(meshPrefabContent, landscapeMeshList[index].prefab, typeof(GameObject), false);
                                if (EditorGUI.EndChangeCheck())
                                {
                                    #if UNITY_2018_3_OR_NEWER
                                    PrefabAssetType prefabAssetType = PrefabUtility.GetPrefabAssetType(landscapeMeshList[index].prefab);

                                    // NotAPrefab, Regular = User created prefab, Model = imported 3D model asset, Variant = Prefab Variant, MissingAsset (unknown prefab type)
                                    if (prefabAssetType != PrefabAssetType.Regular && prefabAssetType != PrefabAssetType.Model && prefabAssetType != PrefabAssetType.Variant)
                                    {
                                        landscapeMeshList[index].prefab = null;
                                        Debug.Log("INFO: Landscape Builder - Only user defined, variant or imported 3D asset prefabs are permitted as an alternative to a mesh. Ensure you are adding a prefab.");

                                    }
                                    #else
                                    // Make sure it was a prefab and not a simple gameobject like a fbx file etc.
                                    if (landscapeMeshList[index].prefab != null)
                                    {
                                        PrefabType prefabType = PrefabUtility.GetPrefabType(landscapeMeshList[index].prefab);

                                        // Preb = User created prefab. ModelPrefab = imported 3D model asset
                                        if (prefabType != PrefabType.Prefab && prefabType != PrefabType.ModelPrefab)
                                        {
                                            landscapeMeshList[index].prefab = null;
                                            Debug.Log("INFO: Landscape Builder - Only user defined or imported 3D asset prefabs are permitted as an alternative to a mesh. Ensure you are adding a prefab.");
                                        }
                                    }
                                    #endif
                                }

                                EditorGUI.BeginChangeCheck();
                                landscapeMeshList[index].isCombineMesh = EditorGUILayout.Toggle(meshIsCombineMeshContent, landscapeMeshList[index].isCombineMesh);
                                if (EditorGUI.EndChangeCheck())
                                {
                                    // With Prefabs, currently we don't allow users to add colliders without combining meshes (use Uniform Groups instead)
                                    if (!landscapeMeshList[index].isCombineMesh) { landscapeMeshList[index].isCreateCollider = false; }
                                }
                                if (landscapeMeshList[index].isCombineMesh)
                                {
                                    landscapeMeshList[index].isRemoveEmptyGameObjects = EditorGUILayout.Toggle(meshIsRemoveEmptyGameObjectContent, landscapeMeshList[index].isRemoveEmptyGameObjects);
                                }
                                landscapeMeshList[index].isKeepPrefabConnection = EditorGUILayout.Toggle(meshKeepPrefabConnectionContent, landscapeMeshList[index].isKeepPrefabConnection);
                            }
                            else
                            {
                                landscapeMeshList[index].mesh = (Mesh)EditorGUILayout.ObjectField(meshMeshContent, landscapeMeshList[index].mesh, typeof(Mesh), false);

                                // Show array of materials
                                if (landscapeMeshList[index].mesh != null)
                                {
                                    arrayInt2 = landscapeMeshList[index].mesh.subMeshCount;
                                }
                                else { arrayInt2 = 1; }
                                EditorGUILayout.LabelField(meshMaterialsContent);
                                // Add items to the list
                                if (arrayInt2 > landscapeMeshList[index].materials.Count)
                                {
                                    temp = arrayInt2 - landscapeMeshList[index].materials.Count;
                                    for (index2 = 0; index2 < temp; index2++)
                                    {
                                        landscapeMeshList[index].materials.Add(AssetDatabase.GetBuiltinExtraResource<Material>("Default-Material.mat"));
                                    }
                                }
                                // Remove items from the list
                                else if (arrayInt2 < landscapeMeshList[index].materials.Count)
                                {
                                    temp = landscapeMeshList[index].materials.Count - arrayInt2;
                                    for (index2 = 0; index2 < temp; index2++)
                                    {
                                        landscapeMeshList[index].materials.RemoveAt(landscapeMeshList[index].materials.Count - 1);
                                    }
                                }
                                for (index2 = 0; index2 < landscapeMeshList[index].materials.Count; index2++)
                                {
                                    landscapeMeshList[index].materials[index2] = (Material)EditorGUILayout.ObjectField("Element " + index2, landscapeMeshList[index].materials[index2], typeof(Material), false);
                                }
                            }
                            // 
                            if (landscapeMeshList[index].isCombineMesh || !landscapeMeshList[index].usePrefab)
                            {
                                landscapeMeshList[index].isCreateCollider = EditorGUILayout.Toggle(meshAddMeshColliderContent, landscapeMeshList[index].isCreateCollider);
                            }
                            landscapeMeshList[index].offset = EditorGUILayout.Vector3Field(meshOffsetContent, landscapeMeshList[index].offset);
                            landscapeMeshList[index].maxMeshes = EditorGUILayout.IntSlider(meshMaxMeshesContent, landscapeMeshList[index].maxMeshes, 1, landscapeMeshList[index].MaxMeshLimit);
                            landscapeMeshList[index].minScale = EditorGUILayout.Slider(meshMinScaleContent, landscapeMeshList[index].minScale, 0.1f, 10f);
                            landscapeMeshList[index].maxScale = EditorGUILayout.Slider(meshMaxScaleContent, landscapeMeshList[index].maxScale, 0.1f, 10f);
                            if (landscapeMeshList[index].maxScale < landscapeMeshList[index].minScale)
                            {
                                landscapeMeshList[index].maxScale = landscapeMeshList[index].minScale;
                            }
                            landscapeMeshList[index].minProximity = EditorGUILayout.Slider(meshMinProximityContent, landscapeMeshList[index].minProximity, 0f, 1000f);
                            landscapeMeshList[index].randomiseYRotation = EditorGUILayout.Toggle(meshRandomiseYRotationContent, landscapeMeshList[index].randomiseYRotation);
                            if (!landscapeMeshList[index].randomiseYRotation)
                            {
                                landscapeMeshList[index].fixedYRotation = EditorGUILayout.Slider(meshFixedYRotationContent, landscapeMeshList[index].fixedYRotation, -359.9f, 359.9f);
                            }

                            EditorGUILayout.BeginHorizontal();
                            EditorGUILayout.LabelField(meshOverrideRotationContent, GUILayout.Width(EditorGUIUtility.labelWidth));
                            EditorGUILayout.LabelField("X", GUILayout.Width(15f));
                            landscapeMeshList[index].XRotation = EditorGUILayout.FloatField(landscapeMeshList[index].XRotation, GUILayout.Width(60f));
                            EditorGUILayout.LabelField("Z", GUILayout.Width(15f));
                            landscapeMeshList[index].ZRotation = EditorGUILayout.FloatField(landscapeMeshList[index].ZRotation, GUILayout.Width(60f));
                            EditorGUILayout.EndHorizontal();

                            landscapeMeshList[index].isTerrainAligned = EditorGUILayout.Toggle(meshAlignWithTerrainContent, landscapeMeshList[index].isTerrainAligned);

                            landscapeMeshList[index].meshPlacingMode = (LBLandscapeMesh.MeshPlacingMode)EditorGUILayout.EnumPopup("Mesh Populating Mode", landscapeMeshList[index].meshPlacingMode);

                            // Terrain Height for Mesh
                            if (landscapeMeshList[index].meshPlacingMode == LBLandscapeMesh.MeshPlacingMode.Height ||
                                landscapeMeshList[index].meshPlacingMode == LBLandscapeMesh.MeshPlacingMode.HeightAndInclination ||
                                landscapeMeshList[index].meshPlacingMode == LBLandscapeMesh.MeshPlacingMode.HeightInclinationMap
                                )
                            {
                                landscapeMeshList[index].minHeight = EditorGUILayout.Slider(meshMinHeightContent, landscapeMeshList[index].minHeight * terrainHeight, 0f, terrainHeight) / terrainHeight;
                                landscapeMeshList[index].maxHeight = EditorGUILayout.Slider(meshMaxHeightContent, landscapeMeshList[index].maxHeight * terrainHeight, 0f, terrainHeight) / terrainHeight;
                                if (landscapeMeshList[index].maxHeight < landscapeMeshList[index].minHeight)
                                {
                                    landscapeMeshList[index].maxHeight = landscapeMeshList[index].minHeight;
                                }
                            }

                            // Terrain Inclination for Mesh
                            if (landscapeMeshList[index].meshPlacingMode == LBLandscapeMesh.MeshPlacingMode.Inclination ||
                                landscapeMeshList[index].meshPlacingMode == LBLandscapeMesh.MeshPlacingMode.HeightAndInclination ||
                                landscapeMeshList[index].meshPlacingMode == LBLandscapeMesh.MeshPlacingMode.HeightInclinationMap
                                )
                            {
                                landscapeMeshList[index].minInclination = EditorGUILayout.Slider(meshMinInclinationContent, landscapeMeshList[index].minInclination, 0f, 90f);
                                landscapeMeshList[index].maxInclination = EditorGUILayout.Slider(meshMaxInclinationContent, landscapeMeshList[index].maxInclination, 0f, 90f);
                                if (landscapeMeshList[index].maxInclination < landscapeMeshList[index].minInclination)
                                {
                                    landscapeMeshList[index].maxInclination = landscapeMeshList[index].minInclination;
                                }
                            }

                            // Terrain Map for Mesh
                            if (landscapeMeshList[index].meshPlacingMode == LBLandscapeMesh.MeshPlacingMode.Map ||
                                landscapeMeshList[index].meshPlacingMode == LBLandscapeMesh.MeshPlacingMode.HeightInclinationMap)
                            {
                                EditorGUI.BeginChangeCheck();
                                landscapeMeshList[index].map = (Texture2D)EditorGUILayout.ObjectField("Map" + GetTextureName(landscapeMeshList[index].map), landscapeMeshList[index].map, typeof(Texture2D), false);
                                if (EditorGUI.EndChangeCheck())
                                {
                                    if (landscapeMeshList[index].map != null) { LBTextureOperations.EnableReadable(landscapeMeshList[index].map, true, true); }
                                }

                                if (!landscapeMeshList[index].mapIsPath)
                                {
                                    landscapeMeshList[index].mapColour = EditorGUILayout.ColorField("Colour", landscapeMeshList[index].mapColour);
                                    landscapeMeshList[index].mapTolerance = EditorGUILayout.IntSlider(meshMapToleranceContent, landscapeMeshList[index].mapTolerance, 0, 20);
                                }

                                EditorGUI.BeginChangeCheck();
                                landscapeMeshList[index].mapIsPath = EditorGUILayout.Toggle(meshIsMapPathContent, landscapeMeshList[index].mapIsPath);
                                if (EditorGUI.EndChangeCheck())
                                {
                                    if (landscapeMeshList[index].mapIsPath)
                                    {
                                        // Use the default LBPath curve when in Map mode
                                        landscapeMeshList[index].mapToleranceBlendCurve = LBPath.GetDefaultBlendCurve;
                                        landscapeMeshList[index].mapColour = UnityEngine.Color.white;
                                    }
                                    // Use the default curve when switching back to standard tolerance mode
                                    else { landscapeMeshList[index].mapToleranceBlendCurve = LBMap.GetDefaultToleranceBlendCurve; }
                                }

                                landscapeMeshList[index].mapInverse = EditorGUILayout.Toggle(meshMapInverseContent, landscapeMeshList[index].mapInverse);
                            }

                            landscapeMeshList[index].useNoise = EditorGUILayout.Toggle(meshUseNoiseContent, landscapeMeshList[index].useNoise);
                            if (landscapeMeshList[index].useNoise)
                            {
                                landscapeMeshList[index].noiseTileSize = EditorGUILayout.Slider(meshNoiseTileSizeContent, landscapeMeshList[index].noiseTileSize, 100f, 10000f);
                                landscapeMeshList[index].meshPlacementCutoff = EditorGUILayout.Slider(meshPlacementCutoffContent, landscapeMeshList[index].meshPlacementCutoff, 0.1f, 1f);
                            }

                            landscapeMeshList[index].isClustered = EditorGUILayout.Toggle(meshIsClusteredContent, landscapeMeshList[index].isClustered);
                            if (landscapeMeshList[index].isClustered)
                            {
                                landscapeMeshList[index].clusterDistance = EditorGUILayout.Slider(meshClusterDistanceContent, landscapeMeshList[index].clusterDistance, 0.1f, 100f);
                                landscapeMeshList[index].clusterDensity = EditorGUILayout.Slider(meshClusterDensityContent, landscapeMeshList[index].clusterDensity, 0.01f, 1f);
                                maxClusterResolution = Mathf.Clamp(landscapeMeshList[index].clusterDistance / 5f, 0.1f, 100f);
                                landscapeMeshList[index].clusterResolution = EditorGUILayout.Slider(meshClusterResolutionContent, landscapeMeshList[index].clusterResolution, 0.01f, maxClusterResolution);
                            }

                            landscapeMeshList[index].removeGrass = EditorGUILayout.Toggle(meshRemoveGrassContent, landscapeMeshList[index].removeGrass);
                            if (landscapeMeshList[index].removeGrass)
                            {
                                landscapeMeshList[index].minGrassProximity = EditorGUILayout.Slider(meshMinGrassProximityContent, landscapeMeshList[index].minGrassProximity, 0f, 25f);
                            }

                            landscapeMeshList[index].minTreeProximity = EditorGUILayout.Slider(meshMinTreeProximityContent, landscapeMeshList[index].minTreeProximity, 0f, 25f);

                            landscapeMeshList[index].isTerrainFlattened = EditorGUILayout.Toggle(meshIsTerrainFlattenContent, landscapeMeshList[index].isTerrainFlattened);
                            if (landscapeMeshList[index].isTerrainFlattened)
                            {
                                landscapeMeshList[index].flattenDistance = EditorGUILayout.Slider(meshFlattenDistanceContent, landscapeMeshList[index].flattenDistance, 0.1f, 100f);
                                landscapeMeshList[index].flattenBlendRate = EditorGUILayout.Slider(meshFlattenBlendRateContent, landscapeMeshList[index].flattenBlendRate, 0.1f, 1f);
                                landscapeMeshList[index].flattenHeightOffset = EditorGUILayout.Slider(meshFlattenHeightOffsetContent, landscapeMeshList[index].flattenHeightOffset, (terrainHeight * -0.25f), terrainHeight * 0.25f);
                            }

                            // Mesh filters
                            GUILayout.BeginHorizontal();
                            if (GUILayout.Button(meshAddFilterContent, GUILayout.Width(100f)))
                            {
                                // Create a new default filter
                                LBFilter newLBFilter = new LBFilter(LBFilter.FilterType.Texture, LBFilter.FilterMode.AND);
                                if (newLBFilter != null)
                                {
                                    newLBFilter.terrainTexture = new LBTerrainTexture();
                                    // If this is the first filter, create an empty List of LBFilters.
                                    if (landscapeMeshList[index].filterList == null)
                                    {
                                        landscapeMeshList[index].filterList = new List<LBFilter>();
                                    }
                                    landscapeMeshList[index].filterList.Add(newLBFilter);
                                    isSceneSaveRequired = true;
                                }
                            }
                            if (landscapeMeshList[index].filterList != null)
                            {
                                if (landscapeMeshList[index].filterList.Count > 0)
                                {
                                    if (GUILayout.Button("Remove Filter", GUILayout.Width(100f)))
                                    {
                                        // Remove the last one from the list
                                        landscapeMeshList[index].filterList.RemoveAt(landscapeMeshList[index].filterList.Count - 1);
                                        isSceneSaveRequired = true;
                                    }
                                }
                            }
                            GUILayout.EndHorizontal();

                            if (landscapeMeshList[index].filterList != null)
                            {
                                // Display the Mesh filters
                                for (int filterIndex = 0; filterIndex < landscapeMeshList[index].filterList.Count; filterIndex++)
                                {
                                    meshLBFilter = landscapeMeshList[index].filterList[filterIndex];

                                    GUILayout.BeginHorizontal();
                                    labelText = "<color=" + txtColourName + "><i>Filter " + (filterIndex + 1).ToString("00") + " </i></color>";
                                    EditorGUILayout.LabelField(labelText, labelFieldRichText, GUILayout.MaxWidth(50f));

                                    EditorGUI.BeginChangeCheck();
                                    // Store as standard LBFilter but only display limited list
                                    LBFilter.FilterTypesForMeshes filterTypeForMeshes = (LBFilter.FilterTypesForMeshes)EditorGUILayout.EnumPopup((LBFilter.FilterTypesForMeshes)meshLBFilter.filterType, GUILayout.Width(90f));
                                    if (EditorGUI.EndChangeCheck())
                                    {
                                        meshLBFilter.filterType = (LBFilter.FilterType)filterTypeForMeshes;

                                        if (meshLBFilter.filterType == LBFilter.FilterType.Proximity || meshLBFilter.filterType == LBFilter.FilterType.StencilLayer)
                                        {
                                            // Only AND is supported for StencilLayer and Proximity filters
                                            meshLBFilter.filterMode = LBFilter.FilterMode.AND;
                                            isSceneSaveRequired = true;
                                        }
                                    }

                                    // Each filter can be a different type.
                                    if (meshLBFilter.filterType == LBFilter.FilterType.Texture)
                                    {
                                        // A Texture Filter has only one texture per filter (this makes coding simplier and reduced
                                        // the need for more buttons to add and remove textures from a single filter.
                                        meshLBFilter.filterMode = (LBFilter.FilterMode)EditorGUILayout.EnumPopup((LBFilter.FilterModeAndNot)meshLBFilter.filterMode, GUILayout.Width(65f));
                                        GUILayout.EndHorizontal();

                                        GUILayout.BeginHorizontal();
                                        labelText = "<color=" + txtColourName + ">Texture</color>";
                                        EditorGUILayout.LabelField(labelText, labelFieldRichText, GUILayout.MaxWidth(50f));

                                        if (TerrainTexturesAvailableList == null || TerrainTexturesAvailableArray == null)
                                        {
                                            EditorGUILayout.LabelField("No textures in this landscape");
                                        }
                                        else if (TerrainTexturesAvailableList.Count == 0)
                                        {
                                            EditorGUILayout.LabelField("No textures in this landscape");
                                        }
                                        else
                                        {
                                            if (meshLBFilter.terrainTexture == null) { Debug.LogError("meshLBFilter.terrainTexture is null"); }

                                            // We can't simply find the matching LBTerrainTexture with FindIndex(ftx => ftx == meshLBFilter.terrainTexture)
                                            // because a splatprototype only contains texture, normalmap, metallic, smoothness and tileSize fields
                                            int textureIndex = TerrainTexturesAvailableList.FindIndex(ftx => ftx.texture == meshLBFilter.terrainTexture.texture &&
                                                                                                             ftx.normalMap == meshLBFilter.terrainTexture.normalMap &&
                                                                                                             ftx.metallic == meshLBFilter.terrainTexture.metallic &&
                                                                                                             ftx.smoothness == meshLBFilter.terrainTexture.smoothness &&
                                                                                                             ftx.tileSize == meshLBFilter.terrainTexture.tileSize);
                                            EditorGUI.BeginChangeCheck();
                                            textureIndex = EditorGUILayout.Popup(textureIndex, TerrainTexturesAvailableArray);
                                            if (EditorGUI.EndChangeCheck())
                                            {
                                                if (textureIndex < TerrainTexturesAvailableList.Count)
                                                {
                                                    meshLBFilter.terrainTexture = TerrainTexturesAvailableList[textureIndex];
                                                    isSceneSaveRequired = true;
                                                }
                                            }
                                        }
                                        GUILayout.EndHorizontal();
                                    }

                                    else if (meshLBFilter.filterType == LBFilter.FilterType.Area)
                                    {
                                        meshLBFilter.filterMode = (LBFilter.FilterMode)EditorGUILayout.EnumPopup(meshLBFilter.filterMode, GUILayout.Width(65f));
                                        GUILayout.EndHorizontal();

                                        // Is the area highlighter required?
                                        areaHighlighterRequired = (areaHighlighterRequired || meshLBFilter.showAreaHighlighter);

                                        if (meshLBFilter.showAreaHighlighter)
                                        {
                                            GUILayout.BeginHorizontal();
                                            if (GUILayout.Button("Disable Area Picker", buttonCompact, GUILayout.MaxWidth(125f)))
                                            {
                                                meshLBFilter.showAreaHighlighter = false;
                                                areaHighlighterRequired = false;
                                            }
                                            if (GUILayout.Button("Move Area to View", buttonCompact, GUILayout.MaxWidth(125f)))
                                            {
                                                meshAreaHighlighter.MoveToSceneView();
                                            }
                                            GUILayout.EndHorizontal();
                                        }
                                        // Only permit area picker to be enabled if no other mesh area filters have the picker enabled.
                                        else if (!meshAreaHighlighterEnabled)
                                        {
                                            if (GUILayout.Button("Enable Area Picker", buttonCompact, GUILayout.MaxWidth(125f)))
                                            {
                                                meshLBFilter.showAreaHighlighter = true;
                                                areaHighlighterRequired = true;
                                            }
                                        }

                                        if (meshAreaHighlighter != null && meshLBFilter.showAreaHighlighter && meshAreaHighlighter.AreaRectSet())
                                        {
                                            meshLBFilter.areaRect = meshAreaHighlighter.GetAreaRect();
                                        }
                                        meshLBFilter.areaRect = EditorGUILayout.RectField(meshFilterAreaRectContent, meshLBFilter.areaRect);
                                        if (meshAreaHighlighter != null && meshLBFilter.showAreaHighlighter)
                                        {
                                            meshAreaHighlighter.AssignAreaRect(meshLBFilter.areaRect, landscape.transform.position, terrainHeight);
                                        }
                                    }
                                    else if (meshLBFilter.filterType == LBFilter.FilterType.Proximity)
                                    {
                                        GUILayout.EndHorizontal();
                                        // Display the Unity Layers without the ones without any names
                                        meshLBFilter.layerMask = LBEditorHelper.LayerMaskField(meshLBFilter.layerMask, "      Unity Layers", "The Unity Layers the mesh or prefab will consider for proximity awareness.", null);

                                        int tagIndex = tagList.FindIndex(t => t == meshLBFilter.filterByTag);
                                        int maxTagIndex = 0;
                                        if (tagList.Count > 0) { maxTagIndex = tagList.Count - 1; }
                                        tagIndex = Mathf.Clamp(tagIndex, 0, maxTagIndex);

                                        tagIndex = EditorGUILayout.Popup("      Match Tag", tagIndex, tagList.ToArray());
                                        meshLBFilter.filterByTag = tagList[tagIndex];

                                        // We're not going to use the TagField as it includes all the default stuff like Camera, Untagged, EditorOnly etc.
                                        //meshLBFilter.filterByTag = EditorGUILayout.TagField(new GUIContent("      Match Tag"), meshLBFilter.filterByTag);

                                        meshLBFilter.minProximity = EditorGUILayout.Slider(meshFilterMinProximityContent, meshLBFilter.minProximity, 0f, 100f);
                                    }
                                    else if (meshLBFilter.filterType == LBFilter.FilterType.StencilLayer)
                                    {
                                        GUILayout.EndHorizontal();


                                        // If there is a Stencil selected, populate the temporary class instance
                                        if (meshLBFilter.lbStencilGUID != null && meshLBFilter.lbStencil == null)
                                        {
                                            meshLBFilter.lbStencil = LBStencil.GetStencilInLandscape(landscape, meshLBFilter.lbStencilGUID, true);
                                        }

                                        EditorGUI.BeginChangeCheck();
                                        meshLBFilter.lbStencil = (LBStencil)EditorGUILayout.ObjectField(meshFilterStencilContent, meshLBFilter.lbStencil, typeof(LBStencil), true);
                                        if (EditorGUI.EndChangeCheck())
                                        {
                                            meshLBFilter.lbStencilGUID = meshLBFilter.lbStencil.GUID;
                                            meshLBFilter.lbStencilLayerGUID = string.Empty;
                                            // When user selects a different stencil, default to the first stencil layer
                                            if (meshLBFilter.lbStencil.stencilLayerList != null)
                                            {
                                                if (meshLBFilter.lbStencil.stencilLayerList.Count > 0)
                                                {
                                                    meshLBFilter.lbStencilLayerGUID = meshLBFilter.lbStencil.stencilLayerList[0].GUID;
                                                }
                                            }
                                        }

                                        // Get list of LBStencilLayers for the current LBStencil
                                        if (meshLBFilter.lbStencil != null)
                                        {
                                            // Get a list of the Layer Names and their GUIDs
                                            List<string> meshFilterStencilLayerGUIDList = new List<string>();
                                            List<string> meshFilterStencilLayerNameList = new List<string>();
                                            int meshFilterStencilLayerIndex = 0;

                                            if (meshLBFilter.lbStencil.stencilLayerList != null)
                                            {
                                                foreach (LBStencilLayer lbStencilLayer in meshLBFilter.lbStencil.stencilLayerList)
                                                {
                                                    if (!string.IsNullOrEmpty(lbStencilLayer.GUID))
                                                    {
                                                        meshFilterStencilLayerGUIDList.Add(lbStencilLayer.GUID);
                                                        meshFilterStencilLayerNameList.Add(lbStencilLayer.LayerName);
                                                    }
                                                }

                                                // Find the stencil layer that was last selected in the mesh filter
                                                meshFilterStencilLayerIndex = meshFilterStencilLayerGUIDList.FindIndex(sl => sl == meshLBFilter.lbStencilLayerGUID);
                                            }

                                            // Display the list of Stencil Layers for the selected Stencil.
                                            EditorGUI.BeginChangeCheck();
                                            meshFilterStencilLayerIndex = EditorGUILayout.Popup("Stencil Layer", meshFilterStencilLayerIndex, meshFilterStencilLayerNameList.ToArray());

                                            if (EditorGUI.EndChangeCheck() && meshFilterStencilLayerGUIDList.Count > meshFilterStencilLayerIndex && meshFilterStencilLayerIndex >= 0)
                                            {
                                                // Update the stencil layer for this mesh filter
                                                meshLBFilter.lbStencilLayerGUID = meshFilterStencilLayerGUIDList[meshFilterStencilLayerIndex];
                                            }
                                        }
                                    }
                                    else { GUILayout.EndHorizontal(); }

                                }
                            }  // end Mesh filters
                        }
                        GUILayout.EndVertical();
                    }
                    EditorGUILayout.EndScrollView();

                    // More than one mesh "could" be removed in same frame but very unlikely so just use the last one
                    if (meshToRemove != null)
                    {
                        int meshPos = landscapeMeshList.FindIndex(tx => tx == meshToRemove);
                        labelText = "Mesh " + (meshPos + 1).ToString() + " (";

                        if (meshToRemove.usePrefab)
                        {
                            if (meshToRemove.prefab != null) { labelText += meshToRemove.prefab.name; }
                            else { labelText += "No prefab"; }
                        }
                        else if (meshToRemove.mesh != null) { labelText += meshToRemove.mesh.name; }
                        else { labelText += "No mesh prefab"; }
                        labelText += ") will be deleted \n\nThis action will remove the mesh from the list and cannot be undone.";
                        if (LBEditorHelper.PromptForDelete("Delete Mesh?", labelText))
                        {
                            landscapeMeshList.Remove(meshToRemove);
                        }
                    }
                    // Does the user wish to move a Mesh downward in the list (or move from last position to top)?
                    else if (moveMeshPos >= 0 && meshToMove != null)
                    {
                        // Attempt to move this Mesh down one in the list
                        if (landscapeMeshList.Count > 1)
                        {
                            // If this is the last in the list we want to put it at the top
                            if (moveMeshPos == landscapeMeshList.Count - 1)
                            {
                                landscapeMeshList.Insert(0, meshToMove);
                                landscapeMeshList.RemoveAt(landscapeMeshList.Count - 1);
                            }
                            else
                            {
                                // Move down one in the list
                                landscapeMeshList.RemoveAt(moveMeshPos);
                                landscapeMeshList.Insert(moveMeshPos + 1, meshToMove);
                            }
                            isSceneSaveRequired = true;
                        }
                        meshToMove = null;
                    }
                    // Does the user wish to insert a new (duplicate) mesh into the list?
                    else if (insertMeshPos >= 0)
                    {
                        // Insert a duplicate above the selected Tree
                        landscapeMeshList.Insert(insertMeshPos, new LBLandscapeMesh(landscapeMeshList[insertMeshPos]));
                        // Show the new duplicate, and hide the original
                        landscapeMeshList[insertMeshPos].showMesh = true;
                        landscapeMeshList[insertMeshPos + 1].showMesh = false;
                        isSceneSaveRequired = true;
                    }

                    // Enable or disable the mesh Area filter Highlighter
                    if (areaHighlighterRequired && meshAreaHighlighter == null)
                    {
                        meshAreaHighlighter = GameObject.FindObjectOfType<LBAreaHighlight>();
                        if (meshAreaHighlighter == null)
                        {
                            meshAreaHighlighter = LBAreaHighlight.CreateAreaHighLighter();
                            // Set to enabled so that we know when we need to repaint the editor in OnInspectorUpdate()
                            meshAreaHighlighterEnabled = true;
                        }
                    }
                    else if (!areaHighlighterRequired && meshAreaHighlighter != null)
                    {
                        DestroyImmediate(meshAreaHighlighter.gameObject);
                        meshAreaHighlighterEnabled = false;
                    }

                    if (GUILayout.Button("Populate Landscape With Meshes"))
                    {

                        // Turn highlighter off before applying meshes or a layout error occurs
                        if (meshAreaHighlighterEnabled || meshAreaHighlighter != null)
                        {
                            areaHighlighterRequired = false;
                            DestroyImmediate(meshAreaHighlighter.gameObject);
                            meshAreaHighlighterEnabled = false;
                        }

                        ApplyMeshes();
                    }
                }
                else
                {
                    EditorGUILayout.HelpBox("No landscape to modify - you can add or find one in the landscape tab.", MessageType.Info, true);
                }
                #endregion
            }
            else if (selectedTabInt == 7)
            {
                // Export tab
                #region ExportTab
                if (landscape != null && landscapeGameObject != null)
                {
                    scrollPosition = EditorGUILayout.BeginScrollView(scrollPosition);

                    #region Create and Save To Project

                    GUILayout.BeginVertical(EditorStyles.helpBox);
                    EditorGUILayout.LabelField("<b>Export To Project</b>\n\nExport To Project allows you to save the generated TerrainData" +
                        " and Mesh files into the project, optionally creating a landscape prefab and/or exporting a package. " +
                        " Any exported packages will be saved outside of the assets folder in the LandscapeBuilder directory. " +
                        "Moving the terrain data from the scene to the project folder is a one-way operation. There is NO UNDO.\n", labelsmallFieldRichText);

                    #region Create and Save Options
                    if (landscape.useProjectForTerrainData)
                    {
                        saveTerrainDataFiles = false;
                    }
                    else
                    {
                        saveTerrainDataFiles = EditorGUILayout.Toggle(exportSaveDataTerrainFilesContent, saveTerrainDataFiles);
                        if (saveTerrainDataFiles)
                        {
                            GUILayout.BeginHorizontal();
                            exportTerrainDataFolder = EditorGUILayout.TextField(exportTerrainDataFolderContent, exportTerrainDataFolder);
                            if (GUILayout.Button("..", toggleTinyButtonStyleNormal, GUILayout.Width(20f)))
                            {
                                LBEditorHelper.CheckFolder("Assets" + (exportTerrainDataFolder.StartsWith("/") ? "" : "/") + exportTerrainDataFolder);
                                LBEditorHelper.GetPathFromUser("Terrain Data Folder", "Landscape/TerrainData", true, ref exportTerrainDataFolder);
                            }
                            GUILayout.EndHorizontal();
                            terrainDataName = EditorGUILayout.TextField(exportTerrainDataAssetNameContent, terrainDataName);
                        }
                    }
                    exportCreatePrefab = EditorGUILayout.Toggle(exportCreateLandscapePrefab, exportCreatePrefab);
                    if (exportCreatePrefab)
                    {
                        landscapePrefabName = EditorGUILayout.TextField(exportLandscapePrefabName, landscapePrefabName);
                    }
                    exportPackage = EditorGUILayout.Toggle(exportIsLandscapePackage, exportPackage);
                    if (exportPackage)
                    {
                        exportedPackageName = EditorGUILayout.TextField(exportLandscapePackageName, exportedPackageName);
                        packageIncludeDependencies = EditorGUILayout.Toggle(exportIncludeDependencies, packageIncludeDependencies);
                    }
                    #endregion

                    landscapeTerrains = landscapeGameObject.GetComponentsInChildren<Terrain>();
                    GUILayout.BeginHorizontal();

                    #region Create and Save Assets
                    if (GUILayout.Button("Create + Save Assets", GUILayout.Width(EditorGUIUtility.labelWidth - 5f)))
                    {
                        List<string> packageAssetFilePaths = new List<string>();
                        LBEditorHelper.CheckFolder("Assets/LandscapeBuilder/TerrainData");

                        if (!AssetDatabase.Contains(landscapeTerrains[0].terrainData))
                        {
                            if (saveTerrainDataFiles)
                            {
                                if (!File.Exists(Application.dataPath + "/LandscapeBuilder/TerrainData/" + terrainDataName + "0000.asset"))
                                {
                                    AssetDatabase.StartAssetEditing();
                                    landscapeTerrains = landscapeGameObject.GetComponentsInChildren<Terrain>();
                                    for (index = 0; index < landscapeTerrains.Length; index++)
                                    {
                                        AssetDatabase.CreateAsset(landscapeTerrains[index].terrainData, "Assets/LandscapeBuilder/TerrainData/" + terrainDataName + index.ToString("0000") + ".asset");
                                        packageAssetFilePaths.Add("Assets/LandscapeBuilder/TerrainData/" + terrainDataName + index.ToString("0000") + ".asset");
                                    }
                                    landscape.useProjectForTerrainData = true;
                                    // terrainDataFolder doesn't store the Assets/ prefix
                                    landscape.terrainDataFolder = "LandscapeBuilder/TerrainData";
                                    useProjectForTerrainData = true;
                                    terrainDataFolder = landscape.terrainDataFolder;
                                    AssetDatabase.StopAssetEditing();
                                    isSceneSaveRequired = true;
                                }
                                else
                                {
                                    Debug.Log("Not saving TerrainData files as the given filename already exists");
                                }
                            }
                        }
                        else
                        {
                            Debug.Log("Not saving TerrainData files as the TerrainData files are already saved");
                            for (index = 0; index < landscapeTerrains.Length; index++)
                            {
                                packageAssetFilePaths.Add(AssetDatabase.GetAssetPath(landscapeTerrains[index].terrainData));
                            }
                        }
                        if (!File.Exists(Application.dataPath + "/LandscapeBuilder/TerrainData/" + landscapePrefabName + ".prefab"))
                        {
                            if (exportCreatePrefab)
                            {
#if UNITY_2018_3_OR_NEWER
                                PrefabUtility.SaveAsPrefabAsset(landscapeGameObject, "Assets/LandscapeBuilder/TerrainData/" + landscapePrefabName + ".prefab");
#else
                                PrefabUtility.CreatePrefab("Assets/LandscapeBuilder/TerrainData/" + landscapePrefabName + ".prefab", landscapeGameObject);
#endif
                                packageAssetFilePaths.Add("Assets/LandscapeBuilder/TerrainData/" + landscapePrefabName + ".prefab");
                            }
                        }
                        else
                        {
                            if (EditorUtility.DisplayDialog("Prefab Already Exists", "Are you sure you want to save the prefab? The currently existing" +
                                                            " prefab will be lost.", "Overwrite", "Cancel"))
                            {
                                if (AssetDatabase.DeleteAsset("Assets/LandscapeBuilder/TerrainData/" + landscapePrefabName + ".prefab"))
                                {
#if UNITY_2018_3_OR_NEWER
                                    PrefabUtility.SaveAsPrefabAsset(landscapeGameObject, "Assets/LandscapeBuilder/TerrainData/" + landscapePrefabName + ".prefab");
#else
                                    PrefabUtility.CreatePrefab("Assets/LandscapeBuilder/TerrainData/" + landscapePrefabName + ".prefab", landscapeGameObject);
#endif
                                    packageAssetFilePaths.Add("Assets/LandscapeBuilder/TerrainData/" + landscapePrefabName + ".prefab");
                                }
                                else { Debug.LogWarning("Existing Prefab asset could not be deleted."); }
                            }
                            else
                            {
                                Debug.Log("Not saving Prefab file as the given filename already exists");
                                packageAssetFilePaths.Add("Assets/LandscapeBuilder/TerrainData/" + landscapePrefabName + ".prefab");
                            }
                        }
                        if (exportPackage && packageAssetFilePaths.Count > 0)
                        {
                            if (packageIncludeDependencies)
                            {
                                AssetDatabase.ExportPackage(packageAssetFilePaths.ToArray(), "LandscapeBuilder/" + exportedPackageName + ".unitypackage", ExportPackageOptions.IncludeDependencies | ExportPackageOptions.Interactive);
                            }
                            else
                            {
                                AssetDatabase.ExportPackage(packageAssetFilePaths.ToArray(), "LandscapeBuilder/" + exportedPackageName + ".unitypackage", ExportPackageOptions.Interactive);
                            }
                        }
                        AssetDatabase.Refresh();
                    }
                    #endregion

                    #region Move Terrain Data From Scene to Project
                    if (saveTerrainDataFiles && !landscape.useProjectForTerrainData)
                    {
                        if (GUILayout.Button(exportMoveTerrainDataBtnContent, GUILayout.Width(130f)))
                        {
                            string outputFolder = "Assets" + (exportTerrainDataFolder.StartsWith("/") ? "" : "/") + exportTerrainDataFolder;

                            LBEditorHelper.CheckFolderStructure(outputFolder);

                            landscape.SetLandscapeTerrains(true);
                            int numTerrains = landscape.landscapeTerrains == null ? 0 : landscape.landscapeTerrains.Length;

                            // Block the Move from scene to project if terrain data already exists
                            UnityEngine.Object obj = AssetDatabase.LoadMainAssetAtPath(outputFolder + "/" + terrainDataName + "0000.asset");

                            if (obj != null)
                            {
                                EditorUtility.DisplayDialog("Move Terrain Data", "Terrain Data already exists in this folder. Select or create another folder", "Got it!");
                            }
                            else
                            {
                                Terrain terrainScene = null;
                                TerrainData terrainDataScene = null;

                                AssetDatabase.StartAssetEditing();

                                for (index = 0; index < numTerrains; index++)
                                {
                                    terrainScene = landscapeTerrains[index];

                                    if (terrainScene != null)
                                    {
                                        terrainDataScene = terrainScene.terrainData;

                                        // Create an asset in the project folder
                                        // Automatically removes the data from the scene when the scene is saved
                                        // Automatically links the TerrainCollider
                                        AssetDatabase.CreateAsset(terrainDataScene, outputFolder + "/" + terrainDataName + index.ToString("0000") + ".asset");

                                        Debug.Log("[INFO] terrainData moved from scene to " + AssetDatabase.GetAssetPath(terrainDataScene));
                                    }
                                }
                                useProjectForTerrainData = true;
                                // The terrainDataFolder does not include the Assets/ prefix.
                                terrainDataFolder = exportTerrainDataFolder;
                                landscape.useProjectForTerrainData = true;
                                landscape.terrainDataFolder = terrainDataFolder;
                                AssetDatabase.StopAssetEditing();
                                isSceneSaveRequired = true;

                                LBEditorHelper.HighlightItemInProjectWindow("Assets/" + exportTerrainDataFolder, false);
                            }
                        }
                    }
                    #endregion
                    
                    GUILayout.EndHorizontal();
                    GUILayout.EndVertical();
                    #endregion

                    #region Export Heightmap To PNG
                    EditorGUILayout.Space();
                    GUILayout.BeginVertical(EditorStyles.helpBox);
                    EditorGUILayout.LabelField("<b>Export Heightmap to PNG</b>\n\nExport the Landscape Terrain data as a grey scale heightmap PNG file.\n" +
                                   "Images will be saved in " + exportPNGFolderPath + "\n", labelsmallFieldRichText);
                    exportPNGFileName = EditorGUILayout.TextField(new GUIContent("Heightmap Filename", "The name of PNG file to be exported"), exportPNGFileName);
                    exportHeightmapNormalise = EditorGUILayout.Toggle(exportHeightmapNormaliseContent, exportHeightmapNormalise);

                    if (GUILayout.Button("Export Heightmap", GUILayout.Width(EditorGUIUtility.labelWidth - 5f)))
                    {
                        bool continueToSave = true;

                        exportPNGFilePath = exportPNGFolderPath + "/" + exportPNGFileName;

                        // Make sure the user hasn't deleted the Images folder
                        LBEditorHelper.CheckFolder(exportPNGFolderPath);

                        if (landscape == null)
                        {
                            continueToSave = false;
                            Debug.LogError("Please select a landscape on the Landscape Tab");
                        }
                        else if (string.IsNullOrEmpty(exportPNGFileName))
                        {
                            continueToSave = false;
                            Debug.LogError("Please enter a valid export image filename");
                        }
                        else if (!exportPNGFileName.ToLower().EndsWith(".png"))
                        {
                            exportPNGFilePath += ".png";
                        }

                        if (continueToSave)
                        {
                            if (System.IO.File.Exists(exportPNGFilePath))
                            {
                                continueToSave = EditorUtility.DisplayDialog("Image File Already Exists", "Are you sure you want to overwrite " + exportPNGFilePath + "?", "Overwrite", "Cancel");
                            }
                        }

                        if (continueToSave)
                        {
                            landscapeTerrains = landscapeGameObject.GetComponentsInChildren<Terrain>();
                            if (landscapeTerrains == null)
                            {
                                Debug.LogWarning("Export To PNG: Could not find Terrain objects under Landscape " + landscape.gameObject.name + " GameObject");
                            }
                            else
                            {
                                // Create a texture the size of the landscape
                                try
                                {
                                    int numTerrains = landscapeTerrains.Length;
                                    int numTerrainsWide = Mathf.RoundToInt(Mathf.Sqrt(numTerrains));
                                    int heightmapResolution = landscape.GetLandscapeTerrainHeightmapResolution();

                                    if (exportHeightmapNormalise)
                                    {
                                        landscapeMinMaxHeight = landscape.GetLandscapeMinMaxHeights();
                                        if (float.IsInfinity(landscapeMinMaxHeight.x) || float.IsInfinity(landscapeMinMaxHeight.y))
                                        {
                                            landscapeMinMaxHeight = Vector2.zero;
                                        }
                                    }

                                    // Ensure texture is a power of 2 by using (heightmapResolution-1).
                                    Texture2D exportHeightMapImage = new Texture2D(numTerrainsWide * (heightmapResolution - 1), numTerrainsWide * (heightmapResolution - 1), TextureFormat.ARGB32, false);

                                    // Loop through all the terrains, and update the appropriate pixels in the image for each terrain
                                    for (index = 0; index < numTerrains; index++)
                                    {

                                        if (EditorUtility.DisplayCancelableProgressBar("Export heightmap to PNG", "Exporting " + (index + 1).ToString() + " of " + numTerrains.ToString() + " terrains",
                                                   (float)(index + 1) / (float)numTerrains))
                                        {
                                            // If the user cancels the process, so exit loop and don't try to save the file
                                            continueToSave = false;
                                            break;
                                        }

                                        LBLandscapeTerrain.ExportImageBasedHeightmap(landscapeTerrains[index].terrainData, landscapeTerrains[index].transform.position,
                                                                                         landscape.size, landscape.transform.position, exportHeightMapImage, exportHeightmapNormalise ? landscapeMinMaxHeight : Vector2.zero);
                                    }

                                    // Check to see if the user cancelled
                                    if (continueToSave)
                                    {
                                        SaveMapTexture(exportHeightMapImage, exportPNGFilePath);
                                        Debug.Log("Exported heightmap as PNG to " + exportPNGFilePath + " successful.");
                                    }
                                }
                                catch (Exception ex)
                                {
                                    Debug.LogError("Could not export heightmap to PNG image " + ex.Message);
                                }

                                EditorUtility.ClearProgressBar();
                            }
                        }
                    }

                    GUILayout.EndVertical();
                    #endregion

                    #region Export Splatmaps To PNG
                    EditorGUILayout.Space();
                    GUILayout.BeginVertical(EditorStyles.helpBox);
                    EditorGUILayout.LabelField("<b>Export Splatmap Textures to PNGs</b>\n\nExport the Landscape Terrain texture splatmap data as a landscape-wide PNG files. " +
                                   "Images will be saved in Assets/LandscapeBuilder/Splatmaps. Texture data will be stored in the (R)ed channel.\n", labelsmallFieldRichText);

                    if (GUILayout.Button("Export Textures", GUILayout.Width(EditorGUIUtility.labelWidth - 5f)))
                    {
                        LBLandscapeOperations.ExportSplatmapTextures(landscape, "R", true);
                    }

                    GUILayout.EndVertical();
                    #endregion

                    #region Export Landscape To Mesh
                    EditorGUILayout.Space();
                    GUILayout.BeginVertical(EditorStyles.helpBox);
                    EditorGUILayout.LabelField("<b>Create Landscape as Mesh</b>\n\nGenerate meshes in the scene from Landscape Terrain data\n", labelsmallFieldRichText);
                    exportMeshAddColliders = EditorGUILayout.Toggle(exportMeshAddCollidersContent, exportMeshAddColliders);
                    exportMeshIsStatic = EditorGUILayout.Toggle(exportMeshIsStaticContent, exportMeshIsStatic);
                    exportMeshIncludeOcclusionArea = EditorGUILayout.Toggle(exportMeshIncludeInclusionAreasContent, exportMeshIncludeOcclusionArea);
                    if (exportMeshIncludeOcclusionArea)
                    {
                        exportMeshBakeOcclusion = EditorGUILayout.Toggle(exportMeshBakeInclusionContent, exportMeshBakeOcclusion);
                    }

                    if (isMegaSplatInstalled)
                    {
                        exportMeshUseMegaSplat = EditorGUILayout.Toggle(exportMeshUseMegaSplatContent, exportMeshUseMegaSplat);
                    }
                    else { exportMeshUseMegaSplat = false; }

                    if (exportMeshUseMegaSplat) { exportMeshIncludeSplatmaps = false; }
                    else
                    {
                        exportMeshIncludeSplatmaps = EditorGUILayout.Toggle(exportMeshIncludeSplatmapsContent, exportMeshIncludeSplatmaps);
                    }

                    exportMeshToProjectFolder = EditorGUILayout.Toggle(exportMeshAddToProjectFolderContent, exportMeshToProjectFolder);

                    GUILayout.BeginHorizontal();
                    if (GUILayout.Button("Export to Mesh", GUILayout.Width(EditorGUIUtility.labelWidth - 5f)))
                    {
                        EditorUtility.DisplayProgressBar("Export to Mesh", "Getting mesh data from landscape", 0.1f);

                        // Get LBMesh list for the whole landscape
                        List<LBMesh> lbMeshList = LBLandscapeOperations.GetMeshDataFromLandscape(landscape, string.Empty, null, Vector4.zero, Color.clear);
                        if (lbMeshList != null)
                        {
                            EditorUtility.DisplayProgressBar("Export to Mesh", "Creating mesh in scene", 0.5f);
                            Transform landscapeMeshTransform = LBLandscapeOperations.CreateLandscapeMesh(landscape, lbMeshList, landscape.name + "_Meshes", exportMeshAddColliders, exportMeshIncludeOcclusionArea, exportMeshIsStatic, exportMeshIncludeSplatmaps, exportMeshUseMegaSplat, exportMeshToProjectFolder);
                            if (landscapeMeshTransform != null)
                            {
                                if (exportMeshIncludeOcclusionArea && exportMeshBakeOcclusion)
                                {

                                    if (StaticOcclusionCulling.isRunning)
                                    {
                                        EditorUtility.DisplayProgressBar("Export to Mesh", "Cancelling previous Occlusion Bake", 0.75f);
                                        StaticOcclusionCulling.Cancel();
                                    }

                                    if (!StaticOcclusionCulling.isRunning)
                                    {
                                        EditorUtility.DisplayProgressBar("Export to Mesh", "Starting background Occlusion Bake", 0.9f);
                                        StaticOcclusionCulling.GenerateInBackground();
                                    }
                                }
                            }
                        }
                        isSceneSaveRequired = true;
                        EditorUtility.ClearProgressBar();
                    }
                    if (GUILayout.Button("Disable Terrains", GUILayout.Width(115f)))
                    {
                        landscape.EnableTerrains(false);
                        isSceneSaveRequired = true;
                        // Update Landscape stats
                        landscapeMinMaxHeight = landscape.GetLandscapeMinMaxHeights();
                    }
                    if (GUILayout.Button("Disable Mesh", GUILayout.Width(95f)))
                    {
                        landscape.EnableMeshTerrains(false);
                        isSceneSaveRequired = true;
                    }
                    GUILayout.EndHorizontal();

                    GUILayout.BeginHorizontal();
                    if (GUILayout.Button("Export Splatmaps", GUILayout.Width(EditorGUIUtility.labelWidth - 5f)))
                    {
                        LBLandscapeOperations.ExportSplatmaps(landscape, true);
                    }
                    if (GUILayout.Button("Enable Terrains", GUILayout.Width(115f)))
                    {
                        landscape.EnableTerrains(true);
                        isSceneSaveRequired = true;
                        // Update Landscape stats
                        landscapeMinMaxHeight = landscape.GetLandscapeMinMaxHeights();
                    }
                    if (GUILayout.Button("Enable Mesh", GUILayout.Width(95f)))
                    {
                        landscape.EnableMeshTerrains(true);
                        isSceneSaveRequired = true;
                    }
                    GUILayout.EndHorizontal();

                    GUILayout.EndVertical();
                    EditorGUILayout.Space();
                    #endregion

                    // EasyRoad v3 Integration
                    #region EasyRoads v3 Integration
                    GUILayout.BeginVertical(EditorStyles.helpBox);
                    EditorGUILayout.LabelField("<b>Export EasyRoads to MAPs</b>\n\nExport EasyRoads3D roads in a Road Network to PNG MAP files. " +
                   "Images will be saved in " + exportPNGFolderPath + " in the chosen map subfolder.\n", labelsmallFieldRichText);
                    //EasyRoads3D_network = (GameObject)EditorGUILayout.ObjectField("EasyRoads Network", EasyRoads3D_network, typeof(GameObject), true);
                    GUI.SetNextControlName("PNGSubfolderName");
                    exportPNGSubfolderName = EditorGUILayout.TextField(new GUIContent("EasyRoads Map Folder", "The name of folder under Assets/LandscapeBuilder/Images where the files will be exported"), exportPNGSubfolderName);
                    exportMapResolutionIndex = EditorGUILayout.Popup("Map Resolution", exportMapResolutionIndex, LBMap.MapResolutionArray, GUILayout.Width(220f));
                    exportERIncludeRoad = EditorGUILayout.Toggle(new GUIContent("Include Road", "Whether to include the road in the map image"), exportERIncludeRoad);
                    if (exportERIncludeRoad)
                    {
                        exportERLeftEdgeMinWidth = 0;
                        exportERRightEdgeMinWidth = 0;
                        exportERLeftEdgeMaxWidth = EditorGUILayout.Slider(new GUIContent("Left Edge Width", "The distance to extend the map beyond the left edge of the road"), exportERLeftEdgeMaxWidth, 0f, 250f);
                        exportERRightEdgeMaxWidth = EditorGUILayout.Slider(new GUIContent("Right Edge Width", "The distance to extend the map beyond the right edge of the road"), exportERRightEdgeMaxWidth, 0f, 250f);
                    }
                    else
                    {
                        EditorGUI.BeginChangeCheck();
                        exportERLeftEdgeMinWidth = EditorGUILayout.Slider(new GUIContent("Left Edge Min Width", "The minimum distance from the left edge of the road"), exportERLeftEdgeMinWidth, 0f, 250f);
                        exportERLeftEdgeMaxWidth = EditorGUILayout.Slider(new GUIContent("Left Edge Max Width", "The distance to extend the map beyond the left edge of the road"), exportERLeftEdgeMaxWidth, 0f, 250f);
                        exportERRightEdgeMinWidth = EditorGUILayout.Slider(new GUIContent("Right Edge Min Width", "The minimum distance from the right edge of the road"), exportERRightEdgeMinWidth, 0f, 250f);
                        exportERRightEdgeMaxWidth = EditorGUILayout.Slider(new GUIContent("Right Edge Max Width", "The distance to extend the map beyond the right edge of the road"), exportERRightEdgeMaxWidth, 0f, 250f);
                        if (EditorGUI.EndChangeCheck())
                        {
                            if (exportERLeftEdgeMinWidth > exportERLeftEdgeMaxWidth) { exportERLeftEdgeMaxWidth = exportERLeftEdgeMinWidth; }
                            if (exportERRightEdgeMinWidth > exportERRightEdgeMaxWidth) { exportERRightEdgeMaxWidth = exportERRightEdgeMinWidth; }
                        }
                    }
                    exportERMapColour = EditorGUILayout.ColorField("Map Colour", exportERMapColour);
                    exportERCombineRoads = EditorGUILayout.Toggle(new GUIContent("Combine Roads", "Combine all the roads into one image map file"), exportERCombineRoads);

                    if (exportERCombineRoads)
                    {
                        // Set the name of the TextField so that we can set focus on it if the filename is invalid
                        GUI.SetNextControlName("ERCombinedFileName");
                        exportERCombinedFileName = EditorGUILayout.TextField(new GUIContent("Combined File Name", "Name of the file to be exported (without the file extension)"), exportERCombinedFileName);
                    }

                    if (GUILayout.Button("Create Road Maps", GUILayout.Width(EditorGUIUtility.labelWidth - 5f)))
                    {
                        // Validate input
                        if (exportERCombineRoads && (string.IsNullOrEmpty(exportERCombinedFileName) || exportERCombinedFileName.Contains(".")))
                        {
                            Debug.LogWarning("Please enter a valid filename without the file extension");
                            GUI.FocusControl("ERCombinedFileName");
                        }
                        else
                        //if (EasyRoads3D_network != null)
                        {
                            bool continueToSave = true;
                            displayDialogComplexInt = 0;

                            // Make sure the user hasn't deleted the Images folder
                            LBEditorHelper.CheckFolder(exportPNGFolderPath);

                            if (landscape == null)
                            {
                                continueToSave = false;
                                Debug.LogWarning("Please select a landscape on the Landscape Tab");
                            }
                            else if (string.IsNullOrEmpty(exportPNGSubfolderName))
                            {
                                continueToSave = false;
                                Debug.LogWarning("Please enter a valid export image folder");
                                GUI.FocusControl("PNGSubfolderName");
                            }
                            else
                            {
                                LBEditorHelper.CheckFolder(exportPNGFolderPath + "/" + exportPNGSubfolderName);
                            }

                            if (continueToSave)
                            {
                                //System.Type erModularRoadType = null;
                                System.Type erRoadNetworkType = null;
                                System.Type erRoadType = null;

                                // classname.GetType().AssemblyQualifiedName where AssemblyQualifiedName is:
                                // EasyRoads3Dv3.ERModularRoad, EasyRoads3Dv3, Version = 1.0.0.0, Culture = neutral, PublicKeyToken = null

                                try
                                {
                                    // Use Reflection to obtain the types
                                    //erModularRoadType = System.Type.GetType("EasyRoads3Dv3.ERModularRoad, EasyRoads3Dv3, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null", true, true);
                                    //var erModularRoads = EasyRoads3D_network.GetComponentsInChildren(erModularRoadType);

                                    // Get EasyRoads3D API Types from the assembly
                                    erRoadNetworkType = System.Type.GetType("EasyRoads3Dv3.ERRoadNetwork, EasyRoads3Dv3, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null", true, true);
                                    erRoadType = System.Type.GetType("EasyRoads3Dv3.ERRoad, EasyRoads3Dv3, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null", true, true);

                                    // Create instances of the API Types to be used so that we can call methods
                                    var erRoadNetworkObj = Activator.CreateInstance(erRoadNetworkType);
                                    // This failed in ER3 Beta 7.6.1 but works in ER3 Beta 7.7
                                    // var erRoadObj = Activator.CreateInstance(erRoadType);

                                    if (erRoadNetworkObj != null)
                                    {
                                        var erRoads = erRoadNetworkType.InvokeMember("GetRoads", System.Reflection.BindingFlags.InvokeMethod, null, erRoadNetworkObj, new object[] { });
                                        if (erRoads != null)
                                        {
                                            // We may wish to re-use the roadMap to combine roads into one texture
                                            int mapResolution = 0;
                                            Texture2D roadMapTexture = null;
                                            LBMap roadMap = null;
                                            int roadsExported = 0;

                                            // Loop through the ERRoad[] array
                                            for (int r = 0; r < ((object[])erRoads).Length; r++)
                                            {
                                                var erRoad = ((object[])erRoads)[r];
                                                if (erRoad != null)
                                                {
                                                    // Get a reference to the ERModularRoad class instance attached to this road
                                                    //var roadScript = erRoadType.InvokeMember("roadScript", System.Reflection.BindingFlags.GetField, null, erRoad, new object[] { });

                                                    //if (roadScript != null)
                                                    {
                                                        //System.Type roadScriptType = roadScript.GetType();

                                                        // Get the roadName and roadWidth from the roadScript
                                                        //string roadName = (string)roadScriptType.InvokeMember("roadName", System.Reflection.BindingFlags.GetField, null, erModularRoads[r], new object[] { });
                                                        //float roadWidth = (float)roadScriptType.InvokeMember("roadWidth", System.Reflection.BindingFlags.GetField, null, erModularRoads[r], new object[] { });

                                                        // Get the roadName and roadWidth from API
                                                        string roadName = (string)erRoadType.InvokeMember("GetName", System.Reflection.BindingFlags.InvokeMethod, null, erRoad, new object[] { });
                                                        float roadWidth = (float)erRoadType.InvokeMember("GetWidth", System.Reflection.BindingFlags.InvokeMethod, null, erRoad, new object[] { });

                                                        // The LBMap will be null if this is the first road or we're not combining roads into one texture
                                                        if (roadMap == null)
                                                        {
                                                            // Create a new texture to store the output from CreateMapFromSpline()
                                                            mapResolution = LBMap.MapResolution(exportMapResolutionIndex);
                                                            roadMapTexture = new Texture2D(mapResolution, mapResolution, TextureFormat.ARGB32, false);
                                                            roadMap = new LBMap(roadMapTexture, exportERMapColour, 0);
                                                        }

                                                        // If the map is still null there is a problem.
                                                        if (roadMap == null)
                                                        {
                                                            continueToSave = false;
                                                            Debug.LogError("Could not create LBMap for " + roadName);
                                                        }
                                                        else if (exportERIncludeRoad)
                                                        {
                                                            // Get the centre of the road
                                                            Vector3[] splinePoints = (Vector3[])erRoadType.InvokeMember("GetSplinePointsCenter", System.Reflection.BindingFlags.InvokeMethod, null, erRoad, new object[] { });
                                                            if (splinePoints != null)
                                                            {
                                                                if (roadMap == null)
                                                                {
                                                                    continueToSave = false;
                                                                    Debug.LogError("Could not create LBMap for " + roadName);
                                                                }
                                                                else
                                                                {
                                                                    continueToSave = roadMap.CreateMapFromSpline(landscape, splinePoints, (roadWidth / 2f) + exportERLeftEdgeMaxWidth,
                                                                                                                 (roadWidth / 2f) + exportERRightEdgeMaxWidth, UnityEngine.Color.black, false);
                                                                }
                                                            }
                                                            else
                                                            {
                                                                continueToSave = false;
                                                                roadMap = null;
                                                                Debug.LogError("Could not create LBMap for " + roadName + ". Could not retrieve centre spline from road.");
                                                            }
                                                        }
                                                        else
                                                        {
                                                            // Get the spline points along the left and right of the road
                                                            Vector3[] splinePointsLeftSide = (Vector3[])erRoadType.InvokeMember("GetSplinePointsLeftSide", System.Reflection.BindingFlags.InvokeMethod, null, erRoad, new object[] { });
                                                            Vector3[] splinePointsRightSide = (Vector3[])erRoadType.InvokeMember("GetSplinePointsRightSide", System.Reflection.BindingFlags.InvokeMethod, null, erRoad, new object[] { });

                                                            if (splinePointsLeftSide != null && splinePointsRightSide != null)
                                                            {
                                                                continueToSave = roadMap.CreateMapFromSplines(landscape, splinePointsLeftSide, splinePointsRightSide,
                                                                                                              exportERLeftEdgeMinWidth, exportERLeftEdgeMaxWidth,
                                                                                                              exportERRightEdgeMinWidth, exportERRightEdgeMaxWidth);
                                                            }
                                                            else
                                                            {
                                                                continueToSave = false;
                                                                roadMap = null;
                                                                Debug.LogError("Could not create LBMap for " + roadName + ". Could not retrieve left/right spline from road.");
                                                            }
                                                        }


                                                        // If we successfully created a map, then go ahead and attempt to save it.
                                                        if (continueToSave)
                                                        {
                                                            exportERFileName = roadName + ".png";
                                                            exportPNGFilePath = exportPNGFolderPath + "/" + exportPNGSubfolderName + "/" + exportERFileName;

                                                            // Has the user already clicked "Overwrite All"? If so, we don't need to see if the file already exists
                                                            // Also, if Combine Roads is on, don't check this path either.
                                                            if (displayDialogComplexInt != 1 && !exportERCombineRoads)
                                                            {
                                                                if (System.IO.File.Exists(exportPNGFilePath))
                                                                {
                                                                    displayDialogComplexInt = EditorUtility.DisplayDialogComplex("Image File Already Exists", "Are you sure you want to overwrite " + exportPNGFilePath + "?", "Overwrite", "Overwrite All", "Cancel");

                                                                    continueToSave = (displayDialogComplexInt == 0 || displayDialogComplexInt == 1);
                                                                }
                                                            }

                                                            if (continueToSave)
                                                            {
                                                                // Only save the texture to disk if all roads are not being combined into one texture
                                                                if (!exportERCombineRoads) { LBEditorHelper.SaveMapTexture(roadMapTexture, exportPNGFilePath, (int)landscape.size.x); }

                                                                roadsExported++;
                                                            }

                                                            // If we're not combining the roads into a single map texture, destroy the current
                                                            // items so they are not re-used.
                                                            if (!exportERCombineRoads)
                                                            {
                                                                roadMap = null;
                                                                roadMapTexture = null;
                                                            }
                                                        }
                                                    }
                                                }
                                            }

                                            // If all roads are being combined, save the final texture
                                            if (exportERCombineRoads && roadsExported > 0)
                                            {
                                                exportPNGFilePath = exportPNGFolderPath + "/" + exportPNGSubfolderName + "/" + exportERCombinedFileName + ".png";

                                                if (System.IO.File.Exists(exportPNGFilePath))
                                                {
                                                    continueToSave = EditorUtility.DisplayDialog("Image File Already Exists", "Are you sure you want to overwrite " + exportPNGFilePath + "?", "Overwrite", "Cancel");
                                                }

                                                // Save the combined map image to disk
                                                if (continueToSave) { SaveMapTexture(roadMapTexture, exportPNGFilePath); }
                                            }
                                        }
                                    }
                                }
                                catch
                                {
                                    Debug.LogWarning("EasyRoads 3D v3.x does not seem to be installed in this project.");
                                }
                            }
                        }
                    }

                    GUILayout.EndVertical();
                    #endregion
                    // END EasyRoad v3 Integration

                    EditorGUILayout.EndScrollView();
                }
                else
                {
                    EditorGUILayout.HelpBox("No landscape to modify - you can add or find one in the landscape tab.", MessageType.Info, true);
                }
                #endregion
            }
            else if (selectedTabInt == 8)
            {
                // Advanced tab
                #region AdvancedTab
                scrollPosition = EditorGUILayout.BeginScrollView(scrollPosition);

                // Texture generation
                EditorGUILayout.LabelField("<color=" + txtColourName + "><b>Texture Generator</b></color>\n\nThe Texture Generator enables you to bring terrain and mesh textures to life with " +
                                           "professional looking Albedo, Metallic, Normal, Height, Occlusion, and Emission Maps.", helpBoxRichText);

                if (GUILayout.Button("Texture Generator")) { LBTextureGeneratorWindow.ShowWindow(); }

                #region Advanced Misc Settings

                if (landscape != null && landscapeGameObject != null)
                {
                    // Disable Trees And Grass
                    GUILayout.BeginHorizontal(helpBoxRichText);
                    EditorGUI.BeginChangeCheck();
                    drawTreesAndFoliage = !EditorGUILayout.Toggle(!drawTreesAndFoliage, GUILayout.Width(15f));
                    labelText = "<color=" + txtColourName + "><b>Disable Trees And Grass</b></color>\n\nYou can disable trees and grass to improve performance, especially helpful in the editor";
                    EditorGUILayout.LabelField(labelText, labelsmallFieldRichText);
                    GUILayout.EndHorizontal();

                    if (EditorGUI.EndChangeCheck())
                    {
                        landscapeTerrains = landscapeGameObject.GetComponentsInChildren<Terrain>();
                        if (landscapeTerrains != null)
                        {
                            for (index = 0; index < landscapeTerrains.Length; index++)
                            {
                                landscapeTerrains[index].drawTreesAndFoliage = drawTreesAndFoliage;
                            }
                        }
                        isSceneSaveRequired = true;
                    }

                    // Show/Hide Timing
                    GUILayout.BeginHorizontal(helpBoxRichText);
                    EditorGUI.BeginChangeCheck();
                    landscape.showTiming = EditorGUILayout.Toggle(landscape.showTiming, GUILayout.Width(15f));
                    if (EditorGUI.EndChangeCheck()) { isSceneSaveRequired = true; }
                    labelText = "<color=" + txtColourName + "><b>Show Timing</b></color>\n\nOutput some operation timings to the console";
                    EditorGUILayout.LabelField(labelText, labelsmallFieldRichText);
                    GUILayout.EndHorizontal();

                    // Show/Hide Texture heightMap option
                    GUILayout.BeginHorizontal(helpBoxRichText);
                    EditorGUI.BeginChangeCheck();
                    landscape.showTextureHeightmap = EditorGUILayout.Toggle(landscape.showTextureHeightmap, GUILayout.Width(15f));
                    if (EditorGUI.EndChangeCheck()) { isSceneSaveRequired = true; }
                    labelText = "<color=" + txtColourName + "><b>Show Texture Heightmap</b></color>\n\nSome products, like RTP and MicroSplat, use texture heightmaps. This allows heightmaps to be stored with Textures in the Texturing Tab.";
                    EditorGUILayout.LabelField(labelText, labelsmallFieldRichText);
                    GUILayout.EndHorizontal();
                }

                if (landscape == null) { EditorGUILayout.Space(); }
                GUILayout.BeginHorizontal(helpBoxRichText);
                EditorGUI.BeginChangeCheck();
                autoSaveEnabled = EditorGUILayout.Toggle(autoSaveEnabled, GUILayout.Width(15f));
                if (EditorGUI.EndChangeCheck())
                {
                    LBLandscape.SetAutoSaveState(autoSaveEnabled);
                    isSceneSaveRequired = true;
                }
                EditorGUILayout.LabelField("<color=" + txtColourName + "><b>AutoSave</b></color>\n\nIf AutoSave is enabled, the scene will be automatically" +
                    " saved after every Landscape Builder operation", labelsmallFieldRichText);
                GUILayout.EndHorizontal();

                #region GPU Acceleration
                if (landscape != null && landscapeGameObject != null)
                {
                    //EditorGUILayout.Space();
                    if (landscape.IsGPUAccelerationAvailable())
                    {
                        GUILayout.BeginVertical(helpBoxRichText);

                        EditorGUI.BeginChangeCheck();
                        GUILayout.BeginHorizontal();
                        landscape.useGPUTopography = EditorGUILayout.Toggle(landscape.useGPUTopography, GUILayout.Width(15f));
                        EditorGUILayout.LabelField("<color=" + txtColourName + "><b>GPU Acceleration - Topography</b></color>", labelsmallFieldRichText);
                        GUILayout.EndHorizontal();
                        if (EditorGUI.EndChangeCheck()) { isSceneSaveRequired = true; }

                        EditorGUI.BeginChangeCheck();
                        GUILayout.BeginHorizontal();
                        landscape.useGPUTexturing = EditorGUILayout.Toggle(landscape.useGPUTexturing, GUILayout.Width(15f));
                        EditorGUILayout.LabelField("<color=" + txtColourName + "><b>GPU Acceleration - Texturing</b></color>", labelsmallFieldRichText);
                        GUILayout.EndHorizontal();
                        if (EditorGUI.EndChangeCheck()) { isSceneSaveRequired = true; }

                        EditorGUI.BeginChangeCheck();
                        GUILayout.BeginHorizontal();
                        landscape.useGPUGrass = EditorGUILayout.Toggle(landscape.useGPUGrass, GUILayout.Width(15f));
                        EditorGUILayout.LabelField("<color=" + txtColourName + "><b>GPU Acceleration - Grass</b></color>", labelsmallFieldRichText);
                        GUILayout.EndHorizontal();
                        if (EditorGUI.EndChangeCheck()) { isSceneSaveRequired = true; }

                        EditorGUI.BeginChangeCheck();
                        GUILayout.BeginHorizontal();
                        landscape.useGPUPath = EditorGUILayout.Toggle(landscape.useGPUPath, GUILayout.Width(15f));
                        EditorGUILayout.LabelField("<color=" + txtColourName + "><b>GPU Acceleration - Path</b></color>\n\nSet per landscape. Not compatible with all hardware.\n" +
                            SystemInfo.graphicsDeviceName + " " + (SystemInfo.graphicsMemorySize / 1024f).ToString("0.0") + "GB", labelsmallFieldRichText);
                        GUILayout.EndHorizontal();
                        if (EditorGUI.EndChangeCheck()) { isSceneSaveRequired = true; }

                        GUILayout.EndVertical();
                    }
                    else
                    {
                        GUILayout.BeginHorizontal(helpBoxRichText);
                        EditorGUILayout.LabelField("<color=" + txtColourName + "><b>GPU Acceleration (PREVIEW)</b></color>\n\nSet per landscape. Not compatible with all hardware.\n\n" +
                            "Compute Shaders: " + (SystemInfo.supportsComputeShaders ? "Supported" : "<b>Not Supported</b>") + "\n" +
                            "Texture2DArrays: " + (SystemInfo.supports2DArrayTextures ? "Supported" : "<b>Not Supported</b>") + "\n" +
                            SystemInfo.graphicsDeviceName + " " + (SystemInfo.graphicsMemorySize / 1024f).ToString("0.0") + "MB", labelsmallFieldRichText);
                        GUILayout.EndHorizontal();
                        landscape.useGPUTexturing = false;
                        landscape.useGPUGrass = false;
                        landscape.useGPUTopography = false;
                    }
                }
                #endregion

                #region Override Undo
                if (landscape != null && landscapeGameObject != null)
                {
                    GUILayout.BeginVertical(helpBoxRichText);
                    EditorGUI.BeginChangeCheck();
                    GUILayout.BeginHorizontal();
                    landscape.isUndoTopographyDisabled = EditorGUILayout.Toggle(landscape.isUndoTopographyDisabled, GUILayout.Width(15f));
                    EditorGUILayout.LabelField("<color=" + txtColourName + "><b>Override Undo - Topography</b></color>", labelsmallFieldRichText);
                    GUILayout.EndHorizontal();
                    if (EditorGUI.EndChangeCheck()) { isSceneSaveRequired = true; }
                    if (landscape.isUndoTopographyDisabled)
                    {
                        EditorGUILayout.HelpBox("NOT RECOMMENDED - If you do not know why you are turning this on, please turn if off, else you might lose data.", MessageType.Error, true);
                    }
                    GUILayout.EndVertical();
                }
                #endregion

                #region Non Square Terrains (EXPERIMENTAL)
                //EditorGUILayout.Space();
                GUILayout.BeginHorizontal(helpBoxRichText);
                EditorGUI.BeginChangeCheck();
                isNonSquareTerrainsEnabled = EditorGUILayout.Toggle(isNonSquareTerrainsEnabled, GUILayout.Width(15f));
                if (EditorGUI.EndChangeCheck())
                {
                    LBLandscape.SetIsNonSquareTerrainsEnabled(isNonSquareTerrainsEnabled);
                    isSceneSaveRequired = true;
                }
                EditorGUILayout.LabelField("<color=" + txtColourName + "><b>Non Square Terrains (EXPERIMENTAL)</b></color>\n\nIf this is enabled, you can create terrains and landscapes " +
                    "with a different width and length. NOTE: Some feature of LB like Stencils will not be available. Heightmap and detail pixels will be non-square.", labelsmallFieldRichText);
                GUILayout.EndHorizontal();
                #endregion

                //EditorGUILayout.Space();
                GUILayout.BeginHorizontal(helpBoxRichText);
                EditorGUI.BeginChangeCheck();
                isLegacyNoiseOffsetEnabled = EditorGUILayout.Toggle(isLegacyNoiseOffsetEnabled, GUILayout.Width(15f));
                if (EditorGUI.EndChangeCheck())
                {
                    LBLandscape.SetIsLegacyNoiseOffsetEnabled(isLegacyNoiseOffsetEnabled);
                    isSceneSaveRequired = true;
                }
                EditorGUILayout.LabelField("<color=" + txtColourName + "><b>Legacy Noise Offset</b></color>\n\nFor backward compatibility with landscapes created prior to version 1.4.2.", labelsmallFieldRichText);
                GUILayout.EndHorizontal();
                #endregion

                #region Advanced Clean Up Undo Files
                //EditorGUILayout.Space();
                EditorGUILayout.LabelField("<color=" + txtColourName + "><b>Undo Cleanup</b></color>\n\nLandscape Builder creates undo files outside of the Assets folder, which" +
                                           " don't get deleted when Unity is closed and take up disk space. You can use the Clean Up Undo Files" +
                                           " button to delete these undo files", helpBoxRichText);

 
                if (GUILayout.Button("Clean Up Undo Files"))
                {
                    LBLandscape.PerformUndoCleanup(0, true);
                }
                #endregion

                #region Position MainCamera to Scene View
                EditorGUILayout.Space();
                EditorGUILayout.LabelField("<color=" + txtColourName + "><b>Position Main Camera</b></color>\n\nSets the camera in the scene with the MainCamera Tag to the same" +
                               " viewable rectange as the Scene view in the Unity Editor.", helpBoxRichText);

                if (GUILayout.Button("Position MainCamera to Scene View"))
                {
                    try
                    {
                        editorCamera = UnityEditor.SceneView.lastActiveSceneView.camera;
                        GameObject mainCameraGO = GameObject.FindGameObjectWithTag("MainCamera");
                        if (mainCameraGO != null)
                        {
                            Camera mainCamera = mainCameraGO.GetComponent<Camera>();
                            if (mainCamera != null && editorCamera != null)
                            {
                                mainCamera.fieldOfView = editorCamera.fieldOfView;

                                //Debug.Log("[DEBUG] main y:" + mainCamera.rect.y + " h:" + mainCamera.rect.height + " editorCamera y:" + editorCamera.rect.y + " h: " + editorCamera.rect.height );
                                
                                // LB 2.10 Beta 3o - don't change the viewport of main camera as it will sometimes be slightly wrong
                                //mainCamera.rect = editorCamera.rect;

                                Transform tfmToMove = mainCamera.transform;
                                Quaternion tfrmRotation = editorCamera.transform.rotation;

                                // Check to see if this is a First or Third Person Controller with a parent GameObject
                                Transform parentCameraTfm = mainCameraGO.transform.parent;
                                if (parentCameraTfm != null)
                                {
                                    // Get a list of all the attached components (and scripts)
                                    Component[] components = parentCameraTfm.GetComponents(typeof(Component));

                                    if (components != null)
                                    {
                                        // Copy the array into a List so we can do a search
                                        List<Component> componentList = new List<Component>(components);

                                        // if any of the scripts have a name containing the word "Person" then assume it is
                                        // a first or third person controller
                                        if (componentList.FindIndex(c => c.GetType().Name.Contains("Person")) >= 0)
                                        {
                                            // Move the parent rather than the child which contains the camera.
                                            tfmToMove = parentCameraTfm;
                                            tfrmRotation.x = 0f;
                                            tfrmRotation.z = 0f;
                                        }
                                    }
                                }

                                tfmToMove.position = editorCamera.transform.position;
                                tfmToMove.rotation = tfrmRotation;
                            }
                        }
                        else { Debug.LogWarning("Couldn't find MainCamera in scene. Is the Tag set to MainCamera on the camera gameobject?"); }
                    }
                    catch (Exception ex)
                    {
                        Debug.LogError("Couldn't set MainCamera. Is Scene tab selected?\n" + ex.Message);
                    }
                }
                #endregion

                // Stitching Tool
                #region StitchTool
                EditorGUILayout.Space();
                EditorGUILayout.LabelField("<color=" + txtColourName + "><b>Stitching Tool</b></color>\n\nStitch two adjoining landscape's terrain topographies seamlessly. " +
                                           "It adjusts the height along the borders of the adjoining landscapes which have the same dimensions and terrain settings.", helpBoxRichText);

                GUILayout.BeginVertical(EditorStyles.helpBox);

                // By default use the current landscape for the first one
                if (stitchLandscape1 == null && landscape != null)
                {
                    stitchLandscape1 = landscape;
                }

                stitchLandscape1 = (LBLandscape)EditorGUILayout.ObjectField("Landscape 1", stitchLandscape1, typeof(LBLandscape), true);
                stitchLandscape2 = (LBLandscape)EditorGUILayout.ObjectField("Landscape 2", stitchLandscape2, typeof(LBLandscape), true);
                stitchEdgeDistance = EditorGUILayout.IntSlider(new GUIContent("Edge Distance", "The distance from the edges of the landscapes, in metres, that stitching will begin"), stitchEdgeDistance, 10, 1000);
                stitchLandscapeWeight = EditorGUILayout.Slider(new GUIContent("Landscape Weight", "The relative weight each landscape has on the stitching process. Values to the left favour Landscape 1, while values to the right favour Landscape 2"), stitchLandscapeWeight, 0f, 1f);
                stitchSetNeighbours = EditorGUILayout.Toggle(new GUIContent("Set Neighbours", "Set the connections between neighbouring terrains to ensure LOD matches"), stitchSetNeighbours);

                if (stitchLandscape1 != null || stitchLandscape2 != null)
                {
                    GUILayout.Label("Reset Neighbours");
                    GUILayout.BeginHorizontal();
                    if (stitchLandscape1 != null)
                    {
                        if (GUILayout.Button("Landscape 1", GUILayout.MaxWidth(100f)))
                        {
                            // We need to flush each terrain so that the sceneview is updated in the editor
                            stitchLandscape1.SetTerrainNeighbours(true);

                            if (!Application.isPlaying)
                            {
                                if (autoSaveEnabled) { sceneSaved = EditorSceneManager.SaveScene(EditorSceneManager.GetActiveScene()); }
                                else { EditorSceneManager.MarkSceneDirty(EditorSceneManager.GetActiveScene()); }
                                SceneView.lastActiveSceneView.Repaint();
                            }
                        }
                    }
                    if (stitchLandscape2 != null)
                    {
                        if (GUILayout.Button("Landscape 2", GUILayout.MaxWidth(100f)))
                        {
                            // We need to flush each terrain so that the sceneview is updated is updated in the editor
                            stitchLandscape2.SetTerrainNeighbours(true);
                            if (!Application.isPlaying)
                            {
                                if (autoSaveEnabled) { sceneSaved = EditorSceneManager.SaveScene(EditorSceneManager.GetActiveScene()); }
                                else { EditorSceneManager.MarkSceneDirty(EditorSceneManager.GetActiveScene()); }
                                SceneView.lastActiveSceneView.Repaint();
                            }
                        }
                    }

                    GUILayout.EndHorizontal();
                }

                GUILayout.EndVertical();

                if (stitchLandscape1 != null && stitchLandscape2 != null)
                {
                    if (GUILayout.Button("Stitch Landscapes Together"))
                    {
                        EditorUtility.DisplayProgressBar("Backing up heightmaps", "Please Wait", 0.2f);

                        stitchLandscape1.SaveData(LBLandscape.UndoType.HeightMap);
                        stitchLandscape2.SaveData(LBLandscape.UndoType.HeightMap);

                        EditorUtility.ClearProgressBar();

                        EditorUtility.DisplayProgressBar("Stitching Landscapes", "Please Wait", 0.3f);

                        bool isSuccessful = LBLandscapeTerrain.StitchLandscapes(stitchLandscape1, stitchLandscape2, stitchEdgeDistance, stitchLandscapeWeight, stitchSetNeighbours);

                        if (isSuccessful)
                        {
                            if (autoSaveEnabled) { sceneSaved = EditorSceneManager.SaveScene(EditorSceneManager.GetActiveScene()); }
                            else { EditorSceneManager.MarkSceneDirty(EditorSceneManager.GetActiveScene()); }
                            EditorUtility.ClearProgressBar();
                        }
                        else
                        {
                            EditorUtility.ClearProgressBar();
                            EditorUtility.DisplayProgressBar("Stitch failed. Rolling back changes", "Please Wait", 0.8f);
                            stitchLandscape1.RevertToLastSave(LBLandscape.UndoType.HeightMap);
                            stitchLandscape2.RevertToLastSave(LBLandscape.UndoType.HeightMap);
                            EditorUtility.ClearProgressBar();
                        }
                    }

                    if (GUILayout.Button("Undo Landscape Stitching"))
                    {
                        EditorUtility.DisplayProgressBar("Undo Landscape Stitching", "Please Wait", 0.5f);
                        stitchLandscape1.RevertToLastSave(LBLandscape.UndoType.HeightMap);
                        stitchLandscape2.RevertToLastSave(LBLandscape.UndoType.HeightMap);
                        EditorUtility.ClearProgressBar();
                    }
                }
                #endregion

                #region Refresh Scene - Fix Known Issues

                EditorGUILayout.Space();
                EditorGUILayout.LabelField("<color=" + txtColourName + "><b>Refresh Scene</b></color>\n\nSometimes items can be left in the scene after errors. This may fix those. If not contact support.", helpBoxRichText);
                GUILayout.BeginVertical(EditorStyles.helpBox);
                if (GUILayout.Button("Refresh Scene", GUILayout.MaxWidth(100f)))
                {
                    if (!isGroupDesignerEnabled)
                    {
                        // GroupBasePlane is left in scene
                        GameObject grpBasePlane = GameObject.Find("GroupBasePlane");
                        if (grpBasePlane != null)
                        {
                            Debug.Log("INFO: LB Refresh Scene - removing old " + grpBasePlane.name);
                            DestroyImmediate(grpBasePlane);
                        }
                    }

                    // TODO - need an efficent, scalable way of finding orphaned meshes.
                    // Can't just get list of all meshes in the scene (as there could be too many)
                    //List<MeshRenderer> meshRenderList = new List<MeshRenderer>();
                    //MeshRenderer[] meshRenders = FindObjectsOfType<MeshRenderer>();
                    //int numRenderers = meshRenders == null ? 0 : meshRenders.Length;

                    //GameObject.FindObjectsOfType<Mesh>().Where(m => m.tran);

                    Debug.Log("INFO: Landscape Builder - Refresh completed successfully");
                }

                GUILayout.EndVertical();

                #endregion

                #region AQUAS Integration
                EditorGUILayout.Space();
                EditorGUILayout.LabelField("<color=" + txtColourName + "><b>AQUAS Integration</b></color>\n\nAdd realistic oceans, lakes and flowing rivers to your landscape." +
                               " ", helpBoxRichText);

                GUILayout.BeginVertical(EditorStyles.helpBox);
                GUILayout.BeginHorizontal();
                EditorGUI.BeginChangeCheck();
                GUILayout.Label(new GUIContent("Flow Map Painter", "The path to the Flow Map Painter exe on your computer"));
                pathFlowMapPainter = EditorGUILayout.TextField(pathFlowMapPainter);
                if (EditorGUI.EndChangeCheck())
                {
                    LBLandscape.SetPath(LBSavedData.PathType.FlowMapPainterExe, pathFlowMapPainter);
                }
                if (GUILayout.Button("..", buttonCompact, GUILayout.MaxWidth(30f)))
                {
#if UNITY_EDITOR_OSX
                    LBEditorHelper.GetFilePathFromUser(LBSavedData.PathType.FlowMapPainterExe, "Assets", "APP", false, ref pathFlowMapPainter, true);
#else
                    LBEditorHelper.GetFilePathFromUser(LBSavedData.PathType.FlowMapPainterExe, "Assets", "EXE", false, ref pathFlowMapPainter, true);
#endif
                }
                GUILayout.EndHorizontal();
                GUILayout.EndVertical();
                #endregion

                // HQ Photographic Textures integration
                #region HQ Photographic Integration
                EditorGUILayout.Space();
                EditorGUILayout.LabelField("<color=" + txtColourName + "><b>HQ Photographic Textures Integration</b></color>\n\nThese packs add realistic grass to your landscape." +
                               " ", helpBoxRichText);

                GUILayout.BeginVertical(EditorStyles.helpBox);

                GUILayout.BeginHorizontal();
                EditorGUI.BeginChangeCheck();
                GUILayout.Label(new GUIContent("Vol 1", "The relative path in the project to the HQ Photographic Textures Pack Vol. 1"), GUILayout.Width(45f));
                pathHQPhotoPackVol1 = EditorGUILayout.TextField(pathHQPhotoPackVol1);
                if (EditorGUI.EndChangeCheck())
                {
                    LBLandscape.SetPath(LBSavedData.PathType.HQPhotographicTexturesVol1, pathHQPhotoPackVol1);
                }
                if (GUILayout.Button("..", buttonCompact, GUILayout.MaxWidth(30f)))
                {
                    LBEditorHelper.GetPathFromUser(LBSavedData.PathType.HQPhotographicTexturesVol1, "Assets", ref pathHQPhotoPackVol1, true);
                }
                GUILayout.EndHorizontal();

                GUILayout.BeginHorizontal();
                EditorGUI.BeginChangeCheck();
                GUILayout.Label(new GUIContent("Vol 2", "The relative path in the project to the HQ Photographic Textures Pack Vol. 2"), GUILayout.Width(45f));
                pathHQPhotoPackVol2 = EditorGUILayout.TextField(pathHQPhotoPackVol2);
                if (EditorGUI.EndChangeCheck())
                {
                    LBLandscape.SetPath(LBSavedData.PathType.HQPhotographicTexturesVol2, pathHQPhotoPackVol2);
                }
                if (GUILayout.Button("..", buttonCompact, GUILayout.MaxWidth(30f)))
                {
                    LBEditorHelper.GetPathFromUser(LBSavedData.PathType.HQPhotographicTexturesVol2, "Assets", ref pathHQPhotoPackVol2, true);
                }
                GUILayout.EndHorizontal();

                GUILayout.BeginHorizontal();
                EditorGUI.BeginChangeCheck();
                GUILayout.Label(new GUIContent("Rustic", "The relative path in the project to the Rustic Grass pack"), GUILayout.Width(45f));
                pathRusticGrass = EditorGUILayout.TextField(pathRusticGrass);
                if (EditorGUI.EndChangeCheck())
                {
                    LBLandscape.SetPath(LBSavedData.PathType.RusticGrass, pathRusticGrass);
                }
                if (GUILayout.Button("..", buttonCompact, GUILayout.MaxWidth(30f)))
                {
                    LBEditorHelper.GetPathFromUser(LBSavedData.PathType.RusticGrass, "Assets", ref pathRusticGrass, true);
                }
                GUILayout.EndHorizontal();

                GUILayout.BeginHorizontal();
                if (GUILayout.Button("Get Support", buttonCompact)) { Application.OpenURL("http://forum.unity3d.com/threads/395638"); }
                if (isHQPhotoPackVol1Installed) { labelText2 = "Vol.1 Asset"; } else { labelText2 = "Get HQ Vol. 1"; }
                if (GUILayout.Button(labelText2, buttonCompact)) { Application.OpenURL("https://www.assetstore.unity3d.com/en/#!/content/32656"); }
                if (isHQPhotoPackVol2Installed) { labelText2 = "Vol.2 Asset"; } else { labelText2 = "Get HQ Vol. 2"; }
                if (GUILayout.Button(labelText2, buttonCompact)) { Application.OpenURL("https://www.assetstore.unity3d.com/en/#!/content/37585"); }
                if (isRusticGrassInstalled) { labelText2 = "Rustic Asset"; } else { labelText2 = "Get Rustic"; }
                if (GUILayout.Button(labelText2, buttonCompact)) { Application.OpenURL("https://www.assetstore.unity3d.com/en/#!/content/76317"); }
                EditorGUILayout.EndHorizontal();

                GUILayout.EndVertical();
                #endregion

                #region MegaSplat Integration

                EditorGUILayout.Space();
                EditorGUILayout.LabelField("<color=" + txtColourName + "><b>MegaSplat Integration</b></color> " + megaSplatVersion + "\n\nAllows you to use up to 256 textures on your terrains.", helpBoxRichText);

                if (landscape != null && landscapeGameObject != null && isMegaSplatInstalled)
                {
                    GUILayout.BeginVertical(EditorStyles.helpBox);

                    EditorGUI.BeginChangeCheck();
                    megaSplatAutoClosePainter = EditorGUILayout.Toggle(new GUIContent("Auto Close Painter", "Automatically Close the Terrain Painter after use"), megaSplatAutoClosePainter);

                    if (EditorGUI.EndChangeCheck())
                    {
                        LBLandscape.SetMegaSplatAutoClosePainter(megaSplatAutoClosePainter);
                        isSceneSaveRequired = true;
                    }
                }
                else
                {
                    EditorGUILayout.HelpBox("To integrate with MegaSplat, install MegaSplat 1.14+ in your project and select a landscape to edit.", MessageType.Info, true);
                    GUILayout.BeginVertical(EditorStyles.helpBox);
                }
                GUILayout.BeginHorizontal();
                if (GUILayout.Button("Get Support", buttonCompact)) { Application.OpenURL("http://forum.unity3d.com/threads/441329"); }
                if (GUILayout.Button("Videos", buttonCompact)) { Application.OpenURL("https://www.youtube.com/user/slipster216"); }
                if (isMegaSplatInstalled) { labelText2 = "MegaSplat Asset"; } else { labelText2 = "Get MegaSplat"; }
                if (GUILayout.Button(labelText2, buttonCompact)) { Application.OpenURL("https://www.assetstore.unity3d.com/en/#!/content/76166"); }
                if (GUILayout.Button("Web Site", buttonCompact)) { Application.OpenURL("http://www.megasplat.com"); }
                EditorGUILayout.EndHorizontal();

                GUILayout.EndVertical();
                EditorGUILayout.Space();

                #endregion

                #region Vegetation Studio Integration

                EditorGUILayout.Space();
                EditorGUILayout.LabelField("<color=" + txtColourName + "><b>Vegetation Studio Integration</b></color>\n\nVegetation rendering and placement system. To enable it, go to Landscape tab, and Terrain Settings.", helpBoxRichText);

                GUILayout.BeginHorizontal();
                if (GUILayout.Button("Get Support", buttonCompact)) { Application.OpenURL("http://forum.unity3d.com/threads/479244"); }
#if VEGETATION_STUDIO
                labelText2 = "VegStud Asset";
#else
                labelText2 = "Get Veg Studio";
#endif
                if (GUILayout.Button(labelText2, buttonCompact)) { Application.OpenURL("https://assetstore.unity.com/packages/tools/terrain/vegetation-studio-103389"); }
                if (GUILayout.Button("Web Site", buttonCompact)) { Application.OpenURL("https://www.awesometech.no/"); }
                EditorGUILayout.EndHorizontal();


#if VEGETATION_STUDIO
                if (landscape != null && landscapeGameObject != null)
                {
                    EditorGUILayout.HelpBox("To specify a particular camera to use, add it to the list. Each camera will get its own vegetation system for each terrain.", MessageType.Info, true);

                    GUILayout.BeginVertical(EditorStyles.helpBox);

                    // Vegetation Studio may have been imported after the landscape was created.
                    if (landscape.vegetationStudioCameraList == null) { landscape.vegetationStudioCameraList = new List<Camera>(); }

#region Add/Remove Cameras
                    EditorGUILayout.BeginHorizontal();
                    if (GUILayout.Button("Get Cameras", GUILayout.MaxWidth(100f)))
                    {
                        landscape.RefreshCameraList(landscape.vegetationStudioCameraList);
                        isSceneSaveRequired = true;
                    }
                    if (GUILayout.Button("+", GUILayout.Width(25f)))
                    {
                        landscape.vegetationStudioCameraList.Add(null);
                        isSceneSaveRequired = true;
                    }

                    if (GUILayout.Button("-", GUILayout.Width(25f)))
                    {
                        if (landscape.vegetationStudioCameraList.Count > 0)
                        {
                            landscape.vegetationStudioCameraList.RemoveAt(landscape.vegetationStudioCameraList.Count - 1);
                            isSceneSaveRequired = true;
                        }
                    }
                    EditorGUILayout.EndHorizontal();
#endregion

#region Display Vegetation Studio cameras

                    cameraToRemove = null;
                    for (int cmIdx = 0; cmIdx < landscape.vegetationStudioCameraList.Count; cmIdx++)
                    {
                        EditorGUILayout.BeginHorizontal();
                        if (GUILayout.Button("X", buttonCompact, GUILayout.MaxWidth(20f))) { cameraToRemove = landscape.vegetationStudioCameraList[cmIdx]; }
                        landscape.vegetationStudioCameraList[cmIdx] = (Camera)EditorGUILayout.ObjectField(landscape.vegetationStudioCameraList[cmIdx], typeof(Camera), true);
                        EditorGUILayout.EndHorizontal();
                    }

                    // Does the user wish to remove a camera from the list?
                    if (cameraToRemove != null)
                    {
                        landscape.vegetationStudioCameraList.Remove(cameraToRemove);
                        isSceneSaveRequired = true;
                    }

#endregion

                    GUILayout.EndVertical();
                }

#endif

                #endregion

                // uNature Integration removed in LB 2.0.6

                // Add some extra space below uNature so that tooltips can be read okay.
                GUILayout.Space(15);

                EditorGUILayout.EndScrollView();

                #endregion
            } // End of Advanced Tab

            #region SaveScene or make dirty (so it needs to be saved)
            if (!EditorApplication.isPlayingOrWillChangePlaymode)
            {
                if (isSceneSaveRequired)
                {
                    isSceneSaveRequired = false;
                    isSceneDirtyRequired = false;
                    if (autoSaveEnabled)
                    {
                        sceneSaved = EditorSceneManager.SaveScene(EditorSceneManager.GetActiveScene());
                    }
                    else
                    {
                        EditorSceneManager.MarkSceneDirty(EditorSceneManager.GetActiveScene());
                    }
                }
                // When Auto Save is enabled, sometimes a full SaveScene is too expensive,
                // so just mark the scene as dirty
                else if (isSceneDirtyRequired)
                {
                    isSceneDirtyRequired = false;
                    EditorSceneManager.MarkSceneDirty(EditorSceneManager.GetActiveScene());
                }
            }
            #endregion

            // Reset at the end of each OnGUI call
            EditorGUIUtility.labelWidth = defaultEditorLabelWidth;
            landscapeHasSwitched = false;
            isJustEnabled = false;

            // Set repaint to true at the end of every OnGUI call
            allowRepaint = true;
        }

        #region ApplyGroups

        /// <summary>
        /// Apply the LBGroups to the current landscape. This method also regenerates the 
        /// topography first if it will affect the terrain heigtmap data.
        /// NOTE: When updating, also update LBLandscape.ApplyGroups() if required
        /// </summary>
        private void ApplyGroups()
        {
            if (landscape == null) { Debug.LogWarning("ERROR: LB Editor ApplyGroups - landscape is not defined. Please Report"); }
            else if (EditorApplication.isPlayingOrWillChangePlaymode) { return; }
            else
            {
                // Do we need to apply topography first?
                bool isTopographyUpdateRequired = false;

                // Are there any active Groups?
                List<LBGroup> activeGroupList = LBGroup.GetActiveGroupList(landscape.lbGroupList);

                // Are there any active Topography Layers?
                // NOTE: For ObjPath flattening, heightmaps will not be regenerated if there are no active Topography Layers.
                // This can result in the path surround blending adding to the last iteration of the path.
                if (landscape.topographyLayersList.Exists(lyr => lyr.isDisabled == false))
                {
                    if (activeGroupList != null && activeGroupList.Count > 0)
                    {
                        // Are there any Clearing Groups with flatten terrain?
                        if (activeGroupList.Exists(agp => (agp.lbGroupType == LBGroup.LBGroupType.ProceduralClearing || agp.lbGroupType == LBGroup.LBGroupType.ManualClearing) &&
                                                           agp.isTerrainFlattened)) { isTopographyUpdateRequired = true; }
                        else
                        {
                            LBGroup lbGroup = null;
                            // Are their any Uniform groups that will flatten the terrain under a prefab or flatten the terrain under an object path?
                            for (int grpIdx = 0; grpIdx < activeGroupList.Count; grpIdx++)
                            {
                                lbGroup = activeGroupList[grpIdx];
                                if (lbGroup.groupMemberList.Exists(mbr => mbr.isTerrainFlattened == true))
                                {
                                    //Debug.Log("[DEBUG] Generate Topography required...");
                                    isTopographyUpdateRequired = true; break;
                                }
                            }
                        }

                        if (isTopographyUpdateRequired) { GenerateTopography(); }
                    }
                }

                // Do we need to first apply Textures from the Texturing tab?
                if (LBGroup.IsApplyTexturesPresent(activeGroupList) || LBGroup.IsApplyObjPathTexturesPresent(activeGroupList))
                {
                    TextureLandscape();
                }

                // Do we need to first apply Trees from the Trees tab?
                // Will the Groups modify any Unity terrain trees in the scene?
                if (LBGroup.IsModifyTrees(activeGroupList))
                {
                    ApplyTrees();
                }

                // Will Groups modify any Unity terrain grass in the scene?
                if (LBGroup.IsRemoveGrassPresent(activeGroupList) || LBGroup.IsPopulateGrassPresent(activeGroupList))
                {
                    ApplyGrass();
                }

                float generationStartTime = Time.realtimeSinceStartup;

                // Backup Textures, Trees, Grass, and Heightmaps before applying groups
                // Show progress as this is in the editor
                landscape.ApplyGroups(true, true);

                if (landscape.showTiming)
                {
                    Debug.Log("Time taken to place groups: " + (Time.realtimeSinceStartup - generationStartTime).ToString("00.00") + " seconds. Prefabs created: " + landscape.numberOfGroupPrefabs + " (does not include any time that may be required to first regenerate the topography)");
                }

                isSceneSaveRequired = true;

            }
        }

        #endregion

        #region ApplyMeshes

        /// <summary>
        /// Apply the meshes (or prefabs) to the current landscape
        /// NOTE: When updating, also update LBLandscape.ApplyMeshes()
        /// </summary>
        private void ApplyMeshes()
        {
            if (landscape == null || EditorApplication.isPlayingOrWillChangePlaymode) { return; }

            int mshIdx = 0;
            float generationStartTime = Time.realtimeSinceStartup;

            // Turn off the showArea indicator in any filters to prevent layout errors
            foreach (LBLandscapeMesh lbLandscapeMesh in landscapeMeshList)
            {
                if (lbLandscapeMesh.filterList != null)
                {
                    foreach (LBFilter lbFilter in lbLandscapeMesh.filterList)
                    {
                        lbFilter.showAreaHighlighter = false;
                    }
                }
            }

            bool hasInvalidTexture = false;
            // Validate any meshes that use the Map constraint have valid readable texture maps
            for (mshIdx = 0; mshIdx < landscapeMeshList.Count; mshIdx++)
            {
                if (landscapeMeshList[mshIdx].meshPlacingMode == LBLandscapeMesh.MeshPlacingMode.Map ||
                    landscapeMeshList[mshIdx].meshPlacingMode == LBLandscapeMesh.MeshPlacingMode.HeightInclinationMap)
                {
                    if (landscapeMeshList[mshIdx].map != null)
                    {
                        hasInvalidTexture = !LBTextureOperations.IsTextureReadable(landscapeMeshList[mshIdx].map, true);
                        if (hasInvalidTexture) { break; }
                    }
                }
            }

            if (!hasInvalidTexture)
            {
                EditorUtility.DisplayProgressBar("Backing up heightmap, trees and grass for mesh placement", "Please Wait", 0.5f);

                landscapeTerrains = landscapeGameObject.GetComponentsInChildren<Terrain>();

                landscape.SaveData(LBLandscape.UndoType.Trees);
                landscape.SaveData(LBLandscape.UndoType.Grass);
                landscape.SaveData(LBLandscape.UndoType.HeightMap);

                //List<Light> sceneLights = LBLighting.GetLightList(true);
                //List<Light> previousLights = new List<Light>(sceneLights);
                //if (sceneLights != null)
                //{
                //    if (Lightmapping.isRunning) { Lightmapping.Cancel(); }

                //    // While meshes are created, set all lights to Baked
                //    LBLighting.SetLightBakeMode(sceneLights, LBLighting.LightBakingMode.Baked);
                //}

                // Delete all mesh prefab parent gameobjects from the landscape
                // These gameobjects contain all previously placed prefabs
                LBLandscapeTerrain.RemoveExistingPrefabs(landscape, true, LBPrefabItem.PrefabItemType.LegacyMeshPrefab, null);

                // Reset the counts (no undo on these)
                landscape.numberOfMeshes = 0;
                landscape.numberOfMeshPrefabs = 0;

                EditorUtility.ClearProgressBar();
                EditorUtility.DisplayProgressBar("Populating Landscape With Meshes", "Please Wait", 0.1f);

                //float generationStartTime = Time.realtimeSinceStartup;
                for (mshIdx = 0; mshIdx < landscapeTerrains.Length; mshIdx++)
                {
                    landscapeTerrains[mshIdx].terrainData = LBLandscapeTerrain.PopulateTerrainWithMeshes(landscape, landscapeTerrains[mshIdx].terrainData, landscapeTerrains[mshIdx].transform,
                                                                                                        landscapeGameObject.transform, landscapeMeshList, landscapeTerrains[mshIdx].transform.position,
                                                                                                        landscape.size, landscape.transform.position, landscape.showTiming, landscapeTerrains[mshIdx].name);

                    if (mshIdx == 0) { EditorUtility.ClearProgressBar(); }
                    if (EditorUtility.DisplayCancelableProgressBar("Populating Landscape With Meshes", "Editing " + (mshIdx + 1).ToString() + " of " + landscapeTerrains.Length.ToString() + " terrains",
                                                                   (float)mshIdx / (float)landscapeTerrains.Length))
                    {
                        // If the user cancels the process, revert to the last save
                        landscape.RevertToLastSave(LBLandscape.UndoType.HeightMap);
                        landscape.RevertToLastSave(LBLandscape.UndoType.Trees);
                        landscape.RevertToLastSave(LBLandscape.UndoType.Grass);
                        break;
                    }
                }

                // We need to update the terrain LOD and vegetation information
                LBLandscapeTerrain.ApplyDelayedHeightmapLOD(landscapeTerrains);

                // If Stencil Layer Filters where used, free up any extra memory allocated
                LBStencil.FreeStencilResources(landscape, true);

                landscape.UpdateTerrainColliders();

                EditorUtility.ClearProgressBar();

                LBLandscapeMeshController lmc = landscapeGameObject.GetComponent<LBLandscapeMeshController>();
                if (lmc == null) { lmc = landscapeGameObject.AddComponent<LBLandscapeMeshController>(); }
                lmc.RemoveExistingCombinedMeshes("LB Combined Mesh");
                if (!lmc.BuildCombinedMeshes(landscapeMeshList))
                {
                    // If no combined meshes were created we don't need the MeshController component
                    DestroyImmediate(lmc);
                }

                if (landscape.showTiming)
                {
                    Debug.Log("Time taken to place meshes: " + (Time.realtimeSinceStartup - generationStartTime).ToString("00.00") + " seconds.");
                }

                isSceneSaveRequired = true;
            }
        }

        #endregion

        #region ApplyGrass

        /// <summary>
        /// Apply the grass to the current landscape
        /// NOTE: When updating, also update LBLandscape.ApplyGrass()
        /// </summary>
        private void ApplyGrass()
        {
            if (landscape == null || EditorApplication.isPlayingOrWillChangePlaymode) { return; }

            int grassIdx = 0;

            // Turn off the showArea indicator in any filters to prevent layout errors
            foreach (LBTerrainGrass lbTerrainGrass in terrainGrassList)
            {
                if (lbTerrainGrass.filterList != null)
                {
                    foreach (LBFilter lbFilter in lbTerrainGrass.filterList)
                    {
                        lbFilter.showAreaHighlighter = false;
                    }
                }
            }

            bool hasInvalidTexture = false;
            // Validate any grass that use the Map constraint have valid readable texture maps
            for (grassIdx = 0; grassIdx < terrainGrassList.Count; grassIdx++)
            {
                if (terrainGrassList[grassIdx].grassPlacingMode == LBTerrainGrass.GrassPlacingMode.Map ||
                    terrainGrassList[grassIdx].grassPlacingMode == LBTerrainGrass.GrassPlacingMode.HeightInclinationMap)
                {
                    if (terrainGrassList[grassIdx].map != null)
                    {
                        hasInvalidTexture = !LBTextureOperations.IsTextureReadable(terrainGrassList[grassIdx].map, true);
                        if (hasInvalidTexture) { break; }
                    }
                }
            }

            if (!hasInvalidTexture)
            {
                EditorUtility.DisplayProgressBar("Backing up grass", "Please Wait", 0.5f);

                landscapeTerrains = landscapeGameObject.GetComponentsInChildren<Terrain>();

                landscape.SaveData(LBLandscape.UndoType.Grass);

                EditorUtility.ClearProgressBar();

                float generationStartTime = Time.realtimeSinceStartup;
                for (grassIdx = 0; grassIdx < landscapeTerrains.Length; grassIdx++)
                {
                    landscapeTerrains[grassIdx].terrainData = LBLandscapeTerrain.PopulateTerrainWithGrass(landscapeTerrains[grassIdx].terrainData, terrainGrassList, landscapeTerrains[grassIdx].transform.position, landscape.size, landscape.transform.position, landscape.showTiming, landscape);
                    if (EditorUtility.DisplayCancelableProgressBar("Populating Landscape With Grass", "Editing " + (grassIdx + 1).ToString() + " of " + landscapeTerrains.Length.ToString() + " terrains",
                                                     (float)grassIdx / (float)landscapeTerrains.Length))
                    {
                        // If the user cancels the process, revert to the last save
                        landscape.RevertToLastSave(LBLandscape.UndoType.Grass);
                        break;
                    }
                }

                // If Stencil Layer Filters where used, free up any extra memory allocated
                LBStencil.FreeStencilResources(landscape, true);

                landscape.UpdateTerrainColliders();
                RefreshAppliedGrassList();

                #if VEGETATION_STUDIO
                if (landscape.useVegetationSystem)
                {
                    EditorUtility.ClearProgressBar();
                    EditorUtility.DisplayProgressBar("Updating Vegetation Studio Grass data", "Please Wait", 0.9f);
                    LBIntegration.VegetationStudioImportGrass(landscape, true);
                }
                #elif VEGETATION_STUDIO_PRO
                if (landscape.useVegetationSystem)
                {
                    EditorUtility.ClearProgressBar();
                    EditorUtility.DisplayProgressBar("Updating Vegetation Studio Pro Grass data", "Please Wait", 0.9f);
                    LBIntegration.VegetationStudioProImportGrass(landscape, true);
                }
                #endif

                EditorUtility.ClearProgressBar();

                if (landscape.showTiming)
                {
                    Debug.Log("Time taken to place grass: " + (Time.realtimeSinceStartup - generationStartTime).ToString("00.00") + " seconds.");
                }

                isSceneSaveRequired = true;
            }
        }

        #endregion

        #region ApplyTrees

        /// <summary>
        /// Build the trees in the current landscape
        /// NOTE: When updating, also update LBLandscape.ApplyTrees()
        /// </summary>
        private void ApplyTrees()
        {
            if (landscape == null || EditorApplication.isPlayingOrWillChangePlaymode) { return; }

            // Check that a texture and tree list exists. This may NOT be the case if this is a new
            // landscape, the tree tab hasn't been visited, and ApplyGroups() is called.
            if (terrainTreesList == null) { terrainTreesList = new List<LBTerrainTree>(); }

            int treeIdx = 0;

            // Turn off the showArea indicator in any filters to prevent layout errors
            foreach (LBTerrainTree lbTerrainTree in terrainTreesList)
            {
                if (lbTerrainTree.filterList != null)
                {
                    foreach (LBFilter lbFilter in lbTerrainTree.filterList)
                    {
                        lbFilter.showAreaHighlighter = false;
                    }
                }
            }

            bool hasInvalidTexture = false;
            // Validate any trees that use the Map constraint have valid readable texture maps
            for (treeIdx = 0; treeIdx < terrainTreesList.Count; treeIdx++)
            {
                if (terrainTreesList[treeIdx].treePlacingMode == LBTerrainTree.TreePlacingMode.Map ||
                    terrainTreesList[treeIdx].treePlacingMode == LBTerrainTree.TreePlacingMode.HeightInclinationMap)
                {
                    if (terrainTreesList[treeIdx].map != null)
                    {
                        hasInvalidTexture = !LBTextureOperations.IsTextureReadable(terrainTreesList[treeIdx].map, true);
                        if (hasInvalidTexture) { break; }
                    }
                }
            }

            if (!hasInvalidTexture)
            {
                EditorUtility.DisplayProgressBar("Backing up trees", "Please Wait", 0.5f);

                landscapeTerrains = landscapeGameObject.GetComponentsInChildren<Terrain>();

                landscape.SaveData(LBLandscape.UndoType.Trees);

                EditorUtility.ClearProgressBar();
                float generationStartTime = Time.realtimeSinceStartup;
                for (treeIdx = 0; treeIdx < landscapeTerrains.Length; treeIdx++)
                {
                    if (EditorUtility.DisplayCancelableProgressBar("Populating Landscape With Trees", "Editing " + (treeIdx + 1).ToString() + " of " + landscapeTerrains.Length.ToString() + " terrains",
                                                     (float)treeIdx / (float)landscapeTerrains.Length))
                    {
                        // If the user cancels the process, revert to the last save
                        landscape.RevertToLastSave(LBLandscape.UndoType.Trees);
                        break;
                    }
                    landscapeTerrains[treeIdx].terrainData = LBLandscapeTerrain.PopulateTerrainWithTrees(landscapeTerrains[treeIdx].terrainData, terrainTreesList, landscape.maxTreesPerSquareKilometre, landscapeTerrains[treeIdx].transform.position, landscape.size, landscape.transform.position, landscape.treePlacementSpeed, landscape.showTiming, landscape);
                }

                // If Stencil Layer Filters where used, free up any extra memory allocated
                LBStencil.FreeStencilResources(landscape, true);

                landscape.UpdateTerrainColliders();

#if VEGETATION_STUDIO
                if (landscape.useVegetationSystem)
                {
                    EditorUtility.ClearProgressBar();
                    EditorUtility.DisplayProgressBar("Updating Vegetation Studio Tree data", "Please Wait", 0.9f);
                    LBIntegration.VegetationStudioImportTrees(landscape, true);
                }
#elif VEGETATION_STUDIO_PRO
                if (landscape.useVegetationSystem)
                {
                    EditorUtility.ClearProgressBar();
                    EditorUtility.DisplayProgressBar("Updating Vegetation Studio Pro Tree data", "Please Wait", 0.9f);
                    LBIntegration.VegetationStudioProImportTrees(landscape, true);
                }
#endif

                if (landscape.showTiming)
                {
                    Debug.Log("Time taken to place trees: " + (Time.realtimeSinceStartup - generationStartTime).ToString("00.00") + " seconds.");
                }

                EditorUtility.ClearProgressBar();

                isSceneSaveRequired = true;
            }
        }

        #endregion

        #region TextureLandscape

        /// <summary>
        /// Apply the textures to the current landscape
        /// NOTE: When updating, also update LBLandscape.ApplyTextures()
        /// </summary>
        private void TextureLandscape()
        {
            if (landscape == null || EditorApplication.isPlayingOrWillChangePlaymode) { return; }

            int txtIdx = 0;

            bool hasInvalidTexture = false;
            EditorUtility.DisplayProgressBar("Validating", "Please Wait", 0.1f);
            // Validate any Textures that use the Map constraint have valid readable texture maps
            for (txtIdx = 0; txtIdx < terrainTexturesList.Count; txtIdx++)
            {
                if (terrainTexturesList[txtIdx].texturingMode == LBTerrainTexture.TexturingMode.Map ||
                    terrainTexturesList[txtIdx].texturingMode == LBTerrainTexture.TexturingMode.HeightInclinationMap)
                {
                    if (terrainTexturesList[txtIdx].map != null)
                    {
                        hasInvalidTexture = !LBTextureOperations.IsTextureReadable(terrainTexturesList[txtIdx].map, true);
                        if (hasInvalidTexture) { break; }
                    }
                }
            }

            // Validate (and fix) any normal map textures that are not set to NormalMap
            if (!hasInvalidTexture)
            {
                for (txtIdx = 0; txtIdx < terrainTexturesList.Count; txtIdx++)
                {
                    if (terrainTexturesList[txtIdx].normalMap != null)
                    {
                        hasInvalidTexture = !LBTextureOperations.IsNormalMap(terrainTexturesList[txtIdx].normalMap, true, true) || hasInvalidTexture;
                    }
                }
            }

            // Validate (and fix) any height map textures that don't appear to be setup as heightmaps
            if (!hasInvalidTexture)
            {
                for (txtIdx = 0; txtIdx < terrainTexturesList.Count; txtIdx++)
                {
                    if (terrainTexturesList[txtIdx].heightMap != null)
                    {
                        hasInvalidTexture = !LBTextureOperations.IsHeightMap(terrainTexturesList[txtIdx].heightMap, true, true) || hasInvalidTexture;
                    }
                }
            }

            EditorUtility.ClearProgressBar();

            if (!hasInvalidTexture)
            {
                EditorUtility.DisplayProgressBar("Backing up textures", "Please Wait", 0.1f);

                landscape.SetLandscapeTerrains(true);
                landscapeTerrains = landscape.landscapeTerrains;
                landscape.SaveData(LBLandscape.UndoType.Textures);

                EditorUtility.ClearProgressBar();

#if UNITY_2018_3_OR_NEWER
                if (landscape.useProjectForTerrainData)
                {
                    EditorUtility.DisplayProgressBar("Updating Terrain Layers in project", "Please Wait", 0.15f);
                    landscape.SetTextureTerrainLayers();
                    EditorUtility.ClearProgressBar();
                }
#endif

                float generationStartTime = Time.realtimeSinceStartup;

                int numTerrains = landscapeTerrains.Length;

                for (txtIdx = 0; txtIdx < numTerrains; txtIdx++)
                {
                    if (txtIdx == 0)
                    {
                        EditorUtility.DisplayProgressBar("Texturing Landscape", "Editing " + (txtIdx + 1).ToString() + " of " + numTerrains.ToString() + " terrains",
                                  (float)(txtIdx + 1) / (float)numTerrains);
                    }

                    landscapeTerrains[txtIdx].terrainData = LBLandscapeTerrain.TextureTerrain(landscapeTerrains[txtIdx].terrainData, terrainTexturesList,
                                                                                             landscapeTerrains[txtIdx].transform.position, landscape.size,
                                                                                             landscape.transform.position, landscape.showTiming, landscape);
                    if (txtIdx == 0) { EditorUtility.ClearProgressBar(); }

                    if (EditorUtility.DisplayCancelableProgressBar("Texturing Landscape", "Editing " + (txtIdx + 1).ToString() + " of " + numTerrains.ToString() + " terrains",
                                                     (float)txtIdx / (float)numTerrains))
                    {
                        // If the user cancels the process, revert to the last save
                        landscape.RevertToLastSave(LBLandscape.UndoType.Textures);
                        break;
                    }
                }

                // If Stencil Layer Filters where used, free up any extra memory allocated
                LBStencil.FreeStencilResources(landscape, true);

                landscape.UpdateTerrainColliders();
                RefreshTerrainTexturesAvailableList();
                RefreshAppliedTexturesList();

#if VEGETATION_STUDIO
                if (landscape.useVegetationSystem)
                {
                    LBIntegration.VegetationStudioImportTextures(landscape, true);
                }
#elif VEGETATION_STUDIO_PRO
                if (landscape.useVegetationSystem)
                {
                    EditorUtility.ClearProgressBar();
                    EditorUtility.DisplayProgressBar("Updating Vegetation Studio Pro Texturing data", "Please Wait", 0.9f);
                    LBIntegration.VegetationStudioProImportTextures(landscape, true);
                }
#endif

#if __MICROSPLAT__
                // Copy the landscape textures over to the MicroSplat TextureArray
                if (terrainMaterialType == LBLandscape.TerrainMaterialType.MicroSplat)
                {
                    LBEditorIntegration.MicroSplatCopyTextures(landscape, terrainMaterialType, terrainCustomMaterial, true);
                }
#endif

                if (terrainMaterialType == LBLandscape.TerrainMaterialType.ReliefTerrainPack)
                {
                    if (LBIntegration.isRTPInstalled(true))
                    {
                        LBIntegration.RTPUpdateTextures(landscape, true);
                    }
                }

                EditorUtility.ClearProgressBar();

                if (landscape.showTiming)
                {
                    Debug.Log("Time taken to texture landscape: " + (Time.realtimeSinceStartup - generationStartTime).ToString("00.00") + " seconds.");
                }

                if (autoSaveEnabled) { sceneSaved = EditorSceneManager.SaveScene(EditorSceneManager.GetActiveScene()); }
                else { EditorSceneManager.MarkSceneDirty(EditorSceneManager.GetActiveScene()); }
            }
        }

        #endregion

        #region Topography and Heightmap

        /// <summary>
        /// Generate the topography for the current landscape
        /// NOTE: When updating, also update LBLandscape.ApplyTopography()
        /// </summary>
        public void GenerateTopography()
        {
            if (landscape == null || EditorApplication.isPlayingOrWillChangePlaymode) { return; }

            int terrainIdx = 0;
            float generationStartTime = Time.realtimeSinceStartup;

            if (landscape.isUndoTopographyDisabled) { EditorUtility.DisplayProgressBar("Initialising", "Please Wait", 0.5f); }
            else { EditorUtility.DisplayProgressBar("Backing up heightmap", "Please Wait", 0.5f); }            
            landscape.SetLandscapeTerrains(true);
            landscapeTerrains = landscape.landscapeTerrains;
            if (!landscape.isUndoTopographyDisabled) { landscape.SaveData(LBLandscape.UndoType.HeightMap); }
            EditorUtility.ClearProgressBar();

            bool InvalidTextures = false;

            // If using images, ensure they are enabled for read/write    
            for (int l = 0; l < topographyLayers.Count; l++)
            {
                if (topographyLayers[l].isDisabled) { continue; }

                if (topographyLayers[l].type == LBLayer.LayerType.ImageBase || topographyLayers[l].type == LBLayer.LayerType.ImageAdditive ||
                    topographyLayers[l].type == LBLayer.LayerType.ImageSubtractive || topographyLayers[l].type == LBLayer.LayerType.ImageDetail)
                {
                    if (l == 0)
                    {
                        EditorUtility.DisplayProgressBar("Validating Heightmap Image Data", "Please Wait", 0.5f);
                    }

                    if (topographyLayers[l].heightmapImage != null)
                    {
                        try { testColour = topographyLayers[l].heightmapImage.GetPixel(0, 0); }
                        catch (UnityException e)
                        {
                            if (e.Message.StartsWith("Texture '" + topographyLayers[l].heightmapImage.name + "' is not readable"))
                            {
                                if (EditorUtility.DisplayDialog("Texure is not readable", "Do you want to fix it now?", "Yes", "No"))
                                {
                                    LBTextureOperations.EnableReadable(topographyLayers[l].heightmapImage, true);
                                }
                                else { InvalidTextures = true; }
                            }
                        }
                    }
                    else { Debug.LogWarning("GenerateTopography - Layer " + (l + 1).ToString() + " heightmap Image is null"); }

                    if (!InvalidTextures && topographyLayers[l].imageRepairHoles)
                    {
                        topographyLayers[l].processingImage = LBTextureOperations.RemoveHoles(topographyLayers[l].heightmapImage, topographyLayers[l].threshholdRepairHoles);
                    }
                }

                // Check for Map filters
            }
            EditorUtility.ClearProgressBar();

            //float generationStartTime = Time.realtimeSinceStartup;
            bool isContinue = false;
            int numTerrains = landscapeTerrains == null ? 0 : landscapeTerrains.Length;

            for (terrainIdx = 0; terrainIdx < numTerrains && !InvalidTextures; terrainIdx++)
            {
                if (terrainIdx == 0)
                {
                    EditorUtility.DisplayProgressBar("Applying Topography Layers", "Editing " + (terrainIdx + 1).ToString() + " of " + numTerrains.ToString() + " terrains",
                              (float)(terrainIdx + 1) / (float)numTerrains);
                }

                landscapeTerrains[terrainIdx].terrainData =
                    LBLandscapeTerrain.HeightmapFromLayers(landscape, landscapeTerrains[terrainIdx].terrainData,
                                                            landscapeTerrains[terrainIdx].transform.position, landscape.size, landscape.transform.position,
                                                            topographyLayers);

                // Apply mask if needed
                int maskModeInt = 0;
                if (landscape.topographyMaskMode == LBLandscape.MaskMode.DistanceToCentre) { maskModeInt = 1; }
                else if (landscape.topographyMaskMode == LBLandscape.MaskMode.Noise) { maskModeInt = 2; }
                if (maskModeInt != 0)
                {
                    landscapeTerrains[terrainIdx].terrainData =
                        LBLandscapeTerrain.MaskedHeightmap(landscapeTerrains[terrainIdx].terrainData,
                                                           landscapeTerrains[terrainIdx].transform.position, landscape.size, landscape.transform.position,
                                                           maskModeInt, landscape.distanceToCentreMask, landscape.maskWarpAmount, landscape.maskNoiseTileSize,
                                                           new Vector2(landscape.maskNoiseOffsetX, landscape.maskNoiseOffsetY), landscape.maskNoiseCurveModifier);
                }

                if (terrainIdx == 0) { EditorUtility.ClearProgressBar(); }

                if (EditorUtility.DisplayCancelableProgressBar("Applying Topography Layers", "Editing " + (terrainIdx + 1).ToString() + " of " + numTerrains.ToString() + " terrains",
                                                 (float)(terrainIdx + 1) / (float)numTerrains))
                {
                    // If the user cancels the process, revert to last save
                    if (!landscape.isUndoTopographyDisabled) { landscape.RevertToLastSave(LBLandscape.UndoType.HeightMap); }
                    break;
                }
                else { isContinue = true; }
            }

            if (isContinue && (landscape.useThermalErosion || useHydraulicErosion || landscape.useFinalPassSmoothing))
            {
                LBLandscape.ShowProgressDelegate showProgressDelegate = new LBLandscape.ShowProgressDelegate(LBLandscape.ShowProgressBar);

                // TODO - convert final pass parameters into a class
                isContinue = LBLandscapeTerrain.FinalPassHeightmap(landscape, landscape.transform.position,
                                                                useHydraulicErosion, hydraulicErosionIterations, hydraulicErosionRainfall, hydraulicErosionEvaporation,
                                                                hydraulicErosionCarryingCapacity, hydraulicErosionStrength, debugFinalPassWaterLevel,
                                                                showProgressDelegate, true);
                EditorUtility.ClearProgressBar();
            }

            // Topography Layer smoothing (since v1.3.2 beta 2a) is a post-topography process
            if (!InvalidTextures)
            {
                EditorUtility.ClearProgressBar();
                for (terrainIdx = 0; terrainIdx < landscapeTerrains.Length; terrainIdx++)
                {
                    if (EditorUtility.DisplayCancelableProgressBar("Smoothing", "Editing " + (terrainIdx + 1).ToString() + " of " + landscapeTerrains.Length.ToString() + " terrains",
                                                     (float)(terrainIdx + 1) / (float)landscapeTerrains.Length))
                    {
                        //If the user cancels the process, revert to last save
                        if (!landscape.isUndoTopographyDisabled) { landscape.RevertToLastSave(LBLandscape.UndoType.HeightMap); }
                        break;
                    }

                    landscapeTerrains[terrainIdx].terrainData = LBLandscapeTerrain.SmoothHeightmapFromLayers(landscape, landscapeTerrains[terrainIdx].terrainData, landscapeTerrains[terrainIdx].transform.position, topographyLayers);
                }
            }

            // We need to update the terrain LOD and vegetation information
            LBLandscapeTerrain.ApplyDelayedHeightmapLOD(landscapeTerrains);

            // Workaround for Smoothing terrain corner issue (only apply if required)
            if (!InvalidTextures && landscapeTerrains.Length > 1 && topographyLayers != null)
            {
                bool fixedEdges = false;
                foreach (LBLayer lbLayer in topographyLayers)
                {
                    if (lbLayer != null)
                    {
                        if (lbLayer.isDisabled) { continue; }

                        if (lbLayer.type == LBLayer.LayerType.ImageAdditive || lbLayer.type == LBLayer.LayerType.ImageBase ||
                            lbLayer.type == LBLayer.LayerType.ImageDetail)
                        {
                            if (lbLayer.detailSmoothRate > 0.001f)
                            {
                                LBLandscapeTerrain.FixTerrainEdges(landscape, landscapeTerrains);
                                fixedEdges = true;
                                break;
                            }
                        }

                        // Check for any layer filters that use smoothing
                        if (lbLayer.filters != null && (lbLayer.type == LBLayer.LayerType.PerlinAdditive || lbLayer.type == LBLayer.LayerType.PerlinSubtractive ||
                            lbLayer.type == LBLayer.LayerType.PerlinDetail || lbLayer.type == LBLayer.LayerType.ImageDetail))
                        {
                            foreach (LBLayerFilter lbLayerFilter in lbLayer.filters)
                            {
                                if (lbLayerFilter.type == LBLayerFilter.LayerFilterType.Map && lbLayerFilter.map != null && lbLayerFilter.smoothRate > 0.01f)
                                {
                                    LBLandscapeTerrain.FixTerrainEdges(landscape, landscapeTerrains);
                                    fixedEdges = true;
                                    break;
                                }
                            }
                        }

                        // Check for any MapPath layers that use smoothing
                        if (!fixedEdges && lbLayer.type == LBLayer.LayerType.MapPath && lbLayer.detailSmoothRate > 0.001f)
                        {
                            LBLandscapeTerrain.FixTerrainEdges(landscape, landscapeTerrains);
                            fixedEdges = true;
                            break;
                        }

                        // If we fixed the edges stop processing layers
                        if (fixedEdges) { break; }
                    }
                }
            }

            // If Stencil Layer Filters where used, free up any extra memory allocated
            LBStencil.FreeStencilResources(landscape, true);

            landscape.UpdateTerrainColliders();

            // Update Landscape stats
            landscapeMinMaxHeight = landscape.GetLandscapeMinMaxHeights();

            if (terrainMaterialType == LBLandscape.TerrainMaterialType.ReliefTerrainPack && landscape.rtpUseTessellation)
            {
                LBIntegration.RTPUpdateTessellationMaps(landscape, landscapeTerrains, true);
            }

            // Update the Object Path Y positions after the topography has changed if snapToTerrain is enabled
            LBGroup.ObjPathSnapToTerrain(landscape, landscape.lbGroupList);

#if VEGETATION_STUDIO_PRO
            if (landscape.useVegetationSystem)
            {
                LBIntegration.VegetationStudioProRefresh(true);
            }
#endif

            if (landscape.showTiming)
            {
                Debug.Log("Time taken to generate topography: " + (Time.realtimeSinceStartup - generationStartTime).ToString("00.00") + " seconds.");
            }

            EditorUtility.ClearProgressBar();
        }

        /// <summary>
        /// Undo the last heightmap / topography changes.
        /// These could have been done by GenerateTopography() or ApplyGroups()
        /// </summary>
        private void UndoHeightmap()
        {
            if (landscape)
            {
                EditorUtility.DisplayProgressBar("Undo Heightmap Modification", "Please Wait", 0.5f);
                landscape.RevertToLastSave(LBLandscape.UndoType.HeightMap);

                // Update Landscape stats
                landscapeMinMaxHeight = landscape.GetLandscapeMinMaxHeights();

                if (terrainMaterialType == LBLandscape.TerrainMaterialType.ReliefTerrainPack && landscape.rtpUseTessellation)
                {
                    LBIntegration.RTPUpdateTessellationMaps(landscape, landscapeTerrains, true);
                }

#if VEGETATION_STUDIO_PRO
                if (landscape.useVegetationSystem)
                {
                    LBIntegration.VegetationStudioProRefresh(true);
                }
#endif

                if (autoSaveEnabled) { sceneSaved = EditorSceneManager.SaveScene(EditorSceneManager.GetActiveScene()); }
                else { EditorSceneManager.MarkSceneDirty(EditorSceneManager.GetActiveScene()); }
                EditorUtility.ClearProgressBar();
            }
        }

        #endregion

        #region Import and Export Terrain Heightmaps

        /// <summary>
        /// Export the terrains in the landscape as RAW files to a subfolder of the Heightmap folder
        /// in the project asset folder
        /// </summary>
        private void ExportTerrainHeightmaps(bool showErrors)
        {
            if (landscape == null || landscape.landscapeTerrains == null) { return; }

            float generationStartTime = Time.realtimeSinceStartup;

            LBEditorHelper.CheckFolder(LBEditorHelper.GetDefaultHeightmapFolder);

            string folderPath = LBEditorHelper.GetDefaultHeightmapFolder + "/" + landscape.name;
            LBEditorHelper.CheckFolder(folderPath);

            landscape.SetLandscapeTerrains(true);
            int numTerrains = landscape.landscapeTerrains == null ? 0 : landscape.landscapeTerrains.Length;

            //if (numTerrains > 1)
            //{
            //    // Prompt the user for isMac RAW format?
            //    string msg = "There are multiple terrains. Export as single or multiple RAW files?";
            //    int dialogInt = EditorUtility.DisplayDialogComplex("Export Heightmap to RAW", msg, "Single", "Mulitple", "Cancel");
            //}

            for (int terrainIdx = 0; terrainIdx < numTerrains; terrainIdx++)
            {
                if (!LBTerrainData.ExportHeightmapRaw(landscape, landscape.landscapeTerrains[terrainIdx], folderPath, landscape.landscapeTerrains[terrainIdx].name, false, showErrors))
                {
                    break;
                }
            }

            AssetDatabase.Refresh(ImportAssetOptions.Default);

            LBEditorHelper.HighlightItemInProjectWindow(folderPath);

            if (landscape.showTiming)
            {
                Debug.Log("Time taken to export terrain heightmaps: " + (Time.realtimeSinceStartup - generationStartTime).ToString("00.00") + " seconds.");
            }
        }

        /// <summary>
        /// Get a folder from a user, then import the RAW heightmap files into a Topography Layer.
        /// The topography can then be generated with the standard LB tools. The Layer will have a
        /// type of Imported.
        /// </summary>
        /// <param name="showErrors"></param>
        private void ImportRAWTerrainHeightmaps(bool showErrors)
        {
            if (landscape == null) { return; }

            string methodName = "LB ImportRAWTerrainHeightmaps";

            float generationStartTime = Time.realtimeSinceStartup;

            // By default we'll start in the LandscapeBuilder\Heightmap folder.
            LBEditorHelper.CheckFolder(LBEditorHelper.GetDefaultHeightmapFolder);

            string rawFileFolder = string.Empty;

            landscape.SetLandscapeTerrains(true);
            int numTerrains = landscape.landscapeTerrains == null ? 0 : landscape.landscapeTerrains.Length;

            if (numTerrains == 0) { if (showErrors) { Debug.LogWarning("ERROR: " + methodName + " - no terrains in the landscape. Please report"); } }
            else
            {
                // Get the folder which contains the RAW Heightmap data
                if (LBEditorHelper.GetPathFromUser("RAW Heightmap", LBEditorHelper.GetDefaultHeightmapFolder, false, ref rawFileFolder))
                {
                    // Get a list of all the RAW files for this landscape
                    List<string> rawFileList = new List<string>();

                    string[] files = Directory.GetFiles(rawFileFolder, "*.raw", SearchOption.TopDirectoryOnly);

                    if (files != null)
                    {
                        if (files.Length < 1)
                        {
                            if (showErrors) { Debug.LogWarning("WARNING: " + methodName + " - No RAW files found in " + rawFileFolder); }
                        }
                        else
                        {
                            // Sort files in Alphanumeric ascending order
                            rawFileList.AddRange(files);
                            rawFileList.Sort();

                            if (rawFileList.Count == 1 && numTerrains > 1)
                            {
                                // Assume 1 RAW file will span all terrains
                                /// TODO - Prompt user

                            }

                            // Prompt the user for isMac RAW format?
                            string msg = "Is the RAW file little endian (Windows) format, or big endian (Mac)?";
                            int dialogInt = EditorUtility.DisplayDialogComplex("RAW Format", msg, "Windows", "Mac", "Cancel");

                            if (dialogInt < 2)
                            {
                                bool isMacRAWFormat = (dialogInt == 1);

                                if (LBImport.ImportRAWHeightmaps(landscape, rawFileList, isMacRAWFormat, showErrors))
                                {
                                    if (landscape.showTiming)
                                    {
                                        Debug.Log("Time taken to import RAW heightmaps: " + (Time.realtimeSinceStartup - generationStartTime).ToString("00.00") + " seconds.");
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Prompt user for a TIFF file and use LBImport class to import the TIFF as a Topography Layer
        /// </summary>
        /// <param name="showErrors"></param>
        private void ImportTIFFHeightmap(bool showErrors)
        {
            if (landscape == null) { return; }

            string methodName = "LB ImportTIFFHeightmap";

            float generationStartTime = Time.realtimeSinceStartup;

            // By default we'll start in the LandscapeBuilder\Heightmap folder.
            LBEditorHelper.CheckFolder(LBEditorHelper.GetDefaultHeightmapFolder);

            string tiffFileFolder = string.Empty;
            string tiffFileName = string.Empty;

            landscape.SetLandscapeTerrains(true);
            int numTerrains = landscape.landscapeTerrains == null ? 0 : landscape.landscapeTerrains.Length;

            if (numTerrains == 0) { if (showErrors) { Debug.LogWarning("ERROR: " + methodName + " - no terrains in the landscape. Please report"); } }
            else
            {
                // Get the folder and file which contains the TIFF Heightmap data
                if (LBEditorHelper.GetFilePathFromUser("GeoTIFF Heightmap", LBEditorHelper.GetDefaultHeightmapFolder, "tif", false, ref tiffFileFolder, ref tiffFileName))
                {
                    if (!string.IsNullOrEmpty(tiffFileName))
                    {
                        string filePath = LBEditorHelper.GetCombinedPath(tiffFileFolder, tiffFileName);

                        if (LBImportTIFF.ImportGeoTIFFHeightmap(landscape, filePath, showErrors))
                        {
                            if (landscape.showTiming)
                            {
                                Debug.Log("Time taken to import TIFF heightmaps: " + (Time.realtimeSinceStartup - generationStartTime).ToString("00.00") + " seconds.");
                            }
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Prompt user for a RAW file and use LBImport class to import the RAW to a specified layer
        /// </summary>
        /// <param name="showErrors"></param>
        private void ImportRAWToLayer(LBLayer lbLayer, bool showErrors)
        {
            if (landscape == null) { return; }

            string methodName = "LB ImportRAWToModifierLayer";

            float generationStartTime = Time.realtimeSinceStartup;

            // By default we'll start in the LandscapeBuilder\Heightmap folder.
            LBEditorHelper.CheckFolder(LBEditorHelper.GetDefaultHeightmapFolder);

            string RAWFileFolder = string.Empty;
            string RAWFileName = string.Empty;

            landscape.SetLandscapeTerrains(true);
            int numTerrains = landscape.landscapeTerrains == null ? 0 : landscape.landscapeTerrains.Length;

            if (numTerrains == 0) { if (showErrors) { Debug.LogWarning("ERROR: " + methodName + " - no terrains in the landscape. Please report"); } }
            else
            {
                // Get the folder and file which contains the RAW Heightmap data
                if (LBEditorHelper.GetFilePathFromUser("RAW Heightmap File", LBEditorHelper.GetDefaultHeightmapFolder, "raw", false, ref RAWFileFolder, ref RAWFileName))
                {
                    if (!string.IsNullOrEmpty(RAWFileName))
                    {
                        string filePath = LBEditorHelper.GetCombinedPath(RAWFileFolder, RAWFileName);

                        // Prompt the user for isMac RAW format?
                        string msg = "Is the RAW file little endian (Windows) format, or big endian (Mac)?";
                        int dialogInt = EditorUtility.DisplayDialogComplex("RAW Format", msg, "Windows", "Mac", "Cancel");

                        if (dialogInt < 2)
                        {
                            bool isMacRAWFormat = (dialogInt == 1);

                            if (LBImport.ImportRAWHeightmapToLayer(landscape, lbLayer, filePath, isMacRAWFormat, false, showErrors))
                            {
                                lbLayer.modifierSourceFileType = LBRaw.SourceFileType.RAW;
                                lbLayer.modifierLandformCategory = LBModifierOperations.ModifierLandformCategory.Custom;
                                if (lbLayer.modifierAddInvert)
                                {
                                    lbLayer.modifierAddInvert = false;
                                }
                                if (landscape.showTiming)
                                {
                                    Debug.Log("Time taken to import RAW heightmap: " + (Time.realtimeSinceStartup - generationStartTime).ToString("00.00") + " seconds.");
                                }
                            }
                            else { Debug.Log("INFO: " + methodName + " import raw heightmap to failed or was cancelled"); }
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Prompt user for a PNG file and use LBImport class to import the PNG to a specified layer
        /// </summary>
        /// <param name="lbLayer"></param>
        /// <param name="showErrors"></param>
        private void ImportPNGToLayer(LBLayer lbLayer, bool showErrors)
        {
            if (landscape == null) { return; }

            string methodName = "LB ImportPNGToLayer";

            float generationStartTime = Time.realtimeSinceStartup;

            // By default we'll start in the LandscapeBuilder\Heightmap folder.
            LBEditorHelper.CheckFolder(LBEditorHelper.GetDefaultHeightmapFolder);

            string PNGFileFolder = string.Empty;
            string PNGFileName = string.Empty;

            landscape.SetLandscapeTerrains(true);
            int numTerrains = landscape.landscapeTerrains == null ? 0 : landscape.landscapeTerrains.Length;

            if (numTerrains == 0) { if (showErrors) { Debug.LogWarning("ERROR: " + methodName + " - no terrains in the landscape. Please report"); } }
            else
            {
                // Get the folder and file which contains the PNG Heightmap data
                if (LBEditorHelper.GetFilePathFromUser("PNG Heightmap File", LBEditorHelper.GetDefaultHeightmapFolder, "png", false, ref PNGFileFolder, ref PNGFileName))
                {
                    if (!string.IsNullOrEmpty(PNGFileName))
                    {
                        string filePath = LBEditorHelper.GetCombinedPath(PNGFileFolder, PNGFileName);

                        if (LBImport.ImportPNGHeightmapToLayer(landscape, lbLayer, filePath, false, showErrors))
                        {
                            lbLayer.modifierSourceFileType = LBRaw.SourceFileType.PNG;
                            lbLayer.modifierLandformCategory = LBModifierOperations.ModifierLandformCategory.Custom;
                            lbLayer.modifierAddInvert = false;
                            if (landscape.showTiming)
                            {
                                Debug.Log("Time taken to import PNG heightmap: " + (Time.realtimeSinceStartup - generationStartTime).ToString("00.00") + " seconds.");
                            }
                        }
                    }
                }
            }
        }

        #endregion

        #region Script Buttons
        /// <summary>
        /// Add a "s" script button in the editor window that will allow user to send a c# script of the curve to the console window
        /// </summary>
        /// <param name="curve"></param>
        /// <param name="curveName"></param>
        private void AddScriptCurveButton(AnimationCurve curve, string curveName)
        {
            if (GUILayout.Button(scriptCurveContent, buttonCompact, GUILayout.MaxWidth(20f))) { Debug.Log(LBCurve.ScriptCurve(curve, "\n", curveName)); }
        }

        #endregion

        #region Water Methods

        /// <summary>
        /// Add Primary or secondary body of water to the scene
        /// NOTE: waterSize is only used for secondary bodies of water
        /// </summary>
        /// <param name="isPrimaryWater"></param>
        /// <param name="lbWaterExisting"></param>
        /// <param name="waterScaleFactorIndex"></param>
        /// <param name="waterHeight"></param>
        /// <param name="waterPrefab"></param>
        /// <param name="waterKeepPrefabAspectRatio"></param>
        /// <param name="waterResizingMode"></param>
        /// <param name="waterPosition"></param>
        /// <param name="waterSize"></param>
        /// <param name="waterMaxMeshThreshold"></param>
        /// <param name="waterMainCamera"></param>
        /// <param name="waterCausticsPrefabList"></param>
        /// <param name="promptToReplace"></param>
        /// <param name="isApplyingTemplate"></param>
        /// <param name="isRiver"></param>
        /// <param name="riverMaterial"></param>
        /// <param name="underWaterFXprefab"></param>
        /// <param name="waterMaterial"></param>
        private void AddWaterToScene(bool isPrimaryWater, LBWater lbWaterExisting, int waterScaleFactorIndex, float waterHeight, Transform waterPrefab,
                                     bool waterKeepPrefabAspectRatio, LBWater.WaterResizingMode waterResizingMode, Vector3 waterPosition, Vector2 waterSize,
                                     int waterMaxMeshThreshold, Camera waterMainCamera, List<Transform> waterCausticsPrefabList,
                                     bool promptToReplace, bool isApplyingTemplate, bool isRiver, Material riverMaterial, Transform underWaterFXprefab, Material waterMaterial)
        {
            if (isPrimaryWater)
            {

                //// Check to see if the primary body of water already exists in the scene
                //LBWater lbWaterExisting = LBWaterOperations.GetPrimaryWaterBody(landscape);

                bool addWater = true;
                bool replaceExistingPrimaryWater = false;

                if (lbWaterExisting != null && isPrimaryWater)
                {
                    string msg = "A primary body of water already exists in the landscape. Do you want to replace it?";

                    if (promptToReplace) { replaceExistingPrimaryWater = EditorUtility.DisplayDialog("Add Water To Scene", msg, "Yes", "No"); }
                    else { replaceExistingPrimaryWater = true; }

                    addWater = replaceExistingPrimaryWater;
                }

                if (addWater)
                {
                    // The water will scaled up so that it is larger than the landscape (default is 2x)
                    float waterScaleFactor = 2f;

                    // The primary body of water size for a Template comes from the template, not the editor ScaleFactor
                    if (!isApplyingTemplate)
                    {
                        waterScaleFactor = LBWaterOperations.WaterPrimarySizeFactor(waterScaleFactorIndex);
                        waterSize = new Vector2(landscape.size.x * waterScaleFactor, landscape.size.y * waterScaleFactor);
                    }

                    EditorUtility.DisplayProgressBar("Adding water to scene", "Please Wait", 0.5f);

                    // Water is removed from the scene for Templates before this method is called
                    if (replaceExistingPrimaryWater && !isApplyingTemplate)
                    {
                        // Remove the old one out of the scene
                        RemoveWaterFromScene(lbWaterExisting);
                    }

                    int numberOfMeshes = 0;
                    // Populate the paramaters to pass to AddWaterToScene()
                    LBWaterParameters lbWaterParms = new LBWaterParameters();
                    lbWaterParms.landscape = landscape;
                    lbWaterParms.landscapeGameObject = landscapeGameObject;
                    lbWaterParms.waterPosition = waterPosition;
                    lbWaterParms.waterSize = waterSize;
                    lbWaterParms.waterIsPrimary = isPrimaryWater;
                    lbWaterParms.waterHeight = waterHeight;
                    lbWaterParms.waterPrefab = waterPrefab;
                    lbWaterParms.keepPrefabAspectRatio = waterKeepPrefabAspectRatio;
                    lbWaterParms.waterResizingMode = waterResizingMode;
                    lbWaterParms.waterMaxMeshThreshold = waterMaxMeshThreshold;
                    lbWaterParms.waterMainCamera = waterMainCamera;
                    lbWaterParms.waterCausticsPrefabList = waterCausticsPrefabList;
                    lbWaterParms.isRiver = isRiver;
                    lbWaterParms.riverMaterial = riverMaterial;
                    lbWaterParms.waterMaterial = waterMaterial;
                    lbWaterParms.lbLighting = GameObject.FindObjectOfType<LBLighting>();

                    LBWater addedWater = LBWaterOperations.AddWaterToScene(lbWaterParms, ref numberOfMeshes);

                    if (addedWater != null)
                    {
                        // Set the prefab path so that the water can be resized / reinstantiated later
                        // This is currently only used for secondary water bodies. However it will is
                        // stored in Primary for future use
                        addedWater.waterPrefabPath = AssetDatabase.GetAssetPath(waterPrefab);

                        if (waterResizingMode == LBWater.WaterResizingMode.AQUAS || waterResizingMode == LBWater.WaterResizingMode.CalmWater)
                        {
                            // If the list doesn't exist, create it
                            if (addedWater.waterCausticList == null) { addedWater.waterCausticList = new List<LBWaterCaustics>(); }

                            if (waterCausticsPrefabList != null)
                            {
                                // Populate the list of LBWaterCaustic objects so they can be saved with the LBWater object in the scene
                                for (int transformIndex = 0; transformIndex < waterCausticsPrefabList.Count; transformIndex++)
                                {
                                    if (waterCausticsPrefabList[transformIndex] != null)
                                    {
                                        LBWaterCaustics lbWaterCaustics = new LBWaterCaustics();
                                        if (lbWaterCaustics != null)
                                        {
                                            lbWaterCaustics.isPrimaryWaterCaustics = (transformIndex == 0);
                                            lbWaterCaustics.waterCausticPrefabPath = AssetDatabase.GetAssetPath(waterCausticsPrefabList[transformIndex]);
                                            lbWaterCaustics.waterCausticPrefabName = waterCausticsPrefabList[transformIndex].name;
                                            addedWater.waterCausticList.Add(lbWaterCaustics);
                                        }
                                    }
                                }
                            }
                        }

                        // If the list hasn't been created yet, do it now
                        if (landscape.landscapeWaterList == null) { landscape.landscapeWaterList = new List<LBWater>(); }

                        if (replaceExistingPrimaryWater)
                        {
                            // Find the location in the list so that the primary LBWater can be placed in the
                            // same location in the list.
                            int oldWaterIndex = landscape.landscapeWaterList.IndexOf(lbWaterExisting);

                            // If the original LBWater was at the end of the list (or was the only one in the list),
                            // just add the new one to the end of the list
                            if (oldWaterIndex == landscape.landscapeWaterList.Count - 1)
                            {
                                // Remove the old one from the list and add the new one
                                landscape.landscapeWaterList.Remove(lbWaterExisting);
                                landscape.landscapeWaterList.Add(addedWater);
                            }
                            else
                            {
                                // Remove the old one from the list and insert the new one
                                landscape.landscapeWaterList.Remove(lbWaterExisting);
                                landscape.landscapeWaterList.Insert(oldWaterIndex, addedWater);
                            }
                            lbWaterExisting = null;
                        }
                        else
                        {
                            // This is a new primary water body, so add it to the top of the list
                            landscape.landscapeWaterList.Insert(0, addedWater);
                        }

                        if (autoSaveEnabled)
                        {
                            sceneSaved = EditorSceneManager.SaveScene(EditorSceneManager.GetActiveScene());
                        }
                        else
                        {
                            EditorSceneManager.MarkSceneDirty(EditorSceneManager.GetActiveScene());
                        }
                    }
                    EditorUtility.ClearProgressBar();
                }
            }
            // Secondary Water Body
            else
            {
                EditorUtility.DisplayProgressBar("Adding water to scene", "Please Wait", 0.5f);

                int numberOfMeshes = 0;
                // Populate the paramaters to pass to AddWaterToScene()
                LBWaterParameters lbWaterParms = new LBWaterParameters();
                lbWaterParms.landscape = landscape;
                lbWaterParms.landscapeGameObject = landscapeGameObject;
                lbWaterParms.waterPosition = waterPosition;
                lbWaterParms.waterSize = waterSize;
                lbWaterParms.waterIsPrimary = isPrimaryWater;
                lbWaterParms.waterHeight = waterHeight;
                lbWaterParms.waterPrefab = waterPrefab;
                lbWaterParms.keepPrefabAspectRatio = waterKeepPrefabAspectRatio;
                lbWaterParms.waterResizingMode = waterResizingMode;
                lbWaterParms.waterMaxMeshThreshold = waterMaxMeshThreshold;
                lbWaterParms.waterMainCamera = waterMainCamera;
                lbWaterParms.waterCausticsPrefabList = waterCausticsPrefabList;
                lbWaterParms.isRiver = isRiver;
                lbWaterParms.riverMaterial = riverMaterial;
                lbWaterParms.waterMaterial = waterMaterial;
                lbWaterParms.lbLighting = GameObject.FindObjectOfType<LBLighting>();

                LBWater addedWater = LBWaterOperations.AddWaterToScene(lbWaterParms, ref numberOfMeshes);

                if (addedWater != null)
                {
                    // Set the prefab path so that the water can be resized / reinstantiated later
                    addedWater.waterPrefabPath = AssetDatabase.GetAssetPath(waterPrefab);

                    if (waterResizingMode == LBWater.WaterResizingMode.AQUAS || waterResizingMode == LBWater.WaterResizingMode.CalmWater)
                    {
                        // If the list doesn't exist, create it
                        if (addedWater.waterCausticList == null) { addedWater.waterCausticList = new List<LBWaterCaustics>(); }

                        if (waterCausticsPrefabList != null)
                        {
                            // Populate the list of LBWaterCaustic objects so they can be saved with the LBWater object in the scene
                            for (int transformIndex = 0; transformIndex < waterCausticsPrefabList.Count; transformIndex++)
                            {
                                if (waterCausticsPrefabList[transformIndex] != null)
                                {
                                    LBWaterCaustics lbWaterCaustics = new LBWaterCaustics();
                                    if (lbWaterCaustics != null)
                                    {
                                        lbWaterCaustics.isPrimaryWaterCaustics = (transformIndex == 0);
                                        lbWaterCaustics.waterCausticPrefabPath = AssetDatabase.GetAssetPath(waterCausticsPrefabList[transformIndex]);
                                        lbWaterCaustics.waterCausticPrefabName = waterCausticsPrefabList[transformIndex].name;
                                        addedWater.waterCausticList.Add(lbWaterCaustics);
                                    }
                                }
                            }
                        }
                    }

                    // Add the LBWater object to the list of waters in LBLandscape
                    if (landscape.landscapeWaterList == null) { landscape.landscapeWaterList = new List<LBWater>(); }

                    if (isApplyingTemplate)
                    {
                        // Find the location in the list so that the primary LBWater can be placed in the
                        // same location in the list.
                        int oldWaterIndex = landscape.landscapeWaterList.IndexOf(lbWaterExisting);

                        // If the original LBWater was at the end of the list (or was the only one in the list),
                        // just add the new one to the end of the list
                        if (oldWaterIndex == landscape.landscapeWaterList.Count - 1)
                        {
                            // Remove the old one from the list and add the new one
                            landscape.landscapeWaterList.Remove(lbWaterExisting);
                            landscape.landscapeWaterList.Add(addedWater);
                        }
                        else
                        {
                            // Remove the old one from the list and insert the new one
                            landscape.landscapeWaterList.Remove(lbWaterExisting);
                            landscape.landscapeWaterList.Insert(oldWaterIndex, addedWater);
                        }
                    }
                    else { landscape.landscapeWaterList.Add(addedWater); }

                    if (autoSaveEnabled)
                    {
                        sceneSaved = EditorSceneManager.SaveScene(EditorSceneManager.GetActiveScene());
                    }
                    else
                    {
                        EditorSceneManager.MarkSceneDirty(EditorSceneManager.GetActiveScene());
                    }
                }
                EditorUtility.ClearProgressBar();
            }
        }

        private void RemoveWaterFromScene(LBWater lbWater)
        {
            Transform transform = LBWaterOperations.FindWaterInLandscape(landscapeGameObject, lbWater);
            if (transform != null)
            {
                string waterName = lbWater.name;
                string waterPrefabName = string.Empty;
                waterPrefabName = lbWater.waterPrefabName;

                // Register this water object in the UnityEditor undo list, and remove it from the scene
                Undo.DestroyObjectImmediate(transform.gameObject);

                if (!string.IsNullOrEmpty(waterPrefabName))
                {
                    // Remove the reflection scene camera if required
                    if (waterPrefabName.Contains("Water4Simple") || waterPrefabName.Contains("Water4Advanced"))
                    {
                        GameObject reflectionCamera = GameObject.Find(waterName + "ReflectionSceneCamera");
                        if (reflectionCamera != null)
                        {
                            Undo.DestroyObjectImmediate(reflectionCamera);
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Remove the water object from the scene.
        /// Remove the mesh data from the layer.
        /// </summary>
        /// <param name="lbLayerToRemoveWater"></param>
        private void RemoveModifierWater(LBLayer lbLayerToRemoveWater)
        {
            lbLayerToRemoveWater.modifierWaterTransform = null;

            if (lbLayerToRemoveWater.modifierWaterLBMesh != null)
            {
                LBMeshOperations.RemoveMeshFromScene(lbLayerToRemoveWater.modifierWaterLBMesh.title, landscape.transform, false);
            }

            lbLayerToRemoveWater.modifierLBWater = null;
            if (lbLayerToRemoveWater.modifierWaterLBMesh != null)
            {
                // Clean-up any mesh data before setting to null.
                LBMesh.DeleteMesh(lbLayerToRemoveWater.modifierWaterLBMesh);
                lbLayerToRemoveWater.modifierWaterLBMesh = null;
            }
        }

        #endregion

        #region Terrain Material Methods

        /// <summary>
        /// Set the terrain material type for a given terrain. This will typically also
        /// change the shader used for the terrain.
        /// NOTE: LBLandscape.SetTerrainMaterial() should also be modified with this routine is updated
        /// </summary>
        /// <param name="terrain"></param>
        /// <param name="tMaterialType"></param>
        /// <param name="prevtMaterialType"></param>
        private void SetTerrainMaterial(Terrain terrain, int terrainIndex, bool isLastTerrain, LBLandscape.TerrainMaterialType tMaterialType, LBLandscape.TerrainMaterialType prevtMaterialType = LBLandscape.TerrainMaterialType.BuiltInStandard)
        {
            bool isFirstTerrain = (terrainIndex == 0);
            Material terrainMat = null;

            #region Check if cleanup is required on previous materials
            // If we're not using using RTP but it is installed the user may
            // have switch from it at some point. Make sure it is not
            // selected for this terrain 
            if (prevtMaterialType == LBLandscape.TerrainMaterialType.ReliefTerrainPack)
            {
                if (landscape != null && landscapeGameObject != null && LBIntegration.isRTPInstalled(false))
                {
                    if (LBIntegration.RTPEnable(landscape, terrain, false, isFirstTerrain, isLastTerrain, false)) { }
                    // Set the pixel error back to a sensible value
                    if (pixelError > 5f) { terrain.heightmapPixelError = 5f; pixelError = 5f; }
                }
            }
            else if (prevtMaterialType == LBLandscape.TerrainMaterialType.MegaSplat)
            {
                if (landscape != null && landscapeGameObject != null && LBIntegration.IsMegaSplatInstalled(false))
                {
                    if (LBIntegration.MegaSplatEnable(landscape, terrain, terrain.materialTemplate, false, true)) { }
                }
            }
            // Only disable MicroSplat if something else is being chosen
            else if (prevtMaterialType == LBLandscape.TerrainMaterialType.MicroSplat && tMaterialType != LBLandscape.TerrainMaterialType.MicroSplat)
            {
                if (landscape != null && landscapeGameObject != null && LBIntegration.IsMicroSplatInstalled())
                {
                    if (LBIntegration.MicroSplatEnable(landscape, terrain, terrain.materialTemplate, false, isFirstTerrain, isLastTerrain, true))
                    {
                        if (isLastTerrain)
                        {
                            // Reset them back to sensible values
                            pixelError = 1;
                            baseMapDistance = 1500f;
                            baseTextureResolution = 512;
                        }
                    }
                }
            }
            // Check for following scenario:
            // MicroSplat was selected in Terrain Settings, Applied, but not initialised. Now another Material Type has been selected and Applied.
            else if (tMaterialType != LBLandscape.TerrainMaterialType.MicroSplat && LBIntegration.IsMicroSplatInstalled())
            {
                LBIntegration.MicroSplatCleanup(terrain, true);
            }
            // Previous was URP, but now want something different
            else if (prevtMaterialType == LBLandscape.TerrainMaterialType.URP && tMaterialType != LBLandscape.TerrainMaterialType.URP)
            {
                landscape.terrainCustomMaterial = null;
                terrain.materialTemplate = null;
            }
            // Previous was LWRP, but now want something different
            else if (prevtMaterialType == LBLandscape.TerrainMaterialType.LWRP && tMaterialType != LBLandscape.TerrainMaterialType.LWRP)
            {
                landscape.terrainCustomMaterial = null;
                terrain.materialTemplate = null;
            }
            // Previous was HDRP, but now want something different
            else if (prevtMaterialType == LBLandscape.TerrainMaterialType.HDRP && tMaterialType != LBLandscape.TerrainMaterialType.HDRP)
            {
                landscape.terrainCustomMaterial = null;
                terrain.materialTemplate = null;
            }
            #endregion

            if (tMaterialType == LBLandscape.TerrainMaterialType.BuiltInStandard)
            {
                #if UNITY_2019_2_OR_NEWER
                // Does the material already exist?
                terrainMat = landscape.GetLandscapeTerrainCustomMaterial();
                if (terrainMat == null || !terrainMat.shader.name.Contains("Nature/Terrain/Standard"))
                {
                    terrain.materialTemplate = landscape.CreateTerrainMaterial(terrainMat, "LBTerrainStandard", LBSetup.materialsFolder + "/_" + currentScene + "/");
                }
                else { terrain.materialTemplate = terrainMat; if (isFirstTerrain) { landscape.terrainCustomMaterial = terrainMat; } }
                #else
                terrain.materialType = Terrain.MaterialType.BuiltInStandard;
                #endif
            }
            else if (tMaterialType == LBLandscape.TerrainMaterialType.BuiltInLegacyDiffuse)
            {
                #if UNITY_2019_2_OR_NEWER
                // Does the material already exist?
                terrainMat = landscape.GetLandscapeTerrainCustomMaterial();
                if (terrainMat == null || !terrainMat.shader.name.Contains("Nature/Terrain/Diffuse"))
                {
                    terrain.materialTemplate = landscape.CreateTerrainMaterial(terrainMat, "LBTerrainDiffuse", LBSetup.materialsFolder + "/_" + currentScene + "/");
                }
                else { terrain.materialTemplate = terrainMat; if (isFirstTerrain) { landscape.terrainCustomMaterial = terrainMat; } }
                #else
                terrain.materialType = Terrain.MaterialType.BuiltInLegacyDiffuse;
                #endif
            }
            else if (tMaterialType == LBLandscape.TerrainMaterialType.BuiltInLegacySpecular)
            {
                #if UNITY_2019_2_OR_NEWER
                // Does the material already exist?
                terrainMat = landscape.GetLandscapeTerrainCustomMaterial();
                if (terrainMat == null || !terrainMat.shader.name.Contains("Nature/Terrain/Specular"))
                {
                    terrain.materialTemplate = landscape.CreateTerrainMaterial(terrainMat, "LBTerrainSpecular", LBSetup.materialsFolder + "/_" + currentScene + "/");
                }
                else { terrain.materialTemplate = terrainMat; if (isFirstTerrain) { landscape.terrainCustomMaterial = terrainMat; } }
                #else
                terrain.materialType = Terrain.MaterialType.BuiltInLegacySpecular;
                #endif
            }

            #region URP
            else if (tMaterialType == LBLandscape.TerrainMaterialType.URP)
            {
                // Set material type to custom to allow us to use our own material
                #if !UNITY_2019_2_OR_NEWER
                terrain.materialType = Terrain.MaterialType.Custom;
                #endif

                // Does the material already exist?
                terrainMat = landscape.GetLandscapeTerrainCustomMaterial();

                // If it does not exist OR it is not a URP 7.1.2+ shader, create a new material
                if (terrainMat == null || !terrainMat.shader.name.Contains("Universal Render Pipeline/Terrain/Lit"))
                {
                    // Load the material
                    Material tempMat = (Material)Resources.Load("LBTerrain", typeof(Material));

                    // Make sure it has been updated from SRP folder package
                    if (tempMat == null)
                    {                   
                        Debug.LogWarning("URP LBTerrain material could not be found at path: " + LBSetup.materialsFolder  + "/Resources/LBTerrain.mat. Please Report");
                    }
                    else if (!tempMat.shader.name.Contains("Universal Render Pipeline/Terrain/Lit"))
                    {
                        Debug.LogWarning("ERROR: Did you apply the LB_URP package from the LandscapeBuilder/SRP folder? If you did, please report this error.");
                    }
                    else
                    {
                        #if UNITY_2019_2_OR_NEWER
                        terrainMat = landscape.CreateTerrainMaterial(tempMat, LBSetup.materialsFolder + "/_" + currentScene + "/");
                        terrain.materialTemplate = terrainMat;
                        #else
                        // Create a copy
                        terrainMat = new Material(tempMat);
                        AssetDatabase.CreateAsset(terrainMat, LBSetup.materialsFolder + "/" + landscapeName + "TerrainMaterial.mat");
                        AssetDatabase.Refresh();
                        landscape.terrainCustomMaterial = terrainMat;
                        #endif
                    }
                }

                if (terrainMat == null)
                {
                    Debug.LogWarning("LandscapeBuilder - Setting URP terrain material failed. Did you apply the LB_URP package from the LandscapeBuilder/SRP folder?");
                    // Fallback to standard builtin material
                    #if UNITY_2019_2_OR_NEWER
                    // Does the material already exist?
                    terrainMat = landscape.GetLandscapeTerrainCustomMaterial();
                    if (terrainMat == null || !terrainMat.shader.name.Contains("Nature/Terrain/Standard"))
                    {
                        terrain.materialTemplate = landscape.CreateTerrainMaterial(terrainMat, "LBTerrainStandard", LBSetup.materialsFolder + "/_" + currentScene + "/");
                    }
                    else { terrain.materialTemplate = terrainMat; }
                    #else
                    terrain.materialType = Terrain.MaterialType.BuiltInStandard;
                    #endif
                }
                else
                {
                    #if UNITY_2019_3_OR_NEWER
                    // There is one material per landscape. If this is the first terrain, update the material            
                    if (terrainIndex == 0)
                    {
                        if (terrainMat.HasProperty("_EnableInstancedPerPixelNormal"))
                        {
                            // Appear to have to update the shader_feature as a keyword, AND set the Float property.
                            if (useTerrainPerPixelNormals) { terrainMat.EnableKeyword("_EnableInstancedPerPixelNormal"); }
                            else { terrainMat.DisableKeyword("_EnableInstancedPerPixelNormal"); }

                            terrainMat.SetFloat("_EnableInstancedPerPixelNormal", useTerrainPerPixelNormals ? 1f : 0f);
                            EditorUtility.SetDirty(terrainMat);
                        }
                        else
                        {
                            Debug.LogWarning("URP material property _EnableInstancedPerPixelNormal is not available. Do you have URP 7.1.2 or newer in your project? Check Package Manager");
                        }
                    }
                    #endif

                    terrain.materialTemplate = terrainMat;
                }
            }
            #endregion

            #region LWRP
            else if (tMaterialType == LBLandscape.TerrainMaterialType.LWRP)
            {
                // Set material type to custom to allow us to use our own material
                #if !UNITY_2019_2_OR_NEWER
                terrain.materialType = Terrain.MaterialType.Custom;
                #endif

                // Does the material already exist?
                terrainMat = landscape.GetLandscapeTerrainCustomMaterial();

                // If it does not exist OR it is not a LWRP 4.0.1+ shader, create a new material
                if (terrainMat == null || !terrainMat.shader.name.Contains("Lightweight Render Pipeline/Terrain/Lit"))
                {
                    // Load the material
                    Material tempMat = (Material)Resources.Load("LBTerrain", typeof(Material));

                    // Make sure it has been updated from SRP folder package
                    if (tempMat == null)
                    {                   
                        Debug.LogWarning("LWRP LBTerrain material could not be found at path: " + LBSetup.materialsFolder  + "/Resources/LBTerrain.mat. Please Report");
                    }
                    else if (!tempMat.shader.name.Contains("Lightweight Render Pipeline/Terrain/Lit"))
                    {
                        Debug.LogWarning("ERROR: Did you apply the LB_LWRP package from the LandscapeBuilder/SRP folder? If you did, please report this error.");
                    }
                    else
                    {
                        #if UNITY_2019_2_OR_NEWER
                        terrainMat = landscape.CreateTerrainMaterial(tempMat, LBSetup.materialsFolder + "/_" + currentScene + "/");
                        terrain.materialTemplate = terrainMat;
                        #else
                        // Create a copy
                        terrainMat = new Material(tempMat);
                        AssetDatabase.CreateAsset(terrainMat, LBSetup.materialsFolder + "/" + landscapeName + "TerrainMaterial.mat");
                        AssetDatabase.Refresh();
                        landscape.terrainCustomMaterial = terrainMat;
                        #endif
                    }
                }

                if (terrainMat == null)
                {
                    Debug.LogWarning("LandscapeBuilder - Setting LWRP terrain material failed. Did you apply the LB_LWRP package from the LandscapeBuilder/SRP folder?");
                    // Fallback to standard builtin material
                    #if UNITY_2019_2_OR_NEWER
                    // Does the material already exist?
                    terrainMat = landscape.GetLandscapeTerrainCustomMaterial();
                    if (terrainMat == null || !terrainMat.shader.name.Contains("Nature/Terrain/Standard"))
                    {
                        terrain.materialTemplate = landscape.CreateTerrainMaterial(terrainMat, "LBTerrainStandard", LBSetup.materialsFolder + "/_" + currentScene + "/");
                    }
                    else { terrain.materialTemplate = terrainMat; }
                    #else
                    terrain.materialType = Terrain.MaterialType.BuiltInStandard;
                    #endif
                }
                else
                {
                    #if UNITY_2018_3_OR_NEWER
                    // There is one material per landscape. If this is the first terrain, update the material            
                    if (terrainIndex == 0)
                    {
                        if (terrainMat.HasProperty("_TERRAIN_INSTANCED_PERPIXEL_NORMAL"))
                        {
                            // Appear to have to update the shader_feature as a keyword, AND set the Float property.
                            if (useTerrainPerPixelNormals) { terrainMat.EnableKeyword("_TERRAIN_INSTANCED_PERPIXEL_NORMAL"); }
                            else { terrainMat.DisableKeyword("_TERRAIN_INSTANCED_PERPIXEL_NORMAL"); }

                            terrainMat.SetFloat("_TERRAIN_INSTANCED_PERPIXEL_NORMAL", useTerrainPerPixelNormals ? 1f : 0f);
                            EditorUtility.SetDirty(terrainMat);
                        }
                        else
                        {
                            Debug.LogWarning("LWRP material property _TERRAIN_INSTANCED_PERPIXEL_NORMAL is not available. Do you have LWRP 4.0.1 or newer in your project? Check Package Manager");
                        }
                    }
                    #endif

                    terrain.materialTemplate = terrainMat;
                }
            }
            #endregion

            #region HDRP
            else if (tMaterialType == LBLandscape.TerrainMaterialType.HDRP)
            {
                // Set material type to custom to allow us to use our own material
                #if !UNITY_2019_2_OR_NEWER
                terrain.materialType = Terrain.MaterialType.Custom;
                #endif

                // Does the material already exist?
                terrainMat = landscape.GetLandscapeTerrainCustomMaterial();

                // If it does not exist OR it is not a HDRP 4.9.0+ or 4.0.1+ shader, create a new material
                if (terrainMat == null || (!terrainMat.shader.name.Contains("HDRP/TerrainLit") && !terrainMat.shader.name.Contains("HDRenderPipeline/TerrainLit")) )
                {
                    // Load the material
                    Material tempMat = (Material)Resources.Load("LBTerrain", typeof(Material));

                    // Make sure it has been updated from SRP folder package
                    if (tempMat == null)
                    {                   
                        Debug.LogWarning("HDRP LBTerrain material could not be found at path: " + LBSetup.materialsFolder  + "/Resources/LBTerrain.mat. Please Report");
                    }
                    // Check for 4.9.0+ or 4.0.1 shaders
                    else if (!tempMat.shader.name.Contains("HDRP/TerrainLit") && !tempMat.shader.name.Contains("HDRenderPipeline/TerrainLit"))
                    {
                        Debug.LogWarning("ERROR: Did you apply the LB_HDRP package from the LandscapeBuilder/SRP folder? If you did, please report this error.");
                    }
                    else
                    {
                        #if UNITY_2019_2_OR_NEWER
                        terrainMat = landscape.CreateTerrainMaterial(tempMat, LBSetup.materialsFolder + "/_" + currentScene + "/");
                        terrain.materialTemplate = terrainMat;
                        #else
                        // Create a copy
                        terrainMat = new Material(tempMat);
                        AssetDatabase.CreateAsset(terrainMat, LBSetup.materialsFolder + "/" + landscapeName + "TerrainMaterial.mat");
                        AssetDatabase.Refresh();
                        landscape.terrainCustomMaterial = terrainMat;
                        #endif
                    }
                }

                if (terrainMat == null)
                {
                    Debug.LogWarning("LandscapeBuilder - Setting HDRP terrain material failed. Did you apply the LB_HDRP package from the LandscapeBuilder/SRP folder?");
                    // Fallback to standard builtin material
                    #if UNITY_2019_2_OR_NEWER
                    // Does the material already exist?
                    terrainMat = landscape.GetLandscapeTerrainCustomMaterial();
                    if (terrainMat == null || !terrainMat.shader.name.Contains("Nature/Terrain/Standard"))
                    {
                        terrain.materialTemplate = landscape.CreateTerrainMaterial(terrainMat, "LBTerrainStandard", LBSetup.materialsFolder + "/_" + currentScene + "/");
                    }
                    else { terrain.materialTemplate = terrainMat; }
                    #else
                    terrain.materialType = Terrain.MaterialType.BuiltInStandard;
                    #endif
                }
                else
                {
                    // There is one material per landscape. If this is the first terrain, update the material
                    // NOTE: CURRENTLY PERPIXEL NORMAL not supported in HDRP 4.0.1
                    //if (terrainIndex == 0)
                    //{
                    //    if (terrainMat.HasProperty("_TERRAIN_INSTANCED_PERPIXEL_NORMAL"))
                    //    {
                    //        // Appear to have to update the shader_feature as a keyword, AND set the Float property.
                    //        if (useTerrainPerPixelNormals) { terrainMat.EnableKeyword("_TERRAIN_INSTANCED_PERPIXEL_NORMAL"); }
                    //        else { terrainMat.DisableKeyword("_TERRAIN_INSTANCED_PERPIXEL_NORMAL"); }

                    //        terrainMat.SetFloat("_TERRAIN_INSTANCED_PERPIXEL_NORMAL", useTerrainPerPixelNormals ? 1f : 0f);
                    //        EditorUtility.SetDirty(terrainMat);
                    //    }
                    //    else
                    //    {
                    //        Debug.LogWarning("HDRP material property _TERRAIN_INSTANCED_PERPIXEL_NORMAL is not available. Do you have HDRP 4.0.1 or newer in your project? Check Package Manager");
                    //    }
                    //}

                    terrain.materialTemplate = terrainMat;
                }
            }

            #endregion

            #region LBStandard
            else if (tMaterialType == LBLandscape.TerrainMaterialType.LBStandard)
            {
                // Set material type to custom to allow us to use our own material
                #if !UNITY_2019_2_OR_NEWER
                terrain.materialType = Terrain.MaterialType.Custom;
                #endif
                // Check if a material has already been created for this landscape
                terrainMat = landscape.GetLandscapeLBStandardTerrainMaterial();
                if (terrainMat != null)
                {
                    // If a material has already been created, set the terrain width and use it
                    terrainMat.SetFloat("_TerrainWidth", terrainWidth);
                    terrain.materialTemplate = terrainMat;
                }
                else
                {
                    // If not, create and save a new material
                    // In v1.3.2 Beta 10+ expect it to be in Assets/LandscapeBuilder/Materials/Resources folder
                    Material tempMat = (Material)Resources.Load("LBTerrain", typeof(Material));

                    if (tempMat == null)
                    {
                        Debug.LogWarning("LBTerrain material could not be found at path: Assets/LandscapeBuilder/Materials/Resources/LBTerrain.mat. Looking in old location..");
                        // Attempt to load from pre-v1.3.2 Beta 10 location
                        tempMat = (Material)UnityEditor.AssetDatabase.LoadAssetAtPath("Assets/LandscapeBuilder/Materials/LBTerrain.mat", typeof(Material));
                    }

                    // Create a new copy of the LBTerrain material
                    if (tempMat != null) { terrainMat = new Material(tempMat); }

                    if (terrainMat != null)
                    {
                        AssetDatabase.CreateAsset(terrainMat, "Assets/LandscapeBuilder/Materials/" + landscapeName + "TerrainMaterial.mat");
                        // The terrain material has now been created, set the terrain width and use it
                        terrainMat.SetFloat("_TerrainWidth", terrainWidth);
                        terrain.materialTemplate = terrainMat;
                        // Send the newly created material back to the landscape for future reference
                        landscape.SetLandscapeLBStandardTerrainMaterial(terrainMat);
                    }
                    else
                    {
                        // If the material doesn't exist, show a warning and revert to the Built-In Standard shader
                        Debug.LogWarning("LBTerrain material not found at path: Assets/LandscapeBuilder/Materials/LBTerrain. Did you accidentally delete it? Reverting to Built-In Standard shader.");
                        // Fallback to standard builtin material
                        #if UNITY_2019_2_OR_NEWER
                        // Does the material already exist?
                        terrainMat = landscape.GetLandscapeTerrainCustomMaterial();
                        if (terrainMat == null || !terrainMat.shader.name.Contains("Nature/Terrain/Standard"))
                        {
                            terrain.materialTemplate = landscape.CreateTerrainMaterial(terrainMat, "LBTerrainStandard", LBSetup.materialsFolder + "/_" + currentScene + "/");
                        }
                        else { terrain.materialTemplate = terrainMat; }
                        #else
                        terrain.materialType = Terrain.MaterialType.BuiltInStandard;
                        #endif
                    }
                }
            }
            #endregion

            #region RTP
            else if (tMaterialType == LBLandscape.TerrainMaterialType.ReliefTerrainPack)
            {
                if (!LBIntegration.isRTPInstalled(true))
                {
                    // Fallback to standard builtin material
#if UNITY_2019_2_OR_NEWER
                    // Does the material already exist?
                    terrainMat = landscape.GetLandscapeTerrainCustomMaterial();
                    if (terrainMat == null || !terrainMat.shader.name.Contains("Nature/Terrain/Standard"))
                    {
                        terrain.materialTemplate = landscape.CreateTerrainMaterial(terrainMat, "LBTerrainStandard", LBSetup.materialsFolder + "/_" + currentScene + "/");
                    }
                    else { terrain.materialTemplate = terrainMat; }
#else
                    terrain.materialType = Terrain.MaterialType.BuiltInStandard;
#endif
                }
                else if (!LBIntegration.RTPValidation(landscape, true))
                {
                    // Fallback to standard builtin material
#if UNITY_2019_2_OR_NEWER
                    // Does the material already exist?
                    terrainMat = landscape.GetLandscapeTerrainCustomMaterial();
                    if (terrainMat == null || !terrainMat.shader.name.Contains("Nature/Terrain/Standard"))
                    {
                        terrain.materialTemplate = landscape.CreateTerrainMaterial(terrainMat, "LBTerrainStandard", LBSetup.materialsFolder + "/_" + currentScene + "/");
                    }
                    else { terrain.materialTemplate = terrainMat; }
#else
                    terrain.materialType = Terrain.MaterialType.BuiltInStandard;
#endif
                }
                else
                {
                    // If the terrain already has a custom terrain material, RTP users that material rather than
                    // creating it's own and assigning it's own shader. This overcomes that issue.
                    if (prevtMaterialType == LBLandscape.TerrainMaterialType.LBStandard || prevtMaterialType == LBLandscape.TerrainMaterialType.Custom)
                    {
                        //Debug.Log("SetTerrainMaterial mat1: " + terrain.materialTemplate.name);
                        terrain.materialTemplate = null;

                        // Fallback to standard builtin material
#if UNITY_2019_2_OR_NEWER
                        // Does the material already exist?
                        terrainMat = landscape.GetLandscapeTerrainCustomMaterial();
                        if (terrainMat == null || !terrainMat.shader.name.Contains("Nature/Terrain/Standard"))
                        {
                            terrain.materialTemplate = landscape.CreateTerrainMaterial(terrainMat, "LBTerrainStandard", LBSetup.materialsFolder + "/_" + currentScene + "/");
                        }
                        else { terrain.materialTemplate = terrainMat; }
#else
                        terrain.materialType = Terrain.MaterialType.BuiltInStandard;
#endif
                    }

                    // Set material type to custom to allow us to use our own material
#if !UNITY_2019_2_OR_NEWER
                    terrain.materialType = Terrain.MaterialType.Custom;
#endif

                    if (landscape != null && landscapeGameObject != null)
                    {
                        if (!LBIntegration.RTPEnable(landscape, terrain, true, isFirstTerrain, isLastTerrain, true))
                        {
                            // Rollback the change
                            if (LBIntegration.RTPEnable(landscape, terrain, false, isFirstTerrain, isLastTerrain, false)) { }

                            // Fallback to standard builtin material
#if UNITY_2019_2_OR_NEWER
                            // Does the material already exist?
                            terrainMat = landscape.GetLandscapeTerrainCustomMaterial();
                            if (terrainMat == null || !terrainMat.shader.name.Contains("Nature/Terrain/Standard"))
                            {
                                terrain.materialTemplate = landscape.CreateTerrainMaterial(terrainMat, "LBTerrainStandard", LBSetup.materialsFolder + "/_" + currentScene + "/");
                            }
                            else { terrain.materialTemplate = terrainMat; }
#else
                            terrain.materialType = Terrain.MaterialType.BuiltInStandard;
#endif
                        }
                        else
                        {
                            // RTP creates the custom materials when the component is added to the terrain
                            // So set our customer material to the one RTP created.
                            terrainCustomMaterial = terrain.materialTemplate;

                            // This has been moved to LBIntergration.RTPEnable and uses reflection
                            //if (isLastTerrain)
                            //{
                            //    RTP_LODmanagerEditor[] editor = Resources.FindObjectsOfTypeAll<RTP_LODmanagerEditor>();
                            //    if (editor != null)
                            //    {
                            //        if (editor.Length >= 0) { editor[0].RefreshFeatures(); }
                            //    }
                            //}
                        }
                    }
                }
            }
            #endregion

            #region MegaSplat
            else if (tMaterialType == LBLandscape.TerrainMaterialType.MegaSplat)
            {
                // If the terrain already has a custom terrain material, set it to null
                if (prevtMaterialType == LBLandscape.TerrainMaterialType.LBStandard || prevtMaterialType == LBLandscape.TerrainMaterialType.Custom)
                {
                    terrain.materialTemplate = null;
#if !UNITY_2019_2_OR_NEWER
                    terrain.materialType = Terrain.MaterialType.BuiltInStandard;
#endif
                    terrainCustomMaterial = null;
                }

                if (!LBIntegration.IsMegaSplatInstalled(true))
                {
                    Debug.LogWarning("Landscape Builder - MegaSplat does not seem to be installed in the project. Setting terrain material to BuiltInStandard");
                    // Fallback to standard builtin material
#if UNITY_2019_2_OR_NEWER
                    // Does the material already exist?
                    terrainMat = landscape.GetLandscapeTerrainCustomMaterial();
                    if (terrainMat == null || !terrainMat.shader.name.Contains("Nature/Terrain/Standard"))
                    {
                        terrain.materialTemplate = landscape.CreateTerrainMaterial(terrainMat, "LBTerrainStandard", LBSetup.materialsFolder + "/_" + currentScene + "/");
                    }
                    else { terrain.materialTemplate = terrainMat; }
#else
                    terrain.materialType = Terrain.MaterialType.BuiltInStandard;
#endif
                }
                else if (!LBIntegration.MegaSplatEnable(landscape, terrain, terrainCustomMaterial, true, true))
                {
                    // Rollback the change
                    Debug.LogWarning("Landscape Builder - Rolling back MegaSplat change. Setting terrain material to BuiltInStandard");
                    if (LBIntegration.MegaSplatEnable(landscape, terrain, null, false, false)) { }

                    // Fallback to standard builtin material
#if UNITY_2019_2_OR_NEWER
                    // Does the material already exist?
                    terrainMat = landscape.GetLandscapeTerrainCustomMaterial();
                    if (terrainMat == null || !terrainMat.shader.name.Contains("Nature/Terrain/Standard"))
                    {
                        terrain.materialTemplate = landscape.CreateTerrainMaterial(terrainMat, "LBTerrainStandard", LBSetup.materialsFolder + "/_" + currentScene + "/");
                    }
                    else { terrain.materialTemplate = terrainMat; }
#else
                    terrain.materialType = Terrain.MaterialType.BuiltInStandard;
#endif
                }
            }
            #endregion

            #region MicroSplat
            else if (tMaterialType == LBLandscape.TerrainMaterialType.MicroSplat)
            {
                if (!LBIntegration.IsMicroSplatInstalled())
                {
                    Debug.LogWarning("Landscape Builder - MicroSplat does not seem to be installed in the project. Setting terrain material to BuiltInStandard");

                    // Fallback to standard builtin material
#if UNITY_2019_2_OR_NEWER
                    // Does the material already exist?
                    terrainMat = landscape.GetLandscapeTerrainCustomMaterial();
                    if (terrainMat == null || !terrainMat.shader.name.Contains("Nature/Terrain/Standard"))
                    {
                        terrain.materialTemplate = landscape.CreateTerrainMaterial(terrainMat, "LBTerrainStandard", LBSetup.materialsFolder + "/_" + currentScene + "/");
                    }
                    else { terrain.materialTemplate = terrainMat; }
#else
                    terrain.materialType = Terrain.MaterialType.BuiltInStandard;
#endif


                    if (isLastTerrain) { terrainMaterialType = LBLandscape.TerrainMaterialType.BuiltInStandard; }
                }
                else
                {
                    if (!LBIntegration.MicroSplatEnable(landscape, terrain, terrainCustomMaterial, true, isFirstTerrain, isLastTerrain, true))
                    {
                        // Rollback the change
                        Debug.LogWarning("Landscape Builder - Rolling back MicroSplat change. Setting terrain material to BuiltInStandard");
                        if (LBIntegration.MicroSplatEnable(landscape, terrain, null, false, isFirstTerrain, isLastTerrain, false)) { }

                        // Fallback to standard builtin material
#if UNITY_2019_2_OR_NEWER
                        // Does the material already exist?
                        terrainMat = landscape.GetLandscapeTerrainCustomMaterial();
                        if (terrainMat == null || !terrainMat.shader.name.Contains("Nature/Terrain/Standard"))
                        {
                            terrain.materialTemplate = landscape.CreateTerrainMaterial(terrainMat, "LBTerrainStandard", LBSetup.materialsFolder + "/_" + currentScene + "/");
                        }
                        else { terrain.materialTemplate = terrainMat; }
#else
                        terrain.materialType = Terrain.MaterialType.BuiltInStandard;
#endif

                        if (isLastTerrain) { terrainMaterialType = LBLandscape.TerrainMaterialType.BuiltInStandard; }
                    }
                }
            }
            #endregion

            else
            {
                #if !UNITY_2019_2_OR_NEWER
                terrain.materialType = Terrain.MaterialType.Custom;
                #endif
                terrain.materialTemplate = terrainCustomMaterial;
            }
        }

        #endregion

        #region Texture Methods

        private void SaveMapTexture(Texture2D mapTexture, string mapTexturePath)
        {
            // create a byte array in PNG format
            byte[] heightMapData = mapTexture.EncodeToPNG();
            // Save the byte array to the disk file
            File.WriteAllBytes(mapTexturePath, heightMapData);
            AssetDatabase.Refresh();
            // Get the new texture so that attributes can be modified
            texImporter = (TextureImporter)AssetImporter.GetAtPath(mapTexturePath);

#if UNITY_5_5_OR_NEWER
            texImporter.textureType = TextureImporterType.Default;
#else
            texImporter.textureType = TextureImporterType.Advanced;
#endif

            // Disable normal maps
            texImporter.convertToNormalmap = false;
            // Use TrueColor compression (our import methods don't work with Crunched settings)
            // Some other 8 and 16 bit compression algorithms (includind Unity default Automatic Compressed)
            // return slightly incorrect colour values. For example RGB 0, 153, 0 returns 0, 154, 0.
            // NOTE: Unity 5.5 doesn't support textureFormat property.
#if UNITY_5_5_OR_NEWER
            texImporter.textureCompression = TextureImporterCompression.Uncompressed;
#else
            texImporter.textureFormat = TextureImporterFormat.AutomaticTruecolor;
#endif
            // Set the size based on the landscape being exported
            if (landscape.size.x > 4096) { texImporter.maxTextureSize = 8192; }
            if (landscape.size.x > 2048) { texImporter.maxTextureSize = 4096; }
            else { texImporter.maxTextureSize = 2048; }
            // Make the new image Read/Write
            texImporter.isReadable = true;
            AssetDatabase.Refresh();
            // Reveals the image that was just added or overwritten in the Project window
            LBEditorHelper.HighlightItemInProjectWindow(mapTexturePath);
        }

        /// <summary>
        /// Get the list of textures contained in the terrain alphamaps
        /// </summary>
        private void RefreshTerrainTexturesAvailableList()
        {
            TerrainTexturesAvailableList = landscape.TerrainTexturesAvailableList();
            if (TerrainTexturesAvailableList != null)
            {
                TerrainTexturesAvailableArray = LBTerrainTexture.GetTextureNameArray(TerrainTexturesAvailableList);

                //Debug.Log("INFO: Available Terrain Textures: " + TerrainTexturesAvailableArray.Length);
            }
            else { TerrainTexturesAvailableArray = null; }
        }

        /// <summary>
        /// Get the list of LBTerrainTextures that have been saved or applied to the landscape.
        /// This could include Disabled textures. These come from the Texturing tab (not from the
        /// actual terrains). For textures in the terrains, see RefreshTerrainTexturesAvailableList().
        /// </summary>
        private void RefreshAppliedTexturesList()
        {
            appliedTexturesList = landscape.TerrainTexturesList();
            if (appliedTexturesList != null)
            {
                appliedTexturesArray = LBTerrainTexture.GetTextureNameArray(appliedTexturesList);
            }
            else { appliedTexturesArray = null; }
        }

        /// <summary>
        /// Return the name of the texture in brackets. Optionally supply the last known
        /// texture name to detect missing textures.
        /// </summary>
        /// <param name="texture"></param>
        /// <param name="lastKnownTextureName"></param>
        /// <returns></returns>
        private string GetTextureName(Texture2D texture, string lastKnownTextureName = "")
        {
            if (texture != null) { return " (" + texture.name + ")"; }
            else if (!string.IsNullOrEmpty(lastKnownTextureName)) { return " (" + lastKnownTextureName + ") N/A"; }
            else { return string.Empty; }
        }

        /// <summary>
        /// Expand or collapse the details of each texture in the list
        /// </summary>
        /// <param name="isExpanded"></param>
        private void TextureListExpand(bool isExpanded)
        {
            if (terrainTexturesList != null)
            {
                for (int txIdx = 0; txIdx < terrainTexturesList.Count; txIdx++)
                {
                    if (terrainTexturesList[txIdx] != null) { terrainTexturesList[txIdx].showTexture = isExpanded; }
                }
            }
        }

        private void UndoTexturing()
        {
            if (landscape != null)
            {
                EditorUtility.DisplayProgressBar("Undo Texture Modification", "Please Wait", 0.5f);
                landscape.RevertToLastSave(LBLandscape.UndoType.Textures);

                if (autoSaveEnabled) { sceneSaved = EditorSceneManager.SaveScene(EditorSceneManager.GetActiveScene()); }
                else { EditorSceneManager.MarkSceneDirty(EditorSceneManager.GetActiveScene()); }
                EditorUtility.ClearProgressBar();
            }
        }

        #endregion

        #region Tree Methods

        /// <summary>
        /// Expand or collapse the details of each tree in the list
        /// </summary>
        /// <param name="isExpanded"></param>
        private void TreeListExpand(bool isExpanded)
        {
            if (terrainTreesList != null)
            {
                for (int trIdx = 0; trIdx < terrainTreesList.Count; trIdx++)
                {
                    if (terrainTreesList[trIdx] != null) { terrainTreesList[trIdx].showTree = isExpanded; }
                }
            }
        }

        private void UndoTrees()
        {
            if (landscape != null)
            {
                EditorUtility.DisplayProgressBar("Undo Tree Modification", "Please Wait", 0.5f);
                landscape.RevertToLastSave(LBLandscape.UndoType.Trees);

                if (autoSaveEnabled) { sceneSaved = EditorSceneManager.SaveScene(EditorSceneManager.GetActiveScene()); }
                else { EditorSceneManager.MarkSceneDirty(EditorSceneManager.GetActiveScene()); }
                EditorUtility.ClearProgressBar();
            }
        }

        #endregion

        #region Grass Methods

        private void UndoGrass()
        {
            if (landscape != null)
            {
                EditorUtility.DisplayProgressBar("Undo Grass Modification", "Please Wait", 0.5f);
                landscape.RevertToLastSave(LBLandscape.UndoType.Grass);

                if (autoSaveEnabled) { sceneSaved = EditorSceneManager.SaveScene(EditorSceneManager.GetActiveScene()); }
                else { EditorSceneManager.MarkSceneDirty(EditorSceneManager.GetActiveScene()); }
                EditorUtility.ClearProgressBar();
            }
        }

        /// <summary>
        /// Expand or collapse the details of each grass type in the list
        /// </summary>
        /// <param name="isExpanded"></param>
        private void GrassListExpand(bool isExpanded)
        {
            if (terrainGrassList != null)
            {
                for (int grIdx = 0; grIdx < terrainGrassList.Count; grIdx++)
                {
                    if (terrainGrassList[grIdx] != null) { terrainGrassList[grIdx].showGrass = isExpanded; }
                }
            }
        }

        /// <summary>
        /// 1. Checks to see if the HQ Photographic Textures Grass Packs or Rustic Grass is installed
        /// 2. Loads the grass configs from the file or creates a new file.
        /// 3. Adds any new grasses to the list with default settings
        /// </summary>
        private void RefreshHQPhotographicTextures()
        {
            List<string> texturePathList = null;

            // Check to see if HQ Photographic Texture packs are installed in the current project
            if (string.IsNullOrEmpty(pathHQPhotoPackVol1)) { pathRusticGrass = LBSavedData.GetHQPhotographicTexturesVol1DefaultPath; }
            if (string.IsNullOrEmpty(pathHQPhotoPackVol1)) { isHQPhotoPackVol1Installed = false; }
            else { isHQPhotoPackVol1Installed = LBEditorHelper.IsProjectFolderAvailable("Assets/" + pathHQPhotoPackVol1); }

            if (string.IsNullOrEmpty(pathHQPhotoPackVol2)) { pathRusticGrass = LBSavedData.GetHQPhotographicTexturesVol2DefaultPath; }
            if (string.IsNullOrEmpty(pathHQPhotoPackVol2)) { isHQPhotoPackVol2Installed = false; }
            else { isHQPhotoPackVol2Installed = LBEditorHelper.IsProjectFolderAvailable("Assets/" + pathHQPhotoPackVol2); }

            if (string.IsNullOrEmpty(pathRusticGrass)) { pathRusticGrass = LBSavedData.GetRusticGrassDefaultPath; }
            if (string.IsNullOrEmpty(pathRusticGrass)) { isRusticGrassInstalled = false; }
            else { isRusticGrassInstalled = LBEditorHelper.IsProjectFolderAvailable("Assets/" + pathRusticGrass); }

            if (grassConfigList == null) { grassConfigList = new List<LBGrassConfig>(); }
            if (grassConfigList == null)
            {
                Debug.LogError("Landscape Builder Window.RefreshHQPhotographicTextures - could not create new GrassConfigList");
            }
            else
            {
                if (isHQPhotoPackVol1Installed)
                {
                    string sourceNameHQPhotoPackVol1 = LBSavedData.GetHQPhotographicTexturesVol1SourceName;
                    texturePathList = LBEditorHelper.GetTexturePathListFromFolder("Assets/" + pathHQPhotoPackVol1, ".psd");
                    AddTexturesToGrassConfigList(texturePathList, sourceNameHQPhotoPackVol1, "Assets/" + pathHQPhotoPackVol1 + "/RealLife", "jpg");
                }
                if (isHQPhotoPackVol2Installed)
                {
                    string sourceNameHQPhotoPackVol2 = LBSavedData.GetHQPhotographicTexturesVol2SourceName;
                    texturePathList = LBEditorHelper.GetTexturePathListFromFolder("Assets/" + pathHQPhotoPackVol2, ".psd");
                    AddTexturesToGrassConfigList(texturePathList, sourceNameHQPhotoPackVol2, "Assets/" + pathHQPhotoPackVol2 + "/RealLife", "jpg");
                }
                if (isRusticGrassInstalled)
                {
                    string sourceNameRusticGrass = LBSavedData.GetRusticGrassSourceName;
                    texturePathList = LBEditorHelper.GetTexturePathListFromFolder("Assets/" + pathRusticGrass, ".psd");
                    AddTexturesToGrassConfigList(texturePathList, sourceNameRusticGrass, "Assets/" + pathRusticGrass + "/RealLife", "jpg");
                }

                LBGrassSetup lbGrassSetup = new LBGrassSetup();
                if (lbGrassSetup != null)
                {
                    // grassConfigList is a global variable that gets populated by
                    // calling AddTexturesToGrassConfigList() 
                    lbGrassSetup.lbGrassConfigList = grassConfigList;
                    // Save the list to disk
                    lbGrassSetup.Save();
                }
            }
        }

        private void AddTexturesToGrassConfigList(List<string> texturePathList, string sourceName, string alternativeTexturePath, string alternativeTextureFileType)
        {
            if (texturePathList != null)
            {
                string grassTextureName = string.Empty;

                foreach (string grassPath in texturePathList)
                {
                    // Extract the grass texture name from the path
                    string[] pathSplit = grassPath.Split('/');
                    if (pathSplit.Length > 2) { grassTextureName = pathSplit[pathSplit.Length - 1]; }
                    else { grassTextureName = string.Empty; }

                    // Find the grass in the grassConfigList
                    LBGrassConfig lbGrassconfig = grassConfigList.Find(g => g.grassTextureName == grassTextureName && g.sourceName == sourceName);
                    if (lbGrassconfig == null)
                    {
                        // Ignore grass textures in any ground folder as Rustic Grass also contains some ground coverage textures
                        if (grassPath.ToLower().Contains("grounds/") || grassPath.ToLower().Contains("ground/")) { continue; }

                        LBGrassConfig newGrassConfig = new LBGrassConfig();
                        if (newGrassConfig != null)
                        {
                            // default configuration
                            if (!string.IsNullOrEmpty(grassTextureName))
                            {
                                newGrassConfig.grassTextureName = grassTextureName;
                                newGrassConfig.grassTexturePath = grassPath;

                                // Remove the file extension and add the alternative file extension
                                string alternativeTextureName = grassTextureName.Substring(0, grassTextureName.LastIndexOf('.')) + "." + alternativeTextureFileType;
                                newGrassConfig.grassTextureAlternativePath = alternativeTexturePath + "/" + alternativeTextureName;
                                newGrassConfig.sourceName = sourceName;
                                newGrassConfig.grassPatchFadingMode = LBGrassConfig.GrassPatchFadingMode.Fade;
                                newGrassConfig.healthyColour = Color.white;
                                newGrassConfig.dryColour = new Color(0.8f, 0.8f, 0.8f, 1f);
                                newGrassConfig.detailRenderMode = DetailRenderMode.GrassBillboard;
                                newGrassConfig.minWidth = 0.3f;
                                newGrassConfig.maxWidth = 0.5f;
                                newGrassConfig.minHeight = 0.1f;
                                newGrassConfig.maxHeight = 0.3f;
                                grassConfigList.Add(newGrassConfig);
                                Debug.Log("LB Window.AddTexturesToGrassConfigList: " + newGrassConfig.grassTextureName + " added to " + sourceName);
                            }
                        }
                    }
                    else
                    {
                        // Update the paths
                        lbGrassconfig.grassTexturePath = grassPath;

                        // Remove the file extension and add the alternative file extension
                        string alternativeTextureName = grassTextureName.Substring(0, grassTextureName.LastIndexOf('.')) + "." + alternativeTextureFileType;
                        lbGrassconfig.grassTextureAlternativePath = alternativeTexturePath + "/" + alternativeTextureName;

                        //lbGrassconfig.texture2D = (Texture2D)AssetDatabase.LoadAssetAtPath(grassPath, typeof(Texture2D));
                        //Debug.Log("AddTexturesToGrassConfigList: " + grassTextureName + " already exists");
                        //Debug.Log("alternativeTextureName:  " + lbGrassconfig.grassTextureAlternativePath);
                    }
                }
            }
        }

        /// <summary>
        /// Load any grass config's from the grass setup file on disk
        /// Disk file is located at [ProjectName]/LandscapeBuilder/LBGrassSetup.dat
        /// </summary>
        private void RefreshGrassConfigList()
        {
            if (grassConfigList == null) { grassConfigList = new List<LBGrassConfig>(); }
            LBGrassSetup lbGrassSetup = new LBGrassSetup();
            if (lbGrassSetup != null)
            {
                lbGrassSetup.Retrieve();
                if (lbGrassSetup.lbGrassConfigList != null)
                {
                    grassConfigList.Clear();
                    grassConfigList.AddRange(lbGrassSetup.lbGrassConfigList);
                }
            }
        }

        /// <summary>
        /// Get the list of LBTerrainGrass that have been saved or applied to the landscape.
        /// This could include Disabled grasses. These come from the Grass tab (not from the
        /// actual terrains).
        /// </summary>
        private void RefreshAppliedGrassList()
        {
            appliedGrassList = landscape.TerrainGrassList();
            if (appliedGrassList != null)
            {
                appliedGrassArray = LBTerrainGrass.GetGrassNameArray(appliedGrassList);
            }
            else { appliedGrassArray = null; }
        }

        #endregion

        #region Mesh/Preb Methods

        /// <summary>
        /// Expand or collapse the details of each mesh/prefab in the list
        /// </summary>
        /// <param name="isExpanded"></param>
        private void MeshPrefabListExpand(bool isExpanded)
        {
            if (landscapeMeshList != null)
            {
                for (int mshIdx = 0; mshIdx < landscapeMeshList.Count; mshIdx++)
                {
                    if (landscapeMeshList[mshIdx] != null) { landscapeMeshList[mshIdx].showMesh = isExpanded; }
                }
            }
        }

        #endregion

        #region Group Methods

        /// <summary>
        /// Create a new Group by importing selected prefabs from the scene
        /// </summary>
        private bool ImportGroup()
        {
            bool isGroupImported = false;

            // Get all the currently selected transforms. This includes those in the scene AND the project folder
            Transform[] selectedTransforms = Selection.GetTransforms(SelectionMode.OnlyUserModifiable);
            int grpIdxGroupDesigner = lbGroupList.FindIndex(grp => grp.showGroupDesigner == true);

            if (landscape == null)
            {
                EditorUtility.DisplayDialog("Import Group", "Could not find current landscape. PLEASE REPORT", "Ok");
            }
            else if (grpIdxGroupDesigner >= 0)
            {
                EditorUtility.DisplayDialog("Import Group", "Please close the GroupDesigner for Group " + grpIdxGroupDesigner.ToString(), "Ok");
            }
            else if (selectedTransforms == null)
            {
                EditorUtility.DisplayDialog("Import Group", "To import prefabs into a new Group, select them in the Scene, then click 'Import Group'", "Got it!");
            }
            else
            {
                // Loop through all the selected transforms and only add prefabs in the scene.
                int numSelectedObjs = selectedTransforms == null ? 0 : selectedTransforms.Length;
                List<Transform> selectedPrefabs = new List<Transform>();

                for (int s = 0; s < numSelectedObjs; s++)
                {
                    Transform trfm = selectedTransforms[s];                    

                    //PrefabType prefabType = PrefabUtility.GetPrefabType(trfm);

                    if (LBEditorHelper.IsPrefabInstance(trfm, false))
                    {
                        selectedPrefabs.Add(trfm);                        
                    }
                }

                int numPrefabs = selectedPrefabs == null ? 0 : selectedPrefabs.Count;

                if (numPrefabs > 0)
                {
                    LBGroup lbGroupImported = new LBGroup();
                    if (lbGroupImported != null)
                    {
                        lbGroupImported.lbGroupType = LBGroup.LBGroupType.ManualClearing;
                        lbGroupImported.groupName = "New Group (Please rename)";
                        Bounds newGroupBounds = new Bounds();
                        float maxMemberExtent = 0f;

                        int numGpMbrsImported = 0;

                        // Keep a record of which prefabs where imported. At the end, the user
                        // is prompted if they wish to delete the originals from the scene.
                        List<Transform> prefabsToDelete = new List<Transform>();

                        // Create GroupMembers for each of the prefab instances in the scene
                        for (int pfIdx = 0; pfIdx < numPrefabs; pfIdx++)
                        {
                            Transform prefabToImport = selectedPrefabs[pfIdx];
                            if (prefabToImport != null)
                            {
                                // Only add Group Members that have a source prefab in the project folder
                                GameObject prefabSource = LBEditorHelper.GetPrefabSource(prefabToImport.gameObject);
                                if (prefabSource == null)
                                {
                                    Debug.Log("[INFO] ImportGroup - could not add prefab in scene (" + prefabToImport.name + ") because we could not locate the source prefab from the Project folder.");
                                }
                                // Ignore prefabsource that have LBPrefabItem component (this should be a are edge case)
                                // where use has made a prefab of prefab already in a Group
                                else if (prefabSource.GetComponentInChildren(typeof(LBPrefabItem), true) != null)
                                {
                                    Debug.Log("[INFO] ImportGroup - could not add prefab in scene (" + prefabToImport.name + ") because the source prefab (" + prefabSource.name + ") in the Project folder has a LBPrefabItem component");
                                }
                                else if (prefabSource.GetComponentInChildren(typeof(Terrain), true) != null)
                                {
                                    Debug.Log("[INFO] ImportGroup - could not add prefab in scene (" + prefabToImport.name + ") because the source prefab (" + prefabSource.name + ") in the Project folder has a Terrain component");
                                }
                                else
                                {
                                    LBGroupMember lbGroupMemberToImport = new LBGroupMember();
                                    if (lbGroupMemberToImport != null)
                                    {
                                        // Remember the prefabs that were imported from the scene
                                        prefabsToDelete.Add(prefabToImport);

                                        // Link this member to the prefab in the project folder (not the instance in the scene)
                                        lbGroupMemberToImport.prefab = prefabSource;
                                        lbGroupMemberToImport.isPlacedInCentre = true;
                                        lbGroupMemberToImport.showInEditor = false;
                                        lbGroupMemberToImport.isKeepPrefabConnection = true;

                                        // Use the source prefab to get the correct extents
                                        Bounds prefabBounds = LBEditorHelper.GetPrefabBounds(prefabSource.transform, true);

                                        // Is the extent (distance from centre to edge) of this prefab, greater that other prefabs in this new Group?
                                        if (prefabBounds.extents.x > maxMemberExtent) { maxMemberExtent = prefabBounds.extents.x; }
                                        if (prefabBounds.extents.z > maxMemberExtent) { maxMemberExtent = prefabBounds.extents.z; }

                                        lbGroupMemberToImport.UpdateProximity(prefabBounds);

                                        // Add the current location of the prefab in the scene
                                        prefabBounds.center += prefabToImport.position;

                                        // Extend the size of the group with the size of the current prefab
                                        if (numGpMbrsImported == 0) { newGroupBounds.SetMinMax(prefabBounds.min, prefabBounds.max); }
                                        else { newGroupBounds.Encapsulate(prefabBounds); }

                                        // Assign temporary offsets
                                        lbGroupMemberToImport.minOffsetX = prefabToImport.position.x;
                                        lbGroupMemberToImport.minOffsetZ = prefabToImport.position.z;
                                        lbGroupMemberToImport.rotationType = LBGroupMember.LBRotationType.GroupSpace;
                                        lbGroupMemberToImport.startRotationY = prefabToImport.rotation.eulerAngles.y;
                                        lbGroupMemberToImport.endRotationY = lbGroupMemberToImport.startRotationY;
                                        lbGroupMemberToImport.randomiseRotationY = false;
                                        lbGroupMemberToImport.randomiseOffsetY = false;
                                        // Get distance above the terrain
                                        lbGroupMemberToImport.minOffsetY = prefabToImport.position.y - LBLandscapeTerrain.GetHeight(landscape, new Vector2(prefabToImport.position.x, prefabToImport.position.z), false);
                                        lbGroupMemberToImport.maxOffsetY = lbGroupMemberToImport.minOffsetY;

                                        // Allows user to see members exactly as they were placed in the scene when imported.
                                        lbGroupMemberToImport.isIgnoreProximityOfOthers = true;

                                        lbGroupImported.groupMemberList.Add(lbGroupMemberToImport);
                                        numGpMbrsImported++;
                                    }
                                }
                            }
                        }

                        numGpMbrsImported = lbGroupImported.groupMemberList == null ? 0 : lbGroupImported.groupMemberList.Count;

                        if (numGpMbrsImported > 0)
                        {
                            // Loop through all the members and update position with distance from the centre of the new group
                            for (int gpMbrIdx = 0; gpMbrIdx < numGpMbrsImported; gpMbrIdx++)
                            {
                                LBGroupMember lbGroupMemberImported = lbGroupImported.groupMemberList[gpMbrIdx];
                                if (lbGroupMemberImported != null)
                                {
                                    lbGroupMemberImported.minOffsetX -= newGroupBounds.center.x;
                                    lbGroupMemberImported.minOffsetZ -= newGroupBounds.center.z;
                                }
                            }

                            // Set the radius of the new clearing based on the extents of all the prefabs
                            lbGroupImported.minClearingRadius = newGroupBounds.extents.x > newGroupBounds.extents.z ? newGroupBounds.extents.x : newGroupBounds.extents.z;
                            // Due to prefab rotation, the prefabs may overhang the edge of the Group.
                            // As a workaround, increase the size of the Group by the distance between the prefab centre and prefab edge of the largest prefab
                            lbGroupImported.minClearingRadius += maxMemberExtent;
                            lbGroupImported.maxClearingRadius = lbGroupImported.minClearingRadius;

                            lbGroupList.Insert(0, lbGroupImported);

                            // Add a manual clearing at the centre of the new group (positions are in landscape-space... I think)
                            if (lbGroupImported.positionList == null) { lbGroupImported.positionList = new List<Vector3>(); }
                            if (lbGroupImported.positionList != null) { lbGroupImported.positionList.Add(newGroupBounds.center - landscape.start); }

                            isGroupImported = true;

                            if (LBEditorHelper.PromptYesNo("Group Import", "Would you like to delete the imported prefabs from the scene?"))
                            {
                                int numPrefsImported = prefabsToDelete == null ? 0 : prefabsToDelete.Count;

                                if (numPrefsImported > 0)
                                {
                                    // Roll the deletes into a single Undo
                                    Undo.SetCurrentGroupName("Delete imported prefabs from scene");
                                    int undoGroup = Undo.GetCurrentGroup();

                                    Undo.RecordObjects(prefabsToDelete.ToArray(), "Delete prefabs");

                                    for (int pIdx = 0; pIdx < numPrefsImported; pIdx++)
                                    {
                                        Undo.DestroyObjectImmediate(prefabsToDelete[pIdx].gameObject);
                                    }
                                    Undo.CollapseUndoOperations(undoGroup);
                                }
                            }
                        }
                    }
                }
            }

            return isGroupImported;
        }

        /// <summary>
        /// Refresh the list of SubGroups in the currently selected landscape
        /// </summary>
        private void RefreshSubGroupLists()
        {
            isSubGroupNameListRefreshRequired = false;
            subGroupNameListLastRefreshed = 0f;

            int numGroups = lbGroupList == null ? 0 : lbGroupList.Count;

            // Create a GUID/name pair of SubGroups
            if (subGroupGUIDList == null) { subGroupGUIDList = new List<string>(numGroups); }
            if (subGroupNameList == null) { subGroupNameList = new List<string>(numGroups); }
              
            if (subGroupGUIDList != null && subGroupNameList != null)
            {
                subGroupGUIDList.Clear();
                subGroupNameList.Clear();

                for (index = 0; index < numGroups; index++)
                {
                    lbGroup = lbGroupList[index];
                    if (lbGroup.lbGroupType == LBGroup.LBGroupType.SubGroup)
                    {
                        subGroupGUIDList.Add(lbGroup.GUID);
                        subGroupNameList.Add(string.IsNullOrEmpty(lbGroup.groupName) ? "(No name)" : lbGroup.groupName + (lbGroup.isDisabled ? " [DISABLED]" : ""));
                    }
                }
            }
        }

        #endregion

        #region Object Path Methods

        /// <summary>
        /// Refresh the Object Path in the current landscape. We cannot include the Button because the context menu
        /// which this is called from contains a delegate which causes issues with GUI elements like Buttons.
        /// </summary>
        /// <param name="lbGroup"></param>
        /// <param name="lbGroupMember"></param>
        /// <param name="lbGroupDesigner"></param>
        /// <param name="isGroupDesignerInitialised"></param>
        private void RefreshObjPath(LBGroup lbGroup, LBGroupMember lbGroupMember, LBGroupDesigner lbGroupDesigner, bool isGroupDesignerInitialised)
        {
            if (lbGroup.lbGroupType == LBGroup.LBGroupType.Uniform)
            {
                if (landscape != null) { landscape.ApplyObjPath(lbGroup, lbGroupMember, true, true, true); }
            }
            // Clearing so, refresh the whole Group in the GroupDesigner
            else if (lbGroup.showGroupDesigner && isGroupDesignerInitialised && lbGroupDesigner != null)
            {
                lbGroupDesigner.RefreshObjPath(lbGroup, lbGroupMember);
            }
        }

        #region AppendPathPoint

        /// <summary>
        /// Add a point to the end of the current path
        /// </summary>
        /// <param name="pointToAdd"></param>
        private void AppendPathPoint(LBGroup lbGroupOwner, LBGroupMember lbGroupMemberOwner, LBObjPath lbObjPathAppend, Vector3 pointToAdd)
        {
            string methodName = "LB Window.AppendPathPoint";

            // Validate basics and get out early if there are issues
            if (lbObjPathAppend == null) { Debug.LogWarning("ERROR: " + methodName + " LBObjPath is null"); return; }
            else if (landscape == null) { Debug.LogWarning("ERROR: " + methodName + " landscape is null"); return; }

            LBPathPoint lbPathPointToAdd = null;

            if (lbObjPathAppend.positionList.Count > 0)
            {
                int currentLastItem = lbObjPathAppend.positionList.Count - 1;
                bool duplicateLastItem = (pointToAdd.x == 0f && pointToAdd.y == 0f && pointToAdd.z == 0f);

                // When another position is added, by default, make it a duplicate of the previous one
                if (duplicateLastItem)
                {
                    lbPathPointToAdd = new LBPathPoint(lbObjPathAppend.pathPointList[currentLastItem]);
                    if (lbPathPointToAdd != null)
                    {
                        lbObjPathAppend.pathPointList.Add(lbPathPointToAdd);
                        lbObjPathAppend.positionList.Add(lbObjPathAppend.positionList[currentLastItem]);
                    }
                }
                else
                {
                    // If a location was indicated on the landscape, add that one. This typically occurs when the
                    // user clicks the '+' key when the mouse is over the scene view.
                    
                    lbPathPointToAdd = new LBPathPoint();
                    if (lbPathPointToAdd != null)
                    {
                        lbObjPathAppend.pathPointList.Add(lbPathPointToAdd);
                        lbObjPathAppend.positionList.Add(pointToAdd);
                    }
                }

                // Clear the selection list and add this new path point
                lbObjPathAppend.selectedList.Clear();
                lbObjPathAppend.selectedList.Add(currentLastItem + 1);

                // Only zoom and change scene view camera if zoom is enabled AND we're NOT in the Group Designer
                if (lbObjPathAppend.zoomOnFind && lbGroupOwner.lbGroupType == LBGroup.LBGroupType.Uniform)
                {
                    LBEditorHelper.PositionSceneView(lbObjPathAppend.positionList[currentLastItem + 1], lbObjPathAppend.findZoomDistance, this.GetType());
                }
            }
            else
            {
                Vector3 firstPointCentre = Vector3.zero;

                if (landscape == null) { Debug.LogWarning("AppendPathPoint - cannot find landscape"); }
                else
                {
                    // If possible, place the first point on the landscape in the centre of the sceneview
                    firstPointCentre = LBEditorHelper.GetCentreSceneView(this.GetType());

                    Rect worldBounds = LBLandscapeTerrain.GetLandscapeWorldBounds(landscape.GetComponentsInChildren<Terrain>());

                    Vector2 firstPointXZ = new Vector2(firstPointCentre.x, firstPointCentre.z);

                    // Is the centre of the screen inside the landscape? If not, set to near bottom left corner of landscape
                    if (!worldBounds.Contains(firstPointXZ))
                    {
                        firstPointCentre.x = worldBounds.xMin + 20f;
                        firstPointCentre.z = worldBounds.yMin + 20f;

                        firstPointXZ.x = firstPointCentre.x;
                        firstPointXZ.y = firstPointCentre.z;
                    }

                    firstPointCentre.y = LBLandscapeTerrain.GetHeight(landscape, firstPointXZ, false) + lbObjPathAppend.heightAboveTerrain + landscape.start.y;

                    lbPathPointToAdd = new LBPathPoint();
                    if (lbPathPointToAdd != null)
                    {
                        lbObjPathAppend.pathPointList.Add(lbPathPointToAdd);
                        lbObjPathAppend.positionList.Add(firstPointCentre);

                        // Clear the selection list and add this new path point
                        lbObjPathAppend.selectedList.Clear();
                        lbObjPathAppend.selectedList.Add(0);

                        // Only zoom and change scene view camera if we're NOT in the Group Designer
                        if (lbGroupOwner.lbGroupType == LBGroup.LBGroupType.Uniform)
                        {
                            LBEditorHelper.PositionSceneView(lbObjPathAppend.positionList[0], lbObjPathAppend.findZoomDistance, this.GetType());
                        }    
                    }
                }
            }
        }

        #endregion

        /// <summary>
        /// Check if the ObjectPath Designer is currently open. Optionally display message to prompt the user to close it.
        /// </summary>
        /// <param name="showGroupMemberMsg"></param>
        /// <returns></returns>
        public bool IsObjPathDesignerOpen(bool showGroupMemberMsg = false)
        {
            bool isOpen = lbObjPathDesigner != null && lbObjPathDesigner.isInitialised && lbObjPathDesigner.lbGroup != null;

            // Do not permit height generation from the Topography tab, when a Group Object Path is being edited
            if (isOpen && showGroupMemberMsg)
            {
                // Find the group member id which is being edited
                int grpMbrIdx = lbObjPathDesigner.lbGroup.groupMemberList.FindIndex(gmbr => gmbr.GUID == lbObjPathDesigner.lbGroupMember.GUID);

                EditorGUILayout.HelpBox("Please close the Object Path Editor in Group '" + lbObjPathDesigner.lbGroup.groupName + "' - Group Member " + (grpMbrIdx + 1).ToString(), MessageType.Info, true);
            }

            return isOpen;
        }

        #endregion

        #region Prefab Methods

        /// <summary>
        /// Return the name of the prefab in brackets. Optionally supply the last known
        /// prefab name to detect missing prefabs.
        /// </summary>
        /// <param name="prefab"></param>
        /// <param name="prefabTypeDesc"></param>
        /// <param name="lastKnownPrefabName"></param>
        /// <returns></returns>
        private string GetPrefabName(GameObject prefab, string prefabTypeDesc, string lastKnownPrefabName = "")
        {
            if (prefab != null) { return " (" + prefab.name + ")"; }
            else if (!string.IsNullOrEmpty(lastKnownPrefabName)) { return " (" + lastKnownPrefabName + ") N/A"; }
            else { return " (No " + prefabTypeDesc + " prefab)"; }
        }

        #endregion

        #region Unity Tags

        /// <summary>
        /// Refresh the list of Unity Tags in the current project
        /// </summary>
        private void RefreshTagList()
        {
            if (tagList == null) { tagList = new List<string>(); }

            if (tagList != null)
            {
                SerializedObject tagManager = new SerializedObject(AssetDatabase.LoadAllAssetsAtPath("ProjectSettings/TagManager.asset")[0]);

                if (tagManager == null) { Debug.LogWarning("LB Editor.RefreshTagList - TagManager.asset could not be found, so tags could not be refreshed."); }
                else
                {
                    // Get the array of tags
                    SerializedProperty tags = tagManager.FindProperty("tags");
                    if (tags == null) { Debug.LogWarning("LB Editor.RefreshTagList - Tags Serialized Property is null, so tags could not be refreshed"); }
                    else
                    {
                        if (!tags.isArray) { Debug.LogWarning("LB Editor.RefreshTagList - Tags Serialized Property is not in the expected format (array), so tags could not be refreshed."); }
                        {
                            if (tags.arraySize > 0)
                            {
                                tagList.Clear();

                                // Iterate through the list of tags
                                for (int t = 0; t < tags.arraySize; t++)
                                {
                                    tagList.Add(tags.GetArrayElementAtIndex(t).stringValue);
                                }
                                tagList.Sort();

                                // Always add the default to the top of the list
                                tagList.Insert(0, LBFilter.FilterByAllTags);
                            }
                        }
                    }
                }
            }
        }

        #endregion

        #region Landscape Selection

        public void SelectLandscape(LBLandscape landscapeToSelect)
        {
            GameObject parentGO = landscapeToSelect.gameObject;
            if (parentGO != null)
            {
                landscapeGameObjectSelection = parentGO;
                CheckSwitchLandscapeSelection(false);
            }
        }

        /// <summary>
        /// A different landscape may have been selected, so update
        /// texture, tree, grass and mesh lists.
        /// Optionally warn user if tried to drag in a terrain without a LB Landscape component
        /// </summary>
        /// <param name="warnIfTerrainOnly"></param>
        private void CheckSwitchLandscapeSelection(bool warnIfTerrainOnly = false)
        {
            if ((landscapeSelection == null && landscape == null) || (landscapeGameObjectSelection != landscapeGameObject))
            {
                landscapeSelection = landscapeGameObjectSelection.GetComponent<LBLandscape>();

                // Make sure the GameObject has an attached LBLandscape script
                if (landscapeSelection == null)
                {
                    // The GameObject doesn't look like a valid Landscape
                    if (warnIfTerrainOnly && landscapeGameObjectSelection.GetComponent<Terrain>() != null)
                    {
                        // NOTE: Saving the scene will not update landscapeGameObjectSelection.
                        EditorUtility.DisplayDialog("Import Terrain", "If you wish to import a single terrain into a new Landscape, attach a LB Landscape script first.\n\n" +
                                                        "If you have multiple terrains OR this one is not a root level object in the scene, consult the manual (Help Button), seek help on the forum " +
                                                        "(Get Support button) or contact us on our Discord channel", "Got It!");
                    }
                    landscapeGameObjectSelection = null;
                    landscapeSelection = null;
                    landscape = null;
                    TerrainTexturesAvailableList = null;
                    landscapeMinMaxHeight = Vector2.zero;
                    lbGroupShowLocations = null;
                    useProjectForTerrainData = false;
                    terrainDataFolder = string.Empty;
                    // Added LB 2.1.5
                    LBEditorCommon.currentLandscape = null;
                    isReparentRequired = false;

                    #if VEGETATION_STUDIO_PRO
                    vsPro = null;
                    #endif
                }
                else
                {
                    landscape = landscapeSelection;
                    LBEditorCommon.currentLandscape = landscape;

                    LoadLandscapeSettings();
                }
            }
        }

        /// <summary>
        /// In the scene view, zoom to the extent of the landscape.
        /// </summary>
        public void ZoomAllLandscape()
        {
            if (landscapeGameObject != null)
            {
                Selection.activeGameObject = landscapeGameObject;
                LBEditorHelper.FrameObjectInSceneView(landscape.size.x * 1.5f, new Vector3(30f, 0f, 0f), this.GetType());
            }
        }

        #endregion

        #region Load Landscape Settings

        /// <summary>
        /// Load all the class lists, the terrain settings etc
        /// from the LBLandscape object into the editor variables.
        /// </summary>
        private void LoadLandscapeSettings()
        {
            if (landscape != null)
            {
                landscapeGameObject = landscape.gameObject;
                topographyLayers = landscape.TopographyLayersList();
                terrainTexturesList = landscape.TerrainTexturesList();
                terrainTreesList = landscape.TerrainTreesList();
                terrainGrassList = landscape.TerrainGrassList();
                landscapeMeshList = landscape.LandscapeMeshList();
                lbGroupList = landscape.GroupList();

                // A different landscape has been selected or Unity was just (re)started
                landscapeHasSwitched = true;

                // Get the list of textures contained in the terrain alphamaps
                RefreshTerrainTexturesAvailableList();

                RefreshAppliedTexturesList();
                RefreshAppliedGrassList();

                RefreshSubGroupLists();

                // Set settings variables to the corresponding settings of the newly selected landscape
                GetLandscapeTerrainSettings();

                // Save the last selected landscape to disk
                LBLandscape.SetLastLandscapeGameObjectSelection(landscapeGameObjectSelection.name);

                // User has switched landscapes so refresh min/max heights. This is relatively
                // slow so we don't want to update these each OnGUI call.
                landscapeMinMaxHeight = landscape.GetLandscapeMinMaxHeights();

                useProjectForTerrainData = landscape.useProjectForTerrainData;
                terrainDataFolder = landscape.terrainDataFolder;

                //Debug.Log("[DEBUG] terraindata folder: " + terrainDataFolder);

                #if VEGETATION_STUDIO_PRO
                if (landscape.useVegetationSystem && vsPro == null) { vsPro = LBIntegration.GetVegetationSystemPro(); }
                #endif
            }
        }
        #endregion

        #region Render Pipeline Methods
        private void CheckInstalledRenderPipelines()
        {
            // Check to see if Universal Render Pipeline is installed in the project
            isURP = LBLandscape.IsURP(false);

            // Check to see if Light Weight Render Pipeline is installed in this project
            isLWRP = !isURP && LBLandscape.IsLWRP(false);

            // Check to see if High Definition Render Pipeline is installed in this project
            isHDRP = !isURP && !isLWRP && LBLandscape.IsHDRP(false);
        }

        #endregion

        #region Event / On... Methods

        private void OnEnable()
        {
            isJustEnabled = true;
            // Load the tab icons
            if (tabTexts != null)
            {
                //LBEditorHelper.LoadGUIContentIcon(tabTexts[0], "lblandscapeicon.png", "LandscapeBuilderWindow.OnEnable");
                //LBEditorHelper.LoadGUIContentIcon(tabTexts[1], "lbtopographyicon.png", "LandscapeBuilderWindow.OnEnable");
                //LBEditorHelper.LoadGUIContentIcon(tabTexts[2], "lbgroupsicon.png", "LandscapeBuilderWindow.OnEnable");
                ////LBEditorHelper.LoadGUIContentIcon(tabTexts[3], "lbtexturingicon.png", "LandscapeBuilderWindow.OnEnable");
                //LBEditorHelper.LoadGUIContentIcon(tabTexts[4], "lbtreesicon.png", "LandscapeBuilderWindow.OnEnable");
                //LBEditorHelper.LoadGUIContentIcon(tabTexts[5], "lbgrassicon.png", "LandscapeBuilderWindow.OnEnable");
                //LBEditorHelper.LoadGUIContentIcon(tabTexts[6], "lbmeshicon.png", "LandscapeBuilderWindow.OnEnable");
                //LBEditorHelper.LoadGUIContentIcon(tabTexts[7], "lbexporticon.png", "LandscapeBuilderWindow.OnEnable");
                //LBEditorHelper.LoadGUIContentIcon(tabTexts[8], "lbadvancedicon.png", "LandscapeBuilderWindow.OnEnable");
            }
            
            // Group Designer
            groupsDesignerToolbarContent[0] = groupsDesignerToolbarGeneralContent;
            groupsDesignerToolbarContent[1] = groupsDesignerToolbarDefaultContent;
            groupsDesignerToolbarContent[2] = groupsDesignerToolbarStencilContent;
            groupsDesignerToolbarContent[3] = groupsDesignerToolbarZoneContent;
            groupsDesignerToolbarContent[4] = groupsDesignerToolbarTextureContent;
            groupsDesignerToolbarContent[5] = groupsDesignerToolbarGrassContent;

            groupsMemberDesignerToolbarContent[0] = groupsMemberDesignerToolbarGeneralContent;
            groupsMemberDesignerToolbarContent[1] = groupsMemberDesignerToolbarXYZContent;
            groupsMemberDesignerToolbarContent[2] = groupsMemberDesignerToolbarProximityContent;
            groupsMemberDesignerToolbarContent[3] = groupsMemberDesignerToolbarZoneContent;
            groupsMemberDesignerToolbarContent[4] = groupsMemberDesignerToolbarPathContent;

            groupsMemberObjPathToolbarContent[0] = groupsMemberDesignerToolbarGeneralContent;
            groupsMemberObjPathToolbarContent[1] = groupsMemberObjPathToolbarObjectsContent;
            groupsMemberObjPathToolbarContent[2] = groupsMemberObjPathToolbarPointsContent;
            groupsMemberObjPathToolbarContent[3] = groupsMemberObjPathToolbarSurfaceContent;       

#if UNITY_2019_1_OR_NEWER
            SceneView.duringSceneGui -= SceneGUI;
            SceneView.duringSceneGui += SceneGUI;
#else
            SceneView.onSceneGUIDelegate -= SceneGUI;
            SceneView.onSceneGUIDelegate += SceneGUI;
#endif

            currentScene = EditorSceneManager.GetActiveScene().name;

            // Set the icon for the window
            Texture2D windowIcon = (Texture2D)AssetDatabase.LoadAssetAtPath("Assets/LandscapeBuilder/LB1Icon.psd", typeof(Texture2D));
            if (windowIcon != null) { this.titleContent.image = windowIcon; }
            else { Debug.LogWarning("Inspector title icon could not be found at path: Assets/LandscapeBuilder/LB1Icon.psd"); }

            landscape = null;
            landscapeGameObject = null;
            // Added LB 2.1.5
            LBEditorCommon.currentLandscape = null;

            // Stops warning "variable is assigned but its value is never used" from appearing in the compiler
            if (testColour == Color.blue) { }
            if (keyInt == 1) { }
            if (sceneSaved) { }

            // Ensure preset dropdown lists are always available
            GetDRPresetNames();

            // remove any old highlighters from the hierarchy
            CleanupHighlighters();

            layerNameListRestricted = LBEditorHelper.GetLayerList(true);

            // Get the paths to the HQ Photographic Textures folders
            pathHQPhotoPackVol1 = LBLandscape.GetPath(LBSavedData.PathType.HQPhotographicTexturesVol1);
            pathHQPhotoPackVol2 = LBLandscape.GetPath(LBSavedData.PathType.HQPhotographicTexturesVol2);

            if (string.IsNullOrEmpty(pathHQPhotoPackVol1))
            {
                LBLandscape.SetPath(LBSavedData.PathType.HQPhotographicTexturesVol1, LBSavedData.GetHQPhotographicTexturesVol1DefaultPath);
                pathHQPhotoPackVol1 = LBLandscape.GetPath(LBSavedData.PathType.HQPhotographicTexturesVol1);
            }

            if (string.IsNullOrEmpty(pathHQPhotoPackVol2))
            {
                LBLandscape.SetPath(LBSavedData.PathType.HQPhotographicTexturesVol2, LBSavedData.GetHQPhotographicTexturesVol2DefaultPath);
                pathHQPhotoPackVol2 = LBLandscape.GetPath(LBSavedData.PathType.HQPhotographicTexturesVol2);
            }

            RefreshGrassConfigList();
            RefreshHQPhotographicTextures();

            // Build a link to the file manual.
#if UNITY_EDITOR_OSX
            lbHelpPDF = "File:///" + Application.dataPath.Replace(" " ,"%20") + "/LandscapeBuilder/Landscape%20Builder.pdf";
#else
            lbHelpPDF = "file:///" + Application.dataPath + "/LandscapeBuilder/Landscape Builder.pdf";
#endif

            RefreshTagList();

            // Check if AQUAS River is installed
            isAQUASRiverInstalled = LBIntegration.isAQUASRiverInstalled(false);
            pathFlowMapPainter = LBLandscape.GetPath(LBSavedData.PathType.FlowMapPainterExe);

            // Check if Calm Water is installed
            isCalmWaterInstalled = LBIntegration.IsCalmWaterInstalled(false);

            // Check if MegaSplat is installed
            isMegaSplatInstalled = LBIntegration.IsMegaSplatInstalled(false);
            if (isMegaSplatInstalled) { megaSplatVersion = LBIntegration.MegaSplatGetVersion(true); }

            // Check if MicroSplat is installed
            isMicroSplatInstalled = LBIntegration.IsMicroSplatInstalled();

            // Check if Vegetation is installed
            isVegetationStudioInstalled = LBIntegration.IsVegetationStudioInstalled(false);
            isVegetationStudioProInstalled = LBIntegration.IsVegetationStudioProInstalled();

            if (EditorGUIUtility.isProSkin) { txtColourName = "White"; }

            isLinearColourSpace = (QualitySettings.activeColorSpace == ColorSpace.Linear);

            RefreshModifierLists("PNG");
            RefreshModifierLists("RAW");

            lbGroupShowLocations = null;
            manualClearingGroupMaterial = LBEditorHelper.GetMaterialFromAssets(LBSetup.materialsFolder, "LBLocation.mat");

            displayLabelColor = Handles.color;
            displayLabelColor.a = 1f;

            CheckInstalledRenderPipelines();
        }

        /// <summary>
        /// Show Terrain Labels
        /// GroupDesigner adjust camera plane
        /// Manual Clearing locations Context Menu
        /// </summary>
        /// <param name="sv"></param>
        private void SceneGUI(SceneView sv)
        {
            Event currentEvent = Event.current;

            if (currentEvent.type == EventType.MouseDown && currentEvent.button == 0) { mouseClickEvent = true; }

            #region Terrain Labels
            // If enabled, display the terrain names in the scene view.
            if (displayTerrainLabels && landscape != null && landscapeTerrains != null)
            {
                for (displayTerrainLabelIdx = 0; displayTerrainLabelIdx < landscapeTerrains.Length; displayTerrainLabelIdx++)
                {
                    Vector3 pos = landscapeTerrains[displayTerrainLabelIdx].GetPosition();
                    displayLabelNamePos.x = pos.x + (terrainWidth / 2) - 100;
                    displayLabelNamePos.z = pos.z + (terrainLength / 2) + 100;
                    displayLabelNamePos.y = pos.y;

                    Handles.Label(displayLabelNamePos, landscapeTerrains[displayTerrainLabelIdx].name, displayTerrainNameLabel);
                    //Handles.PositionHandle(displayLabelNamePos, Quaternion.identity);
                }
            }
            #endregion

            #region GroupDesigner Camera Plane movement
            // If the Group Designer is enabled, update the camera plane to remain in-front of the scene view camera.
            if (lbGroupDesigner != null)
            {
                // Check GroupDesigner workspace (objects) aren't being refreshed. If the base plane
                // was deleted (due to any bugs), it may try to call RefreshWorkspace many times in a row which may
                // lead to the Unity Editor becoming unresponsive for an excessive amount of time.
                if (lbGroupDesigner.isInitialised && !lbGroupDesigner.IsRefreshingWorkspace)
                {
                    if (lbGroupDesigner.grpBasePlaneTrfm != null)
                    {
                        // Reset the camera plane position if the user has changed it
                        if (lbGroupDesigner.cameraPlaneTrfm != null) { lbGroupDesigner.cameraPlaneTrfm.localPosition = Vector3.zero; }

                        // Ensure user hasn't changed to orthographic
                        sv.orthographic = false;

                        Camera svCamera = sv.camera;
                        float tanCameraAngle = Mathf.Tan(svCamera.fieldOfView * Mathf.Deg2Rad * 0.5f);
                        // Lock the camera position within the limits
                        float minClipHeight = svCamera.nearClipPlane * tanCameraAngle * 2f;
                        if (minClipHeight > 1f) { minClipHeight = 1f; }
                        Vector3 pivotOffset = sv.pivot - svCamera.transform.position;
                        Vector3 relativeCamPos = svCamera.transform.position - lbGroupDesigner.grpBasePlaneTrfm.position;
                        if (relativeCamPos.x < lbGroupDesigner.cubeLimitsSize * -0.5f) { relativeCamPos.x = lbGroupDesigner.cubeLimitsSize * -0.5f; }
                        if (relativeCamPos.x > lbGroupDesigner.cubeLimitsSize * 0.5f) { relativeCamPos.x = lbGroupDesigner.cubeLimitsSize * 0.5f; }
                        if (relativeCamPos.y < minClipHeight) { relativeCamPos.y = minClipHeight; }
                        if (relativeCamPos.y > lbGroupDesigner.cubeLimitsSize) { relativeCamPos.y = lbGroupDesigner.cubeLimitsSize; }
                        if (relativeCamPos.z < lbGroupDesigner.cubeLimitsSize * -0.5f) { relativeCamPos.z = lbGroupDesigner.cubeLimitsSize * -0.5f; }
                        if (relativeCamPos.z > lbGroupDesigner.cubeLimitsSize * 0.5f) { relativeCamPos.z = lbGroupDesigner.cubeLimitsSize * 0.5f; }
                        sv.pivot = relativeCamPos + lbGroupDesigner.grpBasePlaneTrfm.position + pivotOffset;
                        // Position the quad a constant distance from the camera
                        float quadDistToCam = lbGroupDesigner.cubeLimitsSize * 1.75f;
                        // Need to adjust distance in case of really low/high clipping planes
                        if (quadDistToCam < svCamera.nearClipPlane) { quadDistToCam = svCamera.nearClipPlane * 1.01f; }
                        else if (quadDistToCam > svCamera.farClipPlane) { quadDistToCam = svCamera.farClipPlane * 0.99f; }
                        lbGroupDesigner.transform.position = svCamera.transform.position + (svCamera.transform.forward * quadDistToCam);
                        // Scale the quad to fill the camera view (actually makes it twice the needed size to avoid issues)
                        lbGroupDesigner.transform.localScale = Vector3.one * Mathf.Max(1f, svCamera.aspect) * tanCameraAngle * quadDistToCam * 4f;
                        // Make the quad face the camera
                        lbGroupDesigner.transform.LookAt(svCamera.transform.position);
                        lbGroupDesigner.transform.rotation *= Quaternion.Euler(0f, 180f, 0f);
                    }
                    else
                    {
                        Debug.Log("LB Editor SceneGUI - there was an error with the GroupDesigner. Please Report");
                        lbGroupDesigner.RefreshWorkspace();
                    }
                }
            }
            #endregion

            #region Manual Clearing Locations Context Menu
            // Process events for Manual Clearings in the scene view when a location is NOT selected.
            // The Context Menu that is displayed when one IS selected, is created in LBGroupLocationItemEditor.OnSceneGUI()
            if (lbGroupShowLocations != null)
            {
                // Did use click right mouse button in the scene view?
                // Ignore HAND Tool so user can still right-click to rotate scene view camera
                if (currentEvent.type == EventType.MouseDown && currentEvent.button == 1 && Tools.current != Tool.View)
                {
                    GenericMenu menu = new GenericMenu();
                    menu.AddItem(new GUIContent("Save and Exit Positions"), false, () =>
                    {
                        LBGroupLocationItem.RemoveLocationsFromScene(landscape, true);
                        lbGroupShowLocations.showGroupsInScene = false;
                        lbGroupShowLocations = null;
                        if (landscape != null) { landscape.LockTerrains(false); }
                        EditorSceneManager.MarkSceneDirty(EditorSceneManager.GetActiveScene());
                        LBEditorHelper.RepaintEditorWindow(typeof(LandscapeBuilderWindow));
                    });
                    menu.AddSeparator("");
                    menu.AddItem(new GUIContent("Add Clearing Position"), false, () => { LBGroupLocationItem.AddNewLocationToScene(landscape, lbGroupShowLocations, currentEvent.mousePosition, sv.camera, true); });
                    menu.AddItem(new GUIContent("Allow scene view rotation"), false, () => { Tools.current = Tool.View; });
                    menu.AddItem(new GUIContent("Zoom Out"), false, () => { ZoomAllLandscape(); });
                    menu.AddSeparator("");
                    // The Cancel option is not really necessary as use can just click anywhere else. However, it may help some users.
                    menu.AddItem(new GUIContent("Cancel"), false, () => { });
                    menu.ShowAsContext();
                    currentEvent.Use();
                }
            }
            #endregion
        }

        /// <summary>
        /// Gets called automatically 10 times per second
        /// </summary>
        void OnInspectorUpdate()
        {
            // If a SubGroup name has changed, refresh the list here so we don't get a mismatch between
            // the Layout and Repaint events.
            if (isSubGroupNameListRefreshRequired && Time.realtimeSinceStartup - subGroupNameListLastRefreshed > 3f)
            {
                RefreshSubGroupLists();
            }

            if (terrainHighlighterEnabled || heightPickerEnabled || waterHighlighterEnabled || areaHighlighterEnabled || volumeHighlighterEnabled ||
                treeAreaHighlighterEnabled || grassAreaHighlighterEnabled || meshAreaHighlighterEnabled || textureFilterAreaHighlighterEnabled)
            {
                // OnGUI () only registers events when the mouse is positioned over the custom editor window
                // This code forces OnGUI () to run every frame, so it registers events even when the mouse
                // is positioned over the scene view

                if (allowRepaint) { Repaint(); }
            }
        }

        /// <summary>
        /// Gets called by Unity when the LB Editor window loses focus
        /// </summary>
        private void OnLostFocus()
        {
            try
            {
                if (mouseOverWindow != null)
                {
                    if (mouseOverWindow.titleContent.text != "Scene")
                    {
                        CleanupHighlighters();
                    }
                }
                else
                {
                    // May have other editor windows as tabs
                    // next to LB. For some reason these return
                    // mouseOverWindow as null.
                    CleanupHighlighters();
                }
            }
            catch (Exception ex)
            {
                Debug.Log("Landscape Builder Window.OnLostFocus error. Please report. " + ex.Message);
            }
        }

        /// <summary>
        /// This gets called by Unity when the window is closed or play mode is entered in fullscreen
        /// </summary>
        private void OnDestroy()
        {
#if UNITY_2019_1_OR_NEWER
            SceneView.duringSceneGui -= SceneGUI;
#else
            SceneView.onSceneGUIDelegate -= SceneGUI;
#endif

            // Did user close window when one of the highlighters was enabled?
            // If so, remove it from the scene that was just loaded.
            CleanupHighlighters();
        }

        /// <summary>
        /// Event handler for when the Hierarchy Windows is changed. Called automatically by Unity.
        /// Disables highlighters and checks for changes in the LBGroupDesigner.
        /// </summary>
        private void OnHierarchyChange()
        {
            if (!Application.isPlaying)
            {
                activeScene = EditorSceneManager.GetActiveScene().name;

                // Has the user loaded a new scene?
                if (currentScene != activeScene)
                {
                    //Debug.Log("INFO: OnHierarchyChange - Changed scene");
                    currentScene = activeScene;
                    landscapeGameObjectSelection = null;
                    landscapeSelection = null;
                    landscape = null;

                    // Added LB 2.1.5
                    LBEditorCommon.currentLandscape = null;
                    isReparentRequired = false;

                    // Did the user exit the new scene while one of the highlighters was active?
                    // If so, remove it from the scene that was just loaded.
                    LBTerrainHighlight oldHighlighter = GameObject.FindObjectOfType<LBTerrainHighlight>();
                    if (oldHighlighter != null)
                    {
                        DestroyImmediate(oldHighlighter.gameObject);
                        waterHighlighterEnabled = false;
                        heightPickerEnabled = false;
                        terrainHighlighterEnabled = false;
                    }

                    // If the user exited the scene or the project while the Area Highlighter was enabled?
                    LBAreaHighlight oldAreaHighlighter = GameObject.FindObjectOfType<LBAreaHighlight>();
                    if (oldAreaHighlighter != null)
                    {
                        DestroyImmediate(oldAreaHighlighter.gameObject);
                        areaHighlighterEnabled = false;
                        textureFilterAreaHighlighterEnabled = false;
                        treeAreaHighlighterEnabled = false;
                        grassAreaHighlighterEnabled = false;
                        meshAreaHighlighterEnabled = false;
                    }

                    // Go to the Landscape tab when a new scene is loaded
                    selectedTabInt = 0;
                }
                else if (lbGroupDesigner != null)
                {
                    //Debug.Log("AddPrefab lbGroupDesigner.isInitialised: " + lbGroupDesigner.isInitialised + " lbGroupDesigner.isObjDesignerEnabled: " + lbGroupDesigner.isObjDesignerEnabled);

                    if (lbGroupDesigner.isInitialised)
                    {
                        // Block AddPrefab when Object Path Designer is enabled to avoid destroying stuff in the hierarchy
                        //if (lbGroupDesigner.isObjDesignerEnabled)
                        //{
                        //    if (lbGroupDesigner.isShowPrefabWarning)
                        //    {
                        //        Debug.LogWarning("WARNING: While the Object Editor is enabled, new prefabs cannot be dragged into the Group Designer. Add them in the LB Editor window OR turn off Object Path Designer first.");
                        //        lbGroupDesigner.isShowPrefabWarning = false;
                        //    }
                        //}
                        //else
                        {
                            Transform[] selected = Selection.GetTransforms(SelectionMode.TopLevel);
                            if (selected != null)
                            {
                                // If a user drags a prefab into the Group Designer in the scene view, attempt to add it.
                                if (selected.Length == 1)
                                {
                                    //Debug.Log("Add prefab ");
                                    lbGroupDesigner.AddPrefab(selected[0]);
                                    Repaint();
                                }
                            }
                        }
                    }
                }
            }
        }

        #endregion

        #region Presets

        private void SetWindZonePresetValues(WindZonePreset preset, WindZone windZone)
        {
            if (preset == WindZonePreset.Default)
            {
                windZone.windMain = 1f;
                windZone.windTurbulence = 1f;
                windZone.windPulseMagnitude = 0.5f;
                windZone.windPulseFrequency = 0.01f;
            }
            else if (preset == WindZonePreset.Calm)
            {
                windZone.windMain = 0.12f;
                windZone.windTurbulence = 0.0f;
                windZone.windPulseMagnitude = 0.5f;
                windZone.windPulseFrequency = 0.05f;
            }
            else if (preset == WindZonePreset.Windy)
            {
                windZone.windMain = 2f;
                windZone.windTurbulence = 2f;
                windZone.windPulseMagnitude = 0.1f;
                windZone.windPulseFrequency = 0.5f;
            }
            else if (preset == WindZonePreset.Gusty)
            {
                windZone.windMain = 2f;
                windZone.windTurbulence = 5f;
                windZone.windPulseMagnitude = 0.5f;
                windZone.windPulseFrequency = 0.5f;
            }
            else if (preset == WindZonePreset.Stormy)
            {
                windZone.windMain = 2f;
                windZone.windTurbulence = 4f;
                windZone.windPulseMagnitude = 3f;
                windZone.windPulseFrequency = 0.5f;
            }
            else if (preset == WindZonePreset.Cyclonic)
            {
                windZone.windMain = 2f;
                windZone.windTurbulence = 4f;
                windZone.windPulseMagnitude = 5f;
                windZone.windPulseFrequency = 1f;
            }
        }

        private void GetDRPresetNames()
        {
            Transform defaultResourcesPrefab = (Transform)AssetDatabase.LoadAssetAtPath(LBSetup.lbFolder + "/Prefabs/LB Default Resources.prefab", typeof(Transform));
            if (defaultResourcesPrefab != null)
            {
                Transform defaultResourcesObj = (Transform)Instantiate(defaultResourcesPrefab, Vector3.zero, Quaternion.identity);
                if (defaultResourcesObj != null)
                {
                    LBDefaultResources defaultResources = defaultResourcesObj.GetComponent<LBDefaultResources>();
                    if (defaultResources != null)
                    {
                        texturingPresetNames = defaultResources.texturingPresetNameList;
                        treePresetNames = defaultResources.treePresetNameList;
                        grassPresetNames = defaultResources.grassPresetNameList;
                        isDefaultResourcesValid = true;
                    }
                    else
                    {
                        isDefaultResourcesValid = false;
                        Debug.Log("Default Resources prefab not set up correctly");
                    }
                    DestroyImmediate(defaultResourcesObj.gameObject);
                }
                else
                {
                    isDefaultResourcesValid = false;
                    Debug.LogWarning("Failed to instantiate Default Resources");
                }
            }
            else
            {
                isDefaultResourcesValid = false;
                Debug.LogWarning("ERROR: Failed to get Default Resources. Did you move LandscapeBuilder from the default location?");
            }
        }

        private void SetFromTexturingPreset(int presetInt)
        {
            Transform defaultResourcesPrefab = (Transform)AssetDatabase.LoadAssetAtPath("Assets/LandscapeBuilder/Prefabs/LB Default Resources.prefab", typeof(Transform));
            if (defaultResourcesPrefab != null)
            {
                Transform defaultResourcesObj = (Transform)Instantiate(defaultResourcesPrefab, Vector3.zero, Quaternion.identity);
                if (defaultResourcesObj != null)
                {
                    LBDefaultResources defaultResources = defaultResourcesObj.GetComponent<LBDefaultResources>();
                    if (defaultResources != null)
                    {
                        if (defaultResources.texturingPresetList.Count > presetInt)
                        {
                            terrainTexturesList = defaultResources.texturingPresetList[presetInt].terrainTextureList;
                            TextureListExpand(false);
                        }
                    }
                    else
                    {
                        Debug.Log("Default Resources prefab not set up correctly");
                    }
                    DestroyImmediate(defaultResourcesObj.gameObject);
                }
                else
                {
                    Debug.LogWarning("Failed to instantiate Default Resources");
                }
            }
            else
            {
                Debug.LogWarning("Failed to get Default Resources");
            }
        }

        private void SetFromTreePreset(int presetInt)
        {
            Transform defaultResourcesPrefab = (Transform)AssetDatabase.LoadAssetAtPath("Assets/LandscapeBuilder/Prefabs/LB Default Resources.prefab", typeof(Transform));
            if (defaultResourcesPrefab != null)
            {
                Transform defaultResourcesObj = (Transform)Instantiate(defaultResourcesPrefab, Vector3.zero, Quaternion.identity);
                if (defaultResourcesObj != null)
                {
                    LBDefaultResources defaultResources = defaultResourcesObj.GetComponent<LBDefaultResources>();
                    if (defaultResources != null)
                    {
                        if (defaultResources.treePresetList.Count > presetInt)
                        {
                            terrainTreesList = defaultResources.treePresetList[presetInt].terrainTreeList;
                            TreeListExpand(false);
                        }
                    }
                    else
                    {
                        Debug.Log("Default Resources prefab not set up correctly");
                    }
                    DestroyImmediate(defaultResourcesObj.gameObject);
                }
                else
                {
                    Debug.LogWarning("Failed to instantiate Default Resources");
                }
            }
            else
            {
                Debug.LogWarning("Failed to get Default Resources");
            }
        }

        private void SetFromGrassPreset(int presetInt)
        {
            Transform defaultResourcesPrefab = (Transform)AssetDatabase.LoadAssetAtPath("Assets/LandscapeBuilder/Prefabs/LB Default Resources.prefab", typeof(Transform));
            if (defaultResourcesPrefab != null)
            {
                Transform defaultResourcesObj = (Transform)Instantiate(defaultResourcesPrefab, Vector3.zero, Quaternion.identity);
                if (defaultResourcesObj != null)
                {
                    LBDefaultResources defaultResources = defaultResourcesObj.GetComponent<LBDefaultResources>();
                    if (defaultResources != null)
                    {
                        if (defaultResources.grassPresetList.Count > presetInt)
                        {
                            terrainGrassList = defaultResources.grassPresetList[presetInt].terrainGrassList;
                            GrassListExpand(false);
                        }
                    }
                    else
                    {
                        Debug.Log("Default Resources prefab not set up correctly");
                    }
                    DestroyImmediate(defaultResourcesObj.gameObject);
                }
                else
                {
                    Debug.LogWarning("Failed to instantiate Default Resources");
                }
            }
            else
            {
                Debug.LogWarning("Failed to get Default Resources");
            }
        }

        #endregion

        #region Modifiers (classic and Topography Layers)

        private void RefreshModifierLists(string fileExtension)
        {
            if (!isLoadingModifierLandformLists)
            {
                isLoadingModifierLandformLists = true;

                string baseModifierPath = "Assets/LandscapeBuilder/Modifiers";

                if (Directory.Exists(baseModifierPath))
                {
                    bool isPNG = (fileExtension == LBRaw.SourceFileType.PNG.ToString());

                    // Clear all the existing lists
                    if (isPNG)
                    {
                        modifierLandformHills.Clear();
                        modifierLandformLakes.Clear();
                        modifierLandformMesas.Clear();
                        modifierLandformMountains.Clear();
                        modifierLandformValleys.Clear();
                        modifierLandformCustom.Clear();
                    }
                    else
                    {
                        modifierLandformHillsRAW.Clear();
                        modifierLandformLakesRAW.Clear();
                        modifierLandformMesasRAW.Clear();
                        modifierLandformMountainsRAW.Clear();
                        modifierLandformValleysRAW.Clear();
                    }

                    // Loop through all modifier categories
                    LBModifierOperations.ModifierLandformCategory[] modifierCategories = (LBModifierOperations.ModifierLandformCategory[])Enum.GetValues(typeof(LBModifierOperations.ModifierLandformCategory));
                    foreach (LBModifierOperations.ModifierLandformCategory mCategory in modifierCategories)
                    {
                        // Add all the PNG files in a category to the appropriate list
                        switch (mCategory)
                        {
                            case LBModifierOperations.ModifierLandformCategory.Hills:
                                if (isPNG) { modifierLandformHills.AddRange(LBModifierOperations.GetModifierList(mCategory.ToString(), fileExtension)); }
                                else { modifierLandformHillsRAW.AddRange(LBModifierOperations.GetModifierList(mCategory.ToString(), fileExtension)); }
                                break;
                            case LBModifierOperations.ModifierLandformCategory.Lakes:
                                if (isPNG) { modifierLandformLakes.AddRange(LBModifierOperations.GetModifierList(mCategory.ToString(), fileExtension)); }
                                else { modifierLandformLakesRAW.AddRange(LBModifierOperations.GetModifierList(mCategory.ToString(), fileExtension)); }
                                break;
                            case LBModifierOperations.ModifierLandformCategory.Mesas:
                                if (isPNG) { modifierLandformMesas.AddRange(LBModifierOperations.GetModifierList(mCategory.ToString(), fileExtension)); }
                                else { modifierLandformMesasRAW.AddRange(LBModifierOperations.GetModifierList(mCategory.ToString(), fileExtension)); }
                                break;
                            case LBModifierOperations.ModifierLandformCategory.Mountains:
                                if (isPNG) { modifierLandformMountains.AddRange(LBModifierOperations.GetModifierList(mCategory.ToString(), fileExtension)); }
                                else { modifierLandformMountainsRAW.AddRange(LBModifierOperations.GetModifierList(mCategory.ToString(), fileExtension)); }
                                break;
                            case LBModifierOperations.ModifierLandformCategory.Valleys:
                                if (isPNG) { modifierLandformValleys.AddRange(LBModifierOperations.GetModifierList(mCategory.ToString(), fileExtension)); }
                                else { modifierLandformValleysRAW.AddRange(LBModifierOperations.GetModifierList(mCategory.ToString(), fileExtension)); }
                                break;
                            case LBModifierOperations.ModifierLandformCategory.Custom:
                                if (isPNG) { modifierLandformCustom.AddRange(LBModifierOperations.GetModifierList(mCategory.ToString(), fileExtension)); }
                                // RAW not required for new Layer Image Modifiers
                                break;
                        }
                    }
                }

                isModifierLandformListsRefreshRequired = false;
                isLoadingModifierLandformLists = false;
                isLandformCategoryDropdownRefreshRequired = true;
            }
        }

        #endregion

        #region Highlighter Methods

        private void CleanupHighlighters()
        {
            // If so, remove it from the scene that was just loaded.
            LBTerrainHighlight oldHighlighter = GameObject.FindObjectOfType<LBTerrainHighlight>();
            if (oldHighlighter != null)
            {
                DestroyImmediate(oldHighlighter.gameObject);
                waterHighlighterEnabled = false;
                heightPickerEnabled = false;
                terrainHighlighterEnabled = false;
            }

            // If the user exited the scene or the project while the Area Highlighter was enabled?
            LBAreaHighlight oldAreaHighlighter = GameObject.FindObjectOfType<LBAreaHighlight>();
            if (oldAreaHighlighter != null)
            {
                DestroyImmediate(oldAreaHighlighter.gameObject);
                areaHighlighterEnabled = false;
                textureFilterAreaHighlighterEnabled = false;
                treeAreaHighlighterEnabled = false;
                grassAreaHighlighterEnabled = false;
                meshAreaHighlighterEnabled = false;
            }

            LBVolumeHighlight oldVolumeHeightlighter = GameObject.FindObjectOfType<LBVolumeHighlight>();
            if (oldVolumeHeightlighter != null)
            {
                volumeHighlighterEnabled = false;
                DestroyImmediate(oldVolumeHeightlighter.gameObject);
            }
        }

        /// <summary>
        /// If the tree area highligher is enabled, turn it off
        /// </summary>
        private void DisableTreeAreaHighlighter()
        {
            // Turn highlighter off before applying trees or a layout error occurs
            if (treeAreaHighlighterEnabled || treeAreaHighlighter != null)
            {
                areaHighlighterRequired = false;
                DestroyImmediate(treeAreaHighlighter.gameObject);
                treeAreaHighlighterEnabled = false;
            }
        }

        /// <summary>
        /// If the grass area highlighter is enabled, turn it off
        /// </summary>
        private void DisableGrassAreaHighlighter()
        {
            if (grassAreaHighlighterEnabled || grassAreaHighlighter != null)
            {
                areaHighlighterRequired = false;
                DestroyImmediate(grassAreaHighlighter.gameObject);
                grassAreaHighlighterEnabled = false;
            }
        }

        #endregion

        #region Draw Header Methods

        /// <summary>
        /// Draw the LB title image and overlayed version text
        /// </summary>
        private void DrawTitleTex()
        {
            if (lbTitleTex == null)
            {
                lbTitleTex = AssetDatabase.LoadAssetAtPath(LBSetup.editorFolder + "/Textures/lbheader.png", typeof(Texture2D)) as Texture2D;
            }
            if (lbTitleTex != null)
            {
                float texWidth = lbTitleTex.width;
                float texHeight = lbTitleTex.height;
                float maxWidth = EditorGUIUtility.currentViewWidth;
                // Set min width to 100
                if (maxWidth < 100f) { maxWidth = 100f; }
                else if (maxWidth > texWidth) { maxWidth = texWidth; }
                // Give it a left/right boarder
                maxWidth -= 8f;
                float maxHeight = maxWidth < texWidth ? lbTitleTex.height / (texWidth / maxWidth) : texHeight;

                // Reserve enough space to display the tile image
                Rect titleRect = GUILayoutUtility.GetRect(GUIContent.none, GUIStyle.none, GUILayout.Height(maxHeight - (maxWidth > 280f ? 26f : 0f)));
                titleRect.height = maxHeight;
                titleRect.width = maxWidth;

                // Centre image
                titleRect.xMin = EditorGUIUtility.currentViewWidth > maxWidth ? (EditorGUIUtility.currentViewWidth - maxWidth) / 2f : 0f;
                if (titleRect.xMin > 0f) { titleRect.xMax = titleRect.xMin + maxWidth; }
                GUI.DrawTexture(titleRect, lbTitleTex, ScaleMode.ScaleToFit, false);

                if (maxWidth > 280f && labelFieldRichTextCentred != null && versionBox != null)
                {
                    GUILayout.BeginHorizontal();
                    // Indent the version background box (left side)
                    #if UNITY_2019_3_OR_NEWER
                    GUILayoutUtility.GetRect(titleRect.xMin-10f, 1f);
                    #else
                    GUILayoutUtility.GetRect(titleRect.xMin-4f, 1f);
                    #endif
                    versionBox.fixedWidth = maxWidth;
                    GUILayout.BeginVertical(versionBox);
                    EditorGUILayout.LabelField("<b>Version " + LBVersion + " " + LBBetaVersion + "</b>", labelFieldRichTextCentred);
                    GUILayout.EndVertical();
                    // Indent the version background box (right side)
                    #if UNITY_2019_3_OR_NEWER
                    GUILayoutUtility.GetRect(titleRect.xMin-10f, 1f);
                    #else
                    GUILayoutUtility.GetRect(titleRect.xMin-8f, 1f);
                    #endif
                    GUILayout.EndHorizontal();
                    GUILayoutUtility.GetRect(1f, 8f);
                }
            }
        }

        /// <summary>
        /// Draw a header texture. e.g. At top of Trees, Grass, Topography, Groups tabs
        /// </summary>
        /// <param name="headerTex"></param>
        /// <param name="maxWidth"></param>
        /// <param name="maxHeight"></param>
        /// <param name="texIndent"></param>
        private void DrawHeaderTex(Texture2D headerTex, GUIContent labelText)
        {
            if (headerTex != null)
            {
                float texWidth = headerTex.width;
                float texHeight = headerTex.height;
                float maxWidth = EditorGUIUtility.currentViewWidth;
                // Set min width to 100
                if (maxWidth < 100f) { maxWidth = 100f; }
                else if (maxWidth > texWidth) { maxWidth = texWidth; }
                // Give it a left/right boarder
                maxWidth -= 8f;
                float maxHeight = maxWidth < texWidth ? headerTex.height / (texWidth / maxWidth) : texHeight;

                // Reserve enough space to display the header image
                float minImageSizeForLabel = 360f;
                Rect titleRect = GUILayoutUtility.GetRect(GUIContent.none, GUIStyle.none, GUILayout.Height(maxHeight - (maxWidth > minImageSizeForLabel ? 80f : 0f)));
                titleRect.height = maxHeight;
                titleRect.width = maxWidth;

                // Centre image
                titleRect.xMin = EditorGUIUtility.currentViewWidth > maxWidth ? (EditorGUIUtility.currentViewWidth - maxWidth) / 2f : 0f;
                if (titleRect.xMin > 0f) { titleRect.xMax = titleRect.xMin + maxWidth; }
                GUI.DrawTexture(titleRect, headerTex, ScaleMode.ScaleToFit, false);

                DrawHeaderLabel(maxWidth, maxHeight, texHeight, titleRect.xMin, minImageSizeForLabel, labelText);
            }
        }

        private void DrawHeaderLabel(float maxWidth, float maxHeight, float texHeight, float labelIndent, float minImageSizeForLabel, GUIContent labelText)
        {
            if (maxWidth > minImageSizeForLabel && labelFieldHeaderBox != null && headerBox != null)
            {
                GUILayout.BeginHorizontal();
                // Indent the header label background box (left side)
                #if UNITY_2019_3_OR_NEWER
                GUILayoutUtility.GetRect(labelIndent - 10f, 1f);
                #else
                GUILayoutUtility.GetRect(labelIndent - 4f, 1f);
                #endif
                headerBox.fixedWidth = maxWidth;
                headerBox.fixedHeight = maxHeight - 22f;
                GUILayout.BeginVertical(headerBox);
                EditorGUILayout.LabelField(labelText, labelFieldHeaderBox);
                GUILayout.EndVertical();
                // Indent the header label background box (right side)
                #if UNITY_2019_3_OR_NEWER
                GUILayoutUtility.GetRect(labelIndent - 10f, 1f);
                #else
                GUILayoutUtility.GetRect(labelIndent - 8f, 1f);
                #endif
                GUILayout.EndHorizontal();
                GUILayoutUtility.GetRect(1f, texHeight - maxHeight + 4f);
            }
        }

        private void DrawTopoHeaderTex()
        {
            if (lbTopoHeaderTex == null)
            {
                lbTopoHeaderTex = AssetDatabase.LoadAssetAtPath(LBSetup.editorFolder + "/Textures/lbheadertopo.png", typeof(Texture2D)) as Texture2D;
            }

            DrawHeaderTex(lbTopoHeaderTex, topoHeaderContent);
        }

        private void DrawTexturingHeaderTex()
        {
            if (lbTexturingHeaderTex == null)
            {
                lbTexturingHeaderTex = AssetDatabase.LoadAssetAtPath(LBSetup.editorFolder + "/Textures/lbheadertexturing.png", typeof(Texture2D)) as Texture2D;
            }

            DrawHeaderTex(lbTexturingHeaderTex, texturingHeaderContent);
        }

        private void DrawTreeHeaderTex()
        {
            if (lbTreeHeaderTex == null)
            {
                lbTreeHeaderTex = AssetDatabase.LoadAssetAtPath(LBSetup.editorFolder + "/Textures/lbheadertrees.png", typeof(Texture2D)) as Texture2D;
            }

            DrawHeaderTex(lbTreeHeaderTex, treesHeaderContent);
        }

        private void DrawGrassHeaderTex()
        {
            if (lbGrassHeaderTex == null)
            {
                lbGrassHeaderTex = AssetDatabase.LoadAssetAtPath(LBSetup.editorFolder + "/Textures/lbheadergrass.png", typeof(Texture2D)) as Texture2D;
            }

            DrawHeaderTex(lbGrassHeaderTex, grassHeaderContent);
        }

        private void DrawGroupsHeaderTex()
        {
            if (lbGroupsHeaderTex == null)
            {
                lbGroupsHeaderTex = AssetDatabase.LoadAssetAtPath(LBSetup.editorFolder + "/Textures/lbheadergroups.png", typeof(Texture2D)) as Texture2D;
            }

            DrawHeaderTex(lbGroupsHeaderTex, groupsHeaderContent);
        }

        #endregion

        #region Misc Methods

        private string GetProjectName()
        {
            string[] s = Application.dataPath.Split('/');
            if (s.Length > 2) return s[s.Length - 2];
            else return string.Empty;
        }

        private void GetLandscapeTerrainSettings()
        {
            startPosition = landscape.start;
            landscapeSize = landscape.size;

            terrainSize3D = landscape.GetLandscapeTerrainSize();
            terrainWidth = terrainSize3D.x;
            terrainLength = terrainSize3D.z;
            terrainHeight = terrainSize3D.y;
            landscapeName = landscapeGameObject.name;
            landscapeTemplateName = landscapeName + " Template";

            // Get general terrain settings
            pixelError = landscape.GetLandscapeTerrainPixelError();
            baseMapDistance = landscape.GetLandscapeTerrainBaseMapDist();
            baseTextureResolution = landscape.GetLandscapeTerrainBaseTextureResolution();
            alphaMapResolution = landscape.GetLandscapeTerrainAlphaMapResolution();
            treeDistance = landscape.GetLandscapeTerrainTreeDistance();
            treeBillboardDistance = landscape.GetLandscapeTerrainTreeBillboardStart();
            detailDistance = landscape.GetLandscapeTerrainDetailDistance();
            detailDensity = landscape.GetLandscapeTerrainDetailDensity();
            detailResolution = landscape.GetLandscapeTerrainDetailResolution();
            treeFadeDistance = landscape.GetLandscapeTerrainTreeFadeLength();
            useTerrainDrawInstanced = landscape.GetLandscapeTerrainDrawInstanced();
            useTerrainAutoConnect = landscape.GetLandscapeTerrainAutoConnect();
            terrainGroupingID = landscape.GetLandscapeTerrainGroupingID();

            landscapeLayerIndex = landscape.GetLandscapeTerrainLayerIndex();

            // Get height map resolution
            heightmapResolution = landscape.GetLandscapeTerrainHeightmapResolution();

            // Check if LB Landscape component has been directly attached to a single terrain
            isReparentRequired = landscape.GetComponent<Terrain>() != null;

            // Get grass settings
            grassWindSpeed = landscape.GetLandscapeTerrainGrassWindSpeed();
            grassWindRippleSize = landscape.GetLandscapeTerrainGrassWindRippleSize();
            grassWindBending = landscape.GetLandscapeTerrainGrassWindBending();
            grassWindTint = landscape.GetLandscapeTerrainGrassWindTint();

            // Get material settings
            terrainLegacySpecular = landscape.GetLandscapeTerrainLegacySpecular();
            terrainLegacyShininess = landscape.GetLandscapeTerrainLegacyShininess();
            terrainCustomMaterial = landscape.GetLandscapeTerrainCustomMaterial();

            //if (terrainCustomMaterial != null) { Debug.Log("GetLandscapeTerrainSettings terrainCustomMaterial: " + terrainCustomMaterial.name + " shader: " + terrainCustomMaterial.shader.name); }

            terrainMaterialType = landscape.GetTerrainMaterialType();

            useTerrainPerPixelNormals = LBEditorCommon.GetTerrainPerPixelNormals(landscape);
        }

        #endregion
    }
}