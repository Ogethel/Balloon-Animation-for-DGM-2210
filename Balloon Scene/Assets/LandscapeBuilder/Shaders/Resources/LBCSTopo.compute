// Landscape Builder. Copyright (c) 2016-2019 SCSM Pty Ltd. All rights reserved.
#pragma kernel TopoPerlin
#pragma kernel TopoImage
#pragma kernel TopoImageModifier
#pragma kernel TopoUnityTerrains

#define LB_TOPO_NUM_THREADS 16
#define LB_TOPO_IMAGE_NUM_THREADS 16

// Heightmap variables
StructuredBuffer<float> heightsIn;
RWStructuredBuffer<float> heightsOut;

// Layer variables
int layerTypeInt;
float heightScale;
bool restrictArea;
// areaRect.x: xMin, areaRect.y: yMin, areaRect.z: xMax, areaRect.w: yMax
float4 areaRect;
float areaRectBlendWidth;
float areaRectRotation; // in Radians
bool removeBaseNoise;
float addHeightN;
float addsubAmount;
uint addsubCurveNumKeys;
StructuredBuffer<float4> addsubCurve;
uint numPerOctaveCurves;
uint numOutputCurves;
uint outputCurveFrameOffset;
StructuredBuffer<float4> modifierCurves;
StructuredBuffer<uint> modifierCurvesNumFrames;

// Noise variables
float noiseTileSize;
float noiseOffsetX;
float noiseOffsetZ;
float noiseOffsetXadj;
float noiseOffsetZadj;
int noiseOctaves;
float noiseLacunarity;
float noiseGain;
float noiseWarpAmount;
int noiseWarpOctaves;
float noiseDownscaling;

// Image layer varibles
Texture2D<float4> heightmapImage;
//SamplerState sampler_heightmapImage;
bool normaliseImage;
// Image Layer x = Min, y = Max, zw unused
// Image Modifier Layer x = Min, y = Max, z = Width, w = Length
float4 imageMinMaxRange;

// Map Filters
Texture2D<float4> mapTex;
uint mapTexWidth;
uint mapTexHeight;
bool mapInverse;

// Image Modifier layer variables
StructuredBuffer<uint> rawHeightData;
bool useBlending;
int modifierMode;
bool modifierInvert;

// temp variables
float heightSum;

#include "LBCGNoiseExt.cginc"
#include "LBCGCalc.cginc"
#include "LBCGLib.cginc"
#include "LBCGNoise.cginc"
#include "LBCGStencil.cginc"

uint numlbFilters;
StructuredBuffer<LBFilter> lbFilters;

// NOTE: Methods need to be declared above where they are called

// Returns the perlin fractal noise value at xPos, yPos modified by a list of curve modifiers affecting each octave
// Similar to LBPerlinFractalNoise(float xPos, float yPos, int octaves, float lacunarity, float gain, List<AnimationCurve> curveModifiers)
float LBPerlinFractalNoise(float xPos, float yPos, int octaves, float lacunarity, float gain)
{
	// Input the position into the fractal noise function to get a value between 0 and 1
	// Fractal noise is generated by getting perlin noise output from world coordinate input
	// then adding scaled versions of itself to it
	float value = 0.0;
	float powFloat = 1.0;
	float powFloat2 = gain;
	for (int o = 0; o < octaves; o++)
	{
		// Get perlin, then normalise from input range of -1.0 to 1.0 by adding 1 and dividing by 2.
		float octaveValue = (Perlin2D(float2(xPos * powFloat, yPos * powFloat)) + 1.0) * 0.5;
		//float octaveValue = (Value2D(float2(xPos * powFloat, yPos * powFloat)) + 1.0) * 0.5;		

		powFloat *= lacunarity;

		uint numKeyFramesOffset = 0;

		// Pre-Octave Curves are packed at the beginning of the modifierCurves buffers (followed by Output Curve modifiers)
		for (uint pcm = 0; pcm < numPerOctaveCurves; pcm++)
		{
			// Get the number of keyframes in this pre-octave curve modifier
			uint numKeyFrames = modifierCurvesNumFrames[pcm];

			octaveValue = LBEvaluate(octaveValue, modifierCurves, numKeyFrames, numKeyFramesOffset);

			numKeyFramesOffset += numKeyFrames;
		}

		octaveValue *= powFloat2;
		powFloat2 *= gain;
		value += octaveValue;
	}
	return value;
}

// Returns an averaged height from normalised posRAW2D
// This function finds the four heightmap points enclosing the coordinates and
// blends between them depending on how close the coordinates are to each point
uint SampleRAWHeightAtCoordinates(float2 posRAW2D)
{
	float rawSourceWidth = imageMinMaxRange.z;
	float rawSourceLength = imageMinMaxRange.w;

	// Clamp input to 0.0 - 1.0
	float2 posRAW2DN = float2(posRAW2D.x < 0.0 ? 0.0 : posRAW2D.x > 1.0 ? 1.0 : posRAW2D.x, posRAW2D.y < 0.0 ? 0.0 : posRAW2D.y > 1.0 ? 1.0 : posRAW2D.y);

	// Get texture-space coordinates from 0-1 coordinates
	float scaledXCoord = posRAW2DN.x * (rawSourceWidth - 1.0);
	float scaledYCoord = posRAW2DN.y * (rawSourceLength - 1.0);
	int minScaledXCoord = (int)scaledXCoord;
	int minScaledYCoord = (int)scaledYCoord;

	if (minScaledXCoord > rawSourceWidth - 2) { minScaledXCoord = rawSourceWidth - 2; }
	if (minScaledYCoord > rawSourceLength - 2) { minScaledYCoord = rawSourceLength - 2; }

	// Get bottom-left height
	uint heightBL = rawHeightData[(minScaledYCoord * rawSourceWidth) + minScaledXCoord];

	// Get bottom-right height
	uint heightBR = rawHeightData[(minScaledYCoord * rawSourceWidth) + (minScaledXCoord + 1)];

	// Get top-left height
	uint heightTL = rawHeightData[((minScaledYCoord + 1) * rawSourceWidth) + minScaledXCoord];

	// Get top-right height
	uint heightTR = rawHeightData[((minScaledYCoord + 1) * rawSourceWidth) + (minScaledXCoord + 1)];

	// Blend the heights of the various cells together
	float horizontalBlendFactor = scaledXCoord - minScaledXCoord;
	float verticalBlendFactor = scaledYCoord - minScaledYCoord;
	uint bottomHeights = (uint)(((1.0 - horizontalBlendFactor) * heightBL) + (horizontalBlendFactor * heightBR));
	uint topHeights = (uint)(((1.0 - horizontalBlendFactor) * heightTL) + (horizontalBlendFactor * heightTR));
	return (uint)(((1.0 - verticalBlendFactor) * bottomHeights) + (verticalBlendFactor * topHeights));
}

[numthreads(LB_TOPO_NUM_THREADS, LB_TOPO_NUM_THREADS,1)]
void TopoPerlin(uint3 id : SV_DispatchThreadID)
{
	// We have extra passes for 2^n + 1 hmapRes so need to ignore pixels outside heightmap
	// id.x & id.y can have a range 0 -> hmapRes-1 + LB_TOPO_NUM_THREADS
	// Each dimension (x,y) will be numThreads - 1 wider than required
	if (id.x > uint(hmapRes-1) || id.y > uint(hmapRes-1)) { return; }

	float2 landscapePos2D = GetTopoLandscapePos2DM(id.xy);
	
	// Get 1D index in heightsIn/Out
	int hIdx = (id.y * hmapRes) + id.x;

	// Restrict Area by rectangle
	// areaRect.x: xMin, areaRect.y: yMin, areaRect.z: xMax, areaRect.w: yMax
	if (restrictArea && (landscapePos2D.x < areaRect.x || landscapePos2D.x > areaRect.z || landscapePos2D.y < areaRect.y || landscapePos2D.y > areaRect.w))
	{
		heightsOut[hIdx] = heightsIn[hIdx];
		return;
	}

	// Now calculate the noise position
	float2 noisePos2D = float2(landscapePos2D.x - noiseOffsetX + noiseOffsetXadj + landscapePos.x, landscapePos2D.y - noiseOffsetZ + noiseOffsetZadj + landscapePos.z);

	if (noiseWarpAmount > 0.0)
	{
		// Warping of noise - adds perlin fractal noise onto the world coordinates
		float2 warpVector = float2(LBPerlinFractalNoise(noisePos2D.x / noiseTileSize, noisePos2D.y / noiseTileSize, noiseWarpOctaves),
								   LBPerlinFractalNoise(noisePos2D.x / noiseTileSize + 5.2, noisePos2D.y / noiseTileSize + 1.3, noiseWarpOctaves));
		noisePos2D.x += warpVector.x * noiseWarpAmount * noiseTileSize;
		noisePos2D.y += warpVector.y * noiseWarpAmount * noiseTileSize;
	}
	
	// Input the position into the fractal noise function to get a value between 0 and 1
	heightSum = LBPerlinFractalNoise(noisePos2D.x / noiseTileSize * noiseDownscaling, noisePos2D.y / noiseTileSize * noiseDownscaling, noiseOctaves, noiseLacunarity, noiseGain);

	// Process using output curve modifiers
	// Loop through all the animation curves
	uint numKeyFramesOffset = outputCurveFrameOffset;
	for (uint ocm = 0; ocm < numOutputCurves; ocm++)
	{		
		// Get the number of keyframes in this output curve modifier
		// Offset by the number of pre-octave curves that may also be included in the buffer.
		uint numKeyFrames = modifierCurvesNumFrames[numPerOctaveCurves+ocm];

		// Modify the terrain based on output animation curve
		heightSum = LBEvaluate(heightSum, modifierCurves, numKeyFrames, numKeyFramesOffset);

		numKeyFramesOffset += numKeyFrames;
	}

	// If this is an additive or subtractive layer we may want to add a constant value
	// This is calculated before getting passed to shader to avoid multiple 'if' branching
	heightSum += addHeightN;

	// If this is an additive or subtractive layer, process the output using the additive or subtractive curve modifier
	// Perlin Base and Detail layers will have addsubAmount = 1.0
	if (addsubAmount < 1.0)
	{
		// Modify the height based on the curve and then scale it to normalise it
		heightSum = LBEvaluate(heightSum, addsubCurve, addsubCurveNumKeys) * addsubAmount;
	}

	// If this is an additive or subtractive layer we may want to add a constant value
	// When heightSum is multiplied by heightScale it will make the previosuly added constant
	// value incorrect. This section adjusts for that
	heightSum += (addHeightN * ((1.0 / heightScale) - 1.0));

	// Scale the noise (Downscaling is only used for Detail layers)
	// Div by 1 when not a Detail layer. This is probably better than branching with an 'if'
	heightSum *= heightScale / noiseDownscaling;

	// Layer filters are only used for detail, additive and subtractive layers
	if (layerTypeInt >= 1 && layerTypeInt <= 3)
	{
		float2 landscapePos2DN = float2(landscapePos2D.x / landscapeSize.x, landscapePos2D.y / landscapeSize.y);

		// loop through filters
		for (uint fIdx = 0; fIdx < numlbFilters; fIdx++)
		{			
			int filterType = lbFilters[fIdx].csfilterType;

			// Height filter
			if (filterType == 0)
			{
				heightSum *= LBEvaluateWideRangeCurve(LBInverseLerp(lbFilters[fIdx].minHeight, lbFilters[fIdx].maxHeight, heightsIn[hIdx]));
			}
			// Inclination filter
			else if (filterType == 1)
			{
				float angle = LBGetSteepnessN(float2((float)id.x / (float)(hmapRes - 1), (float)id.y / (float)(hmapRes - 1))) + 0.00001f;
				heightSum *= LBEvaluateWideRangeCurve(LBInverseLerp(lbFilters[fIdx].minInclination, lbFilters[fIdx].maxInclination, angle));
			}
			// Stencil filter
			else if (filterType == 3)
			{
				float stencilLayerPixel = GetStencilLayerPoint(landscapePos2DN, lbFilters[fIdx].stencilLayerResolution, lbFilters[fIdx].stencilLayerTex2DArrIdx);
				if (stencilLayerPixel <= 0.0) { heightSum = 0.0;  break; }
				else
				{
					// Lerp between 0 and heightSum
					heightSum = lerp(0.0, heightSum, stencilLayerPixel / 65535.0);
				}
			}
			// Map filter - only 1 is supported per Layer in this compute shader
			else if (filterType == 2)
			{
				float mapValue = LBGrayScale(mapTex.SampleLevel(LBLinearClampSampler, landscapePos2DN, 0).rgb);

				// The tolerance curve used here is EaseInOut curve
				mapValue = (mapInverse ? 1.0 - mapValue : mapValue);

				// Do a simple squared blend rather than using a EaseInOut curve like with non-compute shader
				heightSum *= (mapValue * mapValue);
			}			
		}
	}

	// TODO - may wish to pass this condition in as a single bool
	// If this is an additive or subtractive layer we may want to remove the base noise
	if ((layerTypeInt == 1 || layerTypeInt == 2) && removeBaseNoise)
	{
		heightSum -= heightsIn[hIdx] * LBInverseLerp(0.0, heightsIn[hIdx], heightSum);
	}

	// RestrictArea Edge Blending
	if (restrictArea)
	{
		// Blend along edges
		// Get the normalised position within the areaRect
		float xAreaPosNormalised = (landscapePos2D.x - areaRect.x) / (areaRect.z - areaRect.x);
		float zAreaPosNormalised = (landscapePos2D.y - areaRect.y) / (areaRect.w - areaRect.y);

		float areaRectBlendFactor = 0.0;
		float areaRectBlendWidthUpper = 1.0 - areaRectBlendWidth;
		// Calculate the normalised distance away from the edge, then blend towards the original heightmap
		// as you approach the edge.
		if (xAreaPosNormalised < areaRectBlendWidth)
		{
			areaRectBlendFactor = xAreaPosNormalised / areaRectBlendWidth;
			heightSum = lerp(0.0, heightSum, areaRectBlendFactor);
		}
		else if (xAreaPosNormalised > areaRectBlendWidthUpper)
		{
			areaRectBlendFactor = (xAreaPosNormalised - areaRectBlendWidthUpper) / areaRectBlendWidth;
			heightSum = lerp(heightSum, 0.0, areaRectBlendFactor);
		}

		// RestictArea blending - Corners could be an issue...
		if (zAreaPosNormalised < areaRectBlendWidth)
		{
			areaRectBlendFactor = zAreaPosNormalised / areaRectBlendWidth;
			heightSum = lerp(0.0, heightSum, areaRectBlendFactor);
		}
		else if (zAreaPosNormalised > areaRectBlendWidthUpper)
		{
			areaRectBlendFactor = (zAreaPosNormalised - areaRectBlendWidthUpper) / areaRectBlendWidth;
			heightSum = lerp(heightSum, 0.0, areaRectBlendFactor);
		}
	}

	// If this is a subtractive layer, subtract the heightSum 
	heightsOut[hIdx] = heightsIn[hIdx] + (heightSum * (layerTypeInt == 2 ? -1.0 : 1.0));
}

[numthreads(LB_TOPO_IMAGE_NUM_THREADS, LB_TOPO_IMAGE_NUM_THREADS, 1)]
void TopoImage(uint3 id : SV_DispatchThreadID)
{
	// We have extra passes for 2^n + 1 hmapRes so need to ignore pixels outside heightmap
	// id.x & id.y can have a range 0 -> hmapRes-1 + LB_TOPO_IMAGE_NUM_THREADS
	// Each dimension (x,y) will be numThreads - 1 wider than required
	if (id.x > uint(hmapRes - 1) || id.y > uint(hmapRes - 1)) { return; }
	
	// Get 1D index in heightsIn/Out
	int hIdx = (id.y * hmapRes) + id.x;

	float2 landscapePos2D = GetTopoLandscapePos2DM(id.xy);

	// RestrictArea
	// Restrict Area by rectangle
	// areaRect.x: xMin, areaRect.y: yMin, areaRect.z: xMax, areaRect.w: yMax
	if (restrictArea && (landscapePos2D.x < areaRect.x || landscapePos2D.x > areaRect.z || landscapePos2D.y < areaRect.y || landscapePos2D.y > areaRect.w))
	{
		heightsOut[hIdx] = heightsIn[hIdx];
		return;
	}

	// Get 2D normalised position in terrain
	float2 pos2DN = GetTopoPos2DN(id.xy);

	// Get 2D normalised position in landscape
	float2 landscapePos2DN = float2(landscapePos2D.x / landscapeSize.x, landscapePos2D.y / landscapeSize.y);

	// Get pixel from heightmapImage
	heightSum = LBGrayScale(heightmapImage.SampleLevel(LBLinearClampSampler, landscapePos2DN, 0).rgb);
	//heightSum = LBGrayScale(heightmapImage.SampleLevel(sampler_heightmapImage, landscapePos2DN, 0).rgb);

	// Normalise
	if (normaliseImage)
	{
		// Normalise the image Pixel - converting it to a range of 0 to 1
		heightSum = LBNormalise(heightSum, imageMinMaxRange.x, imageMinMaxRange.y);
	}

	// Process using image output curve modifiers
	// Loop through all the animation curves
	uint numKeyFramesOffset = outputCurveFrameOffset;
	for (uint ocm = 0; ocm < numOutputCurves; ocm++)
	{
		// Get the number of keyframes in this output curve modifier
		uint numKeyFrames = modifierCurvesNumFrames[ocm];

		// Modify the terrain based on output animation curve
		heightSum = LBEvaluate(heightSum, modifierCurves, numKeyFrames, numKeyFramesOffset);

		numKeyFramesOffset += numKeyFrames;
	}

	// Scale the heightmap
	heightSum *= heightScale;

	// If this is an additive or subtractive layer, process the output using the additive or subtractive curve modifier
	// Image Base and Detail layers will have addsubAmount = 1.0
	if (layerTypeInt == 5 || layerTypeInt == 6)
	{
		// Modify the height based on the curve and then scale it to normalise it
		heightSum = LBEvaluate(heightSum, addsubCurve, addsubCurveNumKeys) * addsubAmount;
	}

	// Layer filters are only used for detail layers for Image layers
	if (layerTypeInt == 7 && numlbFilters > 0)
	{
		for (uint fIdx = 0; fIdx < numlbFilters; fIdx++)
		{
			int filterType = lbFilters[fIdx].csfilterType;

			// Height filter
			if (filterType == 0)
			{
				heightSum *= LBEvaluateWideRangeCurve(LBInverseLerp(lbFilters[fIdx].minHeight, lbFilters[fIdx].maxHeight, heightsIn[hIdx]));
			}
			// Inclination filter
			else if (filterType == 1)
			{
				float angle = LBGetSteepnessN(pos2DN) + 0.00001f;
				heightSum *= LBEvaluateWideRangeCurve(LBInverseLerp(lbFilters[fIdx].minInclination, lbFilters[fIdx].maxInclination, angle));
			}
			// Stencil filter
			else if (filterType == 3)
			{
				float stencilLayerPixel = GetStencilLayerPoint(landscapePos2DN, lbFilters[fIdx].stencilLayerResolution, lbFilters[fIdx].stencilLayerTex2DArrIdx);
				if (stencilLayerPixel <= 0.0) { heightSum = 0.0;  break; }
				else
				{
					// Lerp between 0 and heightSum
					heightSum = lerp(0.0, heightSum, stencilLayerPixel / 65535.0);
				}
			}
			// Map filter - currently not supported
			else if (filterType == 2)
			{

			}
		}
	}

	// If this is an additive or subtractive layer we may want to remove the base noise
	if ((layerTypeInt == 5 || layerTypeInt == 6) && removeBaseNoise)
	{
		heightSum -= heightsIn[hIdx] * LBInverseLerp(0.0, heightsIn[hIdx], heightSum);
	}

	// RestrictArea Edge Blending
	if (restrictArea)
	{
		// Blend along edges
		// Get the normalised position within the areaRect
		float xAreaPosNormalised = (landscapePos2D.x - areaRect.x) / (areaRect.z - areaRect.x);
		float zAreaPosNormalised = (landscapePos2D.y - areaRect.y) / (areaRect.w - areaRect.y);

		float areaRectBlendFactor = 0.0;
		float areaRectBlendWidthUpper = 1.0 - areaRectBlendWidth;
		// Calculate the normalised distance away from the edge, then blend towards the original heightmap
		// as you approach the edge.
		if (xAreaPosNormalised < areaRectBlendWidth)
		{
			areaRectBlendFactor = xAreaPosNormalised / areaRectBlendWidth;
			heightSum = lerp(0.0, heightSum, areaRectBlendFactor);
		}
		else if (xAreaPosNormalised > areaRectBlendWidthUpper)
		{
			areaRectBlendFactor = (xAreaPosNormalised - areaRectBlendWidthUpper) / areaRectBlendWidth;
			heightSum = lerp(heightSum, 0.0, areaRectBlendFactor);
		}

		// RestictArea blending - Corners could be an issue...
		if (zAreaPosNormalised < areaRectBlendWidth)
		{
			areaRectBlendFactor = zAreaPosNormalised / areaRectBlendWidth;
			heightSum = lerp(0.0, heightSum, areaRectBlendFactor);
		}
		else if (zAreaPosNormalised > areaRectBlendWidthUpper)
		{
			areaRectBlendFactor = (zAreaPosNormalised - areaRectBlendWidthUpper) / areaRectBlendWidth;
			heightSum = lerp(heightSum, 0.0, areaRectBlendFactor);
		}
	}

	// If this is a subtractive layer, subtract the heightSum 
	heightsOut[hIdx] = heightsIn[hIdx] + (heightSum * (layerTypeInt == 6 ? -1.0 : 1.0));
}

[numthreads(LB_TOPO_IMAGE_NUM_THREADS, LB_TOPO_IMAGE_NUM_THREADS, 1)]
void TopoImageModifier(uint3 id : SV_DispatchThreadID)
{
	// We have extra passes for 2^n + 1 hmapRes so need to ignore pixels outside heightmap
	// id.x & id.y can have a range 0 -> hmapRes-1 + LB_TOPO_NUM_THREADS
	// Each dimension (x,y) will be numThreads - 1 wider than required
	if (id.x > uint(hmapRes - 1) || id.y > uint(hmapRes - 1)) { return; }

	float2 landscapePos2D = GetTopoLandscapePos2DM(id.xy);

	// Get 1D index in heightsIn/Out
	int hIdx = (id.y * hmapRes) + id.x;

	float areaRectW = (areaRect.z - areaRect.x);
	float areaRectH = (areaRect.w - areaRect.y);
	float2 areaRectCentre = float2(areaRect.x + (areaRectW * 0.5), areaRect.y + (areaRectH * 0.5));

	// Get position relative to centre of modifier area rect
	float2 pos2DMod = float2(landscapePos2D.x - areaRectCentre.x, landscapePos2D.y - areaRectCentre.y);

	if (areaRectRotation > 0.0)
	{
		// Common constants (must be inside the method)
		const float PI = 3.14159265358979;
		const float PI2 = 3.14159265358979 * 2.0;
		//const float Deg2Rad = 3.141592654 * 2.0 / 360.0;
		//const float Rad2Deg = 1.0 / (3.141592654 * 2.0 / 360.0);

		// Convert position into landspace space by rotating anticlockwise given rotation
		// Get length of original vector
		float vectorLength = sqrt((pos2DMod.x * pos2DMod.x) + (pos2DMod.y * pos2DMod.y));
		// Not approximately 0
		if (vectorLength < -0.00001 || vectorLength > 0.00001)
		{
			// Have to fix result of arctan for 2nd and 3rd quadrants
			float angleAlpha = atan(pos2DMod.y / pos2DMod.x);
			if (pos2DMod.x < 0.0) { angleAlpha += PI; }
			// Get new result of angle
			float vectorAngle = (angleAlpha + areaRectRotation) % (PI2);
			pos2DMod.x = vectorLength * cos(vectorAngle);
			pos2DMod.y = vectorLength * sin(vectorAngle);
		}
	}

	// Convert into image space
	pos2DMod.x = (pos2DMod.x / areaRectW) + 0.5;
	pos2DMod.y = (pos2DMod.y / areaRectH) + 0.5;

	// Only continue if coords are in 0-1 range (this indicates it is inside area rect)
	if (pos2DMod.x < 0.0 || pos2DMod.x > 1.0 || pos2DMod.y < 0.0 || pos2DMod.y > 1.0)
	{
		heightsOut[hIdx] = heightsIn[hIdx];
		return;
	}

	// Sample the height by using a weighted average of the four surrounding data points
	uint heightRAW = SampleRAWHeightAtCoordinates(pos2DMod);

	// Heights are stored as [height,width] and are 0.0 - 1.0f.

	// Normalise the RAW Pixel - converting it to a range of 0 to 1
	float heightSum = LBNormalise(heightRAW, imageMinMaxRange.x, imageMinMaxRange.y);

	// Get current terrain height
	float previousHeight = heightsIn[hIdx];

	// No blending by default
	float blendFactor = 0.0;

	if (useBlending)
	{
		// Calculate blending factor
		// Get the square distance to the centre of the modifier
		// 0.5 is subtracted so that central region isn't blended
		float xDistToCentre = (pos2DMod.x - 0.5) * 2.0;
		float yDistToCentre = (pos2DMod.y - 0.5) * 2.0;
		float distToCentre = ((xDistToCentre * xDistToCentre) + (yDistToCentre * yDistToCentre) - 0.5) * 2.0;
		// Add domain warping to the distance to hide the circular shape
		distToCentre += LBPerlinFractalNoise(pos2DMod.x * 5.0, pos2DMod.y * 5.0, int(3)) * 1.0;
		// If (adjusted) distance to centre is positive, use blending
		// Clamp 0.0 - 1.0
		blendFactor = (distToCentre < 0.0 ? 0.0 : (distToCentre > 1.0 ? 1.0 : distToCentre));
	}

	// ModifierMode can be Add (0) or Set (5)
	if (modifierMode == (int)0)
	{
		// Scale the heightmap and add/remove additive amount
		heightSum = (heightSum - 1.0 + addsubAmount) * heightScale;
		// Clamp
		heightSum = (heightSum < 0.0 ? 0.0 : (heightSum > 1.0 ? 1.0 : heightSum));

		// If subtract is enabled, remove the heightsum from the heightmap
		if (modifierInvert) { heightsOut[hIdx] = previousHeight - (heightSum * (1.0 - blendFactor)); }
		// Else add it to the heightmap
		else { heightsOut[hIdx] = previousHeight + (heightSum * (1.0 - blendFactor)); }
	}
	// Modifier Mode: Set
	else
	{
		// Scale the heightmap
		heightSum *= heightScale;
		// Clamp
		heightSum = (heightSum < 0.0 ? 0.0 : (heightSum > 1.0 ? 1.0 : heightSum));

		// Add the y offset (floorOffsetY re-uses addHeightN in shader)
		heightSum += addHeightN;
		// Clamp
		heightSum = (heightSum < 0.0 ? 0.0 : (heightSum > 1.0 ? 1.0 : heightSum));

		// If subtract is enabled, set the heightmap to the height sum if
		// the height sum is LOWER than the heightmap
		if (modifierInvert)
		{
			// If we are removing from the heightmap, invert heights first
			heightSum = 1.0 - heightSum;
			if (heightSum < previousHeight) { heightsOut[hIdx] = lerp(heightSum, previousHeight, blendFactor); }
			else { heightsOut[hIdx] = previousHeight; }
		}
		// Else set the heightmap to the height sum if the height sum is HIGHER than the heightmap
		else
		{
			if (heightSum > previousHeight) { heightsOut[hIdx] = lerp(heightSum, previousHeight, blendFactor); }
			else { heightsOut[hIdx] = previousHeight; }
		}
	}
}

[numthreads(LB_TOPO_IMAGE_NUM_THREADS, LB_TOPO_IMAGE_NUM_THREADS, 1)]
void TopoUnityTerrains(uint3 id : SV_DispatchThreadID)
{
	// We have extra passes for 2^n + 1 hmapRes so need to ignore pixels outside heightmap
	// id.x & id.y can have a range 0 -> hmapRes-1 + LB_TOPO_NUM_THREADS
	// Each dimension (x,y) will be numThreads - 1 wider than required
	if (id.x > uint(hmapRes - 1) || id.y > uint(hmapRes - 1)) { return; }

	// Get 1D index in raw and heightsOut
	int hIdx = (id.y * hmapRes) + id.x;

	//uint heightRAW = rawHeightData[hIdx];

	float heightSum;
	//float heightSum = (normaliseImage ? LBNormalise((float)rawHeightData[hIdx], imageMinMaxRange.x, imageMinMaxRange.y) : ((float)rawHeightData[hIdx] / 65535.0) ) * heightScale;

	//if (normaliseImage)
	//{
	//	// Normalise the image Pixel - converting it to a range of 0 to 1
	//	heightSum = LBNormalise((float)rawHeightData[hIdx], imageMinMaxRange.x, imageMinMaxRange.y) * heightScale;
	//}
	//else { heightSum = ((float)rawHeightData[hIdx] / 65535.0) * heightScale; }

	if (normaliseImage)
	{
		// Normalise the image Pixel - converting it to a range of 0 to 1
		heightSum = LBNormalise(heightsOut[hIdx], imageMinMaxRange.x, imageMinMaxRange.y) * heightScale;
	}
	else { heightSum = (heightsOut[hIdx] / 65535.0) * heightScale; }

	// Compress lower limit upwards
	// Add the y offset (floorOffsetY re-uses addHeightN in shader)
	// for some 0-1 compression scalar "x": newHeight = x + (oldHeight * (1 - x))
	if (addHeightN > 0.0) { heightSum = addHeightN + (heightSum * (1.0 - addHeightN)); }

	// Clamp
	heightsOut[hIdx] = (heightSum < 0.0 ? 0.0 : (heightSum > 1.0 ? 1.0 : heightSum));
	//heightsOut[hIdx] = saturate(heightSum);
}
